function _typeof(obj) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    })(obj);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
    Constructor;
}

function _defineProperty(obj, key, value) {
    return key in obj ? Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : obj[key] = value, obj;
}

function _inherits(subClass, superClass) {
    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: !0,
            configurable: !0
        }
    }), superClass && _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    })(o);
}

function _setPrototypeOf(o, p) {
    return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        return o.__proto__ = p, o;
    })(o, p);
}

function _assertThisInitialized(self) {
    if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}

function _possibleConstructorReturn(self, call) {
    return !call || "object" != typeof call && "function" != typeof call ? _assertThisInitialized(self) : call;
}

function _superPropBase(object, property) {
    for (;!Object.prototype.hasOwnProperty.call(object, property) && null !== (object = _getPrototypeOf(object)); ) ;
    return object;
}

function _get(target, property, receiver) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (base) {
            var desc = Object.getOwnPropertyDescriptor(base, property);
            return desc.get ? desc.get.call(receiver) : desc.value;
        }
    })(target, property, receiver || target);
}

function set(target, property, value, receiver) {
    return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function set(target, property, value, receiver) {
        var desc, base = _superPropBase(target, property);
        if (base) {
            if ((desc = Object.getOwnPropertyDescriptor(base, property)).set) return desc.set.call(receiver, value), 
            !0;
            if (!desc.writable) return !1;
        }
        if (desc = Object.getOwnPropertyDescriptor(receiver, property)) {
            if (!desc.writable) return !1;
            desc.value = value, Object.defineProperty(receiver, property, desc);
        } else _defineProperty(receiver, property, value);
        return !0;
    })(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
    if (!set(target, property, value, receiver || target) && isStrict) throw new Error("failed to set property");
    return value;
}

function _toConsumableArray(arr) {
    return function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2;
        }
    }(arr) || function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || "[object Arguments]" === Object.prototype.toString.call(iter)) return Array.from(iter);
    }(arr) || function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
    }();
}

function _initializerDefineProperty(target, property, descriptor, context) {
    descriptor && Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    return Object.keys(descriptor).forEach(function(key) {
        desc[key] = descriptor[key];
    }), desc.enumerable = !!desc.enumerable, desc.configurable = !!desc.configurable, 
    ("value" in desc || desc.initializer) && (desc.writable = !0), desc = decorators.slice().reverse().reduce(function(desc, decorator) {
        return decorator(target, property, desc) || desc;
    }, desc), context && void 0 !== desc.initializer && (desc.value = desc.initializer ? desc.initializer.call(context) : void 0, 
    desc.initializer = void 0), void 0 === desc.initializer && (Object.defineProperty(target, property, desc), 
    desc = null), desc;
}

var _global = "undefined" == typeof window ? global : window, cc$1 = _global.cc = _global.cc || {};

function defineMacro(name, defaultValue) {
    void 0 === _global[name] && (_global[name] = defaultValue);
}

function defined(name) {
    return "object" === _typeof(_global[name]);
}

cc$1.internal = cc$1.internal || {}, cc$1._global = _global, defineMacro("CC_BUILD", !1), 
defineMacro("CC_TEST", defined("tap") || defined("QUnit")), defineMacro("CC_EDITOR", defined("Editor") && defined("process") && "electron" in process.versions), 
defineMacro("CC_PREVIEW", !0), defineMacro("CC_DEV", !0), defineMacro("CC_DEBUG", !0), 
defineMacro("CC_JSB", defined("jsb")), defineMacro("CC_WECHATGAME_SUB", !(!defined("wx") || !wx.getSharedCanvas)), 
defineMacro("CC_WECHATGAME", !(!defined("wx") || !wx.getSystemInfoSync && !wx.getSharedCanvas)), 
defineMacro("CC_QQPLAY", defined("bk")), defineMacro("CC_RUNTIME", "function" == typeof loadRuntime), 
defineMacro("CC_SUPPORT_JIT", !0), defineMacro("CC_PHYSICS_BUILT_IN", !0), defineMacro("CC_PHYSICS_CANNON", !1), 
defineMacro("CC_PHYSICS_AMMO", !1);

_global.CocosEngine = cc$1.ENGINE_VERSION = "1.0.0 beta";

var ERROR_MAP_URL = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md", logList = null, ccLog = console.log, ccWarn = console.log, ccError = console.log, ccAssert = function ccAssert(condition, message) {
    if (!condition) {
        for (var _len = arguments.length, optionalParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) optionalParams[_key - 2] = arguments[_key];
        console.log("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
    }
};

function formatString(message) {
    for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) optionalParams[_key2 - 1] = arguments[_key2];
    return cc.js.formatStr.apply(null, [ message ].concat(optionalParams));
}

function log(message) {
    for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) optionalParams[_key3 - 1] = arguments[_key3];
    return ccLog.apply(void 0, [ message ].concat(optionalParams));
}

function warn(message) {
    for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) optionalParams[_key4 - 1] = arguments[_key4];
    return ccWarn.apply(void 0, [ message ].concat(optionalParams));
}

function error(message) {
    for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) optionalParams[_key5 - 1] = arguments[_key5];
    return ccError.apply(void 0, [ message ].concat(optionalParams));
}

function assert(value, message) {
    for (var _len6 = arguments.length, optionalParams = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) optionalParams[_key6 - 2] = arguments[_key6];
    return ccAssert.apply(void 0, [ value, message ].concat(optionalParams));
}

function _resetDebugSetting(mode) {
    if (ccLog = ccWarn = ccError = ccAssert = function ccAssert() {}, mode !== DebugMode.NONE) {
        if (mode > DebugMode.ERROR) {
            var logToWebPage = function logToWebPage(msg) {
                if (cc.game.canvas) {
                    if (!logList) {
                        var logDiv = document.createElement("Div");
                        logDiv.setAttribute("id", "logInfoDiv"), logDiv.setAttribute("width", "200"), logDiv.setAttribute("height", cc.game.canvas.height);
                        var logDivStyle = logDiv.style;
                        logDivStyle.zIndex = "99999", logDivStyle.position = "absolute", logDivStyle.top = logDivStyle.left = "0", 
                        (logList = document.createElement("textarea")).setAttribute("rows", "20"), logList.setAttribute("cols", "30"), 
                        logList.setAttribute("disabled", "true");
                        var logListStyle = logList.style;
                        logListStyle.backgroundColor = "transparent", logListStyle.borderBottom = "1px solid #cccccc", 
                        logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px", 
                        logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none", 
                        logListStyle.padding = "0px", logListStyle.margin = "0px", logDiv.appendChild(logList), 
                        cc.game.canvas.parentNode.appendChild(logDiv);
                    }
                    logList.value = logList.value + msg + "\r\n", logList.scrollTop = logList.scrollHeight;
                }
            };
            ccError = function ccError(message) {
                for (var _len7 = arguments.length, optionalParams = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) optionalParams[_key7 - 1] = arguments[_key7];
                logToWebPage("ERROR :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
            }, ccAssert = function ccAssert(condition, message) {
                if (!condition) {
                    for (var _len8 = arguments.length, optionalParams = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) optionalParams[_key8 - 2] = arguments[_key8];
                    logToWebPage("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }
            }, mode !== DebugMode.ERROR_FOR_WEB_PAGE && (ccWarn = function ccWarn(message) {
                for (var _len9 = arguments.length, optionalParams = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) optionalParams[_key9 - 1] = arguments[_key9];
                logToWebPage("WARN :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
            }), mode === DebugMode.INFO_FOR_WEB_PAGE && (ccLog = function ccLog(message) {
                for (var _len10 = arguments.length, optionalParams = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) optionalParams[_key10 - 1] = arguments[_key10];
                logToWebPage(formatString.apply(void 0, [ message ].concat(optionalParams)));
            });
        } else console && console.log.apply && (console.error || (console.error = console.log), 
        console.warn || (console.warn = console.log), ccError = console.error.bind ? console.error.bind(console) : function(message) {
            for (var _len11 = arguments.length, optionalParams = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) optionalParams[_key11 - 1] = arguments[_key11];
            return console.error.apply(console, [ message ].concat(optionalParams));
        }, ccAssert = function ccAssert(condition, message) {
            if (!condition) {
                for (var _len12 = arguments.length, optionalParams = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) optionalParams[_key12 - 2] = arguments[_key12];
                var errorText = formatString.apply(void 0, [ message ].concat(optionalParams));
                throw new Error(errorText);
            }
        });
        mode !== DebugMode.ERROR && (ccWarn = console.warn.bind ? console.warn.bind(console) : function(message) {
            for (var _len13 = arguments.length, optionalParams = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) optionalParams[_key13 - 1] = arguments[_key13];
            return console.warn.apply(console, [ message ].concat(optionalParams));
        }), mode === DebugMode.INFO && (ccLog = console.log.bind ? console.log.bind(console) : function ccLog(message) {
            for (var _len15 = arguments.length, optionalParams = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) optionalParams[_key15 - 1] = arguments[_key15];
            return console.log.apply(console, [ message ].concat(optionalParams));
        });
    }
}

function _throw(error_) {
    var stack = error_.stack;
    error(stack || error_);
}

function getTypedFormatter(type) {
    return function(id) {
        for (var msg = "".concat(type, " ").concat(id, ", please go to ").concat(ERROR_MAP_URL, "#").concat(id, " to see details."), _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) args[_key16 - 1] = arguments[_key16];
        return 0 === args.length ? msg : msg + " Arguments: " + args.join(", ");
    };
}

var logFormatter = getTypedFormatter("Log");

function logID(id) {
    for (var _len17 = arguments.length, optionalParams = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) optionalParams[_key17 - 1] = arguments[_key17];
    log(logFormatter.apply(void 0, [ id ].concat(optionalParams)));
}

var warnFormatter = getTypedFormatter("Warning");

function warnID(id) {
    for (var _len18 = arguments.length, optionalParams = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) optionalParams[_key18 - 1] = arguments[_key18];
    warn(warnFormatter.apply(void 0, [ id ].concat(optionalParams)));
}

var errorFormatter = getTypedFormatter("Error");

function errorID(id) {
    for (var _len19 = arguments.length, optionalParams = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) optionalParams[_key19 - 1] = arguments[_key19];
    error(errorFormatter.apply(void 0, [ id ].concat(optionalParams)));
}

var DebugMode, assertFormatter = getTypedFormatter("Assert");

function assertID(condition, id) {
    if (!condition) {
        for (var _len20 = arguments.length, optionalParams = new Array(_len20 > 2 ? _len20 - 2 : 0), _key20 = 2; _key20 < _len20; _key20++) optionalParams[_key20 - 2] = arguments[_key20];
        assert(!1, assertFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
}

function getError(errorId, param) {
    return errorFormatter(errorId, param);
}

function setDisplayStats(displayStats) {
    cc.profiler && (displayStats ? cc.profiler.showStats() : cc.profiler.hideStats(), 
    cc.game.config.showFPS = !!displayStats);
}

!function(DebugMode) {
    DebugMode[DebugMode.NONE = 0] = "NONE", DebugMode[DebugMode.INFO = 1] = "INFO", 
    DebugMode[DebugMode.WARN = 2] = "WARN", DebugMode[DebugMode.ERROR = 3] = "ERROR", 
    DebugMode[DebugMode.INFO_FOR_WEB_PAGE = 4] = "INFO_FOR_WEB_PAGE", DebugMode[DebugMode.WARN_FOR_WEB_PAGE = 5] = "WARN_FOR_WEB_PAGE", 
    DebugMode[DebugMode.ERROR_FOR_WEB_PAGE = 6] = "ERROR_FOR_WEB_PAGE";
}(DebugMode || (DebugMode = {}));

var debug = Object.freeze({
    log: log,
    warn: warn,
    error: error,
    assert: assert,
    _resetDebugSetting: _resetDebugSetting,
    _throw: _throw,
    logID: logID,
    warnID: warnID,
    errorID: errorID,
    assertID: assertID,
    get DebugMode() {
        return DebugMode;
    },
    getError: getError,
    isDisplayStats: function isDisplayStats() {
        return !!cc.profiler && cc.profiler.isShowingStats();
    },
    setDisplayStats: setDisplayStats
}), EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/, DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/, NORMALIZE_RE = /[^\.\/]+\/\.\.\//;

function join() {
    for (var result = "", _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) segments[_key] = arguments[_key];
    for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
        result = (result + ("" === result ? "" : "/") + _segments[_i]).replace(/(\/|\\\\)$/, "");
    }
    return result;
}

function extname(path) {
    var temp = EXTNAME_RE.exec(path);
    return temp ? temp[1] : "";
}

function mainFileName(fileName) {
    if (fileName) {
        var idx = fileName.lastIndexOf(".");
        if (-1 !== idx) return fileName.substring(0, idx);
    }
    return fileName;
}

function basename(path, extName) {
    var index = path.indexOf("?");
    index > 0 && (path = path.substring(0, index));
    var result = /(\/|\\)([^\/\\]+)$/g.exec(path.replace(/(\/|\\)$/, ""));
    if (!result) return "";
    var baseName = result[2];
    return extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase() ? baseName.substring(0, baseName.length - extName.length) : baseName;
}

function dirname(path) {
    var temp = DIRNAME_RE.exec(path);
    return temp ? temp[2] : "";
}

function changeExtname(path, extName) {
    extName = extName || "";
    var index = path.indexOf("?"), tempStr = "";
    return index > 0 && (tempStr = path.substring(index), path = path.substring(0, index)), 
    (index = path.lastIndexOf(".")) < 0 ? path + extName + tempStr : path.substring(0, index) + extName + tempStr;
}

function changeBasename(path, baseName, isSameExt) {
    if (0 === baseName.indexOf(".")) return changeExtname(path, baseName);
    var index = path.indexOf("?"), tempStr = "", ext = isSameExt ? extname(path) : "";
    return index > 0 && (tempStr = path.substring(index), path = path.substring(0, index)), 
    index = (index = path.lastIndexOf("/")) <= 0 ? 0 : index + 1, path.substring(0, index) + baseName + ext + tempStr;
}

function _normalize(url) {
    var oldUrl = url = String(url);
    do {
        oldUrl = url, url = url.replace(NORMALIZE_RE, "");
    } while (oldUrl.length !== url.length);
    return url;
}

function stripSep(path) {
    return path.replace(/[\/\\]$/, "");
}

function getSeperator() {
    return cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/";
}

var path = Object.freeze({
    join: join,
    extname: extname,
    mainFileName: mainFileName,
    basename: basename,
    dirname: dirname,
    changeExtname: changeExtname,
    changeBasename: changeBasename,
    _normalize: _normalize,
    stripSep: stripSep,
    getSeperator: getSeperator
});

cc.log = log, cc.warn = warn, cc.error = error, cc.assert = assert, cc._throw = _throw, 
cc.logID = logID, cc.warnID = warnID, cc.errorID = errorID, cc.assertID = assertID, 
cc.debug = debug, cc.path = {
    join: join,
    extname: extname,
    mainFileName: mainFileName,
    basename: basename,
    dirname: dirname,
    changeExtname: changeExtname,
    changeBasename: changeBasename,
    _normalize: _normalize,
    stripSep: stripSep,
    get sep() {
        return getSeperator();
    }
};

var MutableForwardIterator = function() {
    function MutableForwardIterator(array) {
        _classCallCheck(this, MutableForwardIterator), this.array = array, this.i = 0;
    }
    return _createClass(MutableForwardIterator, [ {
        key: "remove",
        value: function remove(value) {
            var index = this.array.indexOf(value);
            index >= 0 && this.removeAt(index);
        }
    }, {
        key: "removeAt",
        value: function removeAt(i) {
            this.array.splice(i, 1), i <= this.i && --this.i;
        }
    }, {
        key: "fastRemove",
        value: function fastRemove(value) {
            var index = this.array.indexOf(value);
            index >= 0 && this.fastRemoveAt(index);
        }
    }, {
        key: "fastRemoveAt",
        value: function fastRemoveAt(i) {
            var array = this.array;
            array[i] = array[array.length - 1], --array.length, i <= this.i && --this.i;
        }
    }, {
        key: "push",
        value: function push(item) {
            this.array.push(item);
        }
    }, {
        key: "length",
        get: function get() {
            return this.array.length;
        },
        set: function set(value) {
            this.array.length = value, this.i >= value && (this.i = value - 1);
        }
    } ]), MutableForwardIterator;
}();

function removeAt(array, index) {
    array.splice(index, 1);
}

function remove(array, value) {
    var index = array.indexOf(value);
    return index >= 0 && (removeAt(array, index), !0);
}

function removeIf(array, predicate) {
    var index = array.findIndex(predicate);
    if (index >= 0) {
        var _value = array[index];
        return removeAt(array, index), _value;
    }
}

function contains(array, value) {
    return array.indexOf(value) >= 0;
}

var jsarray = Object.freeze({
    removeAt: removeAt,
    fastRemoveAt: function fastRemoveAt(array, index) {
        var length = array.length;
        index < 0 || index >= length || (array[index] = array[length - 1], array.length = length - 1);
    },
    remove: remove,
    fastRemove: function fastRemove(array, value) {
        var index = array.indexOf(value);
        index >= 0 && (array[index] = array[array.length - 1], --array.length);
    },
    removeIf: removeIf,
    verifyType: function verifyType(array, type) {
        if (array && array.length > 0) {
            var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                if (!(_ref instanceof type)) return cc.logID(1300), !1;
            }
        }
        return !0;
    },
    removeArray: function removeArray(array, minusArr) {
        for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
    },
    appendObjectsAt: function appendObjectsAt(array, addObjs, index) {
        return array.splice.apply(array, [ index, 0 ].concat(_toConsumableArray(addObjs))), 
        array;
    },
    indexOf: function indexOf(array, searchElement, fromIndex) {
        return Array.prototype.indexOf.call(array, [ searchElement, fromIndex ]);
    },
    contains: contains,
    copy: function copy(array) {
        for (var len = array.length, arr_clone = new Array(len), i = 0; i < len; i += 1) arr_clone[i] = array[i];
        return arr_clone;
    },
    MutableForwardIterator: MutableForwardIterator
}), NonUuidMark = ".", IDGenerator = function() {
    function IDGenerator(category) {
        _classCallCheck(this, IDGenerator), this.id = void 0, this.prefix = void 0, this.id = 0 | 998 * Math.random(), 
        this.prefix = category ? category + NonUuidMark : "";
    }
    return _createClass(IDGenerator, [ {
        key: "getNewId",
        value: function getNewId() {
            return this.prefix + ++this.id;
        }
    } ]), IDGenerator;
}();

IDGenerator.global = new IDGenerator("global");

var tempCIDGenerator = new IDGenerator("TmpCId.");

function isNumber(object) {
    return "number" == typeof object || object instanceof Number;
}

function isString(object) {
    return "string" == typeof object || object instanceof String;
}

var descriptor, value = (descriptor = {
    value: void 0,
    enumerable: !1,
    writable: !1,
    configurable: !0
}, function(object, propertyName, value_, writable, enumerable) {
    descriptor.value = value_, descriptor.writable = writable, descriptor.enumerable = enumerable, 
    Object.defineProperty(object, propertyName, descriptor), descriptor.value = void 0;
}), getset = function() {
    var descriptor = {
        get: void 0,
        set: void 0,
        enumerable: !1
    };
    return function(object, propertyName, getter, setter) {
        var enumerable = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], configurable = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
        "boolean" == typeof setter && (enumerable = setter, setter = void 0), descriptor.get = getter, 
        descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0, 
        descriptor.set = void 0;
    };
}(), get = function() {
    var descriptor = {
        get: void 0,
        enumerable: !1,
        configurable: !1
    };
    return function(object, propertyName, getter, enumerable, configurable) {
        descriptor.get = getter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0;
    };
}(), set$1 = function() {
    var descriptor = {
        set: void 0,
        enumerable: !1,
        configurable: !1
    };
    return function(object, propertyName, setter, enumerable, configurable) {
        descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.set = void 0;
    };
}();

function createMap(forceDictMode) {
    var map = Object.create(null);
    if (forceDictMode) {
        map["."] = !0, map["/"] = !0, delete map["."], delete map["/"];
    }
    return map;
}

function getClassName(objOrCtor) {
    if ("function" == typeof objOrCtor) {
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        if (objOrCtor.name && (retval = objOrCtor.name), objOrCtor.toString) {
            var arr, str = objOrCtor.toString();
            (arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/)) && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
    }
    return objOrCtor && objOrCtor.constructor ? getClassName(objOrCtor.constructor) : "";
}

function obsolete(object, obsoleted, newExpr, writable) {
    var extractPropName = /([^.]+)$/, oldProp = extractPropName.exec(obsoleted)[0], newProp = extractPropName.exec(newExpr)[0];
    function getter() {
        return this[newProp];
    }
    writable ? getset(object, oldProp, getter, function setter(value_) {
        this[newProp] = value_;
    }) : get(object, oldProp, getter);
}

function obsoletes(obj, objName, props, writable) {
    for (var obsoleted in props) {
        obsolete(obj, objName + "." + obsoleted, props[obsoleted], writable);
    }
}

var REGEXP_NUM_OR_STR = /(%d)|(%s)/, REGEXP_STR = /%s/;

function formatStr(msg) {
    for (var _len = arguments.length, subst = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) subst[_key - 1] = arguments[_key];
    if (0 === arguments.length) return "";
    if (0 === subst.length) return "" + msg;
    if ("string" == typeof msg && REGEXP_NUM_OR_STR.test(msg)) for (var _i = 0, _subst = subst; _i < _subst.length; _i++) {
        var arg = _subst[_i], regExpToTest = "number" == typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
        regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
    } else for (var _i2 = 0, _subst2 = subst; _i2 < _subst2.length; _i2++) {
        msg += " " + _subst2[_i2];
    }
    return msg;
}

function shiftArguments() {
    for (var len = arguments.length - 1, args = new Array(len), i = 0; i < len; ++i) args[i] = arguments[i + 1];
    return args;
}

function getPropertyDescriptor(object, propertyName) {
    for (;object; ) {
        var pd = Object.getOwnPropertyDescriptor(object, propertyName);
        if (pd) return pd;
        object = Object.getPrototypeOf(object);
    }
    return null;
}

function _copyprop(name, source, target) {
    var pd = getPropertyDescriptor(source, name);
    pd && Object.defineProperty(target, name, pd);
}

function addon(object) {
    object = object || {};
    for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) sources[_key2 - 1] = arguments[_key2];
    for (var _i3 = 0, _sources = sources; _i3 < _sources.length; _i3++) {
        var source = _sources[_i3];
        if (source) {
            if ("object" !== _typeof(source)) {
                cc.errorID(5402, source);
                continue;
            }
            for (var name in source) name in object || _copyprop(name, source, object);
        }
    }
    return object;
}

function mixin(object) {
    object = object || {};
    for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) sources[_key3 - 1] = arguments[_key3];
    for (var _i4 = 0, _sources2 = sources; _i4 < _sources2.length; _i4++) {
        var source = _sources2[_i4];
        if (source) {
            if ("object" !== _typeof(source)) {
                cc.errorID(5403, source);
                continue;
            }
            for (var name in source) _copyprop(name, source, object);
        }
    }
    return object;
}

function extend(cls, base) {
    for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
    return cls.prototype = Object.create(base.prototype, {
        constructor: {
            value: cls,
            writable: !0,
            configurable: !0
        }
    }), cls;
}

function getSuper(constructor) {
    var proto = constructor.prototype, dunderProto = proto && Object.getPrototypeOf(proto);
    return dunderProto && dunderProto.constructor;
}

function isChildClassOf(subclass, superclass) {
    if (subclass && superclass) {
        if ("function" != typeof subclass) return !1;
        if ("function" != typeof superclass) return !1;
        if (subclass === superclass) return !0;
        for (;;) {
            if (!(subclass = getSuper(subclass))) return !1;
            if (subclass === superclass) return !0;
        }
    }
    return !1;
}

function clear(object) {
    for (var _i5 = 0, _Object$keys = Object.keys(object); _i5 < _Object$keys.length; _i5++) {
        delete object[_Object$keys[_i5]];
    }
}

var _idToClass = {}, _nameToClass = {};

function _setClassId(id, constructor) {
    var key = "__cid__", table = _idToClass;
    if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
    value(constructor.prototype, key, id), id) {
        var registered = table[id];
        if (registered && registered !== constructor) {
            var error = 'A Class already exists with the same __cid__ : "' + id + '".';
            0, cc.error(error);
        } else table[id] = constructor;
    }
}

function setClassName(className, constructor) {
    if (function doSetClassName(id, constructor) {
        var key = "__classname__", table = _nameToClass;
        if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
        value(constructor.prototype, key, id), id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
                var error = "A Class already exists with the same " + key + ' : "' + id + '".';
                0, cc.error(error);
            } else table[id] = constructor;
        }
    }(className, constructor), !constructor.prototype.hasOwnProperty("__cid__")) {
        var id = className || tempCIDGenerator.getNewId();
        id && _setClassId(id, constructor);
    }
}

function unregisterClass() {
    for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) constructors[_key4] = arguments[_key4];
    for (var _i6 = 0, _constructors = constructors; _i6 < _constructors.length; _i6++) {
        var p = _constructors[_i6].prototype, classId = p.__cid__;
        classId && delete _idToClass[classId];
        var classname = p.__classname__;
        classname && delete _nameToClass[classname];
    }
}

function _getClassById(classId) {
    return _idToClass[classId];
}

function getClassByName(classname) {
    return _nameToClass[classname];
}

function _getClassId(obj, allowTempId) {
    if (allowTempId = void 0 === allowTempId || allowTempId, "function" == typeof obj && obj.prototype.hasOwnProperty("__cid__")) return obj.prototype.__cid__;
    if (obj && obj.constructor) {
        var prototype = obj.constructor.prototype;
        if (prototype && prototype.hasOwnProperty("__cid__")) return obj.__cid__;
    }
    return "";
}

var Pool = function() {
    function Pool(_0, _1) {
        _classCallCheck(this, Pool), this.count = void 0, this._pool = void 0, this._cleanup = void 0;
        var size = void 0 === _1 ? _0 : _1, cleanupFunc = void 0 === _1 ? null : _0;
        this.count = 0, this._pool = new Array(size), this._cleanup = cleanupFunc;
    }
    return _createClass(Pool, [ {
        key: "get",
        value: function get() {
            return this._get();
        }
    } ]), _createClass(Pool, [ {
        key: "_get",
        value: function _get() {
            if (this.count > 0) {
                --this.count;
                var cache = this._pool[this.count];
                return this._pool[this.count] = null, cache;
            }
            return null;
        }
    }, {
        key: "put",
        value: function put(obj) {
            var pool = this._pool;
            if (this.count < pool.length) {
                if (this._cleanup && !1 === this._cleanup(obj)) return;
                pool[this.count] = obj, ++this.count;
            }
        }
    }, {
        key: "resize",
        value: function resize(length) {
            length >= 0 && (this._pool.length = length, this.count > length && (this.count = length));
        }
    } ]), Pool;
}(), array = jsarray, js = {
    IDGenerator: IDGenerator,
    Pool: Pool,
    array: jsarray,
    isNumber: isNumber,
    isString: isString,
    getPropertyDescriptor: getPropertyDescriptor,
    addon: addon,
    mixin: mixin,
    extend: extend,
    getSuper: getSuper,
    isChildClassOf: isChildClassOf,
    clear: clear,
    value: value,
    getset: getset,
    get: get,
    set: set$1,
    unregisterClass: unregisterClass,
    getClassName: getClassName,
    setClassName: setClassName,
    getClassByName: getClassByName,
    _getClassId: _getClassId,
    _setClassId: _setClassId,
    _getClassById: _getClassById,
    obsolete: obsolete,
    obsoletes: obsoletes,
    formatStr: formatStr,
    shiftArguments: shiftArguments,
    createMap: createMap
};

cc.js = js;

var js$1 = Object.freeze({
    array: array,
    js: js,
    IDGenerator: IDGenerator,
    Pool: Pool,
    isNumber: isNumber,
    isString: isString,
    value: value,
    getset: getset,
    get: get,
    set: set$1,
    createMap: createMap,
    getClassName: getClassName,
    obsolete: obsolete,
    obsoletes: obsoletes,
    formatStr: formatStr,
    shiftArguments: shiftArguments,
    getPropertyDescriptor: getPropertyDescriptor,
    addon: addon,
    mixin: mixin,
    extend: extend,
    getSuper: getSuper,
    isChildClassOf: isChildClassOf,
    clear: clear,
    _idToClass: _idToClass,
    _nameToClass: _nameToClass,
    _setClassId: _setClassId,
    setClassName: setClassName,
    unregisterClass: unregisterClass,
    _getClassById: _getClassById,
    getClassByName: getClassByName,
    _getClassId: _getClassId
}), Pool$1 = function() {
    function Pool(fn, size) {
        _classCallCheck(this, Pool), this._fn = void 0, this._idx = void 0, this._frees = void 0, 
        this._fn = fn, this._idx = size - 1, this._frees = new Array(size);
        for (var i = 0; i < size; ++i) this._frees[i] = fn();
    }
    return _createClass(Pool, [ {
        key: "alloc",
        value: function alloc() {
            this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
            var ret = this._frees[this._idx];
            return this._frees.splice(this._idx), --this._idx, ret;
        }
    }, {
        key: "free",
        value: function free(obj) {
            ++this._idx, this._frees[this._idx] = obj;
        }
    }, {
        key: "clear",
        value: function clear(fn) {
            for (var i = 0; i <= this._idx; i++) fn && fn(this._frees[i]);
            this._frees.splice(0), this._idx = -1;
        }
    }, {
        key: "_expand",
        value: function _expand(size) {
            var old = this._frees;
            this._frees = new Array(size);
            for (var len = size - old.length, i = 0; i < len; ++i) this._frees[i] = this._fn();
            for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
            this._idx += len;
        }
    } ]), Pool;
}(), fastRemoveAt$1 = array.fastRemoveAt;

function empty() {}

var CallbackInfo = function() {
    function CallbackInfo() {
        _classCallCheck(this, CallbackInfo), this.callback = empty, this.target = void 0, 
        this.once = !1;
    }
    return _createClass(CallbackInfo, [ {
        key: "set",
        value: function set(callback, target, once) {
            this.callback = callback, this.target = target, this.once = !!once;
        }
    } ]), CallbackInfo;
}(), callbackInfoPool = new Pool$1(function() {
    return new CallbackInfo();
}, 32), CallbackList = function() {
    function CallbackList() {
        _classCallCheck(this, CallbackList), this.callbackInfos = [], this.isInvoking = !1, 
        this.containCanceled = !1;
    }
    return _createClass(CallbackList, [ {
        key: "removeByCallback",
        value: function removeByCallback(cb) {
            for (var i = 0; i < this.callbackInfos.length; ++i) {
                var info = this.callbackInfos[i];
                info && info.callback === cb && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                --i);
            }
        }
    }, {
        key: "removeByTarget",
        value: function removeByTarget(target) {
            for (var i = 0; i < this.callbackInfos.length; ++i) {
                var info = this.callbackInfos[i];
                info && info.target === target && (callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                --i);
            }
        }
    }, {
        key: "cancel",
        value: function cancel(index) {
            var info = this.callbackInfos[index];
            info && (callbackInfoPool.free(info), this.callbackInfos[index] = null), this.containCanceled = !0;
        }
    }, {
        key: "cancelAll",
        value: function cancelAll() {
            for (var i = 0; i < this.callbackInfos.length; i++) {
                var info = this.callbackInfos[i];
                info && (callbackInfoPool.free(info), this.callbackInfos[i] = null);
            }
            this.containCanceled = !0;
        }
    }, {
        key: "purgeCanceled",
        value: function purgeCanceled() {
            for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
                this.callbackInfos[i] || fastRemoveAt$1(this.callbackInfos, i);
            }
            this.containCanceled = !1;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1;
        }
    } ]), CallbackList;
}(), callbackListPool = new Pool$1(function() {
    return new CallbackList();
}, 16), CallbacksInvoker = function() {
    function CallbacksInvoker() {
        _classCallCheck(this, CallbacksInvoker), this._callbackTable = createMap(!0);
    }
    return _createClass(CallbacksInvoker, [ {
        key: "on",
        value: function on(key, callback, target, once) {
            var list = this._callbackTable[key];
            list || (list = this._callbackTable[key] = callbackListPool.alloc());
            var info = callbackInfoPool.alloc();
            info.set(callback, target, once), list.callbackInfos.push(info);
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(key, callback) {
            var target = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, list = this._callbackTable[key];
            if (!list) return !1;
            var infos = list.callbackInfos;
            if (!callback) {
                if (list.isInvoking) {
                    var _iterator = infos, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        if (_ref) return !0;
                    }
                    return !1;
                }
                return infos.length > 0;
            }
            var _iterator2 = infos, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var _info = _ref2;
                if (_info && _info.callback === callback && _info.target === target) return !0;
            }
            return !1;
        }
    }, {
        key: "removeAll",
        value: function removeAll(keyOrTarget) {
            if ("string" == typeof keyOrTarget) {
                var list = this._callbackTable[keyOrTarget];
                list && (list.isInvoking ? list.cancelAll() : (list.clear(), callbackListPool.free(list), 
                delete this._callbackTable[keyOrTarget]));
            } else if (keyOrTarget) for (var key in this._callbackTable) {
                var _list = this._callbackTable[key];
                if (_list.isInvoking) for (var infos = _list.callbackInfos, i = 0; i < infos.length; ++i) {
                    var info = infos[i];
                    info && info.target === keyOrTarget && _list.cancel(i);
                } else _list.removeByTarget(keyOrTarget);
            }
        }
    }, {
        key: "off",
        value: function off(key, callback, target) {
            var list = this._callbackTable[key];
            if (list) {
                var infos = list.callbackInfos;
                if (callback) for (var i = 0; i < infos.length; ++i) {
                    var info = infos[i];
                    if (info && info.callback === callback && info.target === target) {
                        list.isInvoking ? list.cancel(i) : (fastRemoveAt$1(infos, i), callbackInfoPool.free(info));
                        break;
                    }
                } else this.removeAll(key);
            }
        }
    }, {
        key: "emit",
        value: function emit(key) {
            var list = this._callbackTable[key];
            if (list) {
                var rootInvoker = !list.isInvoking;
                list.isInvoking = !0;
                for (var infos = list.callbackInfos, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                for (var i = 0, len = infos.length; i < len; ++i) {
                    var info = infos[i];
                    if (info) {
                        var callback = info.callback, target = info.target;
                        info.once && this.off(key, callback, target), target ? callback.call.apply(callback, [ target ].concat(args)) : callback.apply(void 0, args);
                    }
                }
                rootInvoker && (list.isInvoking = !1, list.containCanceled && list.purgeCanceled());
            }
        }
    } ]), CallbacksInvoker;
}();

var fastRemove$1 = array.fastRemove, EventTarget = function(_CallbacksInvoker) {
    function EventTarget() {
        return _classCallCheck(this, EventTarget), _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).apply(this, arguments));
    }
    return _inherits(EventTarget, CallbacksInvoker), _createClass(EventTarget, [ {
        key: "on",
        value: function on(type, callback, target) {
            if (callback) {
                if (!this.hasEventListener(type, callback, target)) {
                    _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target);
                    var targetImpl = target;
                    target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                }
                return callback;
            }
            cc.errorID(6800);
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            if (callback) {
                _get(_getPrototypeOf(EventTarget.prototype), "off", this).call(this, type, callback, target);
                var targetImpl = target;
                target && (targetImpl.__eventTargets ? fastRemove$1(targetImpl.__eventTargets, this) : targetImpl.node && targetImpl.node.__eventTargets && fastRemove$1(targetImpl.node.__eventTargets, this));
            } else this.removeAll(type);
        }
    }, {
        key: "targetOff",
        value: function targetOff(keyOrTarget) {
            this.removeAll(keyOrTarget);
        }
    }, {
        key: "once",
        value: function once(type, callback, target) {
            if (callback) {
                if (!this.hasEventListener(type, callback, target)) {
                    _get(_getPrototypeOf(EventTarget.prototype), "on", this).call(this, type, callback, target, !0);
                    var targetImpl = target;
                    target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                }
                return callback;
            }
            cc.errorID(6800);
        }
    } ]), EventTarget;
}();

cc.EventTarget = EventTarget;

var Event = function() {
    function Event(type, bubbles) {
        _classCallCheck(this, Event), this.type = void 0, this.bubbles = void 0, this.target = null, 
        this.currentTarget = null, this.eventPhase = 0, this.propagationStopped = !1, this.propagationImmediateStopped = !1, 
        this.type = type, this.bubbles = !!bubbles;
    }
    return _createClass(Event, [ {
        key: "unuse",
        value: function unuse() {
            this.type = Event.NO_TYPE, this.target = null, this.currentTarget = null, this.eventPhase = Event.NONE, 
            this.propagationStopped = !1, this.propagationImmediateStopped = !1;
        }
    }, {
        key: "reuse",
        value: function reuse(type, bubbles) {
            this.type = type, this.bubbles = bubbles || !1;
        }
    }, {
        key: "isStopped",
        value: function isStopped() {
            return this.propagationStopped || this.propagationImmediateStopped;
        }
    }, {
        key: "getCurrentTarget",
        value: function getCurrentTarget() {
            return this.currentTarget;
        }
    }, {
        key: "getType",
        value: function getType() {
            return this.type;
        }
    } ]), Event;
}();

Event.NO_TYPE = "no_type", Event.TOUCH = "touch", Event.MOUSE = "mouse", Event.KEYBOARD = "keyboard", 
Event.ACCELERATION = "acceleration", Event.NONE = 0, Event.CAPTURING_PHASE = 1, 
Event.AT_TARGET = 2, Event.BUBBLING_PHASE = 3, cc.Event = Event;

var INT_BITS = 32, INT_MIN = -1 << INT_BITS - 1;

function sign(v) {
    return (v > 0) - (v < 0);
}

function countTrailingZeros(v) {
    var c = 32;
    return (v &= -v) && c--, 65535 & v && (c -= 16), 16711935 & v && (c -= 8), 252645135 & v && (c -= 4), 
    858993459 & v && (c -= 2), 1431655765 & v && (c -= 1), c;
}

var REVERSE_TABLE = new Array(256);

!function(tab) {
    for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) r <<= 1, r |= 1 & v, --s;
        tab[i] = r << s & 255;
    }
}(REVERSE_TABLE);

for (var bits = Object.freeze({
    INT_BITS: INT_BITS,
    INT_MAX: 2147483647,
    INT_MIN: INT_MIN,
    sign: sign,
    abs: function abs(v) {
        var mask = v >> INT_BITS - 1;
        return (v ^ mask) - mask;
    },
    min: function min(x, y) {
        return y ^ (x ^ y) & -(x < y);
    },
    max: function max(x, y) {
        return x ^ (x ^ y) & -(x < y);
    },
    isPow2: function isPow2(v) {
        return !(v & v - 1 || !v);
    },
    log2: function log2(v) {
        var r, shift;
        return r = (v > 65535) << 4, r |= shift = ((v >>>= r) > 255) << 3, r |= shift = ((v >>>= shift) > 15) << 2, 
        (r |= shift = ((v >>>= shift) > 3) << 1) | (v >>>= shift) >> 1;
    },
    log10: function log10(v) {
        return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    },
    popCount: function popCount(v) {
        return 16843009 * ((v = (858993459 & (v -= v >>> 1 & 1431655765)) + (v >>> 2 & 858993459)) + (v >>> 4) & 252645135) >>> 24;
    },
    countTrailingZeros: countTrailingZeros,
    nextPow2: function nextPow2(v) {
        return v += 0 === v, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, 
        (v |= v >>> 16) + 1;
    },
    prevPow2: function prevPow2(v) {
        return v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, (v |= v >>> 16) - (v >>> 1);
    },
    parity: function parity(v) {
        return v ^= v >>> 16, v ^= v >>> 8, v ^= v >>> 4, 27030 >>> (v &= 15) & 1;
    },
    reverse: function reverse(v) {
        return REVERSE_TABLE[255 & v] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    },
    interleave2: function interleave2(x, y) {
        return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x &= 65535) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y &= 65535) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
    },
    deinterleave2: function deinterleave2(v, n) {
        return (v = 65535 & ((v = 16711935 & ((v = 252645135 & ((v = 858993459 & ((v = v >>> n & 1431655765) | v >>> 1)) | v >>> 2)) | v >>> 4)) | v >>> 16)) << 16 >> 16;
    },
    interleave3: function interleave3(x, y, z) {
        return x = 1227133513 & ((x = 3272356035 & ((x = 251719695 & ((x = 4278190335 & ((x &= 1023) | x << 16)) | x << 8)) | x << 4)) | x << 2), 
        (x |= (y = 1227133513 & ((y = 3272356035 & ((y = 251719695 & ((y = 4278190335 & ((y &= 1023) | y << 16)) | y << 8)) | y << 4)) | y << 2)) << 1) | (z = 1227133513 & ((z = 3272356035 & ((z = 251719695 & ((z = 4278190335 & ((z &= 1023) | z << 16)) | z << 8)) | z << 4)) | z << 2)) << 2;
    },
    deinterleave3: function deinterleave3(v, n) {
        return (v = 1023 & ((v = 4278190335 & ((v = 251719695 & ((v = 3272356035 & ((v = v >>> n & 1227133513) | v >>> 2)) | v >>> 4)) | v >>> 8)) | v >>> 16)) << 22 >> 22;
    },
    nextCombination: function nextCombination(v) {
        var t = v | v - 1;
        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    }
}), BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/, values = new Array(123), i = 0; i < 123; ++i) values[i] = 64;

for (var _i = 0; _i < 64; ++_i) values["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(_i)] = _i;

var BASE64_VALUES = values;

function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
    function define(np, propName, getter, setter) {
        var pd = Object.getOwnPropertyDescriptor(np, propName);
        if (pd) pd.get && (np[getter] = pd.get), pd.set && setter && (np[setter] = pd.set); else {
            var getterFunc = np[getter];
            getset(np, propName, getterFunc, np[setter]);
        }
    }
    for (var propName, np = ctor.prototype, _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
        var suffix = (propName = sameNameGetSets[_i2])[0].toUpperCase() + propName.slice(1);
        define(np, propName, "get" + suffix, "set" + suffix);
    }
    for (propName in diffNameGetSets) {
        var gs = diffNameGetSets[propName];
        define(np, propName, gs[0], gs[1]);
    }
}

function nextPOT(x) {
    return x -= 1, x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, (x |= x >> 16) + 1;
}

function pushToMap(map, key, value, pushFront) {
    var exists = map[key];
    exists ? Array.isArray(exists) ? pushFront ? (exists.push(exists[0]), exists[0] = value) : exists.push(value) : map[key] = pushFront ? [ value, exists ] : [ exists, value ] : map[key] = value;
}

function contains$1(refNode, otherNode) {
    if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
    if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
    var node = otherNode.parentNode;
    if (node) do {
        if (node === refNode) return !0;
        node = node.parentNode;
    } while (null !== node);
    return !1;
}

function isDomNode(obj) {
    return "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "function" == typeof Node ? obj instanceof Node : obj && "object" === _typeof(obj) && "number" == typeof obj.nodeType && "string" == typeof obj.nodeName;
}

function callInNextTick(callback, p1, p2) {
    callback && setTimeout(function() {
        callback(p1, p2);
    }, 0);
}

function tryCatchFunctor_EDITOR(funcName, forwardArgs, afterCall, bindArg) {
    return Function("arg", "return " + function call_FUNC_InTryCatch(_R_ARGS_) {
        try {
            target._FUNC_(_U_ARGS_);
        } catch (e) {
            cc._throw(e);
        }
    }.toString().replace(/_FUNC_/g, funcName).replace("_R_ARGS_", "target" + (forwardArgs ? ", " + forwardArgs : "")).replace("_U_ARGS_", forwardArgs || "").replace("_AFTER_CALL_", afterCall || ""))(bindArg);
}

function isPlainEmptyObj_DEV(obj) {
    if (!obj || obj.constructor !== Object) return !1;
    for (var k in obj) return !1;
    return !0;
}

function cloneable_DEV(obj) {
    return obj && "function" == typeof obj.clone && (obj.constructor && obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
}

cc.misc = {
    BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
    BASE64_VALUES: BASE64_VALUES,
    propertyDefine: propertyDefine,
    nextPOT: nextPOT,
    pushToMap: pushToMap,
    contains: contains$1,
    isDomNode: isDomNode,
    callInNextTick: callInNextTick,
    tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
    isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
    cloneable_DEV: cloneable_DEV
};

var misc = Object.freeze({
    BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
    BASE64_VALUES: BASE64_VALUES,
    propertyDefine: propertyDefine,
    nextPOT: nextPOT,
    pushToMap: pushToMap,
    contains: contains$1,
    isDomNode: isDomNode,
    callInNextTick: callInNextTick,
    tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
    isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
    cloneable_DEV: cloneable_DEV
});

function Enum(obj) {
    if ("__enums__" in obj) return obj;
    value(obj, "__enums__", null, !0);
    for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
        var key = keys[i], val = obj[key];
        if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        key !== reverseKey && value(obj, reverseKey, key);
    }
    return obj;
}

function ccenum(enumx) {
    "__enums__" in enumx || value(enumx, "__enums__", null, !0);
}

Enum.isEnum = function(enumType) {
    return enumType && enumType.hasOwnProperty("__enums__");
}, Enum.getList = function(enumDef) {
    if (enumDef.__enums__) return enumDef.__enums__;
    var enums = enumDef.__enums__ = [];
    for (var name in enumDef) {
        var value = enumDef[name];
        Number.isInteger(value) && enums.push({
            name: name,
            value: value
        });
    }
    return enums.sort(function(a, b) {
        return a.value - b.value;
    }), enums;
}, cc.Enum = Enum;

var DELIMETER = "$_$";

function createAttrsSingle(owner, ownerConstructor, superAttrs) {
    var AttrsCtor;
    AttrsCtor = function AttrsCtor() {}, superAttrs && extend(AttrsCtor, superAttrs.constructor);
    var attrs = new AttrsCtor();
    return value(owner, "__attrs__", attrs), attrs;
}

function createAttrs(subclass) {
    for (var superClass, chains = cc.Class.getInheritanceChain(subclass), i = chains.length - 1; i >= 0; i--) {
        var cls = chains[i];
        cls.hasOwnProperty("__attrs__") && cls.__attrs__ || createAttrsSingle(cls, 0, (superClass = chains[i + 1]) && superClass.__attrs__);
    }
    return createAttrsSingle(subclass, 0, (superClass = chains[0]) && superClass.__attrs__), 
    subclass.__attrs__;
}

function attr(constructor, propertyName, newAttributes) {
    var attrs, setter;
    if ("function" == typeof constructor) setter = (attrs = getClassAttrs(constructor)).constructor.prototype; else {
        var instance = constructor;
        if (!(attrs = instance.__attrs__)) attrs = createAttrsSingle(instance, 0, getClassAttrs(constructor = instance.constructor));
        setter = attrs;
    }
    if (void 0 === newAttributes) {
        var prefix = propertyName + DELIMETER, ret = {};
        for (var key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
        return ret;
    }
    if ("object" === _typeof(newAttributes)) for (var _key in newAttributes) 95 !== _key.charCodeAt(0) && (setter[propertyName + DELIMETER + _key] = newAttributes[_key]); else 0;
}

function getClassAttrs(constructor) {
    return constructor.hasOwnProperty("__attrs__") && constructor.__attrs__ || createAttrs(constructor);
}

function getClassAttrsProto(constructor) {
    return getClassAttrs(constructor).constructor.prototype;
}

function setClassAttr(ctor, propName, key, value) {
    getClassAttrsProto(ctor)[propName + DELIMETER + key] = value;
}

var PrimitiveType = function() {
    function PrimitiveType(name, defaultValue) {
        _classCallCheck(this, PrimitiveType), this.name = void 0, this.default = void 0, 
        this.name = name, this.default = defaultValue;
    }
    return _createClass(PrimitiveType, [ {
        key: "toString",
        value: function toString() {
            return this.name;
        }
    } ]), PrimitiveType;
}(), CCInteger = new PrimitiveType("Integer", 0);

cc.Integer = CCInteger, cc.CCInteger = CCInteger;

var CCFloat = new PrimitiveType("Float", 0);

cc.Float = CCFloat, cc.CCFloat = CCFloat;

var CCBoolean = new PrimitiveType("Boolean", !1);

cc.Boolean = CCBoolean, cc.CCBoolean = CCBoolean;

var CCString = new PrimitiveType("String", "");

function getTypeChecker(type, attributeName) {
    return function(constructor, mainPropertyName) {
        var propInfo = '"' + getClassName(constructor) + "." + mainPropertyName + '"', mainPropAttrs = attr(constructor, mainPropertyName);
        if (!mainPropAttrs.saveUrlAsAsset) {
            var mainPropAttrsType = mainPropAttrs.type;
            if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat ? mainPropAttrsType = "Number" : mainPropAttrsType !== CCString && mainPropAttrsType !== CCBoolean || (mainPropAttrsType = mainPropAttrsType.toString()), 
            mainPropAttrsType !== type) return void warnID(3604, propInfo);
        }
        if (mainPropAttrs.hasOwnProperty("default")) {
            var defaultVal = mainPropAttrs.default;
            if (void 0 !== defaultVal) if (!(Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal))) {
                var defaultType = _typeof(defaultVal), type_lowerCase = type.toLowerCase();
                if (defaultType === type_lowerCase) {
                    if (!mainPropAttrs.saveUrlAsAsset) if ("object" === type_lowerCase) {
                        if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) return;
                        warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                    } else "Number" !== type && warnID(3606, attributeName, propInfo, type);
                } else {
                    if ("function" === defaultType) return;
                    type === CCString.default && null == defaultVal ? isChildClassOf(mainPropAttrs.ctor, cc.RawAsset) || warnID(3607, propInfo) : warnID(3611, attributeName, propInfo, defaultType);
                }
                delete mainPropAttrs.type;
            }
        }
    };
}

function getObjTypeChecker(typeCtor) {
    return function(classCtor, mainPropName) {
        getTypeChecker("Object", "type")(classCtor, mainPropName);
        var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER + "default"], defaultVal = cc.Class.getDefault(defaultDef);
        if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, cc.ValueType)) {
            var typename = getClassName(typeCtor), info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
            defaultDef ? log(info) : warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
        }
    };
}

cc.String = CCString, cc.CCString = CCString;

var attributeUtils = Object.freeze({
    DELIMETER: DELIMETER,
    createAttrsSingle: createAttrsSingle,
    createAttrs: createAttrs,
    attr: attr,
    getClassAttrs: getClassAttrs,
    getClassAttrsProto: getClassAttrsProto,
    setClassAttr: setClassAttr,
    PrimitiveType: PrimitiveType,
    CCInteger: CCInteger,
    CCFloat: CCFloat,
    CCBoolean: CCBoolean,
    CCString: CCString,
    getTypeChecker: getTypeChecker,
    getObjTypeChecker: getObjTypeChecker
}), SerializableAttrs = {
    url: {
        canUsedInGet: !0
    },
    default: {},
    serializable: {},
    editorOnly: {},
    formerlySerializedAs: {}
};

function parseNotify(val, propName, notify, properties) {
    if (!val.get && !val.set) if (val.hasOwnProperty("default")) {
        var newKey = "_N$" + propName;
        val.get = function() {
            return this[newKey];
        }, val.set = function(value) {
            var oldValue = this[newKey];
            this[newKey] = value, notify.call(this, oldValue);
        };
        var newValue = {};
        for (var attr in properties[newKey] = newValue, SerializableAttrs) {
            var v = SerializableAttrs[attr];
            val.hasOwnProperty(attr) && (newValue[attr] = val[attr], v.canUsedInGet || delete val[attr]);
        }
    } else 0;
}

function checkUrl(val, className, propName, url) {
    Array.isArray(url) && url.length > 0 && (url = url[0]), val.type = url;
}

function parseType(val, type, className, propName) {
    if (Array.isArray(type)) {
        if (!(type.length > 0)) return errorID(5508, className, propName);
        if (cc.RawAsset.isRawAssetType(type[0])) return val.url = type[0], void delete val.type;
        val.type = type = type[0];
    }
}

function getFullFormOfProperty(options, propname_dev, classname_dev) {
    if (!(options && options.constructor === Object)) {
        if (Array.isArray(options) && options.length > 0) {
            options[0];
            return {
                default: [],
                type: options,
                _short: !0
            };
        }
        if ("function" == typeof options) {
            var _type = options;
            return cc.RawAsset.isRawAssetType(_type) ? {
                default: "",
                url: _type,
                _short: !0
            } : {
                default: isChildClassOf(_type, cc.ValueType) ? new _type() : null,
                type: _type,
                _short: !0
            };
        }
        return options instanceof PrimitiveType ? {
            default: options.default,
            _short: !0
        } : {
            default: options,
            _short: !0
        };
    }
    return null;
}

function validateMethodWithProps(func, funcName, className, cls, base) {
    return "function" == typeof func || null === func;
}

var requiringFrames = [];

function peek() {
    return requiringFrames[requiringFrames.length - 1];
}

cc._RF = {
    push: function push(module, uuid, script) {
        void 0 === script && (script = uuid, uuid = ""), requiringFrames.push({
            uuid: uuid,
            script: script,
            module: module,
            exports: module.exports,
            beh: null
        });
    },
    pop: function pop() {
        var frameInfo = requiringFrames.pop(), module = frameInfo.module, exports = module.exports;
        if (exports === frameInfo.exports) {
            for (var anykey in exports) return;
            module.exports = exports = frameInfo.cls;
        }
    },
    peek: peek
};

var DELIMETER$1 = DELIMETER, BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];

function pushUnique(array, item) {
    array.indexOf(item) < 0 && array.push(item);
}

var deferredInitializer = {
    datas: null,
    push: function push(data) {
        if (this.datas) this.datas.push(data); else {
            this.datas = [ data ];
            var self = this;
            setTimeout(function() {
                self.init();
            }, 0);
        }
    },
    init: function init() {
        var datas = this.datas;
        if (datas) {
            for (var i = 0; i < datas.length; ++i) {
                var data = datas[i], cls = data.cls, properties = data.props;
                "function" == typeof properties && (properties = properties());
                var _name = getClassName(cls);
                properties ? declareProperties(cls, _name, properties, cls.$super, data.mixins) : errorID(3633, _name);
            }
            this.datas = null;
        }
    }
};

function appendProp(cls, name) {
    pushUnique(cls.__props__, name);
}

var tmpArray = [];

function defineProp(cls, className, propName, val, es6) {
    var defaultValue = val.default;
    setClassAttr(cls, propName, "default", defaultValue), appendProp(cls, propName);
    var attrs = parseAttributes(cls, val, className, propName, !1);
    if (attrs) {
        for (var onAfterProp = tmpArray, i = 0; i < attrs.length; i++) {
            var attr$1 = attrs[i];
            attr(cls, propName, attr$1), !1 === attr$1.serializable && pushUnique(cls.__values__, propName), 
            attr$1._onAfterProp && onAfterProp.push(attr$1._onAfterProp);
        }
        for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
        tmpArray.length = 0, attrs.length = 0;
    }
}

function defineGetSet(cls, name, propName, val, es6) {
    var getter = val.get, setter = val.set, proto = cls.prototype, d = Object.getOwnPropertyDescriptor(proto, propName), setterUndefined = !d;
    if (getter) {
        0;
        for (var attrs = parseAttributes(cls, val, name, propName, !0), i = 0; i < attrs.length; i++) attr(cls, propName, attrs[i]);
        attrs.length = 0, setClassAttr(cls, propName, "serializable", !1), es6 || get(proto, propName, getter, setterUndefined, setterUndefined);
    }
    setter && (es6 || set$1(proto, propName, setter, setterUndefined, setterUndefined));
}

function getDefault(defaultVal) {
    return "function" == typeof defaultVal ? defaultVal() : defaultVal;
}

function mixinWithInherited(dest, src, filter) {
    for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
}

function doDefine(className, baseClass, mixins, options) {
    var ctors, fireClass, __ctor__ = options.__ctor__, ctor = options.ctor, __es6__ = options.__ES6__;
    __es6__ ? (ctors = [ ctor ], fireClass = ctor) : (ctors = __ctor__ ? [ __ctor__ ] : function _getAllCtors(baseClass, mixins, options) {
        for (var ctors = [], baseOrMixins = [ baseClass ].concat(mixins), b = 0; b < baseOrMixins.length; b++) {
            var baseOrMixin = baseOrMixins[b];
            if (baseOrMixin) for (var baseCtors = (cls = baseOrMixin, CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ]), c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
        }
        var cls;
        var ctor = options.ctor;
        ctor && ctors.push(ctor);
        return ctors;
    }(baseClass, mixins, options), fireClass = _createCtor(ctors, baseClass, className, options), 
    value(fireClass, "extend", function(options) {
        return options.extends = this, CCClass(options);
    }, !0)), value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, !0);
    var prototype = fireClass.prototype;
    if (baseClass && (__es6__ || (extend(fireClass, baseClass), prototype = fireClass.prototype), 
    fireClass.$super = baseClass), mixins) {
        for (var _loop = function _loop(m) {
            var mixin = mixins[m];
            mixinWithInherited(prototype, mixin.prototype), mixinWithInherited(fireClass, mixin, function(prop) {
                return mixin.hasOwnProperty(prop) && !0;
            }), CCClass._isCCClass(mixin) && mixinWithInherited(getClassAttrs(fireClass).constructor.prototype, getClassAttrs(mixin).constructor.prototype);
        }, m = mixins.length - 1; m >= 0; m--) _loop(m);
        prototype.constructor = fireClass;
    }
    return __es6__ || (prototype.__initProps__ = compileProps), setClassName(className, fireClass), 
    fireClass;
}

function getNewValueTypeCodeJit(value) {
    for (var clsName = getClassName(value), type = value.constructor, res = "new " + clsName + "(", i = 0; i < type.__props__.length; i++) {
        var propVal = value[type.__props__[i]];
        0, res += propVal, i < type.__props__.length - 1 && (res += ",");
    }
    return res + ")";
}

function escapeForJS(s) {
    return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}

var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;

function compileProps(actualClass) {
    var attrs = getClassAttrs(actualClass), propList = actualClass.__props__;
    null === propList && (deferredInitializer.init(), propList = actualClass.__props__);
    var initProps = function getInitPropsJit(attrs, propList) {
        for (var F = [], func = "", i = 0; i < propList.length; i++) {
            var prop = propList[i], attrKey = prop + DELIMETER$1 + "default";
            if (attrKey in attrs) {
                var statement = void 0;
                statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
                var expression = void 0, def = attrs[attrKey];
                if ("object" === _typeof(def) && def) expression = def instanceof cc.ValueType ? getNewValueTypeCodeJit(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" == typeof def) {
                    var index = F.length;
                    F.push(def), expression = "F[" + index + "]()";
                } else expression = "string" == typeof def ? escapeForJS(def) : def;
                func += statement = statement + expression + ";\n";
            }
        }
        return 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
    }(attrs, propList);
    actualClass.prototype.__initProps__ = initProps, initProps.call(this);
}

var _createCtor = function(ctors, baseClass, className, options) {
    var body = "return function CCClass(){\n";
    baseClass && boundSuperCalls(baseClass, options, className) && (body += "this._super=null;\n"), 
    body += "this.__initProps__(CCClass);\n";
    var ctorLen = ctors.length;
    if (ctorLen > 0) {
        0;
        var SNIPPET = "].apply(this,arguments);\n";
        if (1 === ctorLen) body += "CCClass.__ctors__[0" + SNIPPET; else {
            body += "var cs=CCClass.__ctors__;\n";
            for (var i = 0; i < ctorLen; i++) body += "cs[" + i + SNIPPET;
        }
        0;
    }
    return body += "}", Function(body)();
};

var superCllRegCondition = /xyz/.test(function() {}.toString()), SuperCallReg = superCllRegCondition ? /\b\._super\b/ : /.*/;

function boundSuperCalls(baseClass, options, className) {
    var hasSuperCall = !1;
    for (var funcName in options) if (!(BUILTIN_ENTRIES.indexOf(funcName) >= 0)) {
        var func = options[funcName];
        if ("function" == typeof func) {
            var pd = getPropertyDescriptor(baseClass.prototype, funcName);
            if (pd) {
                var superFunc = pd.value;
                if ("function" == typeof superFunc) {
                    SuperCallReg.test(func) && (hasSuperCall = !0, options[funcName] = function(superFunc, func) {
                        return function() {
                            var tmp = this._super;
                            this._super = superFunc;
                            var ret = func.apply(this, arguments);
                            return this._super = tmp, ret;
                        };
                    }(superFunc, func));
                    continue;
                }
            }
            0;
        }
    }
    return hasSuperCall;
}

function declareProperties(cls, className, properties, baseClass, mixins, es6) {
    if (cls.__props__ = [], baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice()), 
    mixins) for (var m = 0; m < mixins.length; ++m) {
        var mixin = mixins[m];
        mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter(function(x) {
            return cls.__props__.indexOf(x) < 0;
        })));
    }
    if (properties) for (var propName in function preprocessAttrs(properties, className, cls, es6) {
        for (var propName in properties) {
            var val = properties[propName], fullForm = getFullFormOfProperty(val);
            if (fullForm && (val = properties[propName] = fullForm), val) {
                var notify = val.notify;
                notify && parseNotify(val, propName, notify, properties), "type" in val && parseType(val, val.type, className, propName), 
                "url" in val && checkUrl(val, 0, 0, val.url), "type" in val && val.type;
            }
        }
    }(properties, className), properties) {
        var val = properties[propName];
        "default" in val ? defineProp(cls, className, propName, val) : defineGetSet(cls, className, propName, val, es6);
    }
    var attrs = getClassAttrs(cls);
    cls.__values__ = cls.__props__.filter(function(prop) {
        return !1 !== attrs[prop + DELIMETER$1 + "serializable"];
    });
}

function CCClass(options) {
    var name = (options = options || {}).name, base = options.extends, mixins = options.mixins, cls = function define(className, baseClass, mixins, options) {
        var Component = cc.Component, frame = peek();
        if (frame && isChildClassOf(baseClass, Component)) {
            if (isChildClassOf(frame.cls, Component)) return errorID(3615), null;
            0, className = className || frame.script;
        }
        var cls = doDefine(className, baseClass, mixins, options);
        if (frame) if (isChildClassOf(baseClass, Component)) {
            var uuid = frame.uuid;
            uuid && _setClassId(uuid, cls), frame.cls = cls;
        } else isChildClassOf(frame.cls, Component) || (frame.cls = cls);
        return cls;
    }(name, base, mixins, options);
    name || (name = cc.js.getClassName(cls)), cls._sealed = !0, base && (base._sealed = !1);
    var properties = options.properties;
    "function" == typeof properties || base && null === base.__props__ || mixins && mixins.some(function(x) {
        return null === x.__props__;
    }) ? (deferredInitializer.push({
        cls: cls,
        props: properties,
        mixins: mixins
    }), cls.__props__ = cls.__values__ = null) : declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
    var staticPropName, statics = options.statics;
    if (statics) for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
    for (var funcName in options) if (!(BUILTIN_ENTRIES.indexOf(funcName) >= 0)) {
        var func = options[funcName];
        validateMethodWithProps(func) && value(cls.prototype, funcName, func, !0, !0);
    }
    var editor = options.editor;
    return editor && isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor), 
    cls;
}

CCClass._isCCClass = function(constructor) {
    return constructor && constructor.hasOwnProperty && constructor.hasOwnProperty("__ctors__");
}, CCClass.fastDefine = function(className, constructor, serializableFields) {
    setClassName(className, constructor);
    for (var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields), attrProtos = getClassAttrsProto(constructor), i = 0; i < props.length; i++) {
        var key = props[i];
        attrProtos[key + DELIMETER$1 + "visible"] = !1, attrProtos[key + DELIMETER$1 + "default"] = serializableFields[key];
    }
}, CCClass.Attr = attributeUtils, CCClass.attr = attr, CCClass.getInheritanceChain = function getInheritanceChain(constructor) {
    for (var chain = []; constructor = getSuper(constructor); ) constructor !== Object && chain.push(constructor);
    return chain;
};

var PrimitiveTypes = {
    Integer: "Number",
    Float: "Number",
    Boolean: "Boolean",
    String: "String"
}, tmpAttrs = [];

function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
    var attrsProto = null, attrsProtoKey = "";
    function getAttrsProto() {
        return attrsProtoKey = propertyName + DELIMETER$1, attrsProto = getClassAttrsProto(constructor);
    }
    tmpAttrs.length = 0;
    var result = tmpAttrs, type = attributes.type;
    if (type) {
        var primitiveType = PrimitiveTypes[type];
        if (primitiveType) result.push({
            type: type,
            _onAfterProp: void 0
        }); else if ("Object" === type) 0; else if ("object" === _typeof(type)) Enum.isEnum(type) && result.push({
            type: "Enum",
            enumList: Enum.getList(type)
        }); else if ("function" == typeof type) {
            var typeChecker;
            0, result.push({
                type: "Object",
                ctor: type,
                _onAfterProp: typeChecker
            });
        } else 0;
    }
    var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
        if (attributeName in attributes) {
            var val = attributes[attributeName];
            _typeof(val) === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attributeName] = val);
        }
    };
    attributes.editorOnly && ((attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = !0), 
    attributes.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = !0), 
    !1 === attributes.serializable && ((attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = !1), 
    parseSimpleAttribute("formerlySerializedAs", "string");
    var range = attributes.range;
    return range && Array.isArray(range) && range.length >= 2 && ((attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0], 
    (attrsProto || getAttrsProto())[attrsProtoKey + "max"] = range[1], range.length > 2 && ((attrsProto || getAttrsProto())[attrsProtoKey + "step"] = range[2])), 
    parseSimpleAttribute("min", "number"), parseSimpleAttribute("max", "number"), parseSimpleAttribute("step", "number"), 
    result;
}

CCClass.isArray = function(defaultVal) {
    return defaultVal = getDefault(defaultVal), Array.isArray(defaultVal);
}, CCClass.getDefault = getDefault, CCClass.escapeForJS = escapeForJS, CCClass.IDENTIFIER_RE = IDENTIFIER_RE, 
CCClass.getNewValueTypeCode = getNewValueTypeCodeJit, cc.Class = CCClass;

var ValueType = function() {
    function ValueType() {
        _classCallCheck(this, ValueType);
    }
    return _createClass(ValueType, [ {
        key: "clone",
        value: function clone() {
            return errorID(100, getClassName(this) + ".clone"), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return !1;
        }
    }, {
        key: "set",
        value: function set(other) {
            errorID(100, getClassName(this) + ".set");
        }
    }, {
        key: "toString",
        value: function toString() {
            return "" + {};
        }
    } ]), ValueType;
}();

setClassName("cc.ValueType", ValueType), cc.ValueType = ValueType;

var _d2r = Math.PI / 180, _r2d = 180 / Math.PI, EPSILON = 1e-6;

function clamp(val, min, max) {
    if (min > max) {
        var temp = min;
        min = max, max = temp;
    }
    return val < min ? min : val > max ? max : val;
}

function clamp01(val) {
    return val < 0 ? 0 : val > 1 ? 1 : val;
}

function lerp(from, to, ratio) {
    return from + (to - from) * ratio;
}

function toRadian(a) {
    return a * _d2r;
}

function toDegree(a) {
    return a * _r2d;
}

var random = Math.random;

function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

function randomRangeInt(min, max) {
    return Math.floor(randomRange(min, max));
}

function pseudoRandom(seed) {
    return (seed = (9301 * seed + 49297) % 233280) / 233280;
}

function pseudoRandomRange(seed, min, max) {
    return pseudoRandom(seed) * (max - min) + min;
}

function repeat(t, length) {
    return t - Math.floor(t / length) * length;
}

function pingPong(t, length) {
    return t = repeat(t, 2 * length), t = length - Math.abs(t - length);
}

function inverseLerp(from, to, value) {
    return (value - from) / (to - from);
}

var _x = 0, _y = 0, Vec2 = function(_ValueType) {
    function Vec2(x, y) {
        var _this;
        return _classCallCheck(this, Vec2), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec2).call(this))).x = void 0, 
        _this.y = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y) : (_this.x = x || 0, 
        _this.y = y || 0), _this;
    }
    return _inherits(Vec2, ValueType), _createClass(Vec2, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Vec2(a.x, a.y);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y) {
            return out.x = x, out.y = y, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.x = a.x + b.x, out.y = a.y + b.y, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.x = a.x - b.x, out.y = a.y - b.y, out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.x = a.x * b.x, out.y = a.y * b.y, out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.x = a.x / b.x, out.y = a.y / b.y, out;
        }
    }, {
        key: "ceil",
        value: function ceil(out, a) {
            return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out;
        }
    }, {
        key: "floor",
        value: function floor(out, a) {
            return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out;
        }
    }, {
        key: "min",
        value: function min(out, a, b) {
            return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out;
        }
    }, {
        key: "max",
        value: function max(out, a, b) {
            return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out;
        }
    }, {
        key: "round",
        value: function round(out, a) {
            return out.x = Math.round(a.x), out.y = Math.round(a.y), out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out;
        }
    }, {
        key: "distance",
        value: function distance(a, b) {
            return _x = b.x - a.x, _y = b.y - a.y, Math.sqrt(_x * _x + _y * _y);
        }
    }, {
        key: "squaredDistance",
        value: function squaredDistance(a, b) {
            return _x = b.x - a.x, _y = b.y - a.y, _x * _x + _y * _y;
        }
    }, {
        key: "len",
        value: function len(a) {
            return _x = a.x, _y = a.y, Math.sqrt(_x * _x + _y * _y);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            return _x = a.x, _y = a.y, _x * _x + _y * _y;
        }
    }, {
        key: "negate",
        value: function negate(out, a) {
            return out.x = -a.x, out.y = -a.y, out;
        }
    }, {
        key: "inverse",
        value: function inverse(out, a) {
            return out.x = 1 / a.x, out.y = 1 / a.y, out;
        }
    }, {
        key: "inverseSafe",
        value: function inverseSafe(out, a) {
            return _x = a.x, _y = a.y, Math.abs(_x) < EPSILON ? out.x = 0 : out.x = 1 / _x, 
            Math.abs(_y) < EPSILON ? out.y = 0 : out.y = 1 / _y, out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            _x = a.x, _y = a.y;
            var len = _x * _x + _y * _y;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = _x * len, out.y = _y * len), 
            out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y;
        }
    }, {
        key: "cross",
        value: function cross(out, a, b) {
            return out.x = out.y = 0, out.z = a.x * b.y - a.y * b.x, out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return _x = a.x, _y = a.y, out.x = _x + t * (b.x - _x), out.y = _y + t * (b.y - _y), 
            out;
        }
    }, {
        key: "random",
        value: function random$1(out, scale) {
            scale = scale || 1;
            var r = 2 * random() * Math.PI;
            return out.x = Math.cos(r) * scale, out.y = Math.sin(r) * scale, out;
        }
    }, {
        key: "transformMat3",
        value: function transformMat3(out, a, m) {
            return _x = a.x, _y = a.y, out.x = m.m00 * _x + m.m03 * _y + m.m06, out.y = m.m01 * _x + m.m04 * _y + m.m07, 
            out;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(out, a, m) {
            return _x = a.x, _y = a.y, out.x = m.m00 * _x + m.m04 * _y + m.m12, out.y = m.m01 * _x + m.m05 * _y + m.m13, 
            out;
        }
    }, {
        key: "str",
        value: function str(a) {
            return "Vec2(".concat(a.x, ", ").concat(a.y, ")");
        }
    }, {
        key: "array",
        value: function array(out, v) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y));
        }
    }, {
        key: "angle",
        value: function angle(a, b) {
            Vec2.normalize(v2_1, a), Vec2.normalize(v2_2, b);
            var cosine = Vec2.dot(v2_1, v2_2);
            return cosine > 1 ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
        }
    } ]), _createClass(Vec2, [ {
        key: "clone",
        value: function clone() {
            return new Vec2(this.x, this.y);
        }
    }, {
        key: "set",
        value: function set(x, y) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y) : (this.x = x || 0, 
            this.y = y || 0), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y));
        }
    }, {
        key: "equals2f",
        value: function equals2f(x, y) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return other && this.x === other.x && this.y === other.y;
        }
    }, {
        key: "strictEquals2f",
        value: function strictEquals2f(x, y) {
            return this.x === x && this.y === y;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ")");
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return _x = this.x, _y = this.y, this.x = _x + ratio * (to.x - _x), this.y = _y + ratio * (to.y - _y), 
            this;
        }
    }, {
        key: "clampf",
        value: function clampf(minInclusive, maxInclusive) {
            return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
            this;
        }
    }, {
        key: "add",
        value: function add(other) {
            return this.x = this.x + other.x, this.y = this.y + other.y, this;
        }
    }, {
        key: "add2f",
        value: function add2f(x, y) {
            return this.x = this.x + x, this.y = this.y + y, this;
        }
    }, {
        key: "subtract",
        value: function subtract(other) {
            return this.x = this.x - other.x, this.y = this.y - other.y, this;
        }
    }, {
        key: "subtract2f",
        value: function subtract2f(x, y) {
            return this.x = this.x - x, this.y = this.y - y, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return "object" === _typeof(scalar) && console.warn("should use Vec2.multiply for vector * vector operation"), 
            this.x = this.x * scalar, this.y = this.y * scalar, this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return "object" !== _typeof(other) && console.warn("should use Vec2.scale for vector * scalar operation"), 
            this.x = this.x * other.x, this.y = this.y * other.y, this;
        }
    }, {
        key: "multiply2f",
        value: function multiply2f(x, y) {
            return this.x = this.x * x, this.y = this.y * y, this;
        }
    }, {
        key: "divide",
        value: function divide(other) {
            return this.x = this.x / other.x, this.y = this.y / other.y, this;
        }
    }, {
        key: "divide2f",
        value: function divide2f(x, y) {
            return this.x = this.x / x, this.y = this.y / y, this;
        }
    }, {
        key: "negative",
        value: function negative() {
            return this.x = -this.x, this.y = -this.y, this;
        }
    }, {
        key: "dot",
        value: function dot(other) {
            return this.x * other.x + this.y * other.y;
        }
    }, {
        key: "cross",
        value: function cross(other) {
            return this.x * other.y - this.y * other.x;
        }
    }, {
        key: "length",
        value: function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return this.x * this.x + this.y * this.y;
        }
    }, {
        key: "normalize",
        value: function normalize() {
            _x = this.x, _y = this.y;
            var len = _x * _x + _y * _y;
            return len > 0 && (len = 1 / Math.sqrt(len), this.x = this.x * len, this.y = this.y * len), 
            this;
        }
    }, {
        key: "angle",
        value: function angle(other) {
            var magSqr1 = this.lengthSqr(), magSqr2 = other.lengthSqr();
            if (0 === magSqr1 || 0 === magSqr2) return console.warn("Can't get angle between zero vector"), 
            0;
            var theta = this.dot(other) / Math.sqrt(magSqr1 * magSqr2);
            return theta = clamp(theta, -1, 1), Math.acos(theta);
        }
    }, {
        key: "signAngle",
        value: function signAngle(other) {
            var angle = this.angle(other);
            return this.cross(other) < 0 ? -angle : angle;
        }
    }, {
        key: "rotate",
        value: function rotate(radians) {
            _x = this.x, _y = this.y;
            var sin = Math.sin(radians), cos = Math.cos(radians);
            return this.x = cos * _x - sin * _y, this.y = sin * _x + cos * _y, this;
        }
    }, {
        key: "project",
        value: function project(other) {
            var scalar = this.dot(other) / other.dot(other);
            return this.x = other.x * scalar, this.y = other.y * scalar, this;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(matrix) {
            return _x = this.x, _y = this.y, this.x = matrix.m00 * _x + matrix.m04 * _y + matrix.m12, 
            this.y = matrix.m01 * _x + matrix.m05 * _y + matrix.m13, this;
        }
    } ]), Vec2;
}();

Vec2.ZERO = Object.freeze(new Vec2(0, 0)), Vec2.ONE = Object.freeze(new Vec2(1, 1)), 
Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1)), Vec2.UNIT_X = Object.freeze(new Vec2(1, 0)), 
Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));

var v2_1 = new Vec2(), v2_2 = new Vec2();

CCClass.fastDefine("cc.Vec2", Vec2, {
    x: 0,
    y: 0
}), cc.Vec2 = Vec2, cc.v2 = function v2(x, y) {
    return new Vec2(x, y);
};

var _x$1 = 0, _y$1 = 0, _z = 0, Vec3 = function(_ValueType) {
    function Vec3(x, y, z) {
        var _this;
        return _classCallCheck(this, Vec3), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec3).call(this))).x = void 0, 
        _this.y = void 0, _this.z = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
        _this.y = x.y, _this.z = x.z) : (_this.x = x || 0, _this.y = y || 0, _this.z = z || 0), 
        _this;
    }
    return _inherits(Vec3, ValueType), _createClass(Vec3, null, [ {
        key: "zero",
        value: function zero(out) {
            return out.x = 0, out.y = 0, out.z = 0, out;
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new Vec3(a.x, a.y, a.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y, z) {
            return out.x = x, out.y = y, out.z = z, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out;
        }
    }, {
        key: "ceil",
        value: function ceil(out, a) {
            return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out;
        }
    }, {
        key: "floor",
        value: function floor(out, a) {
            return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
            out;
        }
    }, {
        key: "min",
        value: function min(out, a, b) {
            return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
            out;
        }
    }, {
        key: "max",
        value: function max(out, a, b) {
            return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
            out;
        }
    }, {
        key: "round",
        value: function round(out, a) {
            return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
            out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
            out;
        }
    }, {
        key: "distance",
        value: function distance(a, b) {
            return _x$1 = b.x - a.x, _y$1 = b.y - a.y, _z = b.z - a.z, Math.sqrt(_x$1 * _x$1 + _y$1 * _y$1 + _z * _z);
        }
    }, {
        key: "squaredDistance",
        value: function squaredDistance(a, b) {
            return _x$1 = b.x - a.x, _y$1 = b.y - a.y, _z = b.z - a.z, _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
        }
    }, {
        key: "len",
        value: function len(a) {
            return _x$1 = a.x, _y$1 = a.y, _z = a.z, Math.sqrt(_x$1 * _x$1 + _y$1 * _y$1 + _z * _z);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            return _x$1 = a.x, _y$1 = a.y, _z = a.z, _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
        }
    }, {
        key: "negate",
        value: function negate(out, a) {
            return out.x = -a.x, out.y = -a.y, out.z = -a.z, out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out;
        }
    }, {
        key: "invertSafe",
        value: function invertSafe(out, a) {
            return _x$1 = a.x, _y$1 = a.y, _z = a.z, Math.abs(_x$1) < EPSILON ? out.x = 0 : out.x = 1 / _x$1, 
            Math.abs(_y$1) < EPSILON ? out.y = 0 : out.y = 1 / _y$1, Math.abs(_z) < EPSILON ? out.z = 0 : out.z = 1 / _z, 
            out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            _x$1 = a.x, _y$1 = a.y, _z = a.z;
            var len = _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = _x$1 * len, out.y = _y$1 * len, 
            out.z = _z * len), out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z;
        }
    }, {
        key: "cross",
        value: function cross(out, a, b) {
            return out.x = a.y * b.z - a.z * b.y, out.y = a.z * b.x - a.x * b.z, out.z = a.x * b.y - a.y * b.x, 
            out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
            out;
        }
    }, {
        key: "random",
        value: function random$1(out, scale) {
            scale = scale || 1;
            var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
            out.z = cosTheta * scale, out;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(out, a, m) {
            _x$1 = a.x, _y$1 = a.y, _z = a.z;
            var rhw = m.m03 * _x$1 + m.m07 * _y$1 + m.m11 * _z + m.m15;
            return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * _x$1 + m.m04 * _y$1 + m.m08 * _z + m.m12) * rhw, 
            out.y = (m.m01 * _x$1 + m.m05 * _y$1 + m.m09 * _z + m.m13) * rhw, out.z = (m.m02 * _x$1 + m.m06 * _y$1 + m.m10 * _z + m.m14) * rhw, 
            out;
        }
    }, {
        key: "transformMat4Normal",
        value: function transformMat4Normal(out, a, m) {
            _x$1 = a.x, _y$1 = a.y, _z = a.z;
            var rhw = m.m03 * _x$1 + m.m07 * _y$1 + m.m11 * _z;
            return rhw = rhw ? 1 / rhw : 1, out.x = (m.m00 * _x$1 + m.m04 * _y$1 + m.m08 * _z) * rhw, 
            out.y = (m.m01 * _x$1 + m.m05 * _y$1 + m.m09 * _z) * rhw, out.z = (m.m02 * _x$1 + m.m06 * _y$1 + m.m10 * _z) * rhw, 
            out;
        }
    }, {
        key: "transformMat3",
        value: function transformMat3(out, a, m) {
            return _x$1 = a.x, _y$1 = a.y, _z = a.z, out.x = _x$1 * m.m00 + _y$1 * m.m03 + _z * m.m06, 
            out.y = _x$1 * m.m01 + _y$1 * m.m04 + _z * m.m07, out.z = _x$1 * m.m02 + _y$1 * m.m05 + _z * m.m08, 
            out;
        }
    }, {
        key: "transformQuat",
        value: function transformQuat(out, a, q) {
            var ix = q.w * a.x + q.y * a.z - q.z * a.y, iy = q.w * a.y + q.z * a.x - q.x * a.z, iz = q.w * a.z + q.x * a.y - q.y * a.x, iw = -q.x * a.x - q.y * a.y - q.z * a.z;
            return out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y, out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z, 
            out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x, out;
        }
    }, {
        key: "transformRTS",
        value: function transformRTS(out, a, r, t, s) {
            var x = a.x * s.x, y = a.y * s.y, z = a.z * s.z, ix = r.w * x + r.y * z - r.z * y, iy = r.w * y + r.z * x - r.x * z, iz = r.w * z + r.x * y - r.y * x, iw = -r.x * x - r.y * y - r.z * z;
            return out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x, out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y, 
            out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z, out;
        }
    }, {
        key: "rotateX",
        value: function rotateX(out, v, o, a) {
            _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
            var cos = Math.cos(a), sin = Math.sin(a), rx = _x$1, ry = _y$1 * cos - _z * sin, rz = _y$1 * sin + _z * cos;
            return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
        }
    }, {
        key: "rotateY",
        value: function rotateY(out, v, o, a) {
            _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
            var cos = Math.cos(a), sin = Math.sin(a), rx = _z * sin + _x$1 * cos, ry = _y$1, rz = _z * cos - _x$1 * sin;
            return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(out, v, o, a) {
            _x$1 = v.x - o.x, _y$1 = v.y - o.y, _z = v.z - o.z;
            var cos = Math.cos(a), sin = Math.sin(a), rx = _x$1 * cos - _y$1 * sin, ry = _x$1 * sin + _y$1 * cos, rz = _z;
            return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
        }
    }, {
        key: "array",
        value: function array(out, v) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y && a.z === b.z;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON, a0 = a.x, a1 = a.y, a2 = a.z, b0 = b.x, b1 = b.y, b2 = b.z;
            return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2));
        }
    }, {
        key: "angle",
        value: function angle(a, b) {
            Vec3.normalize(v3_1, a), Vec3.normalize(v3_2, b);
            var cosine = Vec3.dot(v3_1, v3_2);
            return cosine > 1 ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
        }
    }, {
        key: "projectOnPlane",
        value: function projectOnPlane(out, a, n) {
            return Vec3.subtract(out, a, Vec3.project(out, a, n));
        }
    }, {
        key: "project",
        value: function project(out, a, b) {
            var sqrLen = Vec3.lengthSqr(b);
            return sqrLen < 1e-6 ? Vec3.set(out, 0, 0, 0) : Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
        }
    } ]), _createClass(Vec3, [ {
        key: "clone",
        value: function clone() {
            return new Vec3(this.x, this.y, this.z);
        }
    }, {
        key: "set",
        value: function set(x, y, z) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z) : (this.x = x || 0, 
            this.y = y || 0, this.z = z || 0), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z));
        }
    }, {
        key: "equals3f",
        value: function equals3f(x, y, z) {
            var epsilon = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : EPSILON;
            return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.x === other.x && this.y === other.y && this.z === other.z;
        }
    }, {
        key: "strictEquals3f",
        value: function strictEquals3f(x, y, z) {
            return this.x === x && this.y === y && this.z === z;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ")");
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return this.x = this.x + ratio * (to.x - this.x), this.y = this.y + ratio * (to.y - this.y), 
            this.z = this.z + ratio * (to.z - this.z), this;
        }
    }, {
        key: "add",
        value: function add(other) {
            return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
            this;
        }
    }, {
        key: "add3f",
        value: function add3f(x, y, z) {
            return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this;
        }
    }, {
        key: "subtract",
        value: function subtract(other) {
            return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
            this;
        }
    }, {
        key: "subtract3f",
        value: function subtract3f(x, y, z) {
            return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return "object" === _typeof(scalar) && console.warn("should use Vec3.multiply for vector * vector operation"), 
            this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return "object" !== _typeof(other) && console.warn("should use Vec3.scale for vector * scalar operation"), 
            this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
            this;
        }
    }, {
        key: "multiply3f",
        value: function multiply3f(x, y, z) {
            return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this;
        }
    }, {
        key: "divide",
        value: function divide(other) {
            return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
            this;
        }
    }, {
        key: "divide3f",
        value: function divide3f(x, y, z) {
            return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this;
        }
    }, {
        key: "negative",
        value: function negative() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
    }, {
        key: "clampf",
        value: function clampf(minInclusive, maxInclusive) {
            return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
            this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this;
        }
    }, {
        key: "dot",
        value: function dot(other) {
            return this.x * other.x + this.y * other.y + this.z * other.z;
        }
    }, {
        key: "cross",
        value: function cross(other) {
            var ax = this.x, ay = this.y, az = this.z, bx = other.x, by = other.y, bz = other.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
            this;
        }
    }, {
        key: "length",
        value: function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
    }, {
        key: "normalize",
        value: function normalize() {
            _x$1 = this.x, _y$1 = this.y, _z = this.z;
            var len = _x$1 * _x$1 + _y$1 * _y$1 + _z * _z;
            return len > 0 && (len = 1 / Math.sqrt(len), this.x = _x$1 * len, this.y = _y$1 * len, 
            this.z = _z * len), this;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(matrix) {
            _x$1 = this.x, _y$1 = this.y, _z = this.z;
            var rhw = matrix.m03 * _x$1 + matrix.m07 * _y$1 + matrix.m11 * _z + matrix.m15;
            return rhw = rhw ? 1 / rhw : 1, this.x = (matrix.m00 * _x$1 + matrix.m04 * _y$1 + matrix.m08 * _z + matrix.m12) * rhw, 
            this.y = (matrix.m01 * _x$1 + matrix.m05 * _y$1 + matrix.m09 * _z + matrix.m13) * rhw, 
            this.z = (matrix.m02 * _x$1 + matrix.m06 * _y$1 + matrix.m10 * _z + matrix.m14) * rhw, 
            this;
        }
    } ]), Vec3;
}();

Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0)), Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0)), 
Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1)), Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0)), 
Vec3.ONE = Object.freeze(new Vec3(1, 1, 1)), Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));

var v3_1 = new Vec3(), v3_2 = new Vec3();

CCClass.fastDefine("cc.Vec3", Vec3, {
    x: 0,
    y: 0,
    z: 0
}), cc.Vec3 = Vec3, cc.v3 = function v3(x, y, z) {
    return new Vec3(x, y, z);
};

var _x$2 = 0, _y$2 = 0, _z$1 = 0, _w = 0, Vec4 = function(_ValueType) {
    function Vec4(x, y, z, w) {
        var _this;
        return _classCallCheck(this, Vec4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Vec4).call(this))).x = void 0, 
        _this.y = void 0, _this.z = void 0, _this.w = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
        _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, _this.y = y || 0, 
        _this.z = z || 0, _this.w = w || 0), _this;
    }
    return _inherits(Vec4, ValueType), _createClass(Vec4, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Vec4(a.x, a.y, a.z, a.w);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y, z, w) {
            return out.x = x, out.y = y, out.z = z, out.w = w, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out.w = a.w + b.w, 
            out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out.w = a.w - b.w, 
            out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out.w = a.w * b.w, 
            out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out.w = a.w / b.w, 
            out;
        }
    }, {
        key: "ceil",
        value: function ceil(out, a) {
            return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out.w = Math.ceil(a.w), 
            out;
        }
    }, {
        key: "floor",
        value: function floor(out, a) {
            return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
            out.w = Math.floor(a.w), out;
        }
    }, {
        key: "min",
        value: function min(out, a, b) {
            return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
            out.w = Math.min(a.w, b.w), out;
        }
    }, {
        key: "max",
        value: function max(out, a, b) {
            return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
            out.w = Math.max(a.w, b.w), out;
        }
    }, {
        key: "round",
        value: function round(out, a) {
            return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
            out.w = Math.round(a.w), out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
            out.w = a.w + b.w * scale, out;
        }
    }, {
        key: "distance",
        value: function distance(a, b) {
            var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
            return Math.sqrt(x * x + y * y + z * z + w * w);
        }
    }, {
        key: "squaredDistance",
        value: function squaredDistance(a, b) {
            var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
            return x * x + y * y + z * z + w * w;
        }
    }, {
        key: "len",
        value: function len(a) {
            return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, Math.sqrt(_x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
        }
    }, {
        key: "negate",
        value: function negate(out, a) {
            return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = -a.w, out;
        }
    }, {
        key: "inverse",
        value: function inverse(out, a) {
            return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out.w = 1 / a.w, out;
        }
    }, {
        key: "inverseSafe",
        value: function inverseSafe(out, a) {
            return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, Math.abs(_x$2) < EPSILON ? out.x = 0 : out.x = 1 / _x$2, 
            Math.abs(_y$2) < EPSILON ? out.y = 0 : out.y = 1 / _y$2, Math.abs(_z$1) < EPSILON ? out.z = 0 : out.z = 1 / _z$1, 
            Math.abs(_w) < EPSILON ? out.w = 0 : out.w = 1 / _w, out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w;
            var len = _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = _x$2 * len, out.y = _y$2 * len, 
            out.z = _z$1 * len, out.w = _w * len), out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
            out.w = a.w + t * (b.w - a.w), out;
        }
    }, {
        key: "random",
        value: function random$1(out, scale) {
            scale = scale || 1;
            var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
            out.z = cosTheta * scale, out.w = 0, out;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(out, a, m) {
            return _x$2 = a.x, _y$2 = a.y, _z$1 = a.z, _w = a.w, out.x = m.m00 * _x$2 + m.m04 * _y$2 + m.m08 * _z$1 + m.m12 * _w, 
            out.y = m.m01 * _x$2 + m.m05 * _y$2 + m.m09 * _z$1 + m.m13 * _w, out.z = m.m02 * _x$2 + m.m06 * _y$2 + m.m10 * _z$1 + m.m14 * _w, 
            out.w = m.m03 * _x$2 + m.m07 * _y$2 + m.m11 * _z$1 + m.m15 * _w, out;
        }
    }, {
        key: "transformQuat",
        value: function transformQuat(out, a, q) {
            var x = a.x, y = a.y, z = a.z;
            _x$2 = q.x, _y$2 = q.y, _z$1 = q.z;
            var ix = (_w = q.w) * x + _y$2 * z - _z$1 * y, iy = _w * y + _z$1 * x - _x$2 * z, iz = _w * z + _x$2 * y - _y$2 * x, iw = -_x$2 * x - _y$2 * y - _z$1 * z;
            return out.x = ix * _w + iw * -_x$2 + iy * -_z$1 - iz * -_y$2, out.y = iy * _w + iw * -_y$2 + iz * -_x$2 - ix * -_z$1, 
            out.z = iz * _w + iw * -_z$1 + ix * -_y$2 - iy * -_x$2, out.w = a.w, out;
        }
    }, {
        key: "array",
        value: function array(out, v) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out[ofs + 3] = v.w, 
            out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
        }
    } ]), _createClass(Vec4, [ {
        key: "clone",
        value: function clone() {
            return new Vec4(this.x, this.y, this.z, this.w);
        }
    }, {
        key: "set",
        value: function set(x, y, z, w) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
            this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 0), 
            this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
        }
    }, {
        key: "equals4f",
        value: function equals4f(x, y, z, w) {
            var epsilon = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : EPSILON;
            return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(w));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
    }, {
        key: "strictEquals4f",
        value: function strictEquals4f(x, y, z, w) {
            return this.x === x && this.y === y && this.z === z && this.w === w;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, this.x = _x$2 + ratio * (to.x - _x$2), 
            this.y = _y$2 + ratio * (to.y - _y$2), this.z = _z$1 + ratio * (to.z - _z$1), this.w = _w + ratio * (to.w - _w), 
            this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ", ").concat(this.w.toFixed(2), ")");
        }
    }, {
        key: "clampf",
        value: function clampf(minInclusive, maxInclusive) {
            return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
            this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this.w = clamp(this.w, minInclusive.w, maxInclusive.w), 
            this;
        }
    }, {
        key: "add",
        value: function add(other) {
            return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
            this.w = this.w + other.w, this;
        }
    }, {
        key: "add4f",
        value: function add4f(x, y, z, w) {
            return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this.w = this.w + w, 
            this;
        }
    }, {
        key: "subtract",
        value: function subtract(other) {
            return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
            this.w = this.w - other.w, this;
        }
    }, {
        key: "subtract4f",
        value: function subtract4f(x, y, z, w) {
            return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this.w = this.w - w, 
            this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return "object" === _typeof(scalar) && console.warn("should use Vec4.multiply for vector * vector operation"), 
            this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this.w = this.w * scalar, 
            this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return "object" !== _typeof(other) && console.warn("should use Vec4.scale for vector * scalar operation"), 
            this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
            this.w = this.w * other.w, this;
        }
    }, {
        key: "multiply4f",
        value: function multiply4f(x, y, z, w) {
            return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this.w = this.w * w, 
            this;
        }
    }, {
        key: "divide",
        value: function divide(other) {
            return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
            this.w = this.w / other.w, this;
        }
    }, {
        key: "divide4f",
        value: function divide4f(x, y, z, w) {
            return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this.w = this.w / w, 
            this;
        }
    }, {
        key: "negative",
        value: function negative() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
    }, {
        key: "dot",
        value: function dot(vector) {
            return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        }
    }, {
        key: "cross",
        value: function cross(vector) {
            var ax = this.x, ay = this.y, az = this.z, bx = vector.x, by = vector.y, bz = vector.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
            this;
        }
    }, {
        key: "length",
        value: function length() {
            return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, Math.sqrt(_x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
        }
    }, {
        key: "normalize",
        value: function normalize() {
            _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w;
            var len = _x$2 * _x$2 + _y$2 * _y$2 + _z$1 * _z$1 + _w * _w;
            return len > 0 && (len = 1 / Math.sqrt(len), this.x = _x$2 * len, this.y = _y$2 * len, 
            this.z = _z$1 * len, this.w = _w * len), this;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(matrix) {
            return _x$2 = this.x, _y$2 = this.y, _z$1 = this.z, _w = this.w, this.x = matrix.m00 * _x$2 + matrix.m04 * _y$2 + matrix.m08 * _z$1 + matrix.m12 * _w, 
            this.y = matrix.m01 * _x$2 + matrix.m05 * _y$2 + matrix.m09 * _z$1 + matrix.m13 * _w, 
            this.z = matrix.m02 * _x$2 + matrix.m06 * _y$2 + matrix.m10 * _z$1 + matrix.m14 * _w, 
            this.w = matrix.m03 * _x$2 + matrix.m07 * _y$2 + matrix.m11 * _z$1 + matrix.m15 * _w, 
            this;
        }
    } ]), Vec4;
}();

Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0)), Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1)), 
Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1)), CCClass.fastDefine("cc.Vec4", Vec4, {
    x: 0,
    y: 0,
    z: 0,
    w: 0
}), cc.Vec4 = Vec4, cc.v4 = function v4(x, y, z, w) {
    return new Vec4(x, y, z, w);
};

var _a00 = 0, _a01 = 0, _a02 = 0, _a10 = 0, _a11 = 0, _a12 = 0, _a20 = 0, _a21 = 0, _a22 = 0, Mat3 = function(_ValueType) {
    function Mat3() {
        var _this, m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
        return _classCallCheck(this, Mat3), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mat3).call(this))).m00 = void 0, 
        _this.m01 = void 0, _this.m02 = void 0, _this.m03 = void 0, _this.m04 = void 0, 
        _this.m05 = void 0, _this.m06 = void 0, _this.m07 = void 0, _this.m08 = void 0, 
        "object" === _typeof(m00) ? (_this.m00 = m00.m00, _this.m01 = m00.m01, _this.m02 = m00.m02, 
        _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, _this.m06 = m00.m06, 
        _this.m07 = m00.m07, _this.m08 = m00.m08) : (_this.m00 = m00, _this.m01 = m01, _this.m02 = m02, 
        _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, _this.m07 = m07, 
        _this.m08 = m08), _this;
    }
    return _inherits(Mat3, ValueType), _createClass(Mat3, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
            out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out;
        }
    }, {
        key: "set",
        value: function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
            return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m10, out.m04 = m11, 
            out.m05 = m12, out.m06 = m20, out.m07 = m21, out.m08 = m22, out;
        }
    }, {
        key: "identity",
        value: function identity(out) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
            out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
        }
    }, {
        key: "transpose",
        value: function transpose(out, a) {
            return out === a ? (_a01 = a.m01, _a02 = a.m02, _a12 = a.m05, out.m01 = a.m03, out.m02 = a.m06, 
            out.m03 = _a01, out.m05 = a.m07, out.m06 = _a02, out.m07 = _a12) : (out.m00 = a.m00, 
            out.m01 = a.m03, out.m02 = a.m06, out.m03 = a.m01, out.m04 = a.m04, out.m05 = a.m07, 
            out.m06 = a.m02, out.m07 = a.m05, out.m08 = a.m08), out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
            _a20 = a.m06, _a21 = a.m07;
            var b01 = (_a22 = a.m08) * _a11 - _a12 * _a21, b11 = -_a22 * _a10 + _a12 * _a20, b21 = _a21 * _a10 - _a11 * _a20, det = _a00 * b01 + _a01 * b11 + _a02 * b21;
            return det ? (det = 1 / det, out.m00 = b01 * det, out.m01 = (-_a22 * _a01 + _a02 * _a21) * det, 
            out.m02 = (_a12 * _a01 - _a02 * _a11) * det, out.m03 = b11 * det, out.m04 = (_a22 * _a00 - _a02 * _a20) * det, 
            out.m05 = (-_a12 * _a00 + _a02 * _a10) * det, out.m06 = b21 * det, out.m07 = (-_a21 * _a00 + _a01 * _a20) * det, 
            out.m08 = (_a11 * _a00 - _a01 * _a10) * det, out) : out;
        }
    }, {
        key: "determinant",
        value: function determinant(a) {
            return _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
            _a20 = a.m06, _a21 = a.m07, _a22 = a.m08, _a00 * (_a22 * _a11 - _a12 * _a21) + _a01 * (-_a22 * _a10 + _a12 * _a20) + _a02 * (_a21 * _a10 - _a11 * _a20);
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
            _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
            var b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m03, b11 = b.m04, b12 = b.m05, b20 = b.m06, b21 = b.m07, b22 = b.m08;
            return out.m00 = b00 * _a00 + b01 * _a10 + b02 * _a20, out.m01 = b00 * _a01 + b01 * _a11 + b02 * _a21, 
            out.m02 = b00 * _a02 + b01 * _a12 + b02 * _a22, out.m03 = b10 * _a00 + b11 * _a10 + b12 * _a20, 
            out.m04 = b10 * _a01 + b11 * _a11 + b12 * _a21, out.m05 = b10 * _a02 + b11 * _a12 + b12 * _a22, 
            out.m06 = b20 * _a00 + b21 * _a10 + b22 * _a20, out.m07 = b20 * _a01 + b21 * _a11 + b22 * _a21, 
            out.m08 = b20 * _a02 + b21 * _a12 + b22 * _a22, out;
        }
    }, {
        key: "multiplyMat4",
        value: function multiplyMat4(out, a, b) {
            _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
            _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
            var b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m04, b11 = b.m05, b12 = b.m06, b20 = b.m08, b21 = b.m09, b22 = b.m10;
            return out.m00 = b00 * _a00 + b01 * _a10 + b02 * _a20, out.m01 = b00 * _a01 + b01 * _a11 + b02 * _a21, 
            out.m02 = b00 * _a02 + b01 * _a12 + b02 * _a22, out.m03 = b10 * _a00 + b11 * _a10 + b12 * _a20, 
            out.m04 = b10 * _a01 + b11 * _a11 + b12 * _a21, out.m05 = b10 * _a02 + b11 * _a12 + b12 * _a22, 
            out.m06 = b20 * _a00 + b21 * _a10 + b22 * _a20, out.m07 = b20 * _a01 + b21 * _a11 + b22 * _a21, 
            out.m08 = b20 * _a02 + b21 * _a12 + b22 * _a22, out;
        }
    }, {
        key: "transfrom",
        value: function transfrom(out, a, v) {
            _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
            _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
            var x = v.x, y = v.y;
            return out.m00 = _a00, out.m01 = _a01, out.m02 = _a02, out.m03 = _a10, out.m04 = _a11, 
            out.m05 = _a12, out.m06 = x * _a00 + y * _a10 + _a20, out.m07 = x * _a01 + y * _a11 + _a21, 
            out.m08 = x * _a02 + y * _a12 + _a22, out;
        }
    }, {
        key: "scale",
        value: function scale(out, a, v) {
            var x = v.x, y = v.y;
            return out.m00 = x * a.m00, out.m01 = x * a.m01, out.m02 = x * a.m02, out.m03 = y * a.m03, 
            out.m04 = y * a.m04, out.m05 = y * a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
            out;
        }
    }, {
        key: "rotate",
        value: function rotate(out, a, rad) {
            _a00 = a.m00, _a01 = a.m01, _a02 = a.m02, _a10 = a.m03, _a11 = a.m04, _a12 = a.m05, 
            _a20 = a.m06, _a21 = a.m07, _a22 = a.m08;
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c * _a00 + s * _a10, out.m01 = c * _a01 + s * _a11, out.m02 = c * _a02 + s * _a12, 
            out.m03 = c * _a10 - s * _a00, out.m04 = c * _a11 - s * _a01, out.m05 = c * _a12 - s * _a02, 
            out.m06 = _a20, out.m07 = _a21, out.m08 = _a22, out;
        }
    }, {
        key: "fromMat4",
        value: function fromMat4(out, a) {
            return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m04, out.m04 = a.m05, 
            out.m05 = a.m06, out.m06 = a.m08, out.m07 = a.m09, out.m08 = a.m10, out;
        }
    }, {
        key: "fromViewUp",
        value: function fromViewUp(out, view, up) {
            return Vec3.lengthSqr(view) < EPSILON * EPSILON ? (Mat3.identity(out), out) : (up = up || Vec3.UNIT_Y, 
            Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up, view)), Vec3.lengthSqr(v3_1$1) < EPSILON * EPSILON ? (Mat3.identity(out), 
            out) : (Vec3.cross(v3_2$1, view, v3_1$1), Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z), 
            out));
        }
    }, {
        key: "fromTranslation",
        value: function fromTranslation(out, v) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
            out.m06 = v.x, out.m07 = v.y, out.m08 = 1, out;
        }
    }, {
        key: "fromScaling",
        value: function fromScaling(out, v) {
            return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = v.y, out.m05 = 0, 
            out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
        }
    }, {
        key: "fromRotation",
        value: function fromRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = -s, out.m04 = c, out.m05 = 0, 
            out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(out, q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return out.m00 = 1 - yy - zz, out.m03 = yx - wz, out.m06 = zx + wy, out.m01 = yx + wz, 
            out.m04 = 1 - xx - zz, out.m07 = zy - wx, out.m02 = zx - wy, out.m05 = zy + wx, 
            out.m08 = 1 - xx - yy, out;
        }
    }, {
        key: "inverseTransposeMat4",
        value: function inverseTransposeMat4(out, a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
            out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
            out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
            out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
            out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
            out) : null;
        }
    }, {
        key: "array",
        value: function array(out, m) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
            out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
            out[ofs + 8] = m.m08, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
            out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
            out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
            out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
            out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
            out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
            out.m08 = a.m08 * b, out;
        }
    }, {
        key: "multiplyScalarAndAdd",
        value: function multiplyScalarAndAdd(out, a, b, scale) {
            return out.m00 = b.m00 * scale + a.m00, out.m01 = b.m01 * scale + a.m01, out.m02 = b.m02 * scale + a.m02, 
            out.m03 = b.m03 * scale + a.m03, out.m04 = b.m04 * scale + a.m04, out.m05 = b.m05 * scale + a.m05, 
            out.m06 = b.m06 * scale + a.m06, out.m07 = b.m07 * scale + a.m07, out.m08 = b.m08 * scale + a.m08, 
            out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08));
        }
    } ]), _createClass(Mat3, [ {
        key: "clone",
        value: function clone() {
            var t = this;
            return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
        }
    }, {
        key: "set",
        value: function set() {
            var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
            return "object" === _typeof(m00) ? (this.m00 = m00.m00, this.m01 = m00.m01, this.m02 = m00.m02, 
            this.m03 = m00.m03, this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, 
            this.m07 = m00.m07, this.m08 = m00.m08) : (this.m00 = m00, this.m01 = m01, this.m02 = m02, 
            this.m03 = m03, this.m04 = m04, this.m05 = m05, this.m06 = m06, this.m07 = m07, 
            this.m08 = m08), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
        }
    }, {
        key: "toString",
        value: function toString() {
            var t = this;
            return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ",\n" + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ",\n" + t.m06 + ", " + t.m07 + ",\n" + t.m08 + "\n]";
        }
    }, {
        key: "identity",
        value: function identity() {
            return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 1, this.m05 = 0, 
            this.m06 = 0, this.m07 = 0, this.m08 = 1, this;
        }
    }, {
        key: "transpose",
        value: function transpose() {
            var a01 = this.m01, a02 = this.m02, a12 = this.m05;
            return this.m01 = this.m03, this.m02 = this.m06, this.m03 = a01, this.m05 = this.m07, 
            this.m06 = a02, this.m07 = a12, this;
        }
    }, {
        key: "invert",
        value: function invert() {
            _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
            _a12 = this.m05, _a20 = this.m06, _a21 = this.m07;
            var b01 = (_a22 = this.m08) * _a11 - _a12 * _a21, b11 = -_a22 * _a10 + _a12 * _a20, b21 = _a21 * _a10 - _a11 * _a20, det = _a00 * b01 + _a01 * b11 + _a02 * b21;
            return det ? (det = 1 / det, this.m00 = b01 * det, this.m01 = (-_a22 * _a01 + _a02 * _a21) * det, 
            this.m02 = (_a12 * _a01 - _a02 * _a11) * det, this.m03 = b11 * det, this.m04 = (_a22 * _a00 - _a02 * _a20) * det, 
            this.m05 = (-_a12 * _a00 + _a02 * _a10) * det, this.m06 = b21 * det, this.m07 = (-_a21 * _a00 + _a01 * _a20) * det, 
            this.m08 = (_a11 * _a00 - _a01 * _a10) * det, this) : null;
        }
    }, {
        key: "determinant",
        value: function determinant() {
            return _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
            _a12 = this.m05, _a20 = this.m06, _a21 = this.m07, _a22 = this.m08, _a00 * (_a22 * _a11 - _a12 * _a21) + _a01 * (-_a22 * _a10 + _a12 * _a20) + _a02 * (_a21 * _a10 - _a11 * _a20);
        }
    }, {
        key: "add",
        value: function add(mat) {
            return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
            this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
            this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
            this;
        }
    }, {
        key: "subtract",
        value: function subtract(mat) {
            return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
            this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
            this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
            this;
        }
    }, {
        key: "multiply",
        value: function multiply(mat) {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08, b00 = mat.m00, b01 = mat.m01, b02 = mat.m02, b10 = mat.m03, b11 = mat.m04, b12 = mat.m05, b20 = mat.m06, b21 = mat.m07, b22 = mat.m08;
            return this.m00 = b00 * a00 + b01 * a10 + b02 * a20, this.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
            this.m02 = b00 * a02 + b01 * a12 + b02 * a22, this.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
            this.m04 = b10 * a01 + b11 * a11 + b12 * a21, this.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
            this.m06 = b20 * a00 + b21 * a10 + b22 * a20, this.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
            this.m08 = b20 * a02 + b21 * a12 + b22 * a22, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
            this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
            this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
            this;
        }
    }, {
        key: "scale",
        value: function scale(vec) {
            var x = vec.x, y = vec.y;
            return this.m00 = x * this.m00, this.m01 = x * this.m01, this.m02 = x * this.m02, 
            this.m03 = y * this.m03, this.m04 = y * this.m04, this.m05 = y * this.m05, this.m06 = this.m06, 
            this.m07 = this.m07, this.m08 = this.m08, this;
        }
    }, {
        key: "rotate",
        value: function rotate(rad) {
            _a00 = this.m00, _a01 = this.m01, _a02 = this.m02, _a10 = this.m03, _a11 = this.m04, 
            _a12 = this.m05, _a20 = this.m06, _a21 = this.m07, _a22 = this.m08;
            var s = Math.sin(rad), c = Math.cos(rad);
            return this.m00 = c * _a00 + s * _a10, this.m01 = c * _a01 + s * _a11, this.m02 = c * _a02 + s * _a12, 
            this.m03 = c * _a10 - s * _a00, this.m04 = c * _a11 - s * _a01, this.m05 = c * _a12 - s * _a02, 
            this.m06 = _a20, this.m07 = _a21, this.m08 = _a22, this;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return this.m00 = 1 - yy - zz, this.m03 = yx - wz, this.m06 = zx + wy, this.m01 = yx + wz, 
            this.m04 = 1 - xx - zz, this.m07 = zy - wx, this.m02 = zx - wy, this.m05 = zy + wx, 
            this.m08 = 1 - xx - yy, this;
        }
    } ]), Mat3;
}();

Mat3.IDENTITY = Object.freeze(new Mat3());

var v3_1$1 = new Vec3(), v3_2$1 = new Vec3();

CCClass.fastDefine("cc.Mat3", Mat3, {
    m00: 1,
    m01: 0,
    m02: 0,
    m03: 0,
    m04: 1,
    m05: 0,
    m06: 0,
    m07: 0,
    m08: 1
}), cc.Mat3 = Mat3;

var _x$3 = 0, _y$3 = 0, _z$2 = 0, _w$1 = 0, Quat = function(_ValueType) {
    function Quat(x, y, z, w) {
        var _this;
        return _classCallCheck(this, Quat), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Quat).call(this))).x = void 0, 
        _this.y = void 0, _this.z = void 0, _this.w = void 0, x && "object" === _typeof(x) ? (_this.x = x.x, 
        _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, _this.y = y || 0, 
        _this.z = z || 0, _this.w = w || 1), _this;
    }
    return _inherits(Quat, ValueType), _createClass(Quat, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Quat(a.x, a.y, a.z, a.w);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y, z, w) {
            return out.x = x, out.y = y, out.z = z, out.w = w, out;
        }
    }, {
        key: "identity",
        value: function identity(out) {
            return out.x = 0, out.y = 0, out.z = 0, out.w = 1, out;
        }
    }, {
        key: "rotationTo",
        value: function rotationTo(out, a, b) {
            var dot = Vec3.dot(a, b);
            return dot < -.999999 ? (Vec3.cross(v3_1$2, Vec3.UNIT_X, a), v3_1$2.length() < 1e-6 && Vec3.cross(v3_1$2, Vec3.UNIT_Y, a), 
            Vec3.normalize(v3_1$2, v3_1$2), Quat.fromAxisAngle(out, v3_1$2, Math.PI), out) : dot > .999999 ? (out.x = 0, 
            out.y = 0, out.z = 0, out.w = 1, out) : (Vec3.cross(v3_1$2, a, b), out.x = v3_1$2.x, 
            out.y = v3_1$2.y, out.z = v3_1$2.z, out.w = 1 + dot, Quat.normalize(out, out));
        }
    }, {
        key: "getAxisAngle",
        value: function getAxisAngle(outAxis, q) {
            var rad = 2 * Math.acos(q.w), s = Math.sin(rad / 2);
            return 0 !== s ? (outAxis.x = q.x / s, outAxis.y = q.y / s, outAxis.z = q.z / s) : (outAxis.x = 1, 
            outAxis.y = 0, outAxis.z = 0), rad;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return _x$3 = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y, _y$3 = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z, 
            _z$2 = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x, _w$1 = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, 
            out.x = _x$3, out.y = _y$3, out.z = _z$2, out.w = _w$1, out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
            out.w = a.w + b.w * scale, out;
        }
    }, {
        key: "rotateX",
        value: function rotateX(out, a, rad) {
            rad *= .5;
            var bx = Math.sin(rad), bw = Math.cos(rad);
            return out.x = a.x * bw + a.w * bx, out.y = a.y * bw + a.z * bx, out.z = a.z * bw - a.y * bx, 
            out.w = a.w * bw - a.x * bx, out;
        }
    }, {
        key: "rotateY",
        value: function rotateY(out, a, rad) {
            rad *= .5;
            var by = Math.sin(rad), bw = Math.cos(rad);
            return out.x = a.x * bw - a.z * by, out.y = a.y * bw + a.w * by, out.z = a.z * bw + a.x * by, 
            out.w = a.w * bw - a.y * by, out;
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(out, a, rad) {
            rad *= .5;
            var bz = Math.sin(rad), bw = Math.cos(rad);
            return out.x = a.x * bw + a.y * bz, out.y = a.y * bw - a.x * bz, out.z = a.z * bw + a.w * bz, 
            out.w = a.w * bw - a.z * bz, out;
        }
    }, {
        key: "rotateAround",
        value: function rotateAround(out, rot, axis, rad) {
            return Quat.invert(qt_1, rot), Vec3.transformQuat(v3_1$2, axis, qt_1), Quat.fromAxisAngle(qt_1, v3_1$2, rad), 
            Quat.multiply(out, rot, qt_1), out;
        }
    }, {
        key: "rotateAroundLocal",
        value: function rotateAroundLocal(out, rot, axis, rad) {
            return Quat.fromAxisAngle(qt_1, axis, rad), Quat.multiply(out, rot, qt_1), out;
        }
    }, {
        key: "calculateW",
        value: function calculateW(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out.w = Math.sqrt(Math.abs(1 - a.x * a.x - a.y * a.y - a.z * a.z)), 
            out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
            out.w = a.w + t * (b.w - a.w), out;
        }
    }, {
        key: "slerp",
        value: function slerp(out, a, b, t) {
            var scale0 = 0, scale1 = 0, cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
            if (cosom < 0 && (cosom = -cosom, b.x = -b.x, b.y = -b.y, b.z = -b.z, b.w = -b.w), 
            1 - cosom > 1e-6) {
                var omega = Math.acos(cosom), sinom = Math.sin(omega);
                scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom;
            } else scale0 = 1 - t, scale1 = t;
            return out.x = scale0 * a.x + scale1 * b.x, out.y = scale0 * a.y + scale1 * b.y, 
            out.z = scale0 * a.z + scale1 * b.z, out.w = scale0 * a.w + scale1 * b.w, out;
        }
    }, {
        key: "sqlerp",
        value: function sqlerp(out, a, b, c, d, t) {
            return Quat.slerp(qt_1, a, d, t), Quat.slerp(qt_2, b, c, t), Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t)), 
            out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w, invDot = dot ? 1 / dot : 0;
            return out.x = -a.x * invDot, out.y = -a.y * invDot, out.z = -a.z * invDot, out.w = a.w * invDot, 
            out;
        }
    }, {
        key: "conjugate",
        value: function conjugate(out, a) {
            return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = a.w, out;
        }
    }, {
        key: "len",
        value: function len(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = a.x * len, out.y = a.y * len, 
            out.z = a.z * len, out.w = a.w * len), out;
        }
    }, {
        key: "fromAxes",
        value: function fromAxes(out, xAxis, yAxis, zAxis) {
            return Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z), 
            Quat.normalize(out, Quat.fromMat3(out, m3_1));
        }
    }, {
        key: "fromViewUp",
        value: function fromViewUp(out, view, up) {
            return Mat3.fromViewUp(m3_1, view, up), Quat.normalize(out, Quat.fromMat3(out, m3_1));
        }
    }, {
        key: "fromAxisAngle",
        value: function fromAxisAngle(out, axis, rad) {
            rad *= .5;
            var s = Math.sin(rad);
            return out.x = s * axis.x, out.y = s * axis.y, out.z = s * axis.z, out.w = Math.cos(rad), 
            out;
        }
    }, {
        key: "fromMat3",
        value: function fromMat3(out, m) {
            var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08, trace = m00 + m11 + m22;
            if (trace > 0) {
                var s = .5 / Math.sqrt(trace + 1);
                out.w = .25 / s, out.x = (m21 - m12) * s, out.y = (m02 - m20) * s, out.z = (m10 - m01) * s;
            } else if (m00 > m11 && m00 > m22) {
                var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
                out.w = (m21 - m12) / _s, out.x = .25 * _s, out.y = (m01 + m10) / _s, out.z = (m02 + m20) / _s;
            } else if (m11 > m22) {
                var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
                out.w = (m02 - m20) / _s2, out.x = (m01 + m10) / _s2, out.y = .25 * _s2, out.z = (m12 + m21) / _s2;
            } else {
                var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
                out.w = (m10 - m01) / _s3, out.x = (m02 + m20) / _s3, out.y = (m12 + m21) / _s3, 
                out.z = .25 * _s3;
            }
            return out;
        }
    }, {
        key: "fromEuler",
        value: function fromEuler(out, x, y, z) {
            x *= halfToRad, y *= halfToRad, z *= halfToRad;
            var sx = Math.sin(x), cx = Math.cos(x), sy = Math.sin(y), cy = Math.cos(y), sz = Math.sin(z), cz = Math.cos(z);
            return out.x = sx * cy * cz + cx * sy * sz, out.y = cx * sy * cz + sx * cy * sz, 
            out.z = cx * cy * sz - sx * sy * cz, out.w = cx * cy * cz - sx * sy * sz, out;
        }
    }, {
        key: "toAxisX",
        value: function toAxisX(out, q) {
            var fy = 2 * q.y, fz = 2 * q.z;
            return out.x = 1 - fy * q.y - fz * q.z, out.y = fy * q.x + fz * q.w, out.z = fz * q.x + fy * q.w, 
            out;
        }
    }, {
        key: "toAxisY",
        value: function toAxisY(out, q) {
            var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
            return out.x = fy * q.x - fz * q.w, out.y = 1 - fx * q.x - fz * q.z, out.z = fz * q.y + fx * q.w, 
            out;
        }
    }, {
        key: "toAxisZ",
        value: function toAxisZ(out, q) {
            var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
            return out.x = fz * q.x - fy * q.w, out.y = fz * q.y - fx * q.w, out.z = 1 - fx * q.x - fy * q.y, 
            out;
        }
    }, {
        key: "toEuler",
        value: function toEuler(out, q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, heading = NaN, attitude = NaN, bank = NaN, test = x * y + z * w;
            if (test > .499999 && (heading = 2 * Math.atan2(x, w), attitude = Math.PI / 2, bank = 0), 
            test < -.499999 && (heading = -2 * Math.atan2(x, w), attitude = -Math.PI / 2, bank = 0), 
            isNaN(heading)) {
                var sqx = x * x, sqy = y * y, sqz = z * z;
                heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz), attitude = Math.asin(2 * test), 
                bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
            }
            return out.y = toDegree(heading), out.z = toDegree(attitude), out.x = toDegree(bank), 
            out;
        }
    }, {
        key: "array",
        value: function array(out, q) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = q.x, out[ofs + 1] = q.y, out[ofs + 2] = q.z, out[ofs + 3] = q.w, 
            out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
        }
    } ]), _createClass(Quat, [ {
        key: "clone",
        value: function clone() {
            return new Quat(this.x, this.y, this.z, this.w);
        }
    }, {
        key: "set",
        value: function set(x, y, z, w) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
            this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 1), 
            this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
    }, {
        key: "getEulerAngles",
        value: function getEulerAngles(out) {
            var x = this.x, y = this.y, z = this.z, w = this.w, heading = NaN, attitude = NaN, bank = NaN, test = x * y + z * w;
            if (test > .499999 && (heading = 2 * Math.atan2(x, w), attitude = Math.PI / 2, bank = 0), 
            test < -.499999 && (heading = -2 * Math.atan2(x, w), attitude = -Math.PI / 2, bank = 0), 
            isNaN(heading)) {
                var sqx = x * x, sqy = y * y, sqz = z * z;
                heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz), attitude = Math.asin(2 * test), 
                bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
            }
            return out.y = toDegree(heading), out.z = toDegree(attitude), out.x = toDegree(bank), 
            out;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            var scale0 = 0, scale1 = 0, cosom = this.x * to.x + this.y * to.y + this.z * to.z + this.w * to.w;
            if (cosom < 0 && (cosom = -cosom, to.x = -to.x, to.y = -to.y, to.z = -to.z, to.w = -to.w), 
            1 - cosom > 1e-6) {
                var omega = Math.acos(cosom), sinom = Math.sin(omega);
                scale0 = Math.sin((1 - ratio) * omega) / sinom, scale1 = Math.sin(ratio * omega) / sinom;
            } else scale0 = 1 - ratio, scale1 = ratio;
            return this.x = scale0 * this.x + scale1 * to.x, this.y = scale0 * this.y + scale1 * to.y, 
            this.z = scale0 * this.z + scale1 * to.z, this.w = scale0 * this.w + scale1 * to.w, 
            this;
        }
    }, {
        key: "length",
        value: function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
    } ]), Quat;
}();

Quat.IDENTITY = Object.freeze(new Quat());

var qt_1 = new Quat(), qt_2 = new Quat(), v3_1$2 = new Vec3(), m3_1 = new Mat3(), halfToRad = .5 * Math.PI / 180;

CCClass.fastDefine("cc.Quat", Quat, {
    x: 0,
    y: 0,
    z: 0,
    w: 1
}), cc.Quat = Quat, cc.quat = function quat() {
    var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    return new Quat(x, y, z, w);
};

var _a00$1 = 0, _a01$1 = 0, _a02$1 = 0, _a03 = 0, _a10$1 = 0, _a11$1 = 0, _a12$1 = 0, _a13 = 0, _a20$1 = 0, _a21$1 = 0, _a22$1 = 0, _a23 = 0, _a30 = 0, _a31 = 0, _a32 = 0, _a33 = 0, Mat4 = function(_ValueType) {
    function Mat4() {
        var _this, m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
        return _classCallCheck(this, Mat4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mat4).call(this))).m00 = void 0, 
        _this.m01 = void 0, _this.m02 = void 0, _this.m03 = void 0, _this.m04 = void 0, 
        _this.m05 = void 0, _this.m06 = void 0, _this.m07 = void 0, _this.m08 = void 0, 
        _this.m09 = void 0, _this.m10 = void 0, _this.m11 = void 0, _this.m12 = void 0, 
        _this.m13 = void 0, _this.m14 = void 0, _this.m15 = void 0, "object" === _typeof(m00) ? (_this.m01 = m00.m01, 
        _this.m02 = m00.m02, _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, 
        _this.m06 = m00.m06, _this.m07 = m00.m07, _this.m08 = m00.m08, _this.m09 = m00.m09, 
        _this.m10 = m00.m10, _this.m11 = m00.m11, _this.m12 = m00.m12, _this.m13 = m00.m13, 
        _this.m14 = m00.m14, _this.m15 = m00.m15, _this.m00 = m00.m00) : (_this.m01 = m01, 
        _this.m02 = m02, _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, 
        _this.m07 = m07, _this.m08 = m08, _this.m09 = m09, _this.m10 = m10, _this.m11 = m11, 
        _this.m12 = m12, _this.m13 = m13, _this.m14 = m14, _this.m15 = m15, _this.m00 = m00), 
        _this;
    }
    return _inherits(Mat4, ValueType), _createClass(Mat4, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
            out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out.m09 = a.m09, 
            out.m10 = a.m10, out.m11 = a.m11, out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, 
            out.m15 = a.m15, out;
        }
    }, {
        key: "set",
        value: function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
            return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m03, out.m04 = m10, 
            out.m05 = m11, out.m06 = m12, out.m07 = m13, out.m08 = m20, out.m09 = m21, out.m10 = m22, 
            out.m11 = m23, out.m12 = m30, out.m13 = m31, out.m14 = m32, out.m15 = m33, out;
        }
    }, {
        key: "identity",
        value: function identity(out) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "transpose",
        value: function transpose(out, a) {
            if (out === a) {
                var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
                out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a01, out.m06 = a.m09, 
                out.m07 = a.m13, out.m08 = a02, out.m09 = a12, out.m11 = a.m14, out.m12 = a03, out.m13 = a13, 
                out.m14 = a23;
            } else out.m00 = a.m00, out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a.m01, 
            out.m05 = a.m05, out.m06 = a.m09, out.m07 = a.m13, out.m08 = a.m02, out.m09 = a.m06, 
            out.m10 = a.m10, out.m11 = a.m14, out.m12 = a.m03, out.m13 = a.m07, out.m14 = a.m11, 
            out.m15 = a.m15;
            return out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
            _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
            _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
            var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return 0 === det ? null : (det = 1 / det, out.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
            out.m01 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, out.m02 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
            out.m03 = (_a22$1 * b04 - _a21$1 * b05 - _a23 * b03) * det, out.m04 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, 
            out.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, out.m06 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, 
            out.m07 = (_a20$1 * b05 - _a22$1 * b02 + _a23 * b01) * det, out.m08 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
            out.m09 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, out.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
            out.m11 = (_a21$1 * b02 - _a20$1 * b04 - _a23 * b00) * det, out.m12 = (_a11$1 * b07 - _a10$1 * b09 - _a12$1 * b06) * det, 
            out.m13 = (_a00$1 * b09 - _a01$1 * b07 + _a02$1 * b06) * det, out.m14 = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det, 
            out.m15 = (_a20$1 * b03 - _a21$1 * b01 + _a22$1 * b00) * det, out);
        }
    }, {
        key: "determinant",
        value: function determinant(a) {
            return _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, 
            _a11$1 = a.m05, _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, 
            _a23 = a.m11, _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15, (_a00$1 * _a11$1 - _a01$1 * _a10$1) * (_a22$1 * _a33 - _a23 * _a32) - (_a00$1 * _a12$1 - _a02$1 * _a10$1) * (_a21$1 * _a33 - _a23 * _a31) + (_a00$1 * _a13 - _a03 * _a10$1) * (_a21$1 * _a32 - _a22$1 * _a31) + (_a01$1 * _a12$1 - _a02$1 * _a11$1) * (_a20$1 * _a33 - _a23 * _a30) - (_a01$1 * _a13 - _a03 * _a11$1) * (_a20$1 * _a32 - _a22$1 * _a30) + (_a02$1 * _a13 - _a03 * _a12$1) * (_a20$1 * _a31 - _a21$1 * _a30);
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
            _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
            _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
            var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
            return out.m00 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, out.m01 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, 
            out.m02 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, out.m03 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, 
            b0 = b.m04, b1 = b.m05, b2 = b.m06, b3 = b.m07, out.m04 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
            out.m05 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m06 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
            out.m07 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = b.m08, b1 = b.m09, 
            b2 = b.m10, b3 = b.m11, out.m08 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
            out.m09 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m10 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
            out.m11 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = b.m12, b1 = b.m13, 
            b2 = b.m14, b3 = b.m15, out.m12 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
            out.m13 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, out.m14 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
            out.m15 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, out;
        }
    }, {
        key: "transform",
        value: function transform(out, a, v) {
            var x = v.x, y = v.y, z = v.z;
            return a === out ? (out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12, out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13, 
            out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14, out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15) : (_a00$1 = a.m00, 
            _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, _a12$1 = a.m06, 
            _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, _a30 = a.m12, 
            _a31 = a.m13, _a32 = a.m14, _a33 = a.m15, out.m00 = _a00$1, out.m01 = _a01$1, out.m02 = _a02$1, 
            out.m03 = _a03, out.m04 = _a10$1, out.m05 = _a11$1, out.m06 = _a12$1, out.m07 = _a13, 
            out.m08 = _a20$1, out.m09 = _a21$1, out.m10 = _a22$1, out.m11 = _a23, out.m12 = _a00$1 * x + _a10$1 * y + _a20$1 * z + a.m12, 
            out.m13 = _a01$1 * x + _a11$1 * y + _a21$1 * z + a.m13, out.m14 = _a02$1 * x + _a12$1 * y + _a22$1 * z + a.m14, 
            out.m15 = _a03 * x + _a13 * y + _a23 * z + a.m15), out;
        }
    }, {
        key: "translate",
        value: function translate(out, a, v) {
            return console.warn("function changed"), a === out ? (out.m12 += v.x, out.m13 += v.y, 
            out.m14 += v.y) : (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
            out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
            out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, out.m12 += v.x, out.m13 += v.y, 
            out.m14 += v.z, out.m15 = a.m15), out;
        }
    }, {
        key: "scale",
        value: function scale(out, a, v) {
            var x = v.x, y = v.y, z = v.z;
            return out.m00 = a.m00 * x, out.m01 = a.m01 * x, out.m02 = a.m02 * x, out.m03 = a.m03 * x, 
            out.m04 = a.m04 * y, out.m05 = a.m05 * y, out.m06 = a.m06 * y, out.m07 = a.m07 * y, 
            out.m08 = a.m08 * z, out.m09 = a.m09 * z, out.m10 = a.m10 * z, out.m11 = a.m11 * z, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15, out;
        }
    }, {
        key: "rotate",
        value: function rotate(out, a, rad, axis) {
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
            if (Math.abs(len) < EPSILON) return null;
            x *= len = 1 / len, y *= len, z *= len;
            var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
            _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
            _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            return out.m00 = _a00$1 * b00 + _a10$1 * b01 + _a20$1 * b02, out.m01 = _a01$1 * b00 + _a11$1 * b01 + _a21$1 * b02, 
            out.m02 = _a02$1 * b00 + _a12$1 * b01 + _a22$1 * b02, out.m03 = _a03 * b00 + _a13 * b01 + _a23 * b02, 
            out.m04 = _a00$1 * b10 + _a10$1 * b11 + _a20$1 * b12, out.m05 = _a01$1 * b10 + _a11$1 * b11 + _a21$1 * b12, 
            out.m06 = _a02$1 * b10 + _a12$1 * b11 + _a22$1 * b12, out.m07 = _a03 * b10 + _a13 * b11 + _a23 * b12, 
            out.m08 = _a00$1 * b20 + _a10$1 * b21 + _a20$1 * b22, out.m09 = _a01$1 * b20 + _a11$1 * b21 + _a21$1 * b22, 
            out.m10 = _a02$1 * b20 + _a12$1 * b21 + _a22$1 * b22, out.m11 = _a03 * b20 + _a13 * b21 + _a23 * b22, 
            a !== out && (out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), 
            out;
        }
    }, {
        key: "rotateX",
        value: function rotateX(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
            return a !== out && (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m04 = a10 * c + a20 * s, 
            out.m05 = a11 * c + a21 * s, out.m06 = a12 * c + a22 * s, out.m07 = a13 * c + a23 * s, 
            out.m08 = a20 * c - a10 * s, out.m09 = a21 * c - a11 * s, out.m10 = a22 * c - a12 * s, 
            out.m11 = a23 * c - a13 * s, out;
        }
    }, {
        key: "rotateY",
        value: function rotateY(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
            return a !== out && (out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c - a20 * s, 
            out.m01 = a01 * c - a21 * s, out.m02 = a02 * c - a22 * s, out.m03 = a03 * c - a23 * s, 
            out.m08 = a00 * s + a20 * c, out.m09 = a01 * s + a21 * c, out.m10 = a02 * s + a22 * c, 
            out.m11 = a03 * s + a23 * c, out;
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
            return a !== out && (out.m08 = a.m08, out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c + a10 * s, 
            out.m01 = a01 * c + a11 * s, out.m02 = a02 * c + a12 * s, out.m03 = a03 * c + a13 * s, 
            out.m04 = a10 * c - a00 * s, out.m05 = a11 * c - a01 * s, out.m06 = a12 * c - a02 * s, 
            out.m07 = a13 * c - a03 * s, out;
        }
    }, {
        key: "fromTranslation",
        value: function fromTranslation(out, v) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = v.x, 
            out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
        }
    }, {
        key: "fromScaling",
        value: function fromScaling(out, v) {
            return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = v.y, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = v.z, out.m11 = 0, 
            out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromRotation",
        value: function fromRotation(out, rad, axis) {
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
            if (Math.abs(len) < EPSILON) return null;
            x *= len = 1 / len, y *= len, z *= len;
            var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
            return out.m00 = x * x * t + c, out.m01 = y * x * t + z * s, out.m02 = z * x * t - y * s, 
            out.m03 = 0, out.m04 = x * y * t - z * s, out.m05 = y * y * t + c, out.m06 = z * y * t + x * s, 
            out.m07 = 0, out.m08 = x * z * t + y * s, out.m09 = y * z * t - x * s, out.m10 = z * z * t + c, 
            out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromXRotation",
        value: function fromXRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = c, 
            out.m06 = s, out.m07 = 0, out.m08 = 0, out.m09 = -s, out.m10 = c, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromYRotation",
        value: function fromYRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c, out.m01 = 0, out.m02 = -s, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
            out.m06 = 0, out.m07 = 0, out.m08 = s, out.m09 = 0, out.m10 = c, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromZRotation",
        value: function fromZRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = 0, out.m04 = -s, out.m05 = c, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromRT",
        value: function fromRT(out, q, v) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return out.m00 = 1 - (yy + zz), out.m01 = xy + wz, out.m02 = xz - wy, out.m03 = 0, 
            out.m04 = xy - wz, out.m05 = 1 - (xx + zz), out.m06 = yz + wx, out.m07 = 0, out.m08 = xz + wy, 
            out.m09 = yz - wx, out.m10 = 1 - (xx + yy), out.m11 = 0, out.m12 = v.x, out.m13 = v.y, 
            out.m14 = v.z, out.m15 = 1, out;
        }
    }, {
        key: "getTranslation",
        value: function getTranslation(out, mat) {
            return out.x = mat.m12, out.y = mat.m13, out.z = mat.m14, out;
        }
    }, {
        key: "getScaling",
        value: function getScaling(out, mat) {
            var m00 = m3_1$1.m00 = mat.m00, m01 = m3_1$1.m01 = mat.m01, m02 = m3_1$1.m02 = mat.m02, m04 = m3_1$1.m03 = mat.m04, m05 = m3_1$1.m04 = mat.m05, m06 = m3_1$1.m05 = mat.m06, m08 = m3_1$1.m06 = mat.m08, m09 = m3_1$1.m07 = mat.m09, m10 = m3_1$1.m08 = mat.m10;
            return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
            out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
            out;
        }
    }, {
        key: "getRotation",
        value: function getRotation(out, mat) {
            var trace = mat.m00 + mat.m05 + mat.m10, S = 0;
            return trace > 0 ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (mat.m06 - mat.m09) / S, 
            out.y = (mat.m08 - mat.m02) / S, out.z = (mat.m01 - mat.m04) / S) : mat.m00 > mat.m05 && mat.m00 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10), 
            out.w = (mat.m06 - mat.m09) / S, out.x = .25 * S, out.y = (mat.m01 + mat.m04) / S, 
            out.z = (mat.m08 + mat.m02) / S) : mat.m05 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10), 
            out.w = (mat.m08 - mat.m02) / S, out.x = (mat.m01 + mat.m04) / S, out.y = .25 * S, 
            out.z = (mat.m06 + mat.m09) / S) : (S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05), 
            out.w = (mat.m01 - mat.m04) / S, out.x = (mat.m08 + mat.m02) / S, out.y = (mat.m06 + mat.m09) / S, 
            out.z = .25 * S), out;
        }
    }, {
        key: "toRTS",
        value: function toRTS(m, q, v, s) {
            s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length(), m3_1$1.m00 = m.m00 / s.x, 
            m3_1$1.m01 = m.m01 / s.x, m3_1$1.m02 = m.m02 / s.x, s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length(), 
            m3_1$1.m03 = m.m04 / s.y, m3_1$1.m04 = m.m05 / s.y, m3_1$1.m05 = m.m06 / s.y, s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length(), 
            m3_1$1.m06 = m.m08 / s.z, m3_1$1.m07 = m.m09 / s.z, m3_1$1.m08 = m.m10 / s.z, Mat3.determinant(m3_1$1) < 0 && (s.x *= -1, 
            m3_1$1.m00 *= -1, m3_1$1.m01 *= -1, m3_1$1.m02 *= -1), Quat.fromMat3(q, m3_1$1), 
            Vec3.set(v, m.m12, m.m13, m.m14);
        }
    }, {
        key: "fromRTS",
        value: function fromRTS(out, q, v, s) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
            return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
            out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
            out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
            out.m11 = 0, out.m12 = v.x, out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
        }
    }, {
        key: "fromRTSOrigin",
        value: function fromRTSOrigin(out, q, v, s, o) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z, ox = o.x, oy = o.y, oz = o.z;
            return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
            out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
            out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
            out.m11 = 0, out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz), 
            out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz), out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz), 
            out.m15 = 1, out;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(out, q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return out.m00 = 1 - yy - zz, out.m01 = yx + wz, out.m02 = zx - wy, out.m03 = 0, 
            out.m04 = yx - wz, out.m05 = 1 - xx - zz, out.m06 = zy + wx, out.m07 = 0, out.m08 = zx + wy, 
            out.m09 = zy - wx, out.m10 = 1 - xx - yy, out.m11 = 0, out.m12 = 0, out.m13 = 0, 
            out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "frustum",
        value: function frustum(out, left, right, bottom, top, near, far) {
            var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
            return out.m00 = 2 * near * rl, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
            out.m05 = 2 * near * tb, out.m06 = 0, out.m07 = 0, out.m08 = (right + left) * rl, 
            out.m09 = (top + bottom) * tb, out.m10 = (far + near) * nf, out.m11 = -1, out.m12 = 0, 
            out.m13 = 0, out.m14 = far * near * 2 * nf, out.m15 = 0, out;
        }
    }, {
        key: "perspective",
        value: function perspective(out, fovy, aspect, near, far) {
            var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
            return out.m00 = f / aspect, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
            out.m05 = f, out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = (far + near) * nf, 
            out.m11 = -1, out.m12 = 0, out.m13 = 0, out.m14 = 2 * far * near * nf, out.m15 = 0, 
            out;
        }
    }, {
        key: "ortho",
        value: function ortho(out, left, right, bottom, top, near, far) {
            var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
            return out.m00 = -2 * lr, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = -2 * bt, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 2 * nf, out.m11 = 0, 
            out.m12 = (left + right) * lr, out.m13 = (top + bottom) * bt, out.m14 = (far + near) * nf, 
            out.m15 = 1, out;
        }
    }, {
        key: "lookAt",
        value: function lookAt(out, eye, center, up) {
            var eyex = eye.x, eyey = eye.y, eyez = eye.z, upx = up.x, upy = up.y, upz = up.z, z0 = eyex - center.x, z1 = eyey - center.y, z2 = eyez - center.z, len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2), x0 = upy * (z2 *= len) - upz * (z1 *= len), x1 = upz * (z0 *= len) - upx * z2, x2 = upx * z1 - upy * z0, y0 = z1 * (x2 *= len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2)) - z2 * (x1 *= len), y1 = z2 * (x0 *= len) - z0 * x2, y2 = z0 * x1 - z1 * x0;
            return out.m00 = x0, out.m01 = y0, out.m02 = z0, out.m03 = 0, out.m04 = x1, out.m05 = y1, 
            out.m06 = z1, out.m07 = 0, out.m08 = x2, out.m09 = y2, out.m10 = z2, out.m11 = 0, 
            out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez), out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez), 
            out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez), out.m15 = 1, out;
        }
    }, {
        key: "inverseTranspose",
        value: function inverseTranspose(out, a) {
            _a00$1 = a.m00, _a01$1 = a.m01, _a02$1 = a.m02, _a03 = a.m03, _a10$1 = a.m04, _a11$1 = a.m05, 
            _a12$1 = a.m06, _a13 = a.m07, _a20$1 = a.m08, _a21$1 = a.m09, _a22$1 = a.m10, _a23 = a.m11, 
            _a30 = a.m12, _a31 = a.m13, _a32 = a.m14, _a33 = a.m15;
            var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return det ? (det = 1 / det, out.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
            out.m01 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, out.m02 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
            out.m03 = 0, out.m04 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, out.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, 
            out.m06 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, out.m07 = 0, out.m08 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
            out.m09 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, out.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
            out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out) : null;
        }
    }, {
        key: "array",
        value: function array(out, m) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
            out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
            out[ofs + 8] = m.m08, out[ofs + 9] = m.m09, out[ofs + 10] = m.m10, out[ofs + 11] = m.m11, 
            out[ofs + 12] = m.m12, out[ofs + 13] = m.m13, out[ofs + 14] = m.m14, out[ofs + 15] = m.m15, 
            out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
            out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
            out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out.m09 = a.m09 + b.m09, out.m10 = a.m10 + b.m10, 
            out.m11 = a.m11 + b.m11, out.m12 = a.m12 + b.m12, out.m13 = a.m13 + b.m13, out.m14 = a.m14 + b.m14, 
            out.m15 = a.m15 + b.m15, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
            out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
            out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out.m09 = a.m09 - b.m09, out.m10 = a.m10 - b.m10, 
            out.m11 = a.m11 - b.m11, out.m12 = a.m12 - b.m12, out.m13 = a.m13 - b.m13, out.m14 = a.m14 - b.m14, 
            out.m15 = a.m15 - b.m15, out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
            out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
            out.m08 = a.m08 * b, out.m09 = a.m09 * b, out.m10 = a.m10 * b, out.m11 = a.m11 * b, 
            out.m12 = a.m12 * b, out.m13 = a.m13 * b, out.m14 = a.m14 * b, out.m15 = a.m15 * b, 
            out;
        }
    }, {
        key: "multiplyScalarAndAdd",
        value: function multiplyScalarAndAdd(out, a, b, scale) {
            return out.m00 = a.m00 + b.m00 * scale, out.m01 = a.m01 + b.m01 * scale, out.m02 = a.m02 + b.m02 * scale, 
            out.m03 = a.m03 + b.m03 * scale, out.m04 = a.m04 + b.m04 * scale, out.m05 = a.m05 + b.m05 * scale, 
            out.m06 = a.m06 + b.m06 * scale, out.m07 = a.m07 + b.m07 * scale, out.m08 = a.m08 + b.m08 * scale, 
            out.m09 = a.m09 + b.m09 * scale, out.m10 = a.m10 + b.m10 * scale, out.m11 = a.m11 + b.m11 * scale, 
            out.m12 = a.m12 + b.m12 * scale, out.m13 = a.m13 + b.m13 * scale, out.m14 = a.m14 + b.m14 * scale, 
            out.m15 = a.m15 + b.m15 * scale, out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1, Math.abs(a.m15), Math.abs(b.m15));
        }
    } ]), _createClass(Mat4, [ {
        key: "clone",
        value: function clone() {
            var t = this;
            return new Mat4(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08, t.m09, t.m10, t.m11, t.m12, t.m13, t.m14, t.m15);
        }
    }, {
        key: "set",
        value: function set() {
            var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
            return "object" === _typeof(m00) ? (this.m01 = m00.m01, this.m02 = m00.m02, this.m03 = m00.m03, 
            this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, this.m07 = m00.m07, 
            this.m08 = m00.m08, this.m09 = m00.m09, this.m10 = m00.m10, this.m11 = m00.m11, 
            this.m12 = m00.m12, this.m13 = m00.m13, this.m14 = m00.m14, this.m15 = m00.m15, 
            this.m00 = m00.m00) : (this.m01 = m01, this.m02 = m02, this.m03 = m03, this.m04 = m04, 
            this.m05 = m05, this.m06 = m06, this.m07 = m07, this.m08 = m08, this.m09 = m09, 
            this.m10 = m10, this.m11 = m11, this.m12 = m12, this.m13 = m13, this.m14 = m14, 
            this.m15 = m15, this.m00 = m00), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1, Math.abs(this.m15), Math.abs(other.m15));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "[\n" + this.m00 + ", " + this.m01 + ", " + this.m02 + ", " + this.m03 + ",\n" + this.m04 + ", " + this.m05 + ", " + this.m06 + ", " + this.m07 + ",\n" + this.m08 + ", " + this.m09 + ", " + this.m10 + ", " + this.m11 + ",\n" + this.m12 + ", " + this.m13 + ", " + this.m14 + ", " + this.m15 + "\n]";
        }
    }, {
        key: "identity",
        value: function identity() {
            return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 0, this.m05 = 1, 
            this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, this.m10 = 1, this.m11 = 0, 
            this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, this;
        }
    }, {
        key: "transpose",
        value: function transpose() {
            var a01 = this.m01, a02 = this.m02, a03 = this.m03, a12 = this.m06, a13 = this.m07, a23 = this.m11;
            return this.m01 = this.m04, this.m02 = this.m08, this.m03 = this.m12, this.m04 = a01, 
            this.m06 = this.m09, this.m07 = this.m13, this.m08 = a02, this.m09 = a12, this.m11 = this.m14, 
            this.m12 = a03, this.m13 = a13, this.m14 = a23, this;
        }
    }, {
        key: "invert",
        value: function invert() {
            _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
            _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
            _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, _a32 = this.m14, 
            _a33 = this.m15;
            var b00 = _a00$1 * _a11$1 - _a01$1 * _a10$1, b01 = _a00$1 * _a12$1 - _a02$1 * _a10$1, b02 = _a00$1 * _a13 - _a03 * _a10$1, b03 = _a01$1 * _a12$1 - _a02$1 * _a11$1, b04 = _a01$1 * _a13 - _a03 * _a11$1, b05 = _a02$1 * _a13 - _a03 * _a12$1, b06 = _a20$1 * _a31 - _a21$1 * _a30, b07 = _a20$1 * _a32 - _a22$1 * _a30, b08 = _a20$1 * _a33 - _a23 * _a30, b09 = _a21$1 * _a32 - _a22$1 * _a31, b10 = _a21$1 * _a33 - _a23 * _a31, b11 = _a22$1 * _a33 - _a23 * _a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return 0 === det ? null : (det = 1 / det, this.m00 = (_a11$1 * b11 - _a12$1 * b10 + _a13 * b09) * det, 
            this.m01 = (_a02$1 * b10 - _a01$1 * b11 - _a03 * b09) * det, this.m02 = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det, 
            this.m03 = (_a22$1 * b04 - _a21$1 * b05 - _a23 * b03) * det, this.m04 = (_a12$1 * b08 - _a10$1 * b11 - _a13 * b07) * det, 
            this.m05 = (_a00$1 * b11 - _a02$1 * b08 + _a03 * b07) * det, this.m06 = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det, 
            this.m07 = (_a20$1 * b05 - _a22$1 * b02 + _a23 * b01) * det, this.m08 = (_a10$1 * b10 - _a11$1 * b08 + _a13 * b06) * det, 
            this.m09 = (_a01$1 * b08 - _a00$1 * b10 - _a03 * b06) * det, this.m10 = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det, 
            this.m11 = (_a21$1 * b02 - _a20$1 * b04 - _a23 * b00) * det, this.m12 = (_a11$1 * b07 - _a10$1 * b09 - _a12$1 * b06) * det, 
            this.m13 = (_a00$1 * b09 - _a01$1 * b07 + _a02$1 * b06) * det, this.m14 = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det, 
            this.m15 = (_a20$1 * b03 - _a21$1 * b01 + _a22$1 * b00) * det, this);
        }
    }, {
        key: "determinant",
        value: function determinant() {
            return _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, 
            _a10$1 = this.m04, _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, 
            _a21$1 = this.m09, _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, 
            _a32 = this.m14, _a33 = this.m15, (_a00$1 * _a11$1 - _a01$1 * _a10$1) * (_a22$1 * _a33 - _a23 * _a32) - (_a00$1 * _a12$1 - _a02$1 * _a10$1) * (_a21$1 * _a33 - _a23 * _a31) + (_a00$1 * _a13 - _a03 * _a10$1) * (_a21$1 * _a32 - _a22$1 * _a31) + (_a01$1 * _a12$1 - _a02$1 * _a11$1) * (_a20$1 * _a33 - _a23 * _a30) - (_a01$1 * _a13 - _a03 * _a11$1) * (_a20$1 * _a32 - _a22$1 * _a30) + (_a02$1 * _a13 - _a03 * _a12$1) * (_a20$1 * _a31 - _a21$1 * _a30);
        }
    }, {
        key: "add",
        value: function add(mat) {
            return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
            this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
            this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
            this.m09 = this.m09 + mat.m09, this.m10 = this.m10 + mat.m10, this.m11 = this.m11 + mat.m11, 
            this.m12 = this.m12 + mat.m12, this.m13 = this.m13 + mat.m13, this.m14 = this.m14 + mat.m14, 
            this.m15 = this.m15 + mat.m15, this;
        }
    }, {
        key: "subtract",
        value: function subtract(mat) {
            return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
            this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
            this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
            this.m09 = this.m09 - mat.m09, this.m10 = this.m10 - mat.m10, this.m11 = this.m11 - mat.m11, 
            this.m12 = this.m12 - mat.m12, this.m13 = this.m13 - mat.m13, this.m14 = this.m14 - mat.m14, 
            this.m15 = this.m15 - mat.m15, this;
        }
    }, {
        key: "multiply",
        value: function multiply(mat) {
            _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
            _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
            _a22$1 = this.m10, _a23 = this.m11, _a30 = this.m12, _a31 = this.m13, _a32 = this.m14, 
            _a33 = this.m15;
            var b0 = mat.m00, b1 = mat.m01, b2 = mat.m02, b3 = mat.m03;
            return this.m00 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, this.m01 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, 
            this.m02 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, this.m03 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, 
            b0 = mat.m04, b1 = mat.m05, b2 = mat.m06, b3 = mat.m07, this.m04 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
            this.m05 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m06 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
            this.m07 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = mat.m08, b1 = mat.m09, 
            b2 = mat.m10, b3 = mat.m11, this.m08 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
            this.m09 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m10 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
            this.m11 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, b0 = mat.m12, b1 = mat.m13, 
            b2 = mat.m14, b3 = mat.m15, this.m12 = b0 * _a00$1 + b1 * _a10$1 + b2 * _a20$1 + b3 * _a30, 
            this.m13 = b0 * _a01$1 + b1 * _a11$1 + b2 * _a21$1 + b3 * _a31, this.m14 = b0 * _a02$1 + b1 * _a12$1 + b2 * _a22$1 + b3 * _a32, 
            this.m15 = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
            this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
            this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
            this.m09 = this.m09 * scalar, this.m10 = this.m10 * scalar, this.m11 = this.m11 * scalar, 
            this.m12 = this.m12 * scalar, this.m13 = this.m13 * scalar, this.m14 = this.m14 * scalar, 
            this.m15 = this.m15 * scalar, this;
        }
    }, {
        key: "translate",
        value: function translate(vec) {
            return console.warn("function changed"), this.m12 += vec.x, this.m13 += vec.y, this.m14 += vec.y, 
            this;
        }
    }, {
        key: "scale",
        value: function scale(vec) {
            var x = vec.x, y = vec.y, z = vec.z;
            return this.m00 = this.m00 * x, this.m01 = this.m01 * x, this.m02 = this.m02 * x, 
            this.m03 = this.m03 * x, this.m04 = this.m04 * y, this.m05 = this.m05 * y, this.m06 = this.m06 * y, 
            this.m07 = this.m07 * y, this.m08 = this.m08 * z, this.m09 = this.m09 * z, this.m10 = this.m10 * z, 
            this.m11 = this.m11 * z, this.m12 = this.m12, this.m13 = this.m13, this.m14 = this.m14, 
            this.m15 = this.m15, this;
        }
    }, {
        key: "rotate",
        value: function rotate(rad, axis) {
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
            if (Math.abs(len) < EPSILON) return null;
            x *= len = 1 / len, y *= len, z *= len;
            var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
            _a00$1 = this.m00, _a01$1 = this.m01, _a02$1 = this.m02, _a03 = this.m03, _a10$1 = this.m04, 
            _a11$1 = this.m05, _a12$1 = this.m06, _a13 = this.m07, _a20$1 = this.m08, _a21$1 = this.m09, 
            _a22$1 = this.m10, _a23 = this.m11;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            return this.m00 = _a00$1 * b00 + _a10$1 * b01 + _a20$1 * b02, this.m01 = _a01$1 * b00 + _a11$1 * b01 + _a21$1 * b02, 
            this.m02 = _a02$1 * b00 + _a12$1 * b01 + _a22$1 * b02, this.m03 = _a03 * b00 + _a13 * b01 + _a23 * b02, 
            this.m04 = _a00$1 * b10 + _a10$1 * b11 + _a20$1 * b12, this.m05 = _a01$1 * b10 + _a11$1 * b11 + _a21$1 * b12, 
            this.m06 = _a02$1 * b10 + _a12$1 * b11 + _a22$1 * b12, this.m07 = _a03 * b10 + _a13 * b11 + _a23 * b12, 
            this.m08 = _a00$1 * b20 + _a10$1 * b21 + _a20$1 * b22, this.m09 = _a01$1 * b20 + _a11$1 * b21 + _a21$1 * b22, 
            this.m10 = _a02$1 * b20 + _a12$1 * b21 + _a22$1 * b22, this.m11 = _a03 * b20 + _a13 * b21 + _a23 * b22, 
            this;
        }
    }, {
        key: "getTranslation",
        value: function getTranslation(out) {
            return out.x = this.m12, out.y = this.m13, out.z = this.m14, out;
        }
    }, {
        key: "getScale",
        value: function getScale(out) {
            var m00 = m3_1$1.m00 = this.m00, m01 = m3_1$1.m01 = this.m01, m02 = m3_1$1.m02 = this.m02, m04 = m3_1$1.m03 = this.m04, m05 = m3_1$1.m04 = this.m05, m06 = m3_1$1.m05 = this.m06, m08 = m3_1$1.m06 = this.m08, m09 = m3_1$1.m07 = this.m09, m10 = m3_1$1.m08 = this.m10;
            return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
            out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
            out;
        }
    }, {
        key: "getRotation",
        value: function getRotation(out) {
            var trace = this.m00 + this.m05 + this.m10, S = 0;
            return trace > 0 ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (this.m06 - this.m09) / S, 
            out.y = (this.m08 - this.m02) / S, out.z = (this.m01 - this.m04) / S) : this.m00 > this.m05 && this.m00 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m00 - this.m05 - this.m10), 
            out.w = (this.m06 - this.m09) / S, out.x = .25 * S, out.y = (this.m01 + this.m04) / S, 
            out.z = (this.m08 + this.m02) / S) : this.m05 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m05 - this.m00 - this.m10), 
            out.w = (this.m08 - this.m02) / S, out.x = (this.m01 + this.m04) / S, out.y = .25 * S, 
            out.z = (this.m06 + this.m09) / S) : (S = 2 * Math.sqrt(1 + this.m10 - this.m00 - this.m05), 
            out.w = (this.m01 - this.m04) / S, out.x = (this.m08 + this.m02) / S, out.y = (this.m06 + this.m09) / S, 
            out.z = .25 * S), out;
        }
    }, {
        key: "fromRTS",
        value: function fromRTS(q, v, s) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
            return this.m00 = (1 - (yy + zz)) * sx, this.m01 = (xy + wz) * sx, this.m02 = (xz - wy) * sx, 
            this.m03 = 0, this.m04 = (xy - wz) * sy, this.m05 = (1 - (xx + zz)) * sy, this.m06 = (yz + wx) * sy, 
            this.m07 = 0, this.m08 = (xz + wy) * sz, this.m09 = (yz - wx) * sz, this.m10 = (1 - (xx + yy)) * sz, 
            this.m11 = 0, this.m12 = v.x, this.m13 = v.y, this.m14 = v.z, this.m15 = 1, this;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return this.m00 = 1 - yy - zz, this.m01 = yx + wz, this.m02 = zx - wy, this.m03 = 0, 
            this.m04 = yx - wz, this.m05 = 1 - xx - zz, this.m06 = zy + wx, this.m07 = 0, this.m08 = zx + wy, 
            this.m09 = zy - wx, this.m10 = 1 - xx - yy, this.m11 = 0, this.m12 = 0, this.m13 = 0, 
            this.m14 = 0, this.m15 = 1, this;
        }
    } ]), Mat4;
}();

Mat4.IDENTITY = Object.freeze(new Mat4());

var v3_1$3 = new Vec3(), m3_1$1 = new Mat3();

CCClass.fastDefine("cc.Mat4", Mat4, {
    m00: 1,
    m01: 0,
    m02: 0,
    m03: 0,
    m04: 0,
    m05: 1,
    m06: 0,
    m07: 0,
    m08: 0,
    m09: 0,
    m10: 1,
    m11: 0,
    m12: 0,
    m13: 0,
    m14: 0,
    m15: 1
}), cc.Mat4 = Mat4, cc.mat4 = function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
};

var _a = 0, _b = 0, _c = 0, _d = 0, _tx = 0, _ty = 0, AffineTransform = function() {
    function AffineTransform() {
        var a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, b = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, c = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, tx = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, ty = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
        _classCallCheck(this, AffineTransform), this.a = void 0, this.b = void 0, this.c = void 0, 
        this.d = void 0, this.tx = void 0, this.ty = void 0, this.a = a, this.b = b, this.c = c, 
        this.d = d, this.tx = tx, this.ty = ty;
    }
    return _createClass(AffineTransform, null, [ {
        key: "identity",
        value: function identity() {
            return new AffineTransform();
        }
    }, {
        key: "clone",
        value: function clone(affineTransform) {
            return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
        }
    }, {
        key: "concat",
        value: function concat(out, t1, t2) {
            _a = t1.a, _b = t1.b, _c = t1.c, _d = t1.d, _tx = t1.tx, _ty = t1.ty, out.a = _a * t2.a + _b * t2.c, 
            out.b = _a * t2.b + _b * t2.d, out.c = _c * t2.a + _d * t2.c, out.d = _c * t2.b + _d * t2.d, 
            out.tx = _tx * t2.a + _ty * t2.c + t2.tx, out.ty = _tx * t2.b + _ty * t2.d + t2.ty;
        }
    }, {
        key: "invert",
        value: function invert(out, t) {
            var determinant = 1 / (t.a * t.d - t.b * t.c);
            out.a = determinant * t.d, out.b = -determinant * t.b, out.c = -determinant * t.c, 
            out.d = determinant * t.a, out.tx = determinant * (t.c * t.ty - t.d * t.tx), out.ty = determinant * (t.b * t.tx - t.a * t.ty);
        }
    }, {
        key: "fromMat4",
        value: function fromMat4(out, mat) {
            out.a = mat.m00, out.b = mat.m01, out.c = mat.m04, out.d = mat.m05, out.tx = mat.m12, 
            out.ty = mat.m13;
        }
    }, {
        key: "transformVec2",
        value: function transformVec2(out, point, transOrY, t) {
            var x, y;
            void 0 === t ? (t = transOrY, x = point.x, y = point.y) : (x = point, y = transOrY), 
            out.x = t.a * x + t.c * y + t.tx, out.y = t.b * x + t.d * y + t.ty;
        }
    }, {
        key: "transformSize",
        value: function transformSize(out, size, t) {
            out.width = t.a * size.width + t.c * size.height, out.height = t.b * size.width + t.d * size.height;
        }
    }, {
        key: "transformRect",
        value: function transformRect(out, rect, t) {
            var or = rect.x + rect.width, ot = rect.y + rect.height, lbx = t.a * rect.x + t.c * rect.y + t.tx, lby = t.b * rect.x + t.d * rect.y + t.ty, rbx = t.a * or + t.c * rect.y + t.tx, rby = t.b * or + t.d * rect.y + t.ty, ltx = t.a * rect.x + t.c * ot + t.tx, lty = t.b * rect.x + t.d * ot + t.ty, rtx = t.a * or + t.c * ot + t.tx, rty = t.b * or + t.d * ot + t.ty, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
            out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY;
        }
    }, {
        key: "transformObb",
        value: function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
            var tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx, ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty, xa = anAffineTransform.a * rect.width, xb = anAffineTransform.b * rect.width, yc = anAffineTransform.c * rect.height, yd = anAffineTransform.d * rect.height;
            out_tl.x = tx, out_tl.y = ty, out_tr.x = xa + tx, out_tr.y = xb + ty, out_bl.x = yc + tx, 
            out_bl.y = yd + ty, out_br.x = xa + yc + tx, out_br.y = xb + yd + ty;
        }
    } ]), AffineTransform;
}();

cc.AffineTransform = AffineTransform;

var Size = function(_ValueType) {
    function Size(width, height) {
        var _this;
        return _classCallCheck(this, Size), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Size).call(this))).width = void 0, 
        _this.height = void 0, width && "object" === _typeof(width) ? (_this.height = width.height, 
        _this.width = width.width) : (_this.width = width || 0, _this.height = height || 0), 
        _this;
    }
    return _inherits(Size, ValueType), _createClass(Size, null, [ {
        key: "lerp",
        value: function lerp(out, from, to, ratio) {
            return out.width = from.width + (to.width - from.width) * ratio, out.height = from.height + (to.height - from.height) * ratio, 
            out;
        }
    }, {
        key: "ZERO",
        get: function get() {
            return new Size(0, 0);
        }
    } ]), _createClass(Size, [ {
        key: "clone",
        value: function clone() {
            return new Size(this.width, this.height);
        }
    }, {
        key: "set",
        value: function set(width, height) {
            return width && "object" === _typeof(width) ? (this.height = width.height, this.width = width.width) : (this.width = width || 0, 
            this.height = height || 0), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return this.width === other.width && this.height === other.height;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return this.width = this.width + (to.width - this.width) * ratio, this.height = this.height + (to.height - this.height) * ratio, 
            this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
        }
    } ]), Size;
}();

CCClass.fastDefine("cc.Size", Size, {
    width: 0,
    height: 0
}), cc.size = function size() {
    var width = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return new Size(width, height);
}, cc.Size = Size;

var _x$4 = 0, _y$4 = 0, _w$2 = 0, _h = 0, Rect = function(_ValueType) {
    function Rect(x, y, width, height) {
        var _this;
        return _classCallCheck(this, Rect), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this))).x = void 0, 
        _this.y = void 0, _this.width = void 0, _this.height = void 0, x && "object" === _typeof(x) ? (_this.y = x.y, 
        _this.width = x.width, _this.height = x.height, _this.x = x.x) : (_this.x = x || 0, 
        _this.y = y || 0, _this.width = width || 0, _this.height = height || 0), _this;
    }
    return _inherits(Rect, ValueType), _createClass(Rect, [ {
        key: "xMin",
        get: function get() {
            return this.x;
        },
        set: function set(value) {
            this.width += this.x - value, this.x = value;
        }
    }, {
        key: "yMin",
        get: function get() {
            return this.y;
        },
        set: function set(value) {
            this.height += this.y - value, this.y = value;
        }
    }, {
        key: "xMax",
        get: function get() {
            return this.x + this.width;
        },
        set: function set(value) {
            this.width = value - this.x;
        }
    }, {
        key: "yMax",
        get: function get() {
            return this.y + this.height;
        },
        set: function set(value) {
            this.height = value - this.y;
        }
    }, {
        key: "center",
        get: function get() {
            return new Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
        },
        set: function set(value) {
            this.x = value.x - .5 * this.width, this.y = value.y - .5 * this.height;
        }
    }, {
        key: "origin",
        get: function get() {
            return new cc.Vec2(this.x, this.y);
        },
        set: function set(value) {
            this.x = value.x, this.y = value.y;
        }
    }, {
        key: "size",
        get: function get() {
            return new Size(this.width, this.height);
        },
        set: function set(value) {
            this.width = value.width, this.height = value.height;
        }
    } ], [ {
        key: "fromMinMax",
        value: function fromMinMax(out, v1, v2) {
            var minX = Math.min(v1.x, v2.x), minY = Math.min(v1.y, v2.y), maxX = Math.max(v1.x, v2.x), maxY = Math.max(v1.y, v2.y);
            return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, 
            out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, from, to, ratio) {
            return _x$4 = from.x, _y$4 = from.y, _w$2 = from.width, _h = from.height, out.x = _x$4 + (to.x - _x$4) * ratio, 
            out.y = _y$4 + (to.y - _y$4) * ratio, out.width = _w$2 + (to.width - _w$2) * ratio, 
            out.height = _h + (to.height - _h) * ratio, out;
        }
    }, {
        key: "intersection",
        value: function intersection(out, one, other) {
            var axMin = one.x, ayMin = one.y, axMax = one.x + one.width, ayMax = one.y + one.height, bxMin = other.x, byMin = other.y, bxMax = other.x + other.width, byMax = other.y + other.height;
            return out.x = Math.max(axMin, bxMin), out.y = Math.max(ayMin, byMin), out.width = Math.min(axMax, bxMax) - out.x, 
            out.height = Math.min(ayMax, byMax) - out.y, out;
        }
    }, {
        key: "union",
        value: function union(out, one, other) {
            _x$4 = one.x, _y$4 = one.y, _w$2 = one.width, _h = one.height;
            var bx = other.x, by = other.y, bw = other.width, bh = other.height;
            return out.x = Math.min(_x$4, bx), out.y = Math.min(_y$4, by), out.width = Math.max(_x$4 + _w$2, bx + bw) - out.x, 
            out.height = Math.max(_y$4 + _h, by + bh) - out.y, out;
        }
    } ]), _createClass(Rect, [ {
        key: "clone",
        value: function clone() {
            return new Rect(this.x, this.y, this.width, this.height);
        }
    }, {
        key: "set",
        value: function set(x, y, width, height) {
            return x && "object" === _typeof(x) ? (this.y = x.y, this.width = x.width, this.height = x.height, 
            this.x = x.x) : (this.x = x || 0, this.y = y || 0, this.width = width || 0, this.height = height || 0), 
            this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return _x$4 = this.x, _y$4 = this.y, _w$2 = this.width, _h = this.height, this.x = _x$4 + (to.x - _x$4) * ratio, 
            this.y = _y$4 + (to.y - _y$4) * ratio, this.width = _w$2 + (to.width - _w$2) * ratio, 
            this.height = _h + (to.height - _h) * ratio, this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
        }
    }, {
        key: "intersects",
        value: function intersects(other) {
            var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = other.x + other.width, maxby = other.y + other.height;
            return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
        }
    }, {
        key: "contains",
        value: function contains(point) {
            return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
        }
    }, {
        key: "containsRect",
        value: function containsRect(other) {
            return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(mat) {
            var ol = this.x, ob = this.y, or = ol + this.width, ot = ob + this.height, lbx = mat.m00 * ol + mat.m04 * ob + mat.m12, lby = mat.m01 * ol + mat.m05 * ob + mat.m13, rbx = mat.m00 * or + mat.m04 * ob + mat.m12, rby = mat.m01 * or + mat.m05 * ob + mat.m13, ltx = mat.m00 * ol + mat.m04 * ot + mat.m12, lty = mat.m01 * ol + mat.m05 * ot + mat.m13, rtx = mat.m00 * or + mat.m04 * ot + mat.m12, rty = mat.m01 * or + mat.m05 * ot + mat.m13, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
            return this.x = minX, this.y = minY, this.width = maxX - minX, this.height = maxY - minY, 
            this;
        }
    } ]), Rect;
}();

function rect() {
    var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, width = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, height = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    return new Rect(x, y, width, height);
}

CCClass.fastDefine("cc.Rect", Rect, {
    x: 0,
    y: 0,
    width: 0,
    height: 0
}), cc.Rect = Rect, cc.rect = rect;

var _r = 0, _g = 0, _b$1 = 0, _a$1 = 0, Color = function(_ValueType) {
    function Color(r, g, b, a) {
        var _this;
        return _classCallCheck(this, Color), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Color).call(this)))._val = 0, 
        "string" == typeof r ? _this.fromHEX(r) : ("object" === _typeof(r) && (g = r.g, 
        b = r.b, a = r.a, r = r.r), r = r || 0, g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, 
        _this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r), _this;
    }
    return _inherits(Color, ValueType), _createClass(Color, [ {
        key: "r",
        get: function get() {
            return 255 & this._val;
        },
        set: function set(red) {
            red = ~~cc.math.clamp(red, 0, 255), this._val = (4294967040 & this._val | red) >>> 0;
        }
    }, {
        key: "g",
        get: function get() {
            return (65280 & this._val) >> 8;
        },
        set: function set(green) {
            green = ~~cc.math.clamp(green, 0, 255), this._val = (4294902015 & this._val | green << 8) >>> 0;
        }
    }, {
        key: "b",
        get: function get() {
            return (16711680 & this._val) >> 16;
        },
        set: function set(blue) {
            blue = ~~cc.math.clamp(blue, 0, 255), this._val = (4278255615 & this._val | blue << 16) >>> 0;
        }
    }, {
        key: "a",
        get: function get() {
            return (4278190080 & this._val) >>> 24;
        },
        set: function set(alpha) {
            alpha = ~~cc.math.clamp(alpha, 0, 255), this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0;
        }
    }, {
        key: "x",
        get: function get() {
            return this.r * (1 / 255);
        },
        set: function set(value) {
            this.r = 255 * value;
        }
    }, {
        key: "y",
        get: function get() {
            return this.g * (1 / 255);
        },
        set: function set(value) {
            this.g = 255 * value;
        }
    }, {
        key: "z",
        get: function get() {
            return this.b * (1 / 255);
        },
        set: function set(value) {
            this.b = 255 * value;
        }
    }, {
        key: "w",
        get: function get() {
            return this.a * (1 / 255);
        },
        set: function set(value) {
            this.a = 255 * value;
        }
    } ], [ {
        key: "clone",
        value: function clone(a) {
            var out = new Color();
            return a._val ? out._val = a._val : out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r, 
            out;
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.r = a.r, out.g = a.g, out.b = a.b, out.a = a.a, out;
        }
    }, {
        key: "set",
        value: function set(out, r, g, b, a) {
            return out.r = r, out.g = g, out.b = b, out.a = a, out;
        }
    }, {
        key: "fromHex",
        value: function fromHex(out, hex) {
            return out.r = (hex >> 24) / 255, out.g = (hex >> 16 & 255) / 255, out.b = (hex >> 8 & 255) / 255, 
            out.a = (255 & hex) / 255, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.r = a.r + b.r, out.g = a.g + b.g, out.b = a.b + b.b, out.a = a.a + b.a, 
            out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.r = a.r - b.r, out.g = a.g - b.g, out.b = a.b - b.b, out.a = a.a - b.a, 
            out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.r = a.r * b.r, out.g = a.g * b.g, out.b = a.b * b.b, out.a = a.a * b.a, 
            out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.r = a.r / b.r, out.g = a.g / b.g, out.b = a.b / b.b, out.a = a.a / b.a, 
            out;
        }
    }, {
        key: "scale",
        value: function scale(out, a, b) {
            return out.r = a.r * b, out.g = a.g * b, out.b = a.b * b, out.a = a.a * b, out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, from, to, ratio) {
            return _r = from.r, _g = from.g, _b$1 = from.b, _a$1 = from.a, _r += (to.r - _r) * ratio, 
            _g += (to.g - _g) * ratio, _b$1 += (to.b - _b$1) * ratio, _a$1 += (to.a - _a$1) * ratio, 
            out._val = Math.floor((_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r), out;
        }
    }, {
        key: "array",
        value: function array(out, a) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, scale = a instanceof cc.Color || a.a > 1 ? 1 / 255 : 1;
            return out[ofs + 0] = a.r * scale, out[ofs + 1] = a.g * scale, out[ofs + 2] = a.b * scale, 
            out[ofs + 3] = a.a * scale, out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.r - b.r) <= epsilon * Math.max(1, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1, Math.abs(a.a), Math.abs(b.a));
        }
    }, {
        key: "hex",
        value: function hex(a) {
            return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
        }
    } ]), _createClass(Color, [ {
        key: "clone",
        value: function clone() {
            var ret = new Color();
            return ret._val = this._val, ret;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return other && this._val === other._val;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return _r = this.r, _g = this.g, _b$1 = this.b, _a$1 = this.a, _r += (to.r - _r) * ratio, 
            _g += (to.g - _g) * ratio, _b$1 += (to.b - _b$1) * ratio, _a$1 += (to.a - _a$1) * ratio, 
            this._val = Math.floor((_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r), this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
        }
    }, {
        key: "toCSS",
        value: function toCSS(opt) {
            return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a * (1 / 255)).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
        }
    }, {
        key: "fromHEX",
        value: function fromHEX(hexString) {
            return hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString, 
            _r = parseInt(hexString.substr(0, 2), 16) || 0, _g = parseInt(hexString.substr(2, 2), 16) || 0, 
            _b$1 = parseInt(hexString.substr(4, 2), 16) || 0, _a$1 = parseInt(hexString.substr(6, 2), 16) || 255, 
            this._val = (_a$1 << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r, this;
        }
    }, {
        key: "toHEX",
        value: function toHEX(fmt) {
            var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ], i = -1;
            if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]); else if ("#rrggbbaa" === fmt) for (hex.push((0 | this.a).toString(16)), 
            i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
            return hex.join("");
        }
    }, {
        key: "toRGBValue",
        value: function toRGBValue() {
            return 16777215 & this._val;
        }
    }, {
        key: "fromHSV",
        value: function fromHSV(h, s, v) {
            if (_r = 0, _g = 0, _b$1 = 0, 0 === s) _r = _g = _b$1 = v; else if (0 === v) _r = _g = _b$1 = 0; else {
                1 === h && (h = 0), h *= 6, s = s, v = v;
                var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - s * f), t = v * (1 - s * (1 - f));
                switch (i) {
                  case 0:
                    _r = v, _g = t, _b$1 = p;
                    break;

                  case 1:
                    _r = q, _g = v, _b$1 = p;
                    break;

                  case 2:
                    _r = p, _g = v, _b$1 = t;
                    break;

                  case 3:
                    _r = p, _g = q, _b$1 = v;
                    break;

                  case 4:
                    _r = t, _g = p, _b$1 = v;
                    break;

                  case 5:
                    _r = v, _g = p, _b$1 = q;
                }
            }
            return _r *= 255, _g *= 255, _b$1 *= 255, this._val = (this.a << 24 >>> 0) + (_b$1 << 16) + (_g << 8) + _r, 
            this;
        }
    }, {
        key: "toHSV",
        value: function toHSV() {
            _r = this.r * (1 / 255), _g = this.g * (1 / 255), _b$1 = this.b * (1 / 255);
            var hsv = {
                h: 0,
                s: 0,
                v: 0
            }, max = Math.max(_r, _g, _b$1), min = Math.min(_r, _g, _b$1), delta = 0;
            return hsv.v = max, hsv.s = max ? (max - min) / max : 0, hsv.s ? (delta = max - min, 
            hsv.h = _r === max ? (_g - _b$1) / delta : _g === max ? 2 + (_b$1 - _r) / delta : 4 + (_r - _g) / delta, 
            hsv.h /= 6, hsv.h < 0 && (hsv.h += 1)) : hsv.h = 0, hsv;
        }
    }, {
        key: "set",
        value: function set(r, g, b, a) {
            return "object" === _typeof(r) && (g = r.g, b = r.b, a = r.a, r = r.r), r = r || 0, 
            g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r, 
            this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return _r = (255 & this._val) * other.r >> 8, _g = (65280 & this._val) * other.g >> 8, 
            _b$1 = (16711680 & this._val) * other.b >> 8, _a$1 = ((4278190080 & this._val) >>> 8) * other.a, 
            this._val = 4278190080 & _a$1 | 16711680 & _b$1 | 65280 & _g | 255 & _r, this;
        }
    }, {
        key: "_set_r_unsafe",
        value: function _set_r_unsafe(red) {
            return this._val = (4294967040 & this._val | red) >>> 0, this;
        }
    }, {
        key: "_set_g_unsafe",
        value: function _set_g_unsafe(green) {
            return this._val = (4294902015 & this._val | green << 8) >>> 0, this;
        }
    }, {
        key: "_set_b_unsafe",
        value: function _set_b_unsafe(blue) {
            return this._val = (4278255615 & this._val | blue << 16) >>> 0, this;
        }
    }, {
        key: "_set_a_unsafe",
        value: function _set_a_unsafe(alpha) {
            return this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0, this;
        }
    } ]), Color;
}();

Color.WHITE = Object.freeze(new Color(255, 255, 255, 255)), Color.GRAY = Object.freeze(new Color(127, 127, 127, 255)), 
Color.BLACK = Object.freeze(new Color(0, 0, 0, 255)), Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0)), 
Color.RED = Object.freeze(new Color(255, 0, 0, 255)), Color.GREEN = Object.freeze(new Color(0, 255, 0, 255)), 
Color.BLUE = Object.freeze(new Color(0, 0, 255, 255)), Color.CYAN = Object.freeze(new Color(0, 255, 255, 255)), 
Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255)), Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255)), 
CCClass.fastDefine("cc.Color", Color, {
    r: 0,
    g: 0,
    b: 0,
    a: 255
}), cc.Color = Color, cc.color = function color(r, g, b, a) {
    return new Color(r, g, b, a);
};

var replaceProperty, removeProperty, markAsWarning, replacePropertyLog, markAsWarningLog, removePropertyLog, defaultLogTimes = 10;

function setDefaultLogTimes(times) {
    times > 0 && (defaultLogTimes = times);
}

var messageID = 0, messageMap = new Map();

replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id) {
    var item = messageMap.get(id);
    item && item.logTimes > item.count && (f("'%s' is deprecated, please use '%s' instead.", "".concat(n, ".").concat(dp), "".concat(n2, ".").concat(newp)), 
    item.count++);
}, removePropertyLog = function removePropertyLog(n, dp, f, id) {
    var item = messageMap.get(id);
    item && item.logTimes > item.count && (f("'%s' has been removed.", "".concat(n, ".").concat(dp)), 
    item.count++);
}, removeProperty = function removeProperty(owner, ownerName, properties) {
    null != owner && properties.forEach(function(item) {
        var id = messageID++;
        messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
        }), Object.defineProperty(owner, item.name, {
            get: function get() {
                return removePropertyLog(ownerName, item.name, error, id);
            },
            set: function set() {
                removePropertyLog(ownerName, item.name, error, id);
            }
        });
    });
}, markAsWarningLog = function markAsWarningLog(n, dp, f, id) {
    var item = messageMap.get(id);
    item && item.logTimes > item.count && (f("'%s' is deprecated.", "".concat(n, ".").concat(dp)), 
    item.count++);
}, markAsWarning = function markAsWarning(owner, ownerName, properties) {
    if (null != owner) {
        var _defaultGetSet = function _defaultGetSet(o, p, d, n, dp, f, id) {
            if (d.get) {
                var oldGet = d.get();
                d.get = function() {
                    return markAsWarningLog(n, dp, f, id), oldGet.call(this);
                };
            }
            if (d.set) {
                var oldSet = Object.create(d.set);
                d.set = function(v) {
                    markAsWarningLog(n, dp, f, id), oldSet.call(this, v);
                };
            }
        };
        properties.forEach(function(item) {
            var deprecatedProp = item.name, descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
            if (descriptor) {
                var id = messageID++;
                if (messageMap.set(id, {
                    id: id,
                    count: 0,
                    logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
                }), null != descriptor.value) if ("function" == typeof descriptor.value) {
                    var oldValue = descriptor.value;
                    owner[deprecatedProp] = function() {
                        return markAsWarningLog(ownerName, deprecatedProp, warn, id), oldValue.call(this);
                    };
                } else _defaultGetSet(0, 0, descriptor, ownerName, deprecatedProp, warn, id); else _defaultGetSet(0, 0, descriptor, ownerName, deprecatedProp, warn, id);
            }
        });
    }
}, (replaceProperty = function replaceProperty(owner, ownerName, properties) {
    null != owner && properties.forEach(function(item) {
        var id = messageID++;
        messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
        });
        var target = null != item.target ? item.target : owner, newName = null != item.newName ? item.newName : item.name, targetName = null != item.targetName ? item.targetName : ownerName;
        if (null != item.customFunction) owner[item.name] = function() {
            return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
            item.customFunction.call(this, arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], arguments.length <= 2 ? void 0 : arguments[2], arguments.length <= 3 ? void 0 : arguments[3], arguments.length <= 4 ? void 0 : arguments[4], arguments.length <= 5 ? void 0 : arguments[5], arguments.length <= 6 ? void 0 : arguments[6], arguments.length <= 7 ? void 0 : arguments[7], arguments.length <= 8 ? void 0 : arguments[8], arguments.length <= 9 ? void 0 : arguments[9], arguments.length <= 10 ? void 0 : arguments[10], arguments.length <= 11 ? void 0 : arguments[11]);
        }; else if (null != item.customSetter || null != item.customGetter) {
            var hasSetter = null != item.customSetter, hasGetter = null != item.customGetter;
            hasSetter && hasGetter ? Object.defineProperty(owner, item.name, {
                get: function get() {
                    return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                    item.customGetter.call(this);
                },
                set: function set(v) {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                }
            }) : hasSetter ? Object.defineProperty(owner, item.name, {
                set: function set(v) {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                }
            }) : hasGetter && Object.defineProperty(owner, item.name, {
                get: function get() {
                    return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                    item.customGetter.call(this);
                }
            });
        } else Object.defineProperty(owner, item.name, {
            get: function get() {
                return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                target[newName];
            },
            set: function set(v) {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), target[newName] = v;
            }
        });
    });
})(Vec2, "Vec2", [ {
    name: "sub",
    newName: "subtract",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "mul",
    newName: "multiply",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "div",
    newName: "divide",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "dist",
    newName: "distance",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "sqrDist",
    newName: "squaredDistance",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "mag",
    newName: "len",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec2,
    targetName: "Vec2"
} ]), replaceProperty(Vec2.prototype, "Vec2", [ {
    name: "mag",
    newName: "length",
    target: Vec2.prototype,
    targetName: "Vec2"
}, {
    name: "magSqr",
    newName: "lengthSqr",
    target: Vec2.prototype,
    targetName: "Vec2"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec2.prototype,
    targetName: "Vec2"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec2.prototype,
    targetName: "Vec2"
} ]), removeProperty(Vec2.prototype, "vmath", [ {
    name: "divide"
} ]), replaceProperty(Vec3, "Vec3", [ {
    name: "sub",
    newName: "subtract",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "mul",
    newName: "multiply",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "div",
    newName: "divide",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "dist",
    newName: "distance",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "sqrDist",
    newName: "squaredDistance",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "mag",
    newName: "len",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec3,
    targetName: "Vec3"
} ]), replaceProperty(Vec3.prototype, "Vec3", [ {
    name: "mag",
    newName: "length",
    target: Vec3.prototype,
    targetName: "Vec3"
}, {
    name: "magSqr",
    newName: "lengthSqr",
    target: Vec3.prototype,
    targetName: "Vec3"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec3.prototype,
    targetName: "Vec3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec3.prototype,
    targetName: "Vec3"
} ]), removeProperty(Vec3.prototype, "vmath", [ {
    name: "divide"
} ]), replaceProperty(Vec4, "Vec4", [ {
    name: "sub",
    newName: "subtract",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "mul",
    newName: "multiply",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "div",
    newName: "divide",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "dist",
    newName: "distance",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "sqrDist",
    newName: "squaredDistance",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "mag",
    newName: "len",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec4,
    targetName: "Vec4"
} ]), replaceProperty(Vec4.prototype, "Vec4", [ {
    name: "mag",
    newName: "length",
    target: Vec4.prototype,
    targetName: "Vec4"
}, {
    name: "magSqr",
    newName: "lengthSqr",
    target: Vec4.prototype,
    targetName: "Vec4"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec4.prototype,
    targetName: "Vec4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec4.prototype,
    targetName: "Vec4"
} ]), removeProperty(Vec4.prototype, "vmath", [ {
    name: "divide"
} ]), replaceProperty(Quat, "Quat", [ {
    name: "mag",
    newName: "len",
    target: Quat,
    targetName: "Quat"
}, {
    name: "mul",
    newName: "multiply",
    target: Quat,
    targetName: "Quat"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Quat,
    targetName: "Quat"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Quat,
    targetName: "Quat"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Quat,
    targetName: "Quat"
} ]), replaceProperty(Quat.prototype, "Quat", [ {
    name: "scale",
    newName: "multiplyScalar",
    target: Quat.prototype,
    targetName: "Quat"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Quat.prototype,
    targetName: "Quat"
} ]), replaceProperty(Color, "Color", [ {
    name: "sub",
    newName: "subtract",
    target: Color,
    targetName: "Color"
}, {
    name: "mul",
    newName: "multiply",
    target: Color,
    targetName: "Color"
}, {
    name: "div",
    newName: "divide",
    target: Color,
    targetName: "Color"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Color,
    targetName: "Color"
} ]), replaceProperty(Mat3, "Mat3", [ {
    name: "sub",
    newName: "subtract",
    target: Mat3,
    targetName: "Mat3"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat3,
    targetName: "Mat3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat3,
    targetName: "Mat3"
} ]), replaceProperty(Mat3.prototype, "Mat3", [ {
    name: "sub",
    newName: "subtract",
    target: Mat3.prototype,
    targetName: "Mat3"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat3.prototype,
    targetName: "Mat3"
}, {
    name: "mulScalar",
    newName: "multiplyScalar",
    target: Mat3.prototype,
    targetName: "Mat3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat3.prototype,
    targetName: "Mat3"
} ]), replaceProperty(Mat4, "Mat4", [ {
    name: "sub",
    newName: "subtract",
    target: Mat4,
    targetName: "Mat4"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat4,
    targetName: "Mat4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat4,
    targetName: "Mat4"
} ]), replaceProperty(Mat4.prototype, "Mat4", [ {
    name: "sub",
    newName: "subtract",
    target: Mat4.prototype,
    targetName: "Mat4"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat4.prototype,
    targetName: "Mat4"
}, {
    name: "mulScalar",
    newName: "multiplyScalar",
    target: Mat4.prototype,
    targetName: "Mat4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat4.prototype,
    targetName: "Mat4"
} ]);

var math = Object.freeze({
    bits: bits,
    Vec2: Vec2,
    Vec3: Vec3,
    Vec4: Vec4,
    Quat: Quat,
    Mat3: Mat3,
    Mat4: Mat4,
    AffineTransform: AffineTransform,
    Size: Size,
    Rect: Rect,
    Color: Color,
    EPSILON: EPSILON,
    equals: function equals(a, b) {
        return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    },
    approx: function approx(a, b, maxDiff) {
        return maxDiff = maxDiff || EPSILON, Math.abs(a - b) <= maxDiff;
    },
    clamp: clamp,
    clamp01: clamp01,
    lerp: lerp,
    toRadian: toRadian,
    toDegree: toDegree,
    random: random,
    randomRange: randomRange,
    randomRangeInt: randomRangeInt,
    pseudoRandom: pseudoRandom,
    pseudoRandomRange: pseudoRandomRange,
    pseudoRandomRangeInt: function pseudoRandomRangeInt(seed, min, max) {
        return Math.floor(pseudoRandomRange(seed, min, max));
    },
    nextPow2: function nextPow2$1(val) {
        return --val, val |= val >> 1, val |= val >> 2, val |= val >> 4, val |= val >> 8, 
        val |= val >> 16, ++val;
    },
    repeat: repeat,
    pingPong: pingPong,
    inverseLerp: inverseLerp
}), EventMouse = function(_Event) {
    function EventMouse(eventType, bubbles) {
        var _this;
        return _classCallCheck(this, EventMouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(EventMouse).call(this, Event.MOUSE, bubbles))).movementX = 0, 
        _this.movementY = 0, _this._eventType = void 0, _this._button = 0, _this._x = 0, 
        _this._y = 0, _this._prevX = 0, _this._prevY = 0, _this._scrollX = 0, _this._scrollY = 0, 
        _this._eventType = eventType, _this;
    }
    return _inherits(EventMouse, Event), _createClass(EventMouse, [ {
        key: "setScrollData",
        value: function setScrollData(scrollX, scrollY) {
            this._scrollX = scrollX, this._scrollY = scrollY;
        }
    }, {
        key: "getScrollX",
        value: function getScrollX() {
            return this._scrollX;
        }
    }, {
        key: "getScrollY",
        value: function getScrollY() {
            return this._scrollY;
        }
    }, {
        key: "setLocation",
        value: function setLocation(x, y) {
            this._x = x, this._y = y;
        }
    }, {
        key: "getLocation",
        value: function getLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._x, this._y), out;
        }
    }, {
        key: "getLocationInView",
        value: function getLocationInView(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._x, cc.view._designResolutionSize.height - this._y), 
            out;
        }
    }, {
        key: "getUILocation",
        value: function getUILocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._x, this._y), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "_setPrevCursor",
        value: function _setPrevCursor(x, y) {
            this._prevX = x, this._prevY = y;
        }
    }, {
        key: "getPreviousLocation",
        value: function getPreviousLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._prevX, this._prevY), out;
        }
    }, {
        key: "getUIPreviousLocation",
        value: function getUIPreviousLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._prevX, this._prevY), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "getDelta",
        value: function getDelta(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._x - this._prevX, this._y - this._prevY), 
            out;
        }
    }, {
        key: "getDeltaX",
        value: function getDeltaX() {
            return this._x - this._prevX;
        }
    }, {
        key: "getDeltaY",
        value: function getDeltaY() {
            return this._y - this._prevY;
        }
    }, {
        key: "getUIDelta",
        value: function getUIDelta(out) {
            return out || (out = new Vec2()), Vec2.set(out, (this._x - this._prevX) / cc.view.getScaleX(), (this._y - this._prevY) / cc.view.getScaleY()), 
            out;
        }
    }, {
        key: "getUIDeltaX",
        value: function getUIDeltaX() {
            return (this._x - this._prevX) / cc.view.getScaleX();
        }
    }, {
        key: "getUIDeltaY",
        value: function getUIDeltaY() {
            return (this._y - this._prevY) / cc.view.getScaleY();
        }
    }, {
        key: "setButton",
        value: function setButton(button) {
            this._button = button;
        }
    }, {
        key: "getButton",
        value: function getButton() {
            return this._button;
        }
    }, {
        key: "getLocationX",
        value: function getLocationX() {
            return this._x;
        }
    }, {
        key: "getLocationY",
        value: function getLocationY() {
            return this._y;
        }
    }, {
        key: "getUILocationX",
        value: function getUILocationX() {
            var viewport = cc.view.getViewportRect();
            return (this._x - viewport.x) / cc.view.getScaleX();
        }
    }, {
        key: "getUILocationY",
        value: function getUILocationY() {
            var viewport = cc.view.getViewportRect();
            return (this._y - viewport.y) / cc.view.getScaleY();
        }
    } ]), EventMouse;
}();

EventMouse.NONE = 0, EventMouse.DOWN = 1, EventMouse.UP = 2, EventMouse.MOVE = 3, 
EventMouse.SCROLL = 4, EventMouse.BUTTON_LEFT = 0, EventMouse.BUTTON_RIGHT = 2, 
EventMouse.BUTTON_MIDDLE = 1, EventMouse.BUTTON_4 = 3, EventMouse.BUTTON_5 = 4, 
EventMouse.BUTTON_6 = 5, EventMouse.BUTTON_7 = 6, EventMouse.BUTTON_8 = 7;

var EventTouch = function(_Event2) {
    function EventTouch(touches, bubbles) {
        var _this2;
        return _classCallCheck(this, EventTouch), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(EventTouch).call(this, Event.TOUCH, bubbles))).touch = null, 
        _this2.currentTouch = null, _this2._eventCode = 0, _this2.simulate = !1, _this2._touches = void 0, 
        _this2._eventCode = 0, _this2._touches = touches || [], _this2;
    }
    return _inherits(EventTouch, Event), _createClass(EventTouch, [ {
        key: "getEventCode",
        value: function getEventCode() {
            return this._eventCode;
        }
    }, {
        key: "getTouches",
        value: function getTouches() {
            return this._touches;
        }
    }, {
        key: "_setEventCode",
        value: function _setEventCode(eventCode) {
            this._eventCode = eventCode;
        }
    }, {
        key: "_setTouches",
        value: function _setTouches(touches) {
            this._touches = touches;
        }
    }, {
        key: "setLocation",
        value: function setLocation(x, y) {
            this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
        }
    }, {
        key: "getLocation",
        value: function getLocation(out) {
            return this.touch ? this.touch.getLocation(out) : new Vec2();
        }
    }, {
        key: "getLocationInView",
        value: function getLocationInView(out) {
            return this.touch ? this.touch.getLocationInView(out) : new Vec2();
        }
    }, {
        key: "getPreviousLocation",
        value: function getPreviousLocation(out) {
            return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
        }
    }, {
        key: "getStartLocation",
        value: function getStartLocation(out) {
            return this.touch ? this.touch.getStartLocation(out) : new Vec2();
        }
    }, {
        key: "getID",
        value: function getID() {
            return this.touch ? this.touch.getID() : null;
        }
    }, {
        key: "getDelta",
        value: function getDelta(out) {
            return this.touch ? this.touch.getDelta(out) : new Vec2();
        }
    }, {
        key: "getDeltaX",
        value: function getDeltaX(out) {
            return this.touch ? this.touch.getDelta(out).x : 0;
        }
    }, {
        key: "getDeltaY",
        value: function getDeltaY(out) {
            return this.touch ? this.touch.getDelta(out).y : 0;
        }
    }, {
        key: "getLocationX",
        value: function getLocationX() {
            return this.touch ? this.touch.getLocationX() : 0;
        }
    }, {
        key: "getLocationY",
        value: function getLocationY() {
            return this.touch ? this.touch.getLocationY() : 0;
        }
    } ]), EventTouch;
}();

EventTouch.MAX_TOUCHES = 5, EventTouch.BEGAN = 0, EventTouch.MOVED = 1, EventTouch.ENDED = 2, 
EventTouch.CANCELLED = 3;

var EventAcceleration = function(_Event3) {
    function EventAcceleration(acc, bubbles) {
        var _this3;
        return _classCallCheck(this, EventAcceleration), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(EventAcceleration).call(this, Event.ACCELERATION, bubbles))).acc = void 0, 
        _this3.acc = acc, _this3;
    }
    return _inherits(EventAcceleration, Event), EventAcceleration;
}(), EventKeyboard = function(_Event4) {
    function EventKeyboard(keyCode, isPressed, bubbles) {
        var _this4;
        return _classCallCheck(this, EventKeyboard), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(EventKeyboard).call(this, Event.KEYBOARD, bubbles))).keyCode = void 0, 
        _this4.rawEvent = void 0, _this4.isPressed = void 0, "number" == typeof keyCode ? _this4.keyCode = keyCode : (_this4.keyCode = keyCode.keyCode, 
        _this4.rawEvent = keyCode), _this4.isPressed = isPressed, _this4;
    }
    return _inherits(EventKeyboard, Event), EventKeyboard;
}();

Event.EventMouse = EventMouse, Event.EventTouch = EventTouch, Event.EventAcceleration = EventAcceleration, 
Event.EventKeyboard = EventKeyboard;

var EventListener = function() {
    function EventListener(type, listenerID, callback) {
        _classCallCheck(this, EventListener), this.owner = null, this.mask = null, this._previousIn = !1, 
        this._target = null, this._onEvent = void 0, this._type = void 0, this._listenerID = void 0, 
        this._registered = !1, this._fixedPriority = 0, this._node = null, this._paused = !0, 
        this._isEnabled = !0, this._onEvent = callback, this._type = type || 0, this._listenerID = listenerID || "";
    }
    return _createClass(EventListener, [ {
        key: "onEvent",
        get: function get() {
            return this._onEvent;
        }
    } ], [ {
        key: "create",
        value: function create(argObj) {
            cc.assertID(argObj && argObj.event, 1900);
            var listenerType = argObj.event;
            delete argObj.event;
            var listener = null;
            if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? listener = new TouchOneByOne() : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? listener = new TouchAllAtOnce() : listenerType === cc.EventListener.MOUSE ? listener = new Mouse() : listenerType === cc.EventListener.KEYBOARD ? listener = new Keyboard() : listenerType === cc.EventListener.ACCELERATION && (listener = new Acceleration(argObj.callback), 
            delete argObj.callback), listener) for (var _i = 0, _Object$keys = Object.keys(argObj); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                listener[key] = argObj[key];
            }
            return listener;
        }
    } ]), _createClass(EventListener, [ {
        key: "_setPaused",
        value: function _setPaused(paused) {
            this._paused = paused;
        }
    }, {
        key: "_isPaused",
        value: function _isPaused() {
            return this._paused;
        }
    }, {
        key: "_setRegistered",
        value: function _setRegistered(registered) {
            this._registered = registered;
        }
    }, {
        key: "_isRegistered",
        value: function _isRegistered() {
            return this._registered;
        }
    }, {
        key: "_getType",
        value: function _getType() {
            return this._type;
        }
    }, {
        key: "_getListenerID",
        value: function _getListenerID() {
            return this._listenerID;
        }
    }, {
        key: "_setFixedPriority",
        value: function _setFixedPriority(fixedPriority) {
            this._fixedPriority = fixedPriority;
        }
    }, {
        key: "_getFixedPriority",
        value: function _getFixedPriority() {
            return this._fixedPriority;
        }
    }, {
        key: "_setSceneGraphPriority",
        value: function _setSceneGraphPriority(node) {
            this._target = node, this._node = node;
        }
    }, {
        key: "_getSceneGraphPriority",
        value: function _getSceneGraphPriority() {
            return this._node;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return null !== this._onEvent;
        }
    }, {
        key: "clone",
        value: function clone() {
            return null;
        }
    }, {
        key: "setEnabled",
        value: function setEnabled(enabled) {
            this._isEnabled = enabled;
        }
    }, {
        key: "isEnabled",
        value: function isEnabled() {
            return this._isEnabled;
        }
    } ]), EventListener;
}();

EventListener.UNKNOWN = 0, EventListener.TOUCH_ONE_BY_ONE = 1, EventListener.TOUCH_ALL_AT_ONCE = 2, 
EventListener.KEYBOARD = 3, EventListener.MOUSE = 4, EventListener.ACCELERATION = 6, 
EventListener.CUSTOM = 8, EventListener.ListenerID = {
    MOUSE: "__cc_mouse",
    TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
    TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
    KEYBOARD: "__cc_keyboard",
    ACCELERATION: "__cc_acceleration"
};

var ListenerID = EventListener.ListenerID, Mouse = function(_EventListener) {
    function Mouse() {
        var _this;
        return _classCallCheck(this, Mouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mouse).call(this, EventListener.MOUSE, ListenerID.MOUSE, null))).onMouseDown = null, 
        _this.onMouseUp = null, _this.onMouseMove = null, _this.onMouseScroll = null, _this._onEvent = function(event) {
            return _this._callback(event);
        }, _this;
    }
    return _inherits(Mouse, EventListener), _createClass(Mouse, [ {
        key: "_callback",
        value: function _callback(event) {
            var eventType = cc.Event.EventMouse;
            switch (event._eventType) {
              case eventType.DOWN:
                this.onMouseDown && this.onMouseDown(event);
                break;

              case eventType.UP:
                this.onMouseUp && this.onMouseUp(event);
                break;

              case eventType.MOVE:
                this.onMouseMove && this.onMouseMove(event);
                break;

              case eventType.SCROLL:
                this.onMouseScroll && this.onMouseScroll(event);
            }
        }
    }, {
        key: "clone",
        value: function clone() {
            var eventListener = new Mouse();
            return eventListener.onMouseDown = this.onMouseDown, eventListener.onMouseUp = this.onMouseUp, 
            eventListener.onMouseMove = this.onMouseMove, eventListener.onMouseScroll = this.onMouseScroll, 
            eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return !0;
        }
    } ]), Mouse;
}(), TouchOneByOne = function(_EventListener2) {
    function TouchOneByOne() {
        var _this2;
        return _classCallCheck(this, TouchOneByOne), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(TouchOneByOne).call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null))).swallowTouches = !1, 
        _this2.onTouchBegan = null, _this2.onTouchMoved = null, _this2.onTouchEnded = null, 
        _this2.onTouchCancelled = null, _this2._claimedTouches = [], _this2;
    }
    return _inherits(TouchOneByOne, EventListener), _createClass(TouchOneByOne, [ {
        key: "setSwallowTouches",
        value: function setSwallowTouches(needSwallow) {
            this.swallowTouches = needSwallow;
        }
    }, {
        key: "isSwallowTouches",
        value: function isSwallowTouches() {
            return this.swallowTouches;
        }
    }, {
        key: "clone",
        value: function clone() {
            var eventListener = new TouchOneByOne();
            return eventListener.onTouchBegan = this.onTouchBegan, eventListener.onTouchMoved = this.onTouchMoved, 
            eventListener.onTouchEnded = this.onTouchEnded, eventListener.onTouchCancelled = this.onTouchCancelled, 
            eventListener.swallowTouches = this.swallowTouches, eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return !!this.onTouchBegan || (cc.logID(1801), !1);
        }
    } ]), TouchOneByOne;
}(), TouchAllAtOnce = function(_EventListener3) {
    function TouchAllAtOnce() {
        var _this3;
        return _classCallCheck(this, TouchAllAtOnce), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(TouchAllAtOnce).call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null))).onTouchesBegan = null, 
        _this3.onTouchesMoved = null, _this3.onTouchesEnded = null, _this3.onTouchesCancelled = null, 
        _this3;
    }
    return _inherits(TouchAllAtOnce, EventListener), _createClass(TouchAllAtOnce, [ {
        key: "clone",
        value: function clone() {
            var eventListener = new TouchAllAtOnce();
            return eventListener.onTouchesBegan = this.onTouchesBegan, eventListener.onTouchesMoved = this.onTouchesMoved, 
            eventListener.onTouchesEnded = this.onTouchesEnded, eventListener.onTouchesCancelled = this.onTouchesCancelled, 
            eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (cc.logID(1802), 
            !1);
        }
    } ]), TouchAllAtOnce;
}(), Acceleration = function(_EventListener4) {
    function Acceleration(callback) {
        var _this4;
        return _classCallCheck(this, Acceleration), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(Acceleration).call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null)))._onAccelerationEvent = null, 
        _this4._onEvent = function(event) {
            return _this4._callback(event);
        }, _this4._onAccelerationEvent = callback, _this4;
    }
    return _inherits(Acceleration, EventListener), _createClass(Acceleration, [ {
        key: "_callback",
        value: function _callback(event) {
            this._onAccelerationEvent && this._onAccelerationEvent(event.acc, event);
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return cc.assertID(this._onAccelerationEvent, 1803), !0;
        }
    }, {
        key: "clone",
        value: function clone() {
            return new Acceleration(this._onAccelerationEvent);
        }
    } ]), Acceleration;
}(), Keyboard = function(_EventListener5) {
    function Keyboard() {
        var _this5;
        return _classCallCheck(this, Keyboard), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Keyboard).call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null))).onKeyPressed = null, 
        _this5.onKeyReleased = null, _this5._onEvent = function(event) {
            return _this5._callback(event);
        }, _this5;
    }
    return _inherits(Keyboard, EventListener), _createClass(Keyboard, [ {
        key: "_callback",
        value: function _callback(event) {
            event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
        }
    }, {
        key: "clone",
        value: function clone() {
            var eventListener = new Keyboard();
            return eventListener.onKeyPressed = this.onKeyPressed, eventListener.onKeyReleased = this.onKeyReleased, 
            eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return null !== this.onKeyPressed || null !== this.onKeyReleased || (cc.logID(1800), 
            !1);
        }
    } ]), Keyboard;
}();

cc.EventListener = EventListener;

var ListenerID$1 = EventListener.ListenerID;

var _EventListenerVector = function() {
    function _EventListenerVector() {
        _classCallCheck(this, _EventListenerVector), this.gt0Index = 0, this._fixedListeners = [], 
        this._sceneGraphListeners = [];
    }
    return _createClass(_EventListenerVector, [ {
        key: "size",
        value: function size() {
            return this._fixedListeners.length + this._sceneGraphListeners.length;
        }
    }, {
        key: "empty",
        value: function empty() {
            return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
        }
    }, {
        key: "push",
        value: function push(listener) {
            0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
        }
    }, {
        key: "clearSceneGraphListeners",
        value: function clearSceneGraphListeners() {
            this._sceneGraphListeners.length = 0;
        }
    }, {
        key: "clearFixedListeners",
        value: function clearFixedListeners() {
            this._fixedListeners.length = 0;
        }
    }, {
        key: "clear",
        value: function clear() {
            this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0;
        }
    }, {
        key: "getFixedPriorityListeners",
        value: function getFixedPriorityListeners() {
            return this._fixedListeners;
        }
    }, {
        key: "getSceneGraphPriorityListeners",
        value: function getSceneGraphPriorityListeners() {
            return this._sceneGraphListeners;
        }
    } ]), _EventListenerVector;
}();

var eventManager = new (function() {
    function EventManager() {
        _classCallCheck(this, EventManager), this._listenersMap = {}, this._priorityDirtyFlagMap = {}, 
        this._nodeListenersMap = {}, this._toAddedListeners = [], this._toRemovedListeners = [], 
        this._dirtyListeners = [], this._inDispatch = 0, this._isEnabled = !1, this._internalCustomListenerIDs = [];
    }
    return _createClass(EventManager, [ {
        key: "pauseTarget",
        value: function pauseTarget(node) {
            var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (node instanceof cc._BaseNode) {
                var listeners = this._nodeListenersMap[node.uuid];
                if (listeners) for (var i = 0; i < listeners.length; ++i) {
                    var listener = listeners[i];
                    listener._setPaused(!0);
                }
                if (!0 === recursive) {
                    var locChildren = node.children;
                    if (locChildren) for (var _i = 0; _i < locChildren.length; ++_i) {
                        var locChild = locChildren[_i];
                        this.pauseTarget(locChild, !0);
                    }
                }
            } else cc.warnID(3506);
        }
    }, {
        key: "resumeTarget",
        value: function resumeTarget(node) {
            var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (node instanceof cc._BaseNode) {
                var listeners = this._nodeListenersMap[node.uuid];
                if (listeners) for (var i = 0; i < listeners.length; ++i) {
                    var listener = listeners[i];
                    listener._setPaused(!1);
                }
                if (this._setDirtyForNode(node), !0 === recursive && node.children.length > 0) {
                    var locChildren = node.children;
                    if (locChildren) for (var _i2 = 0; _i2 < locChildren.length; ++_i2) {
                        var locChild = locChildren[_i2];
                        this.resumeTarget(locChild, !0);
                    }
                }
            } else cc.warnID(3506);
        }
    }, {
        key: "frameUpdateListeners",
        value: function frameUpdateListeners() {
            var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
            for (var selKey in locListenersMap) locListenersMap[selKey].empty() && (delete locPriorityDirtyFlagMap[selKey], 
            delete locListenersMap[selKey]);
            var locToAddedListeners = this._toAddedListeners;
            if (0 !== locToAddedListeners.length) {
                for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                locToAddedListeners.length = 0;
            }
            0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(listenerID) {
            return !!this._getListeners(listenerID);
        }
    }, {
        key: "addListener",
        value: function addListener(listener, nodeOrPriority) {
            if (cc.assertID(listener && nodeOrPriority, 3503), cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode) {
                if (listener instanceof cc.EventListener) {
                    if (listener._isRegistered()) return void cc.logID(3505);
                } else cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504), listener = cc.EventListener.create(listener);
                if (listener.checkAvailable()) {
                    if (cc.js.isNumber(nodeOrPriority)) {
                        if (0 === nodeOrPriority) return void cc.logID(3500);
                        listener._setSceneGraphPriority(null), listener._setFixedPriority(nodeOrPriority), 
                        listener._setRegistered(!0), listener._setPaused(!1), this._addListener(listener);
                    } else {
                        if (!function checkUINode(node) {
                            for (;node; ) {
                                if (node.getComponent("cc.CanvasComponent")) return !0;
                                node = node.parent;
                            }
                            return !1;
                        }(nodeOrPriority)) return void cc.logID(3512);
                        listener._setSceneGraphPriority(nodeOrPriority), listener._setFixedPriority(0), 
                        listener._setRegistered(!0), this._addListener(listener);
                    }
                    return listener;
                }
            } else cc.warnID(3506);
        }
    }, {
        key: "addCustomListener",
        value: function addCustomListener(eventName, callback) {
            var listener = EventListener.create({
                event: cc.EventListener.CUSTOM,
                eventName: eventName,
                callback: callback
            });
            return this.addListener(listener, 1), listener;
        }
    }, {
        key: "removeListener",
        value: function removeListener(listener) {
            if (null != listener) {
                var isFound = !1, locListener = this._listenersMap;
                for (var selKey in locListener) {
                    var listeners = locListener[selKey], fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    if ((isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener)) ? this._setDirty(listener._getListenerID(), 2) : (isFound = this._removeListenerInVector(fixedPriorityListeners, listener)) && this._setDirty(listener._getListenerID(), 1), 
                    listeners.empty() && (delete this._priorityDirtyFlagMap[listener._getListenerID()], 
                    delete locListener[selKey]), isFound) break;
                }
                if (!isFound) for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; i >= 0; i--) {
                    var selListener = locToAddedListeners[i];
                    if (selListener === listener) {
                        cc.js.array.removeAt(locToAddedListeners, i), selListener._setRegistered(!1);
                        break;
                    }
                }
            }
        }
    }, {
        key: "removeListeners",
        value: function removeListeners(listenerType) {
            var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode) if (void 0 !== listenerType._id) {
                var listeners = this._nodeListenersMap[listenerType._id];
                if (listeners) {
                    for (var listenersCopy = cc.js.array.copy(listeners), i = 0; i < listenersCopy.length; ++i) {
                        var listenerCopy = listenersCopy[i];
                        this.removeListener(listenerCopy);
                    }
                    delete this._nodeListenersMap[listenerType._id];
                }
                for (var locToAddedListeners = this._toAddedListeners, _i3 = 0; _i3 < locToAddedListeners.length; ) {
                    var listener = locToAddedListeners[_i3];
                    listener._getSceneGraphPriority() === listenerType ? (listener._setSceneGraphPriority(null), 
                    listener._setRegistered(!1), locToAddedListeners.splice(_i3, 1)) : ++_i3;
                }
                if (!0 === recursive) for (var locChildren = listenerType.getChildren(), _i4 = 0; _i4 < locChildren.length; ++_i4) {
                    var locChild = locChildren[_i4];
                    this.removeListeners(locChild, !0);
                }
            } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? this._removeListenersForListenerID(ListenerID$1.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(ListenerID$1.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(ListenerID$1.KEYBOARD) : cc.logID(3501); else cc.warnID(3506);
        }
    }, {
        key: "removeCustomListeners",
        value: function removeCustomListeners(customEventName) {
            this._removeListenersForListenerID(customEventName);
        }
    }, {
        key: "removeAllListeners",
        value: function removeAllListeners() {
            var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
            for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
        }
    }, {
        key: "setPriority",
        value: function setPriority(listener, fixedPriority) {
            if (null != listener) {
                var locListeners = this._listenersMap;
                for (var selKey in locListeners) {
                    var fixedPriorityListeners = locListeners[selKey].getFixedPriorityListeners();
                    if (fixedPriorityListeners) if (-1 !== fixedPriorityListeners.indexOf(listener)) return null != listener._getSceneGraphPriority() && cc.logID(3502), 
                    void (listener._getFixedPriority() !== fixedPriority && (listener._setFixedPriority(fixedPriority), 
                    this._setDirty(listener._getListenerID(), 1)));
                }
            }
        }
    }, {
        key: "setEnabled",
        value: function setEnabled(enabled) {
            this._isEnabled = enabled;
        }
    }, {
        key: "isEnabled",
        value: function isEnabled() {
            return this._isEnabled;
        }
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
            if (this._isEnabled) if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, 
            event && event.getType) {
                if (event.getType().startsWith(cc.Event.TOUCH)) return this._dispatchTouchEvent(event), 
                void this._inDispatch--;
                var listenerID = function __getListenerID(event) {
                    var eventType = Event, type = event.type;
                    return type === eventType.ACCELERATION ? ListenerID$1.ACCELERATION : type === eventType.KEYBOARD ? ListenerID$1.KEYBOARD : type.startsWith(eventType.MOUSE) ? ListenerID$1.MOUSE : (type.startsWith(eventType.TOUCH) && cc.logID(2e3), 
                    "");
                }(event);
                this._sortEventListeners(listenerID);
                var selListeners = this._listenersMap[listenerID];
                null != selListeners && (this._dispatchEventToListeners(selListeners, this._onListenerCallback, event), 
                this._onUpdateListeners(selListeners)), this._inDispatch--;
            } else cc.errorID(3511);
        }
    }, {
        key: "_onListenerCallback",
        value: function _onListenerCallback(listener, event) {
            event.currentTarget = listener._target;
            var onEvent = listener.onEvent;
            return onEvent && onEvent(event), event.isStopped();
        }
    }, {
        key: "dispatchCustomEvent",
        value: function dispatchCustomEvent(eventName, optionalUserData) {
            var ev = new cc.Event.EventCustom(eventName);
            ev.setUserData(optionalUserData), this.dispatchEvent(ev);
        }
    }, {
        key: "_setDirtyForNode",
        value: function _setDirtyForNode(node) {
            var selListeners = this._nodeListenersMap[node._id];
            if (void 0 !== selListeners) for (var j = 0, len = selListeners.length; j < len; j++) {
                var listenerID = selListeners[j]._getListenerID();
                null == this._dirtyListeners[listenerID] && (this._dirtyListeners[listenerID] = !0);
            }
            if (node.children.length > 0) for (var _children = node.children, i = 0, _len = _children ? _children.length : 0; i < _len; i++) this._setDirtyForNode(_children[i]);
        }
    }, {
        key: "_addListener",
        value: function _addListener(listener) {
            0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
        }
    }, {
        key: "_forceAddEventListener",
        value: function _forceAddEventListener(listener) {
            var listenerID = listener._getListenerID(), listeners = this._listenersMap[listenerID];
            if (listeners || (listeners = new _EventListenerVector(), this._listenersMap[listenerID] = listeners), 
            listeners.push(listener), 0 === listener._getFixedPriority()) {
                this._setDirty(listenerID, 2);
                var node = listener._getSceneGraphPriority();
                null === node && cc.logID(3507), this._associateNodeAndEventListener(node, listener), 
                node.activeInHierarchy && this.resumeTarget(node);
            } else this._setDirty(listenerID, 1);
        }
    }, {
        key: "_getListeners",
        value: function _getListeners(listenerID) {
            return this._listenersMap[listenerID];
        }
    }, {
        key: "_updateDirtyFlagForSceneGraph",
        value: function _updateDirtyFlagForSceneGraph() {
            var locDirtyListeners = this._dirtyListeners;
            for (var selKey in locDirtyListeners) this._setDirty(selKey, 2);
            this._dirtyListeners.length = 0;
        }
    }, {
        key: "_removeAllListenersInVector",
        value: function _removeAllListenersInVector(listenerVector) {
            if (listenerVector) for (var selListener, i = listenerVector.length - 1; i >= 0; i--) (selListener = listenerVector[i])._setRegistered(!1), 
            null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
            selListener._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.js.array.removeAt(listenerVector, i);
        }
    }, {
        key: "_removeListenersForListenerID",
        value: function _removeListenersForListenerID(listenerID) {
            var listeners = this._listenersMap[listenerID];
            if (listeners) {
                var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                this._removeAllListenersInVector(sceneGraphPriorityListeners), this._removeAllListenersInVector(fixedPriorityListeners), 
                delete this._priorityDirtyFlagMap[listenerID], this._inDispatch || (listeners.clear(), 
                delete this._listenersMap[listenerID]);
            }
            for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; i >= 0; i--) {
                var listener = locToAddedListeners[i];
                listener && listener._getListenerID() === listenerID && cc.js.array.removeAt(locToAddedListeners, i);
            }
        }
    }, {
        key: "_sortEventListeners",
        value: function _sortEventListeners(listenerID) {
            var dirtyFlag = 0, locFlagMap = this._priorityDirtyFlagMap;
            (locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]), 0 !== dirtyFlag) && (locFlagMap[listenerID] = 0, 
            1 & dirtyFlag && this._sortListenersOfFixedPriority(listenerID), 2 & dirtyFlag && cc.director.getScene() && this._sortListenersOfSceneGraphPriority(listenerID));
        }
    }, {
        key: "_sortListenersOfSceneGraphPriority",
        value: function _sortListenersOfSceneGraphPriority(listenerID) {
            var listeners = this._getListeners(listenerID);
            if (listeners) {
                var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                sceneGraphListener && 0 !== sceneGraphListener.length && listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
            }
        }
    }, {
        key: "_sortEventListenersOfSceneGraphPriorityDes",
        value: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
            var node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
            if (!(l2 && node2 && node2._activeInHierarchy)) return -1;
            if (!l1 || !node1 || !node1._activeInHierarchy) return 1;
            for (var p1 = node1, p2 = node2, ex = !1; p1.parent._id !== p2.parent._id; ) p1 = null === p1.parent.parent ? (ex = !0) && node2 : p1.parent, 
            p2 = null === p2.parent.parent ? (ex = !0) && node1 : p2.parent;
            if (p1._id === p2._id) {
                if (p1._id === node2._id) return -1;
                if (p1._id === node1._id) return 1;
            }
            var priority1 = p1.getSiblingIndex(), priority2 = p2.getSiblingIndex();
            return ex ? priority1 - priority2 : priority2 - priority1;
        }
    }, {
        key: "_sortListenersOfFixedPriority",
        value: function _sortListenersOfFixedPriority(listenerID) {
            var listeners = this._listenersMap[listenerID];
            if (listeners) {
                var fixedListeners = listeners.getFixedPriorityListeners();
                if (fixedListeners && 0 !== fixedListeners.length) {
                    fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                    for (var index = 0, len = fixedListeners.length; index < len && !(fixedListeners[index]._getFixedPriority() >= 0); ) ++index;
                    listeners.gt0Index = index;
                }
            }
        }
    }, {
        key: "_sortListenersOfFixedPriorityAsc",
        value: function _sortListenersOfFixedPriorityAsc(l1, l2) {
            return l1._getFixedPriority() - l2._getFixedPriority();
        }
    }, {
        key: "_onUpdateListeners",
        value: function _onUpdateListeners(listeners) {
            var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), toRemovedListeners = this._toRemovedListeners;
            if (sceneGraphPriorityListeners) for (var i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
                var selListener = sceneGraphPriorityListeners[i];
                if (!selListener._isRegistered()) {
                    cc.js.array.removeAt(sceneGraphPriorityListeners, i);
                    var idx = toRemovedListeners.indexOf(selListener);
                    -1 !== idx && toRemovedListeners.splice(idx, 1);
                }
            }
            if (fixedPriorityListeners) for (var _i5 = fixedPriorityListeners.length - 1; _i5 >= 0; _i5--) {
                var _selListener = fixedPriorityListeners[_i5];
                if (!_selListener._isRegistered()) {
                    cc.js.array.removeAt(fixedPriorityListeners, _i5);
                    var _idx = toRemovedListeners.indexOf(_selListener);
                    -1 !== _idx && toRemovedListeners.splice(_idx, 1);
                }
            }
            sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners(), 
            fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
        }
    }, {
        key: "_updateTouchListeners",
        value: function _updateTouchListeners(event) {
            var locInDispatch = this._inDispatch;
            if (cc.assertID(locInDispatch > 0, 3508), !(locInDispatch > 1)) {
                var listeners;
                (listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE]) && this._onUpdateListeners(listeners), 
                (listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE]) && this._onUpdateListeners(listeners), 
                cc.assertID(1 === locInDispatch, 3509);
                var locToAddedListeners = this._toAddedListeners;
                if (0 !== locToAddedListeners.length) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                    this._toAddedListeners.length = 0;
                }
                0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
            }
        }
    }, {
        key: "_cleanToRemovedListeners",
        value: function _cleanToRemovedListeners() {
            for (var toRemovedListeners = this._toRemovedListeners, i = 0; i < toRemovedListeners.length; ++i) {
                var selListener = toRemovedListeners[i], listeners = this._listenersMap[selListener._getListenerID()];
                if (listeners) {
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    if (sceneGraphPriorityListeners) {
                        var idx = sceneGraphPriorityListeners.indexOf(selListener);
                        -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
                    }
                    if (fixedPriorityListeners) {
                        var _idx2 = fixedPriorityListeners.indexOf(selListener);
                        -1 !== _idx2 && fixedPriorityListeners.splice(_idx2, 1);
                    }
                }
            }
            toRemovedListeners.length = 0;
        }
    }, {
        key: "_onTouchEventCallback",
        value: function _onTouchEventCallback(listener, argsObj) {
            if (!listener._isRegistered()) return !1;
            var event = argsObj.event, selTouch = event.currentTouch;
            event.currentTarget = listener._getSceneGraphPriority();
            var removedIdx, isClaimed = !1, getCode = event.getEventCode();
            return getCode === EventTouch.BEGAN ? listener.onTouchBegan && (isClaimed = listener.onTouchBegan(selTouch, event)) && listener._isRegistered() && listener._claimedTouches.push(selTouch) : listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch)) && (isClaimed = !0, 
            getCode === EventTouch.MOVED && listener.onTouchMoved ? listener.onTouchMoved(selTouch, event) : getCode === EventTouch.ENDED ? (listener.onTouchEnded && listener.onTouchEnded(selTouch, event), 
            listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1)) : getCode === EventTouch.CANCELLED && (listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event), 
            listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1))), event.isStopped() ? (eventManager._updateTouchListeners(event), 
            !0) : !!(isClaimed && listener._isRegistered() && listener.swallowTouches) && (argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1), 
            !0);
        }
    }, {
        key: "_dispatchTouchEvent",
        value: function _dispatchTouchEvent(event) {
            this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE), this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
            var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE), allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
            if (null !== oneByOneListeners || null !== allAtOnceListeners) {
                var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches), oneByOneArgsObj = {
                    event: event,
                    needsMutableSet: oneByOneListeners && allAtOnceListeners,
                    touches: mutableTouches,
                    selTouch: null
                };
                if (oneByOneListeners) for (var i = 0; i < originalTouches.length; ++i) {
                    var originalTouch = originalTouches[i];
                    event.currentTouch = originalTouch, event.propagationStopped = event.propagationImmediateStopped = !1, 
                    this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                }
                allAtOnceListeners && mutableTouches.length > 0 && (this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                    event: event,
                    touches: mutableTouches
                }), event.isStopped()) || this._updateTouchListeners(event);
            }
        }
    }, {
        key: "_onTouchesEventCallback",
        value: function _onTouchesEventCallback(listener, callbackParams) {
            if (!listener._isRegistered()) return !1;
            var event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
            return event.currentTarget = listener._getSceneGraphPriority(), getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event), 
            !!event.isStopped() && (eventManager._updateTouchListeners(event), !0);
        }
    }, {
        key: "_associateNodeAndEventListener",
        value: function _associateNodeAndEventListener(node, listener) {
            var listeners = this._nodeListenersMap[node.uuid];
            listeners || (listeners = [], this._nodeListenersMap[node.uuid] = listeners), listeners.push(listener);
        }
    }, {
        key: "_dissociateNodeAndEventListener",
        value: function _dissociateNodeAndEventListener(node, listener) {
            var listeners = this._nodeListenersMap[node.uuid];
            listeners && (cc.js.array.remove(listeners, listener), 0 === listeners.length && delete this._nodeListenersMap[node.uuid]);
        }
    }, {
        key: "_dispatchEventToListeners",
        value: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
            var shouldStopPropagation = !1, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), i = 0;
            if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
                var selListener = fixedPriorityListeners[i];
                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                    shouldStopPropagation = !0;
                    break;
                }
            }
            if (sceneGraphPriorityListeners && !shouldStopPropagation) for (var _i6 = 0; _i6 < sceneGraphPriorityListeners.length; ++_i6) {
                var _selListener2 = sceneGraphPriorityListeners[_i6];
                if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
                    shouldStopPropagation = !0;
                    break;
                }
            }
            if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
                var _selListener3 = fixedPriorityListeners[i];
                if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
                    shouldStopPropagation = !0;
                    break;
                }
            }
        }
    }, {
        key: "_setDirty",
        value: function _setDirty(listenerID, flag) {
            var locDirtyFlagMap = this._priorityDirtyFlagMap;
            null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
        }
    }, {
        key: "_sortNumberAsc",
        value: function _sortNumberAsc(a, b) {
            return a - b;
        }
    }, {
        key: "_removeListenerInCallback",
        value: function _removeListenerInCallback(listeners, callback) {
            if (null == listeners) return !1;
            for (var i = listeners.length - 1; i >= 0; i--) {
                var selListener = listeners[i];
                if (selListener._onCustomEvent === callback || selListener.onEvent === callback) return selListener._setRegistered(!1), 
                null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                !0;
            }
            return !1;
        }
    }, {
        key: "_removeListenerInVector",
        value: function _removeListenerInVector(listeners, listener) {
            if (null == listeners) return !1;
            for (var i = listeners.length - 1; i >= 0; i--) {
                var selListener = listeners[i];
                if (selListener === listener) return selListener._setRegistered(!1), null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                !0;
            }
            return !1;
        }
    } ]), EventManager;
}())();

cc.eventManager = eventManager;

var macro = {
    SUPPORT_TEXTURE_FORMATS: [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ],
    KEY: {
        none: 0,
        back: 6,
        menu: 18,
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        select: 41,
        insert: 45,
        Delete: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        num0: 96,
        num1: 97,
        num2: 98,
        num3: 99,
        num4: 100,
        num5: 101,
        num6: 102,
        num7: 103,
        num8: 104,
        num9: 105,
        "*": 106,
        "+": 107,
        "-": 109,
        numdel: 110,
        "/": 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        ";": 186,
        semicolon: 186,
        equal: 187,
        "=": 187,
        ",": 188,
        comma: 188,
        dash: 189,
        ".": 190,
        period: 190,
        forwardslash: 191,
        grave: 192,
        "[": 219,
        openbracket: 219,
        backslash: 220,
        "]": 221,
        closebracket: 221,
        quote: 222,
        dpadLeft: 1e3,
        dpadRight: 1001,
        dpadUp: 1003,
        dpadDown: 1004,
        dpadCenter: 1005
    },
    ImageFormat: cc.Enum({
        JPG: 0,
        PNG: 1,
        TIFF: 2,
        WEBP: 3,
        PVR: 4,
        ETC: 5,
        S3TC: 6,
        ATITC: 7,
        TGA: 8,
        RAWDATA: 9,
        UNKNOWN: 10
    }),
    RAD: Math.PI / 180,
    DEG: 180 / Math.PI,
    REPEAT_FOREVER: Number.MAX_VALUE - 1,
    FLT_EPSILON: 1.192092896e-7,
    MIN_ZINDEX: -Math.pow(2, 15),
    MAX_ZINDEX: Math.pow(2, 15) - 1,
    ORIENTATION_PORTRAIT: 1,
    ORIENTATION_LANDSCAPE: 2,
    ORIENTATION_AUTO: 3,
    DENSITYDPI_DEVICE: "device-dpi",
    DENSITYDPI_HIGH: "high-dpi",
    DENSITYDPI_MEDIUM: "medium-dpi",
    DENSITYDPI_LOW: "low-dpi",
    FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: !0,
    DIRECTOR_STATS_POSITION: new Vec2(0, 0),
    ENABLE_STACKABLE_ACTIONS: !0,
    TOUCH_TIMEOUT: 5e3,
    BATCH_VERTEX_COUNT: 2e4,
    ENABLE_TILEDMAP_CULLING: !0,
    DOWNLOAD_MAX_CONCURRENT: 64,
    ENABLE_TRANSPARENT_CANVAS: !1,
    ENABLE_WEBGL_ANTIALIAS: !1,
    ENABLE_CULLING: !1,
    CLEANUP_IMAGE_CACHE: !1,
    SHOW_MESH_WIREFRAME: !1
};

cc.macro = macro;

var buffer, sys = {};

sys.LANGUAGE_ENGLISH = "en", sys.LANGUAGE_CHINESE = "zh", sys.LANGUAGE_FRENCH = "fr", 
sys.LANGUAGE_ITALIAN = "it", sys.LANGUAGE_GERMAN = "de", sys.LANGUAGE_SPANISH = "es", 
sys.LANGUAGE_DUTCH = "du", sys.LANGUAGE_RUSSIAN = "ru", sys.LANGUAGE_KOREAN = "ko", 
sys.LANGUAGE_JAPANESE = "ja", sys.LANGUAGE_HUNGARIAN = "hu", sys.LANGUAGE_PORTUGUESE = "pt", 
sys.LANGUAGE_ARABIC = "ar", sys.LANGUAGE_NORWEGIAN = "no", sys.LANGUAGE_POLISH = "pl", 
sys.LANGUAGE_TURKISH = "tr", sys.LANGUAGE_UKRAINIAN = "uk", sys.LANGUAGE_ROMANIAN = "ro", 
sys.LANGUAGE_BULGARIAN = "bg", sys.LANGUAGE_UNKNOWN = "unknown", sys.OS_IOS = "iOS", 
sys.OS_ANDROID = "Android", sys.OS_WINDOWS = "Windows", sys.OS_MARMALADE = "Marmalade", 
sys.OS_LINUX = "Linux", sys.OS_BADA = "Bada", sys.OS_BLACKBERRY = "Blackberry", 
sys.OS_OSX = "OS X", sys.OS_WP8 = "WP8", sys.OS_WINRT = "WINRT", sys.OS_UNKNOWN = "Unknown", 
sys.UNKNOWN = -1, sys.WIN32 = 0, sys.LINUX = 1, sys.MACOS = 2, sys.ANDROID = 3, 
sys.IPHONE = 4, sys.IPAD = 5, sys.BLACKBERRY = 6, sys.NACL = 7, sys.EMSCRIPTEN = 8, 
sys.TIZEN = 9, sys.WINRT = 10, sys.WP8 = 11, sys.MOBILE_BROWSER = 100, sys.DESKTOP_BROWSER = 101, 
sys.EDITOR_PAGE = 102, sys.EDITOR_CORE = 103, sys.WECHAT_GAME = 104, sys.QQ_PLAY = 105, 
sys.BROWSER_TYPE_WECHAT = "wechat", sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame", 
sys.BROWSER_TYPE_WECHAT_GAME_SUB = "wechatgamesub", sys.BROWSER_TYPE_QQ_PLAY = "qqplay", 
sys.BROWSER_TYPE_ANDROID = "androidbrowser", sys.BROWSER_TYPE_IE = "ie", sys.BROWSER_TYPE_QQ = "qqbrowser", 
sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", sys.BROWSER_TYPE_UC = "ucbrowser", sys.BROWSER_TYPE_UCBS = "ucbs", 
sys.BROWSER_TYPE_360 = "360browser", sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", 
sys.BROWSER_TYPE_BAIDU = "baidubrowser", sys.BROWSER_TYPE_MAXTHON = "maxthon", sys.BROWSER_TYPE_OPERA = "opera", 
sys.BROWSER_TYPE_OUPENG = "oupeng", sys.BROWSER_TYPE_MIUI = "miuibrowser", sys.BROWSER_TYPE_FIREFOX = "firefox", 
sys.BROWSER_TYPE_SAFARI = "safari", sys.BROWSER_TYPE_CHROME = "chrome", sys.BROWSER_TYPE_LIEBAO = "liebao", 
sys.BROWSER_TYPE_QZONE = "qzone", sys.BROWSER_TYPE_SOUGOU = "sogou", sys.BROWSER_TYPE_UNKNOWN = "unknown", 
sys.isNative = !1, sys.isBrowser = "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "object" === ("undefined" == typeof document ? "undefined" : _typeof(document)) && !0, 
sys.isLittleEndian = (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
256 === new Int16Array(buffer)[0]);

var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement, ua = nav.userAgent.toLowerCase();

sys.isMobile = /mobile|android|iphone|ipad/.test(ua), sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;

var currLanguage = nav.language;

currLanguage = (currLanguage = currLanguage || nav.browserLanguage) ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH, 
sys.language = currLanguage;

var isAndroid = !1, iOS = !1, osVersion = "", osMainVersion = 0, uaResult = /android (\d+(?:\.\d+)+)/i.exec(ua) || /android (\d+(?:\.\d+)+)/i.exec(nav.platform);

uaResult && (isAndroid = !0, osVersion = uaResult[1] || "", osMainVersion = parseInt(osVersion) || 0), 
(uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua)) ? (iOS = !0, osVersion = uaResult[2] || "", 
osMainVersion = parseInt(osVersion) || 0) : /(iPhone|iPad|iPod)/.exec(nav.platform) && (iOS = !0, 
osVersion = "", osMainVersion = 0);

var osName = sys.OS_UNKNOWN;

-1 !== nav.appVersion.indexOf("Win") ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : -1 !== nav.appVersion.indexOf("Mac") ? osName = sys.OS_OSX : -1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux") ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : -1 === nav.appVersion.indexOf("Linux") && -1 === ua.indexOf("ubuntu") || (osName = sys.OS_LINUX), 
sys.os = osName, sys.osVersion = osVersion, sys.osMainVersion = osMainVersion, sys.browserType = sys.BROWSER_TYPE_UNKNOWN, 
function() {
    var browserTypes = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i.exec(ua);
    browserTypes || (browserTypes = /qqbrowser|ucbrowser/i.exec(ua)), browserTypes || (browserTypes = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i.exec(ua));
    var browserType = browserTypes ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN;
    "micromessenger" === browserType ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid ? browserType = sys.BROWSER_TYPE_ANDROID : "qq" === browserType && ua.match(/android.*applewebkit/i) ? browserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr/" === browserType && (browserType = sys.BROWSER_TYPE_OPERA), 
    sys.browserType = browserType;
}(), sys.browserVersion = "", (tmp = ua.match(/(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui)(mobile)?(browser)?\/?([\d.]+)/i)) || (tmp = ua.match(/(qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i)), 
sys.browserVersion = tmp ? tmp[4] : "";

var _w3 = window.innerWidth || document.documentElement.clientWidth, _h3 = window.innerHeight || document.documentElement.clientHeight, _ratio3 = window.devicePixelRatio || 1;

sys.windowPixelResolution = {
    width: _ratio3 * _w3,
    height: _ratio3 * _h3
}, sys._checkWebGLRenderMode = function() {
    if (cc.game.renderType !== cc.game.RENDER_TYPE_WEBGL) throw new Error("This feature supports WebGL render mode only.");
};

var _tmpCanvas1 = document.createElement("canvas");

try {
    var localStorage = sys.localStorage = win.localStorage;
    localStorage.setItem("storage", ""), localStorage.removeItem("storage"), localStorage = null;
} catch (e) {
    var warn$1 = function warn() {
        cc.warnID(5200);
    };
    sys.localStorage = {
        getItem: warn$1,
        setItem: warn$1,
        removeItem: warn$1,
        clear: warn$1
    };
}

var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp"), _supportCanvas = !!_tmpCanvas1.getContext("2d"), _supportWebGL = !1;

if (sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME) _supportWebGL = !0; else if (win.WebGLRenderingContext && (function create3DContext(canvas, opt_attribs, opt_contextType) {
    if (!opt_contextType) return create3DContext(canvas, opt_attribs, "webgl") || create3DContext(canvas, opt_attribs, "experimental-webgl") || create3DContext(canvas, opt_attribs, "webkit-3d") || create3DContext(canvas, opt_attribs, "moz-webgl") || null;
    try {
        return canvas.getContext(opt_contextType, opt_attribs);
    } catch (e) {
        return null;
    }
}(document.createElement("CANVAS")) && (_supportWebGL = !0), _supportWebGL && sys.os === sys.OS_ANDROID)) {
    var browserVer = parseFloat(sys.browserVersion);
    switch (sys.browserType) {
      case sys.BROWSER_TYPE_MOBILE_QQ:
      case sys.BROWSER_TYPE_BAIDU:
      case sys.BROWSER_TYPE_BAIDU_APP:
        _supportWebGL = browserVer >= 6.2;
        break;

      case sys.BROWSER_TYPE_ANDROID:
        sys.osMainVersion && sys.osMainVersion >= 5 && (_supportWebGL = !0);
        break;

      case sys.BROWSER_TYPE_CHROME:
        _supportWebGL = browserVer >= 30;
        break;

      case sys.BROWSER_TYPE_UC:
        _supportWebGL = browserVer > 11;
        break;

      case sys.BROWSER_TYPE_360:
        _supportWebGL = !1;
    }
}

var __audioSupport, _capabilities = sys.capabilities = {
    canvas: _supportCanvas,
    opengl: _supportWebGL,
    webp: _supportWebp
};

(void 0 !== docEle.ontouchstart || void 0 !== doc.ontouchstart || nav.msPointerEnabled) && (_capabilities.touches = !0), 
void 0 !== docEle.onmouseup && (_capabilities.mouse = !0), void 0 !== docEle.onkeyup && (_capabilities.keyboard = !0), 
(win.DeviceMotionEvent || win.DeviceOrientationEvent) && (_capabilities.accelerometer = !0), 
supportWebAudio = sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME && !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext), 
__audioSupport = {
    ONLY_ONE: !1,
    WEB_AUDIO: supportWebAudio,
    DELAY_CREATE_CTX: !1
}, sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata"), 
sys.browserType === sys.BROWSER_TYPE_FIREFOX && (__audioSupport.DELAY_CREATE_CTX = !0, 
__audioSupport.USE_LOADER_EVENT = "canplay"), sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = !0);

try {
    __audioSupport.WEB_AUDIO && (__audioSupport._context = null, Object.defineProperty(__audioSupport, "context", {
        get: function get() {
            return this._context ? this._context : this._context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
        }
    }));
} catch (error) {
    __audioSupport.WEB_AUDIO = !1, cc.logID(5201);
}

var audio, supportWebAudio, tmp, formatSupport = [];

(audio = document.createElement("audio")).canPlayType && (audio.canPlayType('audio/ogg; codecs="vorbis"') && formatSupport.push(".ogg"), 
audio.canPlayType("audio/mpeg") && formatSupport.push(".mp3"), audio.canPlayType('audio/wav; codecs="1"') && formatSupport.push(".wav"), 
audio.canPlayType("audio/mp4") && formatSupport.push(".mp4"), audio.canPlayType("audio/x-m4a") && formatSupport.push(".m4a")), 
__audioSupport.format = formatSupport, sys.__audioSupport = __audioSupport, sys.NetworkType = {
    NONE: 0,
    LAN: 1,
    WWAN: 2
}, sys.getNetworkType = function() {
    return sys.NetworkType.LAN;
}, sys.getBatteryLevel = function() {
    return 1;
}, sys.garbageCollect = function() {}, sys.dumpRoot = function() {}, sys.restartVM = function() {}, 
sys.cleanScript = function(jsfile) {}, sys.isObjectValid = function(obj) {
    return !!obj;
}, sys.dump = function() {
    var str = "";
    str += "isMobile : " + this.isMobile + "\r\n", str += "language : " + this.language + "\r\n", 
    str += "browserType : " + this.browserType + "\r\n", str += "browserVersion : " + this.browserVersion + "\r\n", 
    str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", str += "os : " + this.os + "\r\n", 
    str += "osVersion : " + this.osVersion + "\r\n", str += "platform : " + this.platform + "\r\n", 
    str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n", 
    cc.log(str);
}, sys.openURL = function(url) {
    window.open(url);
}, sys.now = function() {
    return Date.now ? Date.now() : +new Date();
}, cc.sys = sys;

var _vec2 = new Vec2(), Touch = function() {
    function Touch(x, y) {
        var id = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        _classCallCheck(this, Touch), this._point = new Vec2(), this._prevPoint = new Vec2(), 
        this._lastModified = 0, this._id = null, this._startPoint = new Vec2(), this._startPointCaptured = !1, 
        this.setTouchInfo(id, x, y);
    }
    return _createClass(Touch, [ {
        key: "getLocation",
        value: function getLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._point.x, this._point.y), out;
        }
    }, {
        key: "getLocationX",
        value: function getLocationX() {
            return this._point.x;
        }
    }, {
        key: "getLocationY",
        value: function getLocationY() {
            return this._point.y;
        }
    }, {
        key: "getUILocation",
        value: function getUILocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._point.x, this._point.y), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "getUILocationX",
        value: function getUILocationX() {
            var viewport = cc.view.getViewportRect();
            return (this._point.x - viewport.x) / cc.view.getScaleX();
        }
    }, {
        key: "getUILocationY",
        value: function getUILocationY() {
            var viewport = cc.view.getViewportRect();
            return (this._point.y - viewport.y) / cc.view.getScaleY();
        }
    }, {
        key: "getPreviousLocation",
        value: function getPreviousLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._prevPoint.x, this._prevPoint.y), 
            out;
        }
    }, {
        key: "getUIPreviousLocation",
        value: function getUIPreviousLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._prevPoint.x, this._prevPoint.y), 
            cc.view._convertPointWithScale(out), out;
        }
    }, {
        key: "getStartLocation",
        value: function getStartLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._startPoint.x, this._startPoint.y), 
            out;
        }
    }, {
        key: "getUIStartLocation",
        value: function getUIStartLocation(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._startPoint.x, this._startPoint.y), 
            cc.view._convertPointWithScale(out), out;
        }
    }, {
        key: "getDelta",
        value: function getDelta(out) {
            return out || (out = new Vec2()), out.set(this._point), out.subtract(this._prevPoint), 
            out;
        }
    }, {
        key: "getUIDelta",
        value: function getUIDelta(out) {
            return out || (out = new Vec2()), _vec2.set(this._point), _vec2.subtract(this._prevPoint), 
            Vec2.set(out, cc.view.getScaleX(), cc.view.getScaleY()), Vec2.divide(out, _vec2, out), 
            out;
        }
    }, {
        key: "getLocationInView",
        value: function getLocationInView(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._point.x, cc.view._designResolutionSize.height - this._point.y), 
            out;
        }
    }, {
        key: "getPreviousLocationInView",
        value: function getPreviousLocationInView(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y), 
            out;
        }
    }, {
        key: "getStartLocationInView",
        value: function getStartLocationInView(out) {
            return out || (out = new Vec2()), Vec2.set(out, this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y), 
            out;
        }
    }, {
        key: "getID",
        value: function getID() {
            return this._id;
        }
    }, {
        key: "setTouchInfo",
        value: function setTouchInfo() {
            var id = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, x = arguments.length > 1 ? arguments[1] : void 0, y = arguments.length > 2 ? arguments[2] : void 0;
            this._prevPoint = this._point, this._point = new Vec2(x || 0, y || 0), this._id = id, 
            this._startPointCaptured || (this._startPoint = new Vec2(this._point), this._startPointCaptured = !0);
        }
    }, {
        key: "_setPoint",
        value: function _setPoint(x, y) {
            "object" === _typeof(x) ? (this._point.x = x.x, this._point.y = x.y) : (this._point.x = x || 0, 
            this._point.y = y || 0);
        }
    }, {
        key: "_setPrevPoint",
        value: function _setPrevPoint(x, y) {
            "object" === _typeof(x) ? this._prevPoint = new Vec2(x.x, x.y) : this._prevPoint = new Vec2(x || 0, y || 0);
        }
    } ]), Touch;
}();

cc.Touch = Touch;

var _didAccelerateFun, SystemEventType, TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT, _vec2$1 = new Vec2(), _preLocation = new Vec2(), Acceleration$1 = function Acceleration() {
    var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, timestamp = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    _classCallCheck(this, Acceleration), this.x = void 0, this.y = void 0, this.z = void 0, 
    this.timestamp = void 0, this.x = x, this.y = y, this.z = z, this.timestamp = timestamp;
}, inputManager = new (function() {
    function InputManager() {
        _classCallCheck(this, InputManager), this._mousePressed = !1, this._isRegisterEvent = !1, 
        this._preTouchPoint = new Vec2(), this._prevMousePoint = new Vec2(), this._preTouchPool = [], 
        this._preTouchPoolPointer = 0, this._touches = [], this._touchesIntegerDict = {}, 
        this._indexBitsUsed = 0, this._maxTouches = 8, this._accelEnabled = !1, this._accelInterval = .2, 
        this._accelMinus = 1, this._accelCurTime = 0, this._acceleration = null, this._accelDeviceEvent = null, 
        this._glView = null, this._minus = 0, this._pointLocked = !1;
    }
    return _createClass(InputManager, [ {
        key: "handleTouchesBegin",
        value: function handleTouchesBegin(touches) {
            for (var handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now(), i = 0; i < touches.length; ++i) {
                var touch = touches[i], touchID = touch.getID();
                if (null !== touchID) if (void 0 === locTouchIntDict[touchID]) {
                    var unusedIndex = this._getUnUsedIndex();
                    if (-1 === unusedIndex) {
                        cc.logID(2300, unusedIndex);
                        continue;
                    }
                    var curTouch = new Touch(touch._point.x, touch._point.y, touch.getID());
                    this._touches[unusedIndex] = curTouch, curTouch._lastModified = now, curTouch._setPrevPoint(touch._prevPoint), 
                    locTouchIntDict[touchID] = unusedIndex, handleTouches.push(curTouch);
                }
            }
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches);
                touchEvent._eventCode = EventTouch.BEGAN, eventManager.dispatchEvent(touchEvent);
            }
        }
    }, {
        key: "handleTouchesMove",
        value: function handleTouchesMove(touches) {
            for (var handleTouches = [], locTouches = this._touches, now = sys.now(), i = 0; i < touches.length; ++i) {
                var touch = touches[i], touchID = touch.getID();
                if (null !== touchID) {
                    var _index2 = this._touchesIntegerDict[touchID];
                    void 0 !== _index2 && locTouches[_index2] && (locTouches[_index2]._setPoint(touch._point), 
                    locTouches[_index2]._setPrevPoint(touch._prevPoint), locTouches[_index2]._lastModified = now, 
                    handleTouches.push(locTouches[_index2]));
                }
            }
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches);
                touchEvent._eventCode = EventTouch.MOVED, eventManager.dispatchEvent(touchEvent);
            }
        }
    }, {
        key: "handleTouchesEnd",
        value: function handleTouchesEnd(touches) {
            var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches);
                touchEvent._eventCode = EventTouch.ENDED, eventManager.dispatchEvent(touchEvent);
            }
            this._preTouchPool.length = 0;
        }
    }, {
        key: "handleTouchesCancel",
        value: function handleTouchesCancel(touches) {
            var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches);
                touchEvent._eventCode = EventTouch.CANCELLED, eventManager.dispatchEvent(touchEvent);
            }
            this._preTouchPool.length = 0;
        }
    }, {
        key: "getSetOfTouchesEndOrCancel",
        value: function getSetOfTouchesEndOrCancel(touches) {
            for (var handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict, i = 0; i < touches.length; ++i) {
                var touch = touches[i], touchID = touch.getID();
                if (null !== touchID) {
                    var _index3 = locTouchesIntDict[touchID];
                    void 0 !== _index3 && locTouches[_index3] && (locTouches[_index3]._setPoint(touch._point), 
                    locTouches[_index3]._setPrevPoint(touch._prevPoint), handleTouches.push(locTouches[_index3]), 
                    this._removeUsedIndexBit(_index3), delete locTouchesIntDict[touchID]);
                }
            }
            return handleTouches;
        }
    }, {
        key: "getHTMLElementPosition",
        value: function getHTMLElementPosition(element) {
            if (sys.platform === sys.WECHAT_GAME) return {
                left: 0,
                top: 0,
                width: window.innerWidth,
                height: window.innerHeight
            };
            var docElem = document.documentElement, leftOffset = window.pageXOffset - docElem.clientLeft, topOffset = window.pageYOffset - docElem.clientTop;
            if (element.getBoundingClientRect) {
                var box = element.getBoundingClientRect();
                return {
                    left: box.left + leftOffset,
                    top: box.top + topOffset,
                    width: box.width,
                    height: box.height
                };
            }
            return element instanceof HTMLCanvasElement ? {
                left: leftOffset,
                top: topOffset,
                width: element.width,
                height: element.height
            } : {
                left: leftOffset,
                top: topOffset,
                width: parseInt(element.style.width || "0", void 0),
                height: parseInt(element.style.height || "0", void 0)
            };
        }
    }, {
        key: "getPreTouch",
        value: function getPreTouch(touch) {
            for (var preTouch = null, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
                preTouch = locPreTouchPool[i];
                break;
            }
            return preTouch || (preTouch = touch), preTouch;
        }
    }, {
        key: "setPreTouch",
        value: function setPreTouch(touch) {
            for (var find = !1, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
                locPreTouchPool[i] = touch, find = !0;
                break;
            }
            find || (locPreTouchPool.length <= 50 ? locPreTouchPool.push(touch) : (locPreTouchPool[this._preTouchPoolPointer] = touch, 
            this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50));
        }
    }, {
        key: "getTouchByXY",
        value: function getTouchByXY(event, tx, ty, pos) {
            var locPreTouch = this._preTouchPoint, location = this._glView.convertToLocationInView(tx, ty, pos);
            this._pointLocked && (location.x = locPreTouch.x + event.movementX, location.y = locPreTouch.y - event.movementY);
            var touch = new Touch(location.x, location.y, 0);
            return touch._setPrevPoint(locPreTouch.x, locPreTouch.y), locPreTouch.x = location.x, 
            locPreTouch.y = location.y, touch;
        }
    }, {
        key: "getMouseEvent",
        value: function getMouseEvent(location, pos, eventType) {
            var locPreMouse = this._prevMousePoint, mouseEvent = new EventMouse(eventType);
            return mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y), locPreMouse.x = location.x, 
            locPreMouse.y = location.y, this._glView._convertMouseToLocation(locPreMouse, pos), 
            mouseEvent.setLocation(locPreMouse.x, locPreMouse.y), mouseEvent;
        }
    }, {
        key: "getPointByEvent",
        value: function getPointByEvent(event, pos) {
            return null != event.pageX ? {
                x: event.pageX,
                y: event.pageY
            } : (sys.platform === sys.WECHAT_GAME ? (pos.left = 0, pos.top = 0) : (pos.left -= document.body.scrollLeft, 
            pos.top -= document.body.scrollTop), {
                x: event.clientX,
                y: event.clientY
            });
        }
    }, {
        key: "getTouchesByEvent",
        value: function getTouchesByEvent(event, position) {
            for (var touches = [], locView = this._glView, locPreTouch = this._preTouchPoint, length = event.changedTouches.length, i = 0; i < length; i++) {
                var changedTouch = event.changedTouches[i];
                if (changedTouch) {
                    var _location = void 0;
                    _location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(changedTouch.pageX, changedTouch.pageY, position, _vec2$1) : locView.convertToLocationInView(changedTouch.clientX, changedTouch.clientY, position, _vec2$1);
                    var touch = void 0;
                    null != changedTouch.identifier ? (touch = new Touch(_location.x, _location.y, changedTouch.identifier), 
                    this.getPreTouch(touch).getLocation(_preLocation), touch._setPrevPoint(_preLocation.x, _preLocation.y), 
                    this.setPreTouch(touch)) : (touch = new Touch(_location.x, _location.y))._setPrevPoint(locPreTouch.x, locPreTouch.y), 
                    locPreTouch.x = _location.x, locPreTouch.y = _location.y, touches.push(touch);
                }
            }
            return touches;
        }
    }, {
        key: "registerSystemEvent",
        value: function registerSystemEvent(element) {
            if (!this._isRegisterEvent) {
                this._glView = cc.view;
                var prohibition = sys.isMobile, supportMouse = "mouse" in sys.capabilities, supportTouches = "touches" in sys.capabilities;
                sys.platform === sys.WECHAT_GAME && (prohibition = !1, supportTouches = !0, supportMouse = !1), 
                supportMouse && this._registerMouseEvents(element, prohibition), window.navigator.msPointerEnabled && this._registerMousePointerEvents(element), 
                supportTouches && this._registerTouchEvents(element), cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent(), 
                this._isRegisterEvent = !0;
            }
        }
    }, {
        key: "setAccelerometerEnabled",
        value: function setAccelerometerEnabled(isEnable) {
            if (this._accelEnabled !== isEnable) {
                this._accelEnabled = isEnable;
                var scheduler = cc.director.getScheduler();
                scheduler.enableForTarget(this), this._accelEnabled ? (this._registerAccelerometerEvent(), 
                this._accelCurTime = 0, scheduler.scheduleUpdate(this)) : (this._unregisterAccelerometerEvent(), 
                this._accelCurTime = 0, scheduler.unscheduleUpdate(this));
            }
        }
    }, {
        key: "didAccelerate",
        value: function didAccelerate(eventData) {
            if (this._accelEnabled) {
                var mAcceleration = this._acceleration, x = 0, y = 0, z = 0;
                if (this._accelDeviceEvent === window.DeviceMotionEvent) {
                    var eventAcceleration = eventData.accelerationIncludingGravity;
                    eventAcceleration && (x = this._accelMinus * (eventAcceleration.x || 0) * .1, y = this._accelMinus * (eventAcceleration.y || 0) * .1, 
                    z = .1 * (eventAcceleration.z || 0));
                } else {
                    var deviceOrientationEvent = eventData;
                    x = (deviceOrientationEvent.gamma || 0) / 90 * .981, y = -(deviceOrientationEvent.beta || 0) / 90 * .981, 
                    z = (deviceOrientationEvent.alpha || 0) / 90 * .981;
                }
                if (cc.view._isRotated) {
                    var tmp = x;
                    x = -y, y = tmp;
                }
                mAcceleration.x = x, mAcceleration.y = y, mAcceleration.z = z, mAcceleration.timestamp = eventData.timeStamp || Date.now();
                var tmpX = mAcceleration.x;
                90 === window.orientation ? (mAcceleration.x = -mAcceleration.y, mAcceleration.y = tmpX) : -90 === window.orientation ? (mAcceleration.x = mAcceleration.y, 
                mAcceleration.y = -tmpX) : 180 === window.orientation && (mAcceleration.x = -mAcceleration.x, 
                mAcceleration.y = -mAcceleration.y), cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ && (mAcceleration.x = -mAcceleration.x, 
                mAcceleration.y = -mAcceleration.y);
            }
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, 
            eventManager.dispatchEvent(new EventAcceleration(this._acceleration))), this._accelCurTime += dt;
        }
    }, {
        key: "setAccelerometerInterval",
        value: function setAccelerometerInterval(interval) {
            this._accelInterval !== interval && (this._accelInterval = interval);
        }
    }, {
        key: "_getUnUsedIndex",
        value: function _getUnUsedIndex() {
            for (var temp = this._indexBitsUsed, now = cc.sys.now(), i = 0; i < this._maxTouches; i++) {
                if (!(1 & temp)) return this._indexBitsUsed |= 1 << i, i;
                var touch = this._touches[i];
                if (now - touch._lastModified > TOUCH_TIMEOUT) {
                    this._removeUsedIndexBit(i);
                    var touchID = touch.getID();
                    return null !== touchID && delete this._touchesIntegerDict[touchID], i;
                }
                temp >>= 1;
            }
            return -1;
        }
    }, {
        key: "_removeUsedIndexBit",
        value: function _removeUsedIndexBit(index) {
            if (!(index < 0 || index >= this._maxTouches)) {
                var temp = 1 << index;
                temp = ~temp, this._indexBitsUsed &= temp;
            }
        }
    }, {
        key: "_registerMouseEvents",
        value: function _registerMouseEvents(element, prohibition) {
            this._registerPointerLockEvent(), prohibition || this._registerWindowMouseEvents(element), 
            this._registerElementMouseEvents(element, prohibition);
        }
    }, {
        key: "_registerPointerLockEvent",
        value: function _registerPointerLockEvent() {
            var _this = this, lockChangeAlert = function lockChangeAlert() {
                var canvas = cc.game.canvas;
                document.pointerLockElement === canvas || document.mozPointerLockElement === canvas ? _this._pointLocked = !0 : _this._pointLocked = !1;
            };
            "onpointerlockchange" in document ? document.addEventListener("pointerlockchange", lockChangeAlert, !1) : "onmozpointerlockchange" in document && document.addEventListener("mozpointerlockchange", lockChangeAlert, !1);
        }
    }, {
        key: "_registerWindowMouseEvents",
        value: function _registerWindowMouseEvents(element) {
            var _this2 = this;
            window.addEventListener("mousedown", function() {
                _this2._mousePressed = !0;
            }, !1), window.addEventListener("mouseup", function(event) {
                if (_this2._mousePressed) {
                    _this2._mousePressed = !1;
                    var position = _this2.getHTMLElementPosition(element), location = _this2.getPointByEvent(event, position);
                    if (!rect(position.left, position.top, position.width, position.height).contains(new Vec2(location.x, location.y))) {
                        _this2.handleTouchesEnd([ _this2.getTouchByXY(event, location.x, location.y, position) ]);
                        var _mouseEvent = _this2.getMouseEvent(location, position, EventMouse.UP);
                        _mouseEvent.setButton(event.button), eventManager.dispatchEvent(_mouseEvent);
                    }
                }
            }, !1);
        }
    }, {
        key: "_registerElementMouseEvents",
        value: function _registerElementMouseEvents(element, prohibition) {
            var _this3 = this, listenDOMMouseEvent = function listenDOMMouseEvent(eventName, type, handler) {
                element.addEventListener(eventName, function(event) {
                    var pos = _this3.getHTMLElementPosition(element), location = _this3.getPointByEvent(event, pos), mouseEvent = _this3.getMouseEvent(location, pos, type);
                    mouseEvent.setButton(event.button), handler(event, mouseEvent, location, pos), eventManager.dispatchEvent(mouseEvent), 
                    event.stopPropagation(), event.preventDefault();
                });
            };
            prohibition || (listenDOMMouseEvent("mousedown", EventMouse.DOWN, function(event, mouseEvent, location, pos) {
                _this3._mousePressed = !0, _this3.handleTouchesBegin([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                element.focus();
            }), listenDOMMouseEvent("mouseup", EventMouse.UP, function(event, mouseEvent, location, pos) {
                _this3._mousePressed = !1, _this3.handleTouchesEnd([ _this3.getTouchByXY(event, location.x, location.y, pos) ]);
            }), listenDOMMouseEvent("mousemove", EventMouse.MOVE, function(event, mouseEvent, location, pos) {
                _this3.handleTouchesMove([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                _this3._mousePressed || mouseEvent.setButton(null), void 0 !== event.movementX && void 0 !== event.movementY && (mouseEvent.movementX = event.movementX, 
                mouseEvent.movementY = event.movementY);
            })), listenDOMMouseEvent("mousewheel", EventMouse.SCROLL, function(event, mouseEvent, location, pos) {
                mouseEvent.setScrollData(0, event.wheelDelta);
            }), listenDOMMouseEvent("DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent, location, pos) {
                mouseEvent.setScrollData(0, -120 * event.detail);
            });
        }
    }, {
        key: "_registerMousePointerEvents",
        value: function _registerMousePointerEvents(element) {
            var _this4 = this, _pointerEventsMap = {
                MSPointerDown: this.handleTouchesBegin,
                MSPointerMove: this.handleTouchesMove,
                MSPointerUp: this.handleTouchesEnd,
                MSPointerCancel: this.handleTouchesCancel
            }, _loop = function _loop(eventName) {
                var touchEvent = _pointerEventsMap[eventName];
                element.addEventListener(eventName, function(event) {
                    var pos = _this4.getHTMLElementPosition(element);
                    pos.left -= document.documentElement.scrollLeft, pos.top -= document.documentElement.scrollTop, 
                    touchEvent.call(_this4, [ _this4.getTouchByXY(event, event.clientX, event.clientY, pos) ]), 
                    event.stopPropagation();
                }, !1);
            };
            for (var eventName in _pointerEventsMap) _loop(eventName);
        }
    }, {
        key: "_registerTouchEvents",
        value: function _registerTouchEvents(element) {
            cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? this._registerWXGameTouchEvents(element) : this._registerHTMLTouchEvents(element);
        }
    }, {
        key: "_registerWXGameTouchEvents",
        value: function _registerWXGameTouchEvents(element) {
            var _this5 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                return function(event) {
                    var pos = _this5.getHTMLElementPosition(element), body = document.body;
                    pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this5.getTouchesByEvent(event, pos));
                };
            };
            wx.onTouchStart(makeTouchListener(function(touchesToHandle) {
                _this5.handleTouchesBegin(touchesToHandle);
            })), wx.onTouchEnd(makeTouchListener(function(touchesToHandle) {
                _this5.handleTouchesEnd(touchesToHandle);
            })), wx.onTouchMove(makeTouchListener(function(touchesToHandle) {
                _this5.handleTouchesMove(touchesToHandle);
            })), wx.onTouchCancel(makeTouchListener(function(touchesToHandle) {
                _this5.handleTouchesCancel(touchesToHandle);
            }));
        }
    }, {
        key: "_registerHTMLTouchEvents",
        value: function _registerHTMLTouchEvents(element) {
            var _this6 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                return function(event) {
                    if (event.changedTouches) {
                        var pos = _this6.getHTMLElementPosition(element), body = document.body;
                        pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this6.getTouchesByEvent(event, pos)), 
                        event.stopPropagation(), event.preventDefault();
                    }
                };
            };
            element.addEventListener("touchstart", makeTouchListener(function(touchesToHandle) {
                _this6.handleTouchesBegin(touchesToHandle), sys.platform !== sys.WECHAT_GAME && element.focus();
            }), !1), element.addEventListener("touchmove", makeTouchListener(function(touchesToHandle) {
                _this6.handleTouchesMove(touchesToHandle);
            }), !1), element.addEventListener("touchend", makeTouchListener(function(touchesToHandle) {
                _this6.handleTouchesEnd(touchesToHandle);
            }), !1), element.addEventListener("touchcancel", makeTouchListener(function(touchesToHandle) {
                _this6.handleTouchesCancel(touchesToHandle);
            }), !1);
        }
    }, {
        key: "_registerKeyboardEvent",
        value: function _registerKeyboardEvent() {
            var canvas = cc.game.canvas;
            canvas.addEventListener("keydown", function(event) {
                eventManager.dispatchEvent(new EventKeyboard(event, !0)), event.stopPropagation(), 
                event.preventDefault();
            }, !1), canvas.addEventListener("keyup", function(event) {
                eventManager.dispatchEvent(new EventKeyboard(event, !1)), event.stopPropagation(), 
                event.preventDefault();
            }, !1);
        }
    }, {
        key: "_registerAccelerometerEvent",
        value: function _registerAccelerometerEvent() {
            var _this7 = this;
            this._acceleration = new Acceleration$1(), this._accelDeviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent, 
            cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
            var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation", ua = navigator.userAgent;
            (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (this._minus = -1), 
            _didAccelerateFun = function _didAccelerateFun() {
                return _this7.didAccelerate.apply(_this7, arguments);
            }, window.addEventListener(_deviceEventType, _didAccelerateFun, !1);
        }
    }, {
        key: "_unregisterAccelerometerEvent",
        value: function _unregisterAccelerometerEvent() {
            var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
            _didAccelerateFun && window.removeEventListener(_deviceEventType, _didAccelerateFun, !1);
        }
    } ]), InputManager;
}())();

cc.internal.inputManager = inputManager, function(SystemEventType) {
    SystemEventType.TOUCH_START = "touch-start", SystemEventType.TOUCH_MOVE = "touch-move", 
    SystemEventType.TOUCH_END = "touch-end", SystemEventType.TOUCH_CANCEL = "touch-cancel", 
    SystemEventType.MOUSE_DOWN = "mouse-down", SystemEventType.MOUSE_MOVE = "mouse-move", 
    SystemEventType.MOUSE_UP = "mouse-up", SystemEventType.MOUSE_WHEEL = "mouse-wheel", 
    SystemEventType.MOUSE_ENTER = "mouse-enter", SystemEventType.MOUSE_LEAVE = "mouse-leave", 
    SystemEventType.KEY_DOWN = "keydown", SystemEventType.KEY_UP = "keyup", SystemEventType.DEVICEMOTION = "devicemotion", 
    SystemEventType.TRANSFORM_CHANGED = "transform-changed", SystemEventType.POSITION_PART = "position-part", 
    SystemEventType.ROTATION_PART = "rotation-part", SystemEventType.SCALE_PART = "scale-part", 
    SystemEventType.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists", SystemEventType.SIZE_CHANGED = "size-changed", 
    SystemEventType.ANCHOR_CHANGED = "anchor-changed", SystemEventType.CHILD_ADDED = "child-added", 
    SystemEventType.CHILD_REMOVED = "child-removed";
}(SystemEventType || (SystemEventType = {})), ccenum(SystemEventType), cc.SystemEventType = SystemEventType;

var keyboardListener = null, accelerationListener = null, touchListener = null, mouseListener = null, SystemEvent = function(_EventTarget) {
    function SystemEvent() {
        return _classCallCheck(this, SystemEvent), _possibleConstructorReturn(this, _getPrototypeOf(SystemEvent).call(this));
    }
    return _inherits(SystemEvent, EventTarget), _createClass(SystemEvent, [ {
        key: "setAccelerometerEnabled",
        value: function setAccelerometerEnabled(isEnable) {
            inputManager.setAccelerometerEnabled(isEnable);
        }
    }, {
        key: "setAccelerometerInterval",
        value: function setAccelerometerInterval(interval) {
            inputManager.setAccelerometerInterval(interval);
        }
    }, {
        key: "on",
        value: function on(type, callback, target) {
            return _get(_getPrototypeOf(SystemEvent.prototype), "on", this).call(this, type, callback, target), 
            type !== SystemEventType.KEY_DOWN && type !== SystemEventType.KEY_UP || (keyboardListener || (keyboardListener = EventListener.create({
                event: EventListener.KEYBOARD,
                onKeyPressed: function onKeyPressed(keyCode, event) {
                    event.type = SystemEventType.KEY_DOWN, systemEvent.emit(event.type, event);
                },
                onKeyReleased: function onKeyReleased(keyCode, event) {
                    event.type = SystemEventType.KEY_UP, systemEvent.emit(event.type, event);
                }
            })), eventManager.hasEventListener(EventListener.ListenerID.KEYBOARD) || eventManager.addListener(keyboardListener, 256)), 
            type === SystemEventType.DEVICEMOTION && (accelerationListener || (accelerationListener = EventListener.create({
                event: EventListener.ACCELERATION,
                callback: function callback(acc, event) {
                    event.type = SystemEventType.DEVICEMOTION, cc.systemEvent.emit(event.type, event);
                }
            })), eventManager.hasEventListener(EventListener.ListenerID.ACCELERATION) || eventManager.addListener(accelerationListener, 256)), 
            type !== SystemEventType.TOUCH_START && type !== SystemEventType.TOUCH_MOVE && type !== SystemEventType.TOUCH_END && type !== SystemEventType.TOUCH_CANCEL || touchListener || (touchListener = EventListener.create({
                event: EventListener.TOUCH_ONE_BY_ONE,
                onTouchBegan: function onTouchBegan(touch, event) {
                    return event.type = SystemEventType.TOUCH_START, cc.systemEvent.emit(event.type, touch, event), 
                    !0;
                },
                onTouchMoved: function onTouchMoved(touch, event) {
                    event.type = SystemEventType.TOUCH_MOVE, cc.systemEvent.emit(event.type, touch, event);
                },
                onTouchEnded: function onTouchEnded(touch, event) {
                    event.type = SystemEventType.TOUCH_END, cc.systemEvent.emit(event.type, touch, event);
                },
                onTouchCancelled: function onTouchCancelled(touch, event) {
                    event.type = SystemEventType.TOUCH_CANCEL, cc.systemEvent.emit(event.type, touch, event);
                }
            }), eventManager.addListener(touchListener, 256)), type !== SystemEventType.MOUSE_DOWN && type !== SystemEventType.MOUSE_MOVE && type !== SystemEventType.MOUSE_UP && type !== SystemEventType.MOUSE_WHEEL || mouseListener || (mouseListener = EventListener.create({
                event: EventListener.MOUSE,
                onMouseDown: function onMouseDown(event) {
                    event.type = SystemEventType.MOUSE_DOWN, cc.systemEvent.emit(event.type, event);
                },
                onMouseMove: function onMouseMove(event) {
                    event.type = SystemEventType.MOUSE_MOVE, cc.systemEvent.emit(event.type, event);
                },
                onMouseUp: function onMouseUp(event) {
                    event.type = SystemEventType.MOUSE_UP, cc.systemEvent.emit(event.type, event);
                },
                onMouseScroll: function onMouseScroll(event) {
                    event.type = SystemEventType.MOUSE_WHEEL, cc.systemEvent.emit(event.type, event);
                }
            }), eventManager.addListener(mouseListener, 256)), callback;
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            if (_get(_getPrototypeOf(SystemEvent.prototype), "off", this).call(this, type, callback, target), 
            keyboardListener && (type === SystemEventType.KEY_DOWN || type === SystemEventType.KEY_UP)) {
                var hasKeyDownEventListener = this.hasEventListener(SystemEventType.KEY_DOWN), hasKeyUpEventListener = this.hasEventListener(SystemEventType.KEY_UP);
                hasKeyDownEventListener || hasKeyUpEventListener || eventManager.removeListener(keyboardListener);
            }
            accelerationListener && type === SystemEventType.DEVICEMOTION && eventManager.removeListener(accelerationListener);
        }
    } ]), SystemEvent;
}();

SystemEvent.EventType = SystemEventType, cc.SystemEvent = SystemEvent;

var systemEvent = new SystemEvent();

cc.systemEvent = systemEvent;

var fastRemove$2 = array.fastRemove, _cachedArray = new Array(16), _currentHovered = null, pos = new Vec2(), _touchEvents = [ SystemEventType.TOUCH_START.toString(), SystemEventType.TOUCH_MOVE.toString(), SystemEventType.TOUCH_END.toString(), SystemEventType.TOUCH_CANCEL.toString() ], _mouseEvents = [ SystemEventType.MOUSE_DOWN.toString(), SystemEventType.MOUSE_ENTER.toString(), SystemEventType.MOUSE_MOVE.toString(), SystemEventType.MOUSE_LEAVE.toString(), SystemEventType.MOUSE_UP.toString(), SystemEventType.MOUSE_WHEEL.toString() ];

function _touchStartHandler(touch, event) {
    var node = this.owner;
    return !(!node || !node.uiTransfromComp) && (touch.getUILocation(pos), !!node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.TOUCH_START.toString(), 
    event.touch = touch, event.bubbles = !0, node.dispatchEvent(event), !0));
}

function _touchMoveHandler(touch, event) {
    var node = this.owner;
    if (!node || !node.uiTransfromComp) return !1;
    event.type = SystemEventType.TOUCH_MOVE.toString(), event.touch = touch, event.bubbles = !0, 
    node.dispatchEvent(event);
}

function _touchEndHandler(touch, event) {
    var node = this.owner;
    node && node.uiTransfromComp && (touch.getUILocation(pos), node.uiTransfromComp.isHit(pos, this) ? event.type = SystemEventType.TOUCH_END.toString() : event.type = SystemEventType.TOUCH_CANCEL.toString(), 
    event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
}

function _touchCancelHandler(touch, event) {
    var node = this.owner;
    node && node.uiTransfromComp && (event.type = SystemEventType.TOUCH_CANCEL.toString(), 
    event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
}

function _mouseDownHandler(event) {
    var node = this.owner;
    node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.MOUSE_DOWN.toString(), 
    event.bubbles = !0, node.dispatchEvent(event)));
}

function _mouseMoveHandler(event) {
    var node = this.owner;
    if (node && node.uiTransfromComp) {
        if (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this)) this._previousIn || (_currentHovered && _currentHovered.eventProcessor.mouseListener && (event.type = SystemEventType.MOUSE_LEAVE, 
        _currentHovered.dispatchEvent(event), _currentHovered.eventProcessor.mouseListener && (_currentHovered.eventProcessor.mouseListener._previousIn = !1)), 
        _currentHovered = node, event.type = SystemEventType.MOUSE_ENTER.toString(), node.dispatchEvent(event), 
        this._previousIn = !0), event.type = SystemEventType.MOUSE_MOVE.toString(), event.bubbles = !0, 
        node.dispatchEvent(event); else {
            if (!this._previousIn) return;
            event.type = SystemEventType.MOUSE_LEAVE.toString(), node.dispatchEvent(event), 
            this._previousIn = !1, _currentHovered = null;
        }
        event.propagationStopped = !0;
    }
}

function _mouseUpHandler(event) {
    var node = this.owner;
    node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.MOUSE_UP.toString(), 
    event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
}

function _mouseWheelHandler(event) {
    var node = this.owner;
    node && node.uiTransfromComp && (pos = event.getUILocation(), node.uiTransfromComp.isHit(pos, this) && (event.type = SystemEventType.MOUSE_WHEEL.toString(), 
    event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
}

function _searchMaskInParent(node) {
    var Mask = cc.MaskComponent;
    if (Mask) for (var index = 0, curr = node; curr && cc.Node.isNode(curr); curr = curr.parent, 
    ++index) if (curr.getComponent(Mask)) return {
        index: index,
        node: curr
    };
    return null;
}

function _checkListeners(node, events) {
    if (!node._persistNode) {
        var i = 0;
        if (node.eventProcessor.bubblingTargets) for (;i < events.length; ++i) if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) return !0;
        if (node.eventProcessor.capturingTargets) for (;i < events.length; ++i) if (node.eventProcessor.capturingTargets.hasEventListener(events[i])) return !0;
        return !1;
    }
    return !0;
}

var NodeEventProcessor = function() {
    function NodeEventProcessor(node) {
        _classCallCheck(this, NodeEventProcessor), this.bubblingTargets = null, this.capturingTargets = null, 
        this.touchListener = null, this.mouseListener = null, this._node = void 0, this._node = node;
    }
    return _createClass(NodeEventProcessor, [ {
        key: "node",
        get: function get() {
            return this._node;
        }
    } ]), _createClass(NodeEventProcessor, [ {
        key: "reattach",
        value: function reattach() {
            if (this.touchListener) {
                var mask = this.touchListener.mask = _searchMaskInParent(this._node);
                this.mouseListener && (this.mouseListener.mask = mask);
            } else this.mouseListener && (this.mouseListener.mask = _searchMaskInParent(this._node));
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _currentHovered === this._node && (_currentHovered = null), (this.touchListener || this.mouseListener) && (eventManager.removeListeners(this._node), 
            this.touchListener && (this.touchListener.owner = null, this.touchListener.mask = null, 
            this.touchListener = null), this.mouseListener && (this.mouseListener.owner = null, 
            this.mouseListener.mask = null, this.mouseListener = null));
        }
    }, {
        key: "on",
        value: function on(type, callback, target, useCapture) {
            return this._checknSetupSysEvent(type) ? this._onDispatch(type, callback, target, useCapture) : (this.bubblingTargets || (this.bubblingTargets = new EventTarget()), 
            this.bubblingTargets.on(type, callback, target));
        }
    }, {
        key: "once",
        value: function once(type, callback, target, useCapture) {
            (this._checknSetupSysEvent(type) && useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget() : this.bubblingTargets = this.bubblingTargets || new EventTarget()).once(type, callback, target);
        }
    }, {
        key: "off",
        value: function off(type, callback, target, useCapture) {
            var touchEvent = -1 !== _touchEvents.indexOf(type), mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
            touchEvent || mouseEvent ? (this._offDispatch(type, callback, target, useCapture), 
            touchEvent ? this.touchListener && !_checkListeners(this._node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
            this.touchListener = null) : mouseEvent && this.mouseListener && !_checkListeners(this._node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
            this.mouseListener = null)) : this.bubblingTargets && this.bubblingTargets.off(type, callback, target);
        }
    }, {
        key: "emit",
        value: function emit(type) {
            if (this.bubblingTargets) {
                for (var _this$bubblingTargets, _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                (_this$bubblingTargets = this.bubblingTargets).emit.apply(_this$bubblingTargets, [ type ].concat(args));
            }
        }
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
            !function _doDispatchEvent(owner, event) {
                var target, i = 0;
                for (event.target = owner, _cachedArray.length = 0, owner.eventProcessor.getCapturingTargets(event.type, _cachedArray), 
                event.eventPhase = 1, i = _cachedArray.length - 1; i >= 0; --i) if ((target = _cachedArray[i]).eventProcessor.capturingTargets && (event.currentTarget = target, 
                target.eventProcessor.capturingTargets.emit(event.type, event, _cachedArray), event.propagationStopped)) return void (_cachedArray.length = 0);
                if (_cachedArray.length = 0, event.eventPhase = 2, event.currentTarget = owner, 
                owner.eventProcessor.capturingTargets && owner.eventProcessor.capturingTargets.emit(event.type, event), 
                !event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets && owner.eventProcessor.bubblingTargets.emit(event.type, event), 
                !event.propagationStopped && event.bubbles) for (owner.eventProcessor.getBubblingTargets(event.type, _cachedArray), 
                event.eventPhase = 3, i = 0; i < _cachedArray.length; ++i) if ((target = _cachedArray[i]).eventProcessor.bubblingTargets && (event.currentTarget = target, 
                target.eventProcessor.bubblingTargets.emit(event.type, event), event.propagationStopped)) return void (_cachedArray.length = 0);
                _cachedArray.length = 0;
            }(this._node, event), _cachedArray.length = 0;
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(type) {
            var has = !1;
            return this.bubblingTargets && (has = this.bubblingTargets.hasEventListener(type)), 
            !has && this.capturingTargets && (has = this.capturingTargets.hasEventListener(type)), 
            has;
        }
    }, {
        key: "targetOff",
        value: function targetOff(target) {
            this.capturingTargets && this.capturingTargets.targetOff(target), this.bubblingTargets && this.bubblingTargets.targetOff(target), 
            this.touchListener && !_checkListeners(this.node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
            this.touchListener = null), this.mouseListener && !_checkListeners(this.node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
            this.mouseListener = null);
        }
    }, {
        key: "getCapturingTargets",
        value: function getCapturingTargets(type, targets) {
            for (var parent = this._node.parent; parent; ) parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type) && targets.push(parent), 
            parent = parent.parent;
        }
    }, {
        key: "getBubblingTargets",
        value: function getBubblingTargets(type, targets) {
            for (var parent = this._node.parent; parent; ) parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type) && targets.push(parent), 
            parent = parent.parent;
        }
    }, {
        key: "_checknSetupSysEvent",
        value: function _checknSetupSysEvent(type) {
            var _this = this, newAdded = !1, forDispatch = !1;
            return -1 !== _touchEvents.indexOf(type) ? (this.touchListener || (this.touchListener = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !0,
                owner: this._node,
                mask: _searchMaskInParent(this._node),
                onTouchBegan: _touchStartHandler,
                onTouchMoved: _touchMoveHandler,
                onTouchEnded: _touchEndHandler,
                onTouchCancelled: _touchCancelHandler
            }), eventManager.addListener(this.touchListener, this._node), newAdded = !0), forDispatch = !0) : -1 !== _mouseEvents.indexOf(type) && (this.mouseListener || (this.mouseListener = cc.EventListener.create({
                event: cc.EventListener.MOUSE,
                _previousIn: !1,
                owner: this._node,
                mask: _searchMaskInParent(this._node),
                onMouseDown: _mouseDownHandler,
                onMouseMove: _mouseMoveHandler,
                onMouseUp: _mouseUpHandler,
                onMouseScroll: _mouseWheelHandler
            }), eventManager.addListener(this.mouseListener, this._node), newAdded = !0), forDispatch = !0), 
            newAdded && !this._node.activeInHierarchy && cc.director.getScheduler().schedule(function() {
                _this._node.activeInHierarchy || eventManager.pauseTarget(_this._node);
            }, this._node, 0, 0, 0, !1), forDispatch;
        }
    }, {
        key: "_onDispatch",
        value: function _onDispatch(type, callback, target, useCapture) {
            if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
            callback) {
                var listeners = null;
                if (!(listeners = useCapture ? this.capturingTargets = this.capturingTargets || new EventTarget() : this.bubblingTargets = this.bubblingTargets || new EventTarget()).hasEventListener(type, callback, target)) {
                    listeners.on(type, callback, target);
                    var targetImpl = target;
                    target && (targetImpl.__eventTargets ? targetImpl.__eventTargets.push(this) : targetImpl.node && targetImpl.node.__eventTargets && targetImpl.node.__eventTargets.push(this));
                }
                return callback;
            }
            cc.errorID(6800);
        }
    }, {
        key: "_offDispatch",
        value: function _offDispatch(type, callback, target, useCapture) {
            if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
            callback) {
                var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;
                if (listeners) {
                    listeners.off(type, callback, target);
                    var targetImpl = target;
                    target && (targetImpl.__eventTargets ? fastRemove$2(targetImpl.__eventTargets, this) : targetImpl.node && targetImpl.node.__eventTargets && fastRemove$2(targetImpl.node.__eventTargets, this));
                }
            } else this.capturingTargets && this.capturingTargets.removeAll(type), this.bubblingTargets && this.bubblingTargets.removeAll(type);
        }
    } ]), NodeEventProcessor;
}();

cc.NodeEventProcessor = NodeEventProcessor;

var CACHE_KEY = "__ccclassCache__";

function fNOP(ctor) {
    return ctor;
}

function getSubDict(obj, key) {
    return obj[key] || (obj[key] = {});
}

function checkCtorArgument(decorate) {
    return function(target) {
        return "function" == typeof target ? decorate(target) : function(ctor) {
            return decorate(ctor, target);
        };
    };
}

function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
    return function(target) {
        return function(ctor) {
            return decorate(ctor, target);
        };
    };
}

var checkCompArgument = _checkNormalArgument.bind(null, !1);

function _argumentChecker(type) {
    return _checkNormalArgument.bind(null, !1);
}

var checkStringArgument = _argumentChecker(), checkNumberArgument = _argumentChecker();

function getClassCache(ctor, decoratorName) {
    return getSubDict(ctor, CACHE_KEY);
}

function genProperty(ctor, properties, propName, options, desc, cache) {
    var fullOptions;
    options && (fullOptions = (fullOptions = getFullFormOfProperty(options)) || options);
    var prop = mixin(properties[propName] || {}, fullOptions || {});
    if (desc && (desc.get || desc.set)) {
        desc.get && (prop.get = desc.get), desc.set && (prop.set = desc.set);
    } else {
        var defaultValue;
        0;
        if (desc) desc.initializer && (defaultValue = function getDefaultFromInitializer(initializer) {
            var value;
            try {
                value = initializer();
            } catch (e) {
                return initializer;
            }
            return "object" !== _typeof(value) || null === value ? value : initializer;
        }(desc.initializer), !0); else {
            var actualDefaultValues = cache.default || (cache.default = function extractActualDefaultValues(ctor) {
                var dummyObj;
                try {
                    dummyObj = new ctor();
                } catch (e) {
                    return {};
                }
                return dummyObj;
            }(ctor));
            actualDefaultValues.hasOwnProperty(propName) && (defaultValue = actualDefaultValues[propName], 
            !0);
        }
        0, prop.default = defaultValue;
    }
    properties[propName] = prop;
}

var ccclass = checkCtorArgument(function(ctor, name) {
    var base = getSuper(ctor);
    base === Object && (base = null);
    var proto = {
        name: name,
        extends: base,
        ctor: ctor,
        __ES6__: !0
    }, cache = ctor[CACHE_KEY];
    if (cache) {
        var decoratedProto = cache.proto;
        decoratedProto && mixin(proto, decoratedProto), ctor[CACHE_KEY] = void 0;
    }
    return cc.Class(proto);
});

function property(ctorProtoOrOptions, propName, desc) {
    var options = null;
    function normalized(ctorProto, propName, desc) {
        var cache = getClassCache(ctorProto.constructor);
        if (cache) {
            var ccclassProto = getSubDict(cache, "proto"), properties = getSubDict(ccclassProto, "properties");
            genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
        }
    }
    if (void 0 === propName) return options = ctorProtoOrOptions, normalized;
    normalized(ctorProtoOrOptions, propName, desc);
}

function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
    return argCheckFunc(function(ctor, decoratedValue) {
        var cache = getClassCache(ctor);
        if (cache) {
            var value = void 0 !== staticValue ? staticValue : decoratedValue, proto = getSubDict(cache, "proto");
            getSubDict(proto, "editor")[editorPropName] = value;
        }
    }, editorPropName);
}

function createDummyDecorator(argCheckFunc) {
    return argCheckFunc(fNOP);
}

var executeInEditMode = createDummyDecorator(checkCtorArgument), requireComponent = createEditorDecorator(checkCompArgument, "requireComponent"), menu = createDummyDecorator(checkStringArgument), executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder"), disallowMultiple = createDummyDecorator(checkCtorArgument), playOnFocus = createDummyDecorator(checkCtorArgument), inspector = createDummyDecorator(checkStringArgument), icon = createDummyDecorator(checkStringArgument), help = createDummyDecorator(checkStringArgument);

var _decorator = Object.freeze({
    ccclass: ccclass,
    property: property,
    executeInEditMode: executeInEditMode,
    requireComponent: requireComponent,
    menu: menu,
    executionOrder: executionOrder,
    disallowMultiple: disallowMultiple,
    playOnFocus: playOnFocus,
    inspector: inspector,
    icon: icon,
    help: help,
    mixins: function mixins() {
        for (var mixins = [], i = 0; i < arguments.length; i++) mixins[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
        return function(ctor) {
            var cache = getClassCache(ctor);
            cache && (getSubDict(cache, "proto").mixins = mixins);
        };
    }
}), objectsToDestroy = [];

var _class, CCObject = function() {
    function CCObject() {
        var name = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        _classCallCheck(this, CCObject), this._objFlags = void 0, this._name = void 0, this._name = name, 
        this._objFlags = 0;
    }
    return _createClass(CCObject, null, [ {
        key: "_deferredDestroy",
        value: function _deferredDestroy() {
            for (var deleteCount = objectsToDestroy.length, i = 0; i < deleteCount; ++i) {
                var obj = objectsToDestroy[i];
                1 & obj._objFlags || obj._destroyImmediate();
            }
            deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
        }
    } ]), _createClass(CCObject, [ {
        key: "destroy",
        value: function destroy() {
            return 1 & this._objFlags ? (cc.warnID(5e3), !1) : !(4 & this._objFlags) && (this._objFlags |= 4, 
            objectsToDestroy.push(this), !0);
        }
    }, {
        key: "_destruct",
        value: function _destruct() {
            var ctor = this.constructor, destruct = ctor.__destruct__;
            destruct || (destruct = function compileDestruct(obj, ctor) {
                var key, shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component, idToSkip = shouldSkipId ? "_id" : null, propsToReset = {};
                for (key in obj) if (obj.hasOwnProperty(key)) {
                    if (key === idToSkip) continue;
                    switch (_typeof(obj[key])) {
                      case "string":
                        propsToReset[key] = "";
                        break;

                      case "object":
                      case "function":
                        propsToReset[key] = null;
                    }
                }
                if (CCClass._isCCClass(ctor)) for (var attrs = cc.Class.Attr.getClassAttrs(ctor), propList = ctor.__props__, i = 0; i < propList.length; i++) {
                    var attrKey = (key = propList[i]) + cc.Class.Attr.DELIMETER + "default";
                    if (attrKey in attrs) {
                        if (shouldSkipId && "_id" === key) continue;
                        switch (_typeof(attrs[attrKey])) {
                          case "string":
                            propsToReset[key] = "";
                            break;

                          case "object":
                          case "function":
                            propsToReset[key] = null;
                            break;

                          case "undefined":
                            propsToReset[key] = void 0;
                        }
                    }
                }
                var func = "";
                for (key in propsToReset) {
                    var statement = void 0;
                    statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
                    var val = propsToReset[key];
                    "" === val && (val = '""'), func += statement + val + ";\n";
                }
                return Function("o", func);
            }(this, ctor), value(ctor, "__destruct__", destruct, !0)), destruct(this);
        }
    }, {
        key: "_destroyImmediate",
        value: function _destroyImmediate() {
            1 & this._objFlags ? cc.errorID(5e3) : (this._onPreDestroy && this._onPreDestroy(), 
            this._destruct(), this._objFlags |= 1);
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        },
        set: function set(value) {
            this._name = value;
        }
    }, {
        key: "isValid",
        get: function get() {
            return !(1 & this._objFlags);
        }
    } ]), CCObject;
}(), prototype = CCObject.prototype;

prototype._deserialize = null, prototype._onPreDestroy = null, CCClass.fastDefine("cc.Object", CCObject, {
    _name: "",
    _objFlags: 0
}), value(CCObject, "Flags", {
    Destroyed: 1,
    DontSave: 8,
    EditorOnly: 16,
    Dirty: 32,
    DontDestroy: 64,
    PersistentMask: -4192741,
    Destroying: 128,
    Deactivating: 256,
    LockedInEditor: 512,
    HideInHierarchy: 1024,
    IsPreloadStarted: 8192,
    IsOnLoadStarted: 32768,
    IsOnLoadCalled: 16384,
    IsOnEnableCalled: 2048,
    IsStartCalled: 65536,
    IsEditorOnEnableCalled: 4096,
    IsPositionLocked: 1 << 21,
    IsRotationLocked: 1 << 17,
    IsScaleLocked: 1 << 18,
    IsAnchorLocked: 1 << 19,
    IsSizeLocked: 1 << 20
}), cc.isValid = function(value, strictMode) {
    return "object" === _typeof(value) ? !(!value || value._objFlags & (strictMode ? 5 : 1)) : void 0 !== value;
}, cc.Object = CCObject;

var _dec$1, _dec2, _class$1, _class2, _descriptor, _class3, _temp$1, RawAsset = ccclass("cc.RawAsset")(_class = function(_CCObject) {
    function RawAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RawAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RawAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uuid = void 0, 
        Object.defineProperty(_assertThisInitialized(_this), "_uuid", {
            value: "",
            writable: !0
        }), _this;
    }
    return _inherits(RawAsset, CCObject), _createClass(RawAsset, null, [ {
        key: "isRawAssetType",
        value: function isRawAssetType(ctor) {
            return isChildClassOf(ctor, cc.RawAsset) && !isChildClassOf(ctor, cc.Asset);
        }
    } ]), RawAsset;
}()) || _class;

function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function(baseCtor) {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function(name) {
            "constructor" !== name && Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
        });
    });
}

cc.RawAsset = RawAsset;

var Asset = (_dec$1 = ccclass("cc.Asset"), _dec2 = property({
    visible: !1
}), _dec$1((_temp$1 = _class3 = function(_RawAsset) {
    function Asset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Asset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Asset)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).loaded = !0, 
        _initializerDefineProperty(_this, "_native", _descriptor, _assertThisInitialized(_this)), 
        _this._file = null, _this._callbackTable = createMap(!0), _this;
    }
    return _inherits(Asset, RawAsset), _createClass(Asset, null, [ {
        key: "deserialize",
        value: function deserialize(data) {
            return cc.deserialize(data);
        }
    } ]), _createClass(Asset, [ {
        key: "on",
        value: function on(type, callback, target) {}
    }, {
        key: "off",
        value: function off(type, callback, target) {}
    }, {
        key: "targetOff",
        value: function targetOff(keyOrTarget) {}
    }, {
        key: "once",
        value: function once(type, callback, target) {}
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {}
    }, {
        key: "hasEventListener",
        value: function hasEventListener(key, callback, target) {
            return !1;
        }
    }, {
        key: "removeAll",
        value: function removeAll(keyOrTarget) {}
    }, {
        key: "emit",
        value: function emit(key) {}
    }, {
        key: "toString",
        value: function toString() {
            return this.nativeUrl;
        }
    }, {
        key: "_setRawAsset",
        value: function _setRawAsset(filename) {
            var inLibrary = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            this._native = !1 !== inLibrary ? filename || void 0 : "/" + filename;
        }
    }, {
        key: "nativeUrl",
        get: function get() {
            if (this._native) {
                var name = this._native;
                if (47 === name.charCodeAt(0)) return name.slice(1);
                if (cc.AssetLibrary) {
                    var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, !0);
                    return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
                }
                cc.errorID(6400);
            }
            return "";
        }
    }, {
        key: "_nativeAsset",
        get: function get() {
            return this._file;
        },
        set: function set(obj) {
            this._file = obj;
        }
    } ]), Asset;
}(), _class3.preventDeferredLoadDependents = !1, _class3.preventPreloadNativeObject = !1, 
_descriptor = _applyDecoratedDescriptor((_class2 = _temp$1).prototype, "_native", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _applyDecoratedDescriptor(_class2.prototype, "nativeUrl", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2.prototype, "nativeUrl"), _class2.prototype), 
_applyDecoratedDescriptor(_class2.prototype, "_nativeAsset", [ property ], Object.getOwnPropertyDescriptor(_class2.prototype, "_nativeAsset"), _class2.prototype), 
_class$1 = _class2)) || _class$1);

function flattenCodeArray(array) {
    var strList = [];
    return function deepFlatten(strList, array) {
        var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                if ((_i = _iterator.next()).done) break;
                _ref = _i.value;
            }
            var item = _ref;
            Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
        }
    }(strList, array), strList.join("");
}

applyMixins(Asset, [ CallbacksInvoker, EventTarget ]), Asset.prototype.createNode = null, 
cc.Asset = Asset;

var Destroyed$1 = CCObject.Flags.Destroyed, PersistentMask$1 = CCObject.Flags.PersistentMask, DEFAULT = DELIMETER + "default", IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE, VAR = "var ", LOCAL_OBJ = "o", LOCAL_TEMP_OBJ = "t", DEFAULT_MODULE_CACHE = {
    "cc.Node": "cc.Node",
    "cc.Sprite": "cc.Sprite",
    "cc.Label": "cc.Label",
    "cc.Button": "cc.Button",
    "cc.Widget": "cc.Widget",
    "cc.Animation": "cc.Animation",
    "cc.ClickEvent": !1,
    "cc.PrefabInfo": !1
}, escapeForJS$1 = CCClass.escapeForJS, Declaration = function() {
    function Declaration(varName, expression) {
        _classCallCheck(this, Declaration), this.varName = void 0, this.expression = void 0, 
        this.varName = varName, this.expression = expression;
    }
    return _createClass(Declaration, [ {
        key: "toString",
        value: function toString() {
            return VAR + this.varName + "=" + this.expression + ";";
        }
    } ]), Declaration;
}();

function mergeDeclaration(statement, expression) {
    return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
}

function writeAssignment(codeArray, statement, expression) {
    Array.isArray(expression) ? (expression[0] = mergeDeclaration(statement, expression[0]), 
    codeArray.push(expression)) : codeArray.push(mergeDeclaration(statement, expression) + ";");
}

var Assignments = function() {
    function Assignments(targetExpression) {
        _classCallCheck(this, Assignments), this._exps = void 0, this._targetExp = void 0, 
        this._exps = [], this._targetExp = targetExpression;
    }
    return _createClass(Assignments, [ {
        key: "append",
        value: function append(key, expression) {
            this._exps.push([ key, expression ]);
        }
    }, {
        key: "writeCode",
        value: function writeCode(codeArray) {
            var targetVar;
            if (this._exps.length > 1) codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";"), 
            targetVar = LOCAL_TEMP_OBJ; else {
                if (1 !== this._exps.length) return;
                targetVar = this._targetExp;
            }
            for (var i = 0; i < this._exps.length; i++) {
                var pair = this._exps[i];
                writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
            }
        }
    } ]), Assignments;
}();

function getPropAccessor(key) {
    return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
}

Assignments.pool = void 0, Assignments.pool = new Pool(function(obj) {
    obj._exps.length = 0, obj._targetExp = null;
}, 1), Assignments.pool.get = function(targetExpression) {
    var cache = this._get() || new Assignments();
    return cache._targetExp = targetExpression, cache;
};

var _class$2, _class2$1, _descriptor$1, _descriptor2, _descriptor3, _class3$1, _temp$2, Parser = function() {
    function Parser(obj, parent) {
        var globalVariablesDeclaration;
        _classCallCheck(this, Parser), this.parent = void 0, this.objsToClear_iN$t = void 0, 
        this.codeArray = void 0, this.objs = void 0, this.funcs = void 0, this.funcModuleCache = void 0, 
        this.globalVariables = void 0, this.globalVariableId = void 0, this.localVariableId = void 0, 
        this.result = void 0, this.parent = parent, this.objsToClear_iN$t = [], this.codeArray = [], 
        this.objs = [], this.funcs = [], this.funcModuleCache = createMap(), mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE), 
        this.globalVariables = [], this.globalVariableId = 0, this.localVariableId = 0, 
        this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", "if(R){", LOCAL_OBJ + "=R;", "}else{", LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, !0) + "();", "}"), 
        obj._iN$t = {
            globalVar: "R"
        }, this.objsToClear_iN$t.push(obj), this.enumerateObject(this.codeArray, obj), this.globalVariables.length > 0 && (globalVariablesDeclaration = VAR + this.globalVariables.join(",") + ";");
        var code = flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
        this.result = Function("O", "F", code)(this.objs, this.funcs);
        for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
        this.objsToClear_iN$t.length = 0;
    }
    return _createClass(Parser, [ {
        key: "getFuncModule",
        value: function getFuncModule(func, usedInNew) {
            var clsName = getClassName(func);
            if (clsName) {
                var cache = this.funcModuleCache[clsName];
                if (cache) return cache;
                if (void 0 === cache) {
                    var clsNameIsModule = -1 !== clsName.indexOf(".");
                    if (clsNameIsModule) try {
                        if (clsNameIsModule = func === Function("return " + clsName)()) return this.funcModuleCache[clsName] = clsName, 
                        clsName;
                    } catch (e) {}
                }
            }
            var index = this.funcs.indexOf(func);
            index < 0 && (index = this.funcs.length, this.funcs.push(func));
            var res = "F[" + index + "]";
            return usedInNew && (res = "(" + res + ")"), this.funcModuleCache[clsName] = res, 
            res;
        }
    }, {
        key: "getObjRef",
        value: function getObjRef(obj) {
            var index = this.objs.indexOf(obj);
            return index < 0 && (index = this.objs.length, this.objs.push(obj)), "O[" + index + "]";
        }
    }, {
        key: "setValueType",
        value: function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
            var assignments = Assignments.pool.get(targetExpression), fastDefinedProps = defaultValue.constructor.__props__;
            fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
            for (var i = 0; i < fastDefinedProps.length; i++) {
                var propName = fastDefinedProps[i], prop = srcValue[propName];
                if (defaultValue[propName] !== prop) {
                    var expression = this.enumerateField(srcValue, propName, prop);
                    assignments.append(propName, expression);
                }
            }
            assignments.writeCode(codeArray), Assignments.pool.put(assignments);
        }
    }, {
        key: "enumerateCCClass",
        value: function enumerateCCClass(codeArray, obj, klass) {
            for (var props = klass.__values__, attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                var key = props[p], val = obj[key], defaultValue = attrs[key + DEFAULT];
                if (!equalsToDefault(defaultValue, val)) if ("object" === _typeof(val) && val instanceof cc.ValueType && (defaultValue = CCClass.getDefault(defaultValue)) && defaultValue.constructor === val.constructor) {
                    var targetExpression = LOCAL_OBJ + getPropAccessor(key);
                    this.setValueType(codeArray, defaultValue, val, targetExpression);
                } else this.setObjProp(codeArray, obj, key, val);
            }
        }
    }, {
        key: "instantiateArray",
        value: function instantiateArray(value) {
            if (0 === value.length) return "[]";
            var arrayVar = "a" + ++this.localVariableId, codeArray = [ new Declaration(arrayVar, "new Array(" + value.length + ")") ];
            value._iN$t = {
                globalVar: "",
                source: codeArray
            }, this.objsToClear_iN$t.push(value);
            for (var i = 0; i < value.length; ++i) {
                writeAssignment(codeArray, arrayVar + "[" + i + "]=", this.enumerateField(value, i, value[i]));
            }
            return codeArray;
        }
    }, {
        key: "enumerateField",
        value: function enumerateField(obj, key, value) {
            if ("object" === _typeof(value) && value) {
                var _iN$t = value._iN$t;
                if (_iN$t) {
                    var globalVar = _iN$t.globalVar;
                    if (!globalVar) {
                        globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId, this.globalVariables.push(globalVar);
                        var line = _iN$t.source[0];
                        _iN$t.source[0] = mergeDeclaration(globalVar + "=", line);
                    }
                    return globalVar;
                }
                return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
            }
            return "function" == typeof value ? this.getFuncModule(value) : "string" == typeof value ? escapeForJS$1(value) : ("_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask$1), 
            value);
        }
    }, {
        key: "setObjProp",
        value: function setObjProp(codeArray, obj, key, value) {
            writeAssignment(codeArray, LOCAL_OBJ + getPropAccessor(key) + "=", this.enumerateField(obj, key, value));
        }
    }, {
        key: "enumerateObject",
        value: function enumerateObject(codeArray, obj) {
            var klass = obj.constructor;
            if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
                var value = obj[key];
                "object" === _typeof(value) && value && value === obj._iN$t || this.setObjProp(codeArray, obj, key, value);
            }
        }
    }, {
        key: "instantiateObj",
        value: function instantiateObj(obj) {
            if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
            if (obj instanceof cc.Asset) return this.getObjRef(obj);
            if (obj._objFlags & Destroyed$1) return null;
            var createCode, ctor = obj.constructor;
            if (cc.Class._isCCClass(ctor)) {
                if (this.parent) if (this.parent instanceof cc.Component) {
                    if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
                } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                    if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
                } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
                createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, !0) + "()");
            } else if (ctor === Object) createCode = new Declaration(LOCAL_OBJ, "{}"); else {
                if (ctor) return this.getObjRef(obj);
                createCode = new Declaration(LOCAL_OBJ, "Object.create(null)");
            }
            var codeArray = [ createCode ];
            return obj._iN$t = {
                globalVar: "",
                source: codeArray
            }, this.objsToClear_iN$t.push(obj), this.enumerateObject(codeArray, obj), [ "(function(){", codeArray, "return o;})();" ];
        }
    } ]), Parser;
}();

function equalsToDefault(def, value) {
    if ("function" == typeof def) try {
        def = def();
    } catch (e) {
        return !1;
    }
    if (def === value) return !0;
    if (def && value) {
        if (def instanceof cc.ValueType && def.equals(value)) return !0;
        if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
            return Array.isArray(def) && Array.isArray(value) && 0 === def.length && 0 === value.length;
        } catch (e) {}
    }
    return !1;
}

function compile(node) {
    var root = node instanceof cc._BaseNode && node;
    return new Parser(node, root).result;
}

var _class$3, _class2$2, _class3$2, OptimizationPolicy = Enum({
    AUTO: 0,
    SINGLE_INSTANCE: 1,
    MULTI_INSTANCE: 2
}), Prefab = ccclass("cc.Prefab")((_temp$2 = _class3$1 = function(_Asset) {
    function Prefab() {
        var _this;
        return _classCallCheck(this, Prefab), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this)), "data", _descriptor$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor3, _assertThisInitialized(_this)), 
        _this._createFunction = void 0, _this._instantiatedTimes = void 0, _this._createFunction = null, 
        _this._instantiatedTimes = 0, _this;
    }
    return _inherits(Prefab, Asset), _createClass(Prefab, [ {
        key: "createNode",
        value: function createNode(cb) {
            var node = cc.instantiate(this);
            node.name = this.name, cb(null, node);
        }
    }, {
        key: "compileCreateFunction",
        value: function compileCreateFunction() {
            this._createFunction = compile(this.data);
        }
    }, {
        key: "_doInstantiate",
        value: function _doInstantiate(rootToRedirect) {
            return this.data._prefab ? this.data._prefab._synced = !0 : cc.warnID(3700), this._createFunction || this.compileCreateFunction(), 
            this._createFunction(rootToRedirect);
        }
    }, {
        key: "_instantiate",
        value: function _instantiate() {
            var node;
            return this.optimizationPolicy !== OptimizationPolicy.SINGLE_INSTANCE && (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold) ? (node = this._doInstantiate(), 
            this.data._instantiate(node)) : (this.data._prefab._synced = !0, node = this.data._instantiate()), 
            ++this._instantiatedTimes, node;
        }
    } ]), Prefab;
}(), _class3$1.OptimizationPolicy = OptimizationPolicy, _class3$1.OptimizationPolicyThreshold = 3, 
_descriptor$1 = _applyDecoratedDescriptor((_class2$1 = _temp$2).prototype, "data", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2 = _applyDecoratedDescriptor(_class2$1.prototype, "optimizationPolicy", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return OptimizationPolicy.AUTO;
    }
}), _descriptor3 = _applyDecoratedDescriptor(_class2$1.prototype, "asyncLoadAssets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$2 = _class2$1)) || _class$2;

cc.Prefab = Prefab, obsolete(cc, "cc._Prefab", "Prefab");

var Script = ccclass("cc.Script")(_class$3 = function(_Asset) {
    function Script() {
        return _classCallCheck(this, Script), _possibleConstructorReturn(this, _getPrototypeOf(Script).apply(this, arguments));
    }
    return _inherits(Script, Asset), Script;
}()) || _class$3;

cc._Script = Script;

var JavaScript = ccclass("cc.JavaScript")(_class2$2 = function(_Script) {
    function JavaScript() {
        return _classCallCheck(this, JavaScript), _possibleConstructorReturn(this, _getPrototypeOf(JavaScript).apply(this, arguments));
    }
    return _inherits(JavaScript, Script), JavaScript;
}()) || _class2$2;

cc._JavaScript = JavaScript;

var _class$4, _class2$3, _descriptor$2, _descriptor2$1, TypeScript = ccclass("cc.TypeScript")(_class3$2 = function(_Script2) {
    function TypeScript() {
        return _classCallCheck(this, TypeScript), _possibleConstructorReturn(this, _getPrototypeOf(TypeScript).apply(this, arguments));
    }
    return _inherits(TypeScript, Script), TypeScript;
}()) || _class3$2;

cc._TypeScript = TypeScript;

var SceneAsset = ccclass("cc.SceneAsset")((_descriptor$2 = _applyDecoratedDescriptor((_class2$3 = function(_Asset) {
    function SceneAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SceneAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SceneAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "scene", _descriptor$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor2$1, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SceneAsset, Asset), SceneAsset;
}()).prototype, "scene", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "asyncLoadAssets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$4 = _class2$3)) || _class$4;

function murmurhash2_32_gc(str, seed) {
    for (var l = str.length, h = seed ^ l, i = 0; l >= 4; ) {
        var k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (k = 1540483477 * (65535 & (k ^= k >>> 24)) + ((1540483477 * (k >>> 16) & 65535) << 16)), 
        l -= 4, ++i;
    }
    switch (l) {
      case 3:
        h ^= (255 & str.charCodeAt(i + 2)) << 16;

      case 2:
        h ^= (255 & str.charCodeAt(i + 1)) << 8;

      case 1:
        h = 1540483477 * (65535 & (h ^= 255 & str.charCodeAt(i))) + ((1540483477 * (h >>> 16) & 65535) << 16);
    }
    return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), 
    (h ^= h >>> 15) >>> 0;
}

cc.SceneAsset = SceneAsset;

var GFXObjectType, GFXStatus, GFX_MAX_BUFFER_BINDINGS = 24;

!function(GFXObjectType) {
    GFXObjectType[GFXObjectType.UNKNOWN = 0] = "UNKNOWN", GFXObjectType[GFXObjectType.BUFFER = 1] = "BUFFER", 
    GFXObjectType[GFXObjectType.TEXTURE = 2] = "TEXTURE", GFXObjectType[GFXObjectType.TEXTURE_VIEW = 3] = "TEXTURE_VIEW", 
    GFXObjectType[GFXObjectType.RENDER_PASS = 4] = "RENDER_PASS", GFXObjectType[GFXObjectType.FRAMEBUFFER = 5] = "FRAMEBUFFER", 
    GFXObjectType[GFXObjectType.SAMPLER = 6] = "SAMPLER", GFXObjectType[GFXObjectType.SHADER = 7] = "SHADER", 
    GFXObjectType[GFXObjectType.PIPELINE_LAYOUT = 8] = "PIPELINE_LAYOUT", GFXObjectType[GFXObjectType.PIPELINE_STATE = 9] = "PIPELINE_STATE", 
    GFXObjectType[GFXObjectType.BINDING_LAYOUT = 10] = "BINDING_LAYOUT", GFXObjectType[GFXObjectType.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", 
    GFXObjectType[GFXObjectType.COMMAND_ALLOCATOR = 12] = "COMMAND_ALLOCATOR", GFXObjectType[GFXObjectType.COMMAND_BUFFER = 13] = "COMMAND_BUFFER", 
    GFXObjectType[GFXObjectType.QUEUE = 14] = "QUEUE", GFXObjectType[GFXObjectType.WINDOW = 15] = "WINDOW";
}(GFXObjectType || (GFXObjectType = {})), function(GFXStatus) {
    GFXStatus[GFXStatus.UNREADY = 0] = "UNREADY", GFXStatus[GFXStatus.FAILED = 1] = "FAILED", 
    GFXStatus[GFXStatus.SUCCESS = 2] = "SUCCESS";
}(GFXStatus || (GFXStatus = {}));

var GFXAttributeName, GFXType, GFXFormat, GFXBufferUsageBit, GFXMemoryUsageBit, GFXBufferAccessBit, GFXPrimitiveMode, GFXPolygonMode, GFXShadeModel, GFXCullMode, GFXComparisonFunc, GFXStencilOp, GFXBlendOp, GFXBlendFactor, GFXColorMask, GFXFilter, GFXAddress, GFXTextureType, GFXTextureUsageBit, GFXSampleCount, GFXTextureFlagBit, GFXTextureViewType, GFXShaderType, GFXBindingType, GFXCommandBufferType, GFXLoadOp, GFXStoreOp, GFXTextureLayout, GFXPipelineBindPoint, GFXDynamicState, GFXStencilFace, GFXQueueType, GFXClearFlag, GFXObject = function() {
    function GFXObject(gfxType) {
        _classCallCheck(this, GFXObject), this._gfxType = GFXObjectType.UNKNOWN, this._status = GFXStatus.UNREADY, 
        this._gfxType = gfxType;
    }
    return _createClass(GFXObject, [ {
        key: "gfxType",
        get: function get() {
            return this._gfxType;
        }
    }, {
        key: "status",
        get: function get() {
            return this._status;
        }
    } ]), GFXObject;
}();

!function(GFXAttributeName) {
    GFXAttributeName.ATTR_POSITION = "a_position", GFXAttributeName.ATTR_NORMAL = "a_normal", 
    GFXAttributeName.ATTR_TANGENT = "a_tangent", GFXAttributeName.ATTR_BITANGENT = "a_bitangent", 
    GFXAttributeName.ATTR_WEIGHTS = "a_weights", GFXAttributeName.ATTR_JOINTS = "a_joints", 
    GFXAttributeName.ATTR_COLOR = "a_color", GFXAttributeName.ATTR_COLOR1 = "a_color1", 
    GFXAttributeName.ATTR_COLOR2 = "a_color2", GFXAttributeName.ATTR_TEX_COORD = "a_texCoord", 
    GFXAttributeName.ATTR_TEX_COORD1 = "a_texCoord1", GFXAttributeName.ATTR_TEX_COORD2 = "a_texCoord2", 
    GFXAttributeName.ATTR_TEX_COORD3 = "a_texCoord3", GFXAttributeName.ATTR_TEX_COORD4 = "a_texCoord4", 
    GFXAttributeName.ATTR_TEX_COORD5 = "a_texCoord5", GFXAttributeName.ATTR_TEX_COORD6 = "a_texCoord6", 
    GFXAttributeName.ATTR_TEX_COORD7 = "a_texCoord7", GFXAttributeName.ATTR_TEX_COORD8 = "a_texCoord8", 
    GFXAttributeName.ATTR_BATCH_ID = "a_batch_id", GFXAttributeName.ATTR_BATCH_UV = "a_batch_uv";
}(GFXAttributeName || (GFXAttributeName = {})), function(GFXType) {
    GFXType[GFXType.UNKNOWN = 0] = "UNKNOWN", GFXType[GFXType.BOOL = 1] = "BOOL", GFXType[GFXType.BOOL2 = 2] = "BOOL2", 
    GFXType[GFXType.BOOL3 = 3] = "BOOL3", GFXType[GFXType.BOOL4 = 4] = "BOOL4", GFXType[GFXType.INT = 5] = "INT", 
    GFXType[GFXType.INT2 = 6] = "INT2", GFXType[GFXType.INT3 = 7] = "INT3", GFXType[GFXType.INT4 = 8] = "INT4", 
    GFXType[GFXType.UINT = 9] = "UINT", GFXType[GFXType.UINT2 = 10] = "UINT2", GFXType[GFXType.UINT3 = 11] = "UINT3", 
    GFXType[GFXType.UINT4 = 12] = "UINT4", GFXType[GFXType.FLOAT = 13] = "FLOAT", GFXType[GFXType.FLOAT2 = 14] = "FLOAT2", 
    GFXType[GFXType.FLOAT3 = 15] = "FLOAT3", GFXType[GFXType.FLOAT4 = 16] = "FLOAT4", 
    GFXType[GFXType.MAT2 = 17] = "MAT2", GFXType[GFXType.MAT2X3 = 18] = "MAT2X3", GFXType[GFXType.MAT2X4 = 19] = "MAT2X4", 
    GFXType[GFXType.MAT3X2 = 20] = "MAT3X2", GFXType[GFXType.MAT3 = 21] = "MAT3", GFXType[GFXType.MAT3X4 = 22] = "MAT3X4", 
    GFXType[GFXType.MAT4X2 = 23] = "MAT4X2", GFXType[GFXType.MAT4X3 = 24] = "MAT4X3", 
    GFXType[GFXType.MAT4 = 25] = "MAT4", GFXType[GFXType.SAMPLER1D = 26] = "SAMPLER1D", 
    GFXType[GFXType.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", GFXType[GFXType.SAMPLER2D = 28] = "SAMPLER2D", 
    GFXType[GFXType.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", GFXType[GFXType.SAMPLER3D = 30] = "SAMPLER3D", 
    GFXType[GFXType.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", GFXType[GFXType.COUNT = 32] = "COUNT";
}(GFXType || (GFXType = {})), function(GFXFormat) {
    GFXFormat[GFXFormat.UNKNOWN = 0] = "UNKNOWN", GFXFormat[GFXFormat.A8 = 1] = "A8", 
    GFXFormat[GFXFormat.L8 = 2] = "L8", GFXFormat[GFXFormat.LA8 = 3] = "LA8", GFXFormat[GFXFormat.R8 = 4] = "R8", 
    GFXFormat[GFXFormat.R8SN = 5] = "R8SN", GFXFormat[GFXFormat.R8UI = 6] = "R8UI", 
    GFXFormat[GFXFormat.R8I = 7] = "R8I", GFXFormat[GFXFormat.R16F = 8] = "R16F", GFXFormat[GFXFormat.R16UI = 9] = "R16UI", 
    GFXFormat[GFXFormat.R16I = 10] = "R16I", GFXFormat[GFXFormat.R32F = 11] = "R32F", 
    GFXFormat[GFXFormat.R32UI = 12] = "R32UI", GFXFormat[GFXFormat.R32I = 13] = "R32I", 
    GFXFormat[GFXFormat.RG8 = 14] = "RG8", GFXFormat[GFXFormat.RG8SN = 15] = "RG8SN", 
    GFXFormat[GFXFormat.RG8UI = 16] = "RG8UI", GFXFormat[GFXFormat.RG8I = 17] = "RG8I", 
    GFXFormat[GFXFormat.RG16F = 18] = "RG16F", GFXFormat[GFXFormat.RG16UI = 19] = "RG16UI", 
    GFXFormat[GFXFormat.RG16I = 20] = "RG16I", GFXFormat[GFXFormat.RG32F = 21] = "RG32F", 
    GFXFormat[GFXFormat.RG32UI = 22] = "RG32UI", GFXFormat[GFXFormat.RG32I = 23] = "RG32I", 
    GFXFormat[GFXFormat.RGB8 = 24] = "RGB8", GFXFormat[GFXFormat.SRGB8 = 25] = "SRGB8", 
    GFXFormat[GFXFormat.RGB8SN = 26] = "RGB8SN", GFXFormat[GFXFormat.RGB8UI = 27] = "RGB8UI", 
    GFXFormat[GFXFormat.RGB8I = 28] = "RGB8I", GFXFormat[GFXFormat.RGB16F = 29] = "RGB16F", 
    GFXFormat[GFXFormat.RGB16UI = 30] = "RGB16UI", GFXFormat[GFXFormat.RGB16I = 31] = "RGB16I", 
    GFXFormat[GFXFormat.RGB32F = 32] = "RGB32F", GFXFormat[GFXFormat.RGB32UI = 33] = "RGB32UI", 
    GFXFormat[GFXFormat.RGB32I = 34] = "RGB32I", GFXFormat[GFXFormat.RGBA8 = 35] = "RGBA8", 
    GFXFormat[GFXFormat.SRGB8_A8 = 36] = "SRGB8_A8", GFXFormat[GFXFormat.RGBA8SN = 37] = "RGBA8SN", 
    GFXFormat[GFXFormat.RGBA8UI = 38] = "RGBA8UI", GFXFormat[GFXFormat.RGBA8I = 39] = "RGBA8I", 
    GFXFormat[GFXFormat.RGBA16F = 40] = "RGBA16F", GFXFormat[GFXFormat.RGBA16UI = 41] = "RGBA16UI", 
    GFXFormat[GFXFormat.RGBA16I = 42] = "RGBA16I", GFXFormat[GFXFormat.RGBA32F = 43] = "RGBA32F", 
    GFXFormat[GFXFormat.RGBA32UI = 44] = "RGBA32UI", GFXFormat[GFXFormat.RGBA32I = 45] = "RGBA32I", 
    GFXFormat[GFXFormat.R5G6B5 = 46] = "R5G6B5", GFXFormat[GFXFormat.R11G11B10F = 47] = "R11G11B10F", 
    GFXFormat[GFXFormat.RGB5A1 = 48] = "RGB5A1", GFXFormat[GFXFormat.RGBA4 = 49] = "RGBA4", 
    GFXFormat[GFXFormat.RGB10A2 = 50] = "RGB10A2", GFXFormat[GFXFormat.RGB10A2UI = 51] = "RGB10A2UI", 
    GFXFormat[GFXFormat.RGB9E5 = 52] = "RGB9E5", GFXFormat[GFXFormat.D16 = 53] = "D16", 
    GFXFormat[GFXFormat.D16S8 = 54] = "D16S8", GFXFormat[GFXFormat.D24 = 55] = "D24", 
    GFXFormat[GFXFormat.D24S8 = 56] = "D24S8", GFXFormat[GFXFormat.D32F = 57] = "D32F", 
    GFXFormat[GFXFormat.D32F_S8 = 58] = "D32F_S8", GFXFormat[GFXFormat.BC1 = 59] = "BC1", 
    GFXFormat[GFXFormat.BC1_ALPHA = 60] = "BC1_ALPHA", GFXFormat[GFXFormat.BC1_SRGB = 61] = "BC1_SRGB", 
    GFXFormat[GFXFormat.BC1_SRGB_ALPHA = 62] = "BC1_SRGB_ALPHA", GFXFormat[GFXFormat.BC2 = 63] = "BC2", 
    GFXFormat[GFXFormat.BC2_SRGB = 64] = "BC2_SRGB", GFXFormat[GFXFormat.BC3 = 65] = "BC3", 
    GFXFormat[GFXFormat.BC3_SRGB = 66] = "BC3_SRGB", GFXFormat[GFXFormat.BC4 = 67] = "BC4", 
    GFXFormat[GFXFormat.BC4_SNORM = 68] = "BC4_SNORM", GFXFormat[GFXFormat.BC5 = 69] = "BC5", 
    GFXFormat[GFXFormat.BC5_SNORM = 70] = "BC5_SNORM", GFXFormat[GFXFormat.BC6H_UF16 = 71] = "BC6H_UF16", 
    GFXFormat[GFXFormat.BC6H_SF16 = 72] = "BC6H_SF16", GFXFormat[GFXFormat.BC7 = 73] = "BC7", 
    GFXFormat[GFXFormat.BC7_SRGB = 74] = "BC7_SRGB", GFXFormat[GFXFormat.ETC_RGB8 = 75] = "ETC_RGB8", 
    GFXFormat[GFXFormat.ETC2_RGB8 = 76] = "ETC2_RGB8", GFXFormat[GFXFormat.ETC2_SRGB8 = 77] = "ETC2_SRGB8", 
    GFXFormat[GFXFormat.ETC2_RGB8_A1 = 78] = "ETC2_RGB8_A1", GFXFormat[GFXFormat.ETC2_SRGB8_A1 = 79] = "ETC2_SRGB8_A1", 
    GFXFormat[GFXFormat.ETC2_RGBA8 = 80] = "ETC2_RGBA8", GFXFormat[GFXFormat.ETC2_SRGB8_A8 = 81] = "ETC2_SRGB8_A8", 
    GFXFormat[GFXFormat.EAC_R11 = 82] = "EAC_R11", GFXFormat[GFXFormat.EAC_R11SN = 83] = "EAC_R11SN", 
    GFXFormat[GFXFormat.EAC_RG11 = 84] = "EAC_RG11", GFXFormat[GFXFormat.EAC_RG11SN = 85] = "EAC_RG11SN", 
    GFXFormat[GFXFormat.PVRTC_RGB2 = 86] = "PVRTC_RGB2", GFXFormat[GFXFormat.PVRTC_RGBA2 = 87] = "PVRTC_RGBA2", 
    GFXFormat[GFXFormat.PVRTC_RGB4 = 88] = "PVRTC_RGB4", GFXFormat[GFXFormat.PVRTC_RGBA4 = 89] = "PVRTC_RGBA4", 
    GFXFormat[GFXFormat.PVRTC2_2BPP = 90] = "PVRTC2_2BPP", GFXFormat[GFXFormat.PVRTC2_4BPP = 91] = "PVRTC2_4BPP";
}(GFXFormat || (GFXFormat = {})), function(GFXBufferUsageBit) {
    GFXBufferUsageBit[GFXBufferUsageBit.NONE = 0] = "NONE", GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", 
    GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", GFXBufferUsageBit[GFXBufferUsageBit.INDEX = 4] = "INDEX", 
    GFXBufferUsageBit[GFXBufferUsageBit.VERTEX = 8] = "VERTEX", GFXBufferUsageBit[GFXBufferUsageBit.UNIFORM = 16] = "UNIFORM", 
    GFXBufferUsageBit[GFXBufferUsageBit.STORAGE = 32] = "STORAGE", GFXBufferUsageBit[GFXBufferUsageBit.INDIRECT = 64] = "INDIRECT";
}(GFXBufferUsageBit || (GFXBufferUsageBit = {})), function(GFXMemoryUsageBit) {
    GFXMemoryUsageBit[GFXMemoryUsageBit.NONE = 0] = "NONE", GFXMemoryUsageBit[GFXMemoryUsageBit.DEVICE = 1] = "DEVICE", 
    GFXMemoryUsageBit[GFXMemoryUsageBit.HOST = 2] = "HOST";
}(GFXMemoryUsageBit || (GFXMemoryUsageBit = {})), function(GFXBufferAccessBit) {
    GFXBufferAccessBit[GFXBufferAccessBit.NONE = 0] = "NONE", GFXBufferAccessBit[GFXBufferAccessBit.READ = 1] = "READ", 
    GFXBufferAccessBit[GFXBufferAccessBit.WRITE = 2] = "WRITE";
}(GFXBufferAccessBit || (GFXBufferAccessBit = {})), function(GFXPrimitiveMode) {
    GFXPrimitiveMode[GFXPrimitiveMode.POINT_LIST = 0] = "POINT_LIST", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST = 1] = "LINE_LIST", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP = 2] = "LINE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LOOP = 3] = "LINE_LOOP", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", 
    GFXPrimitiveMode[GFXPrimitiveMode.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST";
}(GFXPrimitiveMode || (GFXPrimitiveMode = {})), function(GFXPolygonMode) {
    GFXPolygonMode[GFXPolygonMode.FILL = 0] = "FILL", GFXPolygonMode[GFXPolygonMode.POINT = 1] = "POINT", 
    GFXPolygonMode[GFXPolygonMode.LINE = 2] = "LINE";
}(GFXPolygonMode || (GFXPolygonMode = {})), function(GFXShadeModel) {
    GFXShadeModel[GFXShadeModel.GOURAND = 0] = "GOURAND", GFXShadeModel[GFXShadeModel.FLAT = 1] = "FLAT";
}(GFXShadeModel || (GFXShadeModel = {})), function(GFXCullMode) {
    GFXCullMode[GFXCullMode.NONE = 0] = "NONE", GFXCullMode[GFXCullMode.FRONT = 1] = "FRONT", 
    GFXCullMode[GFXCullMode.BACK = 2] = "BACK";
}(GFXCullMode || (GFXCullMode = {})), function(GFXComparisonFunc) {
    GFXComparisonFunc[GFXComparisonFunc.NEVER = 0] = "NEVER", GFXComparisonFunc[GFXComparisonFunc.LESS = 1] = "LESS", 
    GFXComparisonFunc[GFXComparisonFunc.EQUAL = 2] = "EQUAL", GFXComparisonFunc[GFXComparisonFunc.LESS_EQUAL = 3] = "LESS_EQUAL", 
    GFXComparisonFunc[GFXComparisonFunc.GREATER = 4] = "GREATER", GFXComparisonFunc[GFXComparisonFunc.NOT_EQUAL = 5] = "NOT_EQUAL", 
    GFXComparisonFunc[GFXComparisonFunc.GREATER_EQUAL = 6] = "GREATER_EQUAL", GFXComparisonFunc[GFXComparisonFunc.ALWAYS = 7] = "ALWAYS";
}(GFXComparisonFunc || (GFXComparisonFunc = {})), function(GFXStencilOp) {
    GFXStencilOp[GFXStencilOp.ZERO = 0] = "ZERO", GFXStencilOp[GFXStencilOp.KEEP = 1] = "KEEP", 
    GFXStencilOp[GFXStencilOp.REPLACE = 2] = "REPLACE", GFXStencilOp[GFXStencilOp.INCR = 3] = "INCR", 
    GFXStencilOp[GFXStencilOp.DECR = 4] = "DECR", GFXStencilOp[GFXStencilOp.INVERT = 5] = "INVERT", 
    GFXStencilOp[GFXStencilOp.INCR_WRAP = 6] = "INCR_WRAP", GFXStencilOp[GFXStencilOp.DECR_WRAP = 7] = "DECR_WRAP";
}(GFXStencilOp || (GFXStencilOp = {})), function(GFXBlendOp) {
    GFXBlendOp[GFXBlendOp.ADD = 0] = "ADD", GFXBlendOp[GFXBlendOp.SUB = 1] = "SUB", 
    GFXBlendOp[GFXBlendOp.REV_SUB = 2] = "REV_SUB", GFXBlendOp[GFXBlendOp.MIN = 3] = "MIN", 
    GFXBlendOp[GFXBlendOp.MAX = 4] = "MAX";
}(GFXBlendOp || (GFXBlendOp = {})), function(GFXBlendFactor) {
    GFXBlendFactor[GFXBlendFactor.ZERO = 0] = "ZERO", GFXBlendFactor[GFXBlendFactor.ONE = 1] = "ONE", 
    GFXBlendFactor[GFXBlendFactor.SRC_ALPHA = 2] = "SRC_ALPHA", GFXBlendFactor[GFXBlendFactor.DST_ALPHA = 3] = "DST_ALPHA", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", 
    GFXBlendFactor[GFXBlendFactor.SRC_COLOR = 6] = "SRC_COLOR", GFXBlendFactor[GFXBlendFactor.DST_COLOR = 7] = "DST_COLOR", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", 
    GFXBlendFactor[GFXBlendFactor.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", GFXBlendFactor[GFXBlendFactor.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", 
    GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", 
    GFXBlendFactor[GFXBlendFactor.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA";
}(GFXBlendFactor || (GFXBlendFactor = {})), function(GFXColorMask) {
    GFXColorMask[GFXColorMask.NONE = 0] = "NONE", GFXColorMask[GFXColorMask.R = 1] = "R", 
    GFXColorMask[GFXColorMask.G = 2] = "G", GFXColorMask[GFXColorMask.B = 4] = "B", 
    GFXColorMask[GFXColorMask.A = 8] = "A", GFXColorMask[GFXColorMask.ALL = 15] = "ALL";
}(GFXColorMask || (GFXColorMask = {})), function(GFXFilter) {
    GFXFilter[GFXFilter.NONE = 0] = "NONE", GFXFilter[GFXFilter.POINT = 1] = "POINT", 
    GFXFilter[GFXFilter.LINEAR = 2] = "LINEAR", GFXFilter[GFXFilter.ANISOTROPIC = 3] = "ANISOTROPIC";
}(GFXFilter || (GFXFilter = {})), function(GFXAddress) {
    GFXAddress[GFXAddress.WRAP = 0] = "WRAP", GFXAddress[GFXAddress.MIRROR = 1] = "MIRROR", 
    GFXAddress[GFXAddress.CLAMP = 2] = "CLAMP", GFXAddress[GFXAddress.BORDER = 3] = "BORDER";
}(GFXAddress || (GFXAddress = {})), function(GFXTextureType) {
    GFXTextureType[GFXTextureType.TEX1D = 0] = "TEX1D", GFXTextureType[GFXTextureType.TEX2D = 1] = "TEX2D", 
    GFXTextureType[GFXTextureType.TEX3D = 2] = "TEX3D";
}(GFXTextureType || (GFXTextureType = {})), function(GFXTextureUsageBit) {
    GFXTextureUsageBit[GFXTextureUsageBit.NONE = 0] = "NONE", GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", 
    GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", GFXTextureUsageBit[GFXTextureUsageBit.SAMPLED = 4] = "SAMPLED", 
    GFXTextureUsageBit[GFXTextureUsageBit.STORAGE = 8] = "STORAGE", GFXTextureUsageBit[GFXTextureUsageBit.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", 
    GFXTextureUsageBit[GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", 
    GFXTextureUsageBit[GFXTextureUsageBit.TRANSIENT_ATTACHMENT = 64] = "TRANSIENT_ATTACHMENT", 
    GFXTextureUsageBit[GFXTextureUsageBit.INPUT_ATTACHMENT = 128] = "INPUT_ATTACHMENT";
}(GFXTextureUsageBit || (GFXTextureUsageBit = {})), function(GFXSampleCount) {
    GFXSampleCount[GFXSampleCount.X1 = 0] = "X1", GFXSampleCount[GFXSampleCount.X2 = 1] = "X2", 
    GFXSampleCount[GFXSampleCount.X4 = 2] = "X4", GFXSampleCount[GFXSampleCount.X8 = 3] = "X8", 
    GFXSampleCount[GFXSampleCount.X16 = 4] = "X16", GFXSampleCount[GFXSampleCount.X32 = 5] = "X32", 
    GFXSampleCount[GFXSampleCount.X64 = 6] = "X64";
}(GFXSampleCount || (GFXSampleCount = {})), function(GFXTextureFlagBit) {
    GFXTextureFlagBit[GFXTextureFlagBit.NONE = 0] = "NONE", GFXTextureFlagBit[GFXTextureFlagBit.GEN_MIPMAP = 1] = "GEN_MIPMAP", 
    GFXTextureFlagBit[GFXTextureFlagBit.CUBEMAP = 2] = "CUBEMAP", GFXTextureFlagBit[GFXTextureFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER";
}(GFXTextureFlagBit || (GFXTextureFlagBit = {})), function(GFXTextureViewType) {
    GFXTextureViewType[GFXTextureViewType.TV1D = 0] = "TV1D", GFXTextureViewType[GFXTextureViewType.TV2D = 1] = "TV2D", 
    GFXTextureViewType[GFXTextureViewType.TV3D = 2] = "TV3D", GFXTextureViewType[GFXTextureViewType.CUBE = 3] = "CUBE", 
    GFXTextureViewType[GFXTextureViewType.TV1D_ARRAY = 4] = "TV1D_ARRAY", GFXTextureViewType[GFXTextureViewType.TV2D_ARRAY = 5] = "TV2D_ARRAY";
}(GFXTextureViewType || (GFXTextureViewType = {})), function(GFXShaderType) {
    GFXShaderType[GFXShaderType.VERTEX = 0] = "VERTEX", GFXShaderType[GFXShaderType.HULL = 1] = "HULL", 
    GFXShaderType[GFXShaderType.DOMAIN = 2] = "DOMAIN", GFXShaderType[GFXShaderType.GEOMETRY = 3] = "GEOMETRY", 
    GFXShaderType[GFXShaderType.FRAGMENT = 4] = "FRAGMENT", GFXShaderType[GFXShaderType.COMPUTE = 5] = "COMPUTE", 
    GFXShaderType[GFXShaderType.COUNT = 6] = "COUNT";
}(GFXShaderType || (GFXShaderType = {})), function(GFXBindingType) {
    GFXBindingType[GFXBindingType.UNKNOWN = 0] = "UNKNOWN", GFXBindingType[GFXBindingType.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", 
    GFXBindingType[GFXBindingType.SAMPLER = 2] = "SAMPLER", GFXBindingType[GFXBindingType.STORAGE_BUFFER = 3] = "STORAGE_BUFFER";
}(GFXBindingType || (GFXBindingType = {})), function(GFXCommandBufferType) {
    GFXCommandBufferType[GFXCommandBufferType.PRIMARY = 0] = "PRIMARY", GFXCommandBufferType[GFXCommandBufferType.SECONDARY = 1] = "SECONDARY";
}(GFXCommandBufferType || (GFXCommandBufferType = {})), function(GFXLoadOp) {
    GFXLoadOp[GFXLoadOp.LOAD = 0] = "LOAD", GFXLoadOp[GFXLoadOp.CLEAR = 1] = "CLEAR", 
    GFXLoadOp[GFXLoadOp.DISCARD = 2] = "DISCARD";
}(GFXLoadOp || (GFXLoadOp = {})), function(GFXStoreOp) {
    GFXStoreOp[GFXStoreOp.STORE = 0] = "STORE", GFXStoreOp[GFXStoreOp.DISCARD = 1] = "DISCARD";
}(GFXStoreOp || (GFXStoreOp = {})), function(GFXTextureLayout) {
    GFXTextureLayout[GFXTextureLayout.UNDEFINED = 0] = "UNDEFINED", GFXTextureLayout[GFXTextureLayout.GENERAL = 1] = "GENERAL", 
    GFXTextureLayout[GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL = 2] = "COLOR_ATTACHMENT_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_READONLY_OPTIMAL = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.SHADER_READONLY_OPTIMAL = 5] = "SHADER_READONLY_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.TRANSFER_SRC_OPTIMAL = 6] = "TRANSFER_SRC_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.TRANSFER_DST_OPTIMAL = 7] = "TRANSFER_DST_OPTIMAL", 
    GFXTextureLayout[GFXTextureLayout.PREINITIALIZED = 8] = "PREINITIALIZED", GFXTextureLayout[GFXTextureLayout.PRESENT_SRC = 9] = "PRESENT_SRC";
}(GFXTextureLayout || (GFXTextureLayout = {})), function(GFXPipelineBindPoint) {
    GFXPipelineBindPoint[GFXPipelineBindPoint.GRAPHICS = 0] = "GRAPHICS", GFXPipelineBindPoint[GFXPipelineBindPoint.COMPUTE = 1] = "COMPUTE", 
    GFXPipelineBindPoint[GFXPipelineBindPoint.RAY_TRACING = 2] = "RAY_TRACING";
}(GFXPipelineBindPoint || (GFXPipelineBindPoint = {})), function(GFXDynamicState) {
    GFXDynamicState[GFXDynamicState.VIEWPORT = 0] = "VIEWPORT", GFXDynamicState[GFXDynamicState.SCISSOR = 1] = "SCISSOR", 
    GFXDynamicState[GFXDynamicState.LINE_WIDTH = 2] = "LINE_WIDTH", GFXDynamicState[GFXDynamicState.DEPTH_BIAS = 3] = "DEPTH_BIAS", 
    GFXDynamicState[GFXDynamicState.BLEND_CONSTANTS = 4] = "BLEND_CONSTANTS", GFXDynamicState[GFXDynamicState.DEPTH_BOUNDS = 5] = "DEPTH_BOUNDS", 
    GFXDynamicState[GFXDynamicState.STENCIL_WRITE_MASK = 6] = "STENCIL_WRITE_MASK", 
    GFXDynamicState[GFXDynamicState.STENCIL_COMPARE_MASK = 7] = "STENCIL_COMPARE_MASK";
}(GFXDynamicState || (GFXDynamicState = {})), function(GFXStencilFace) {
    GFXStencilFace[GFXStencilFace.FRONT = 0] = "FRONT", GFXStencilFace[GFXStencilFace.BACK = 1] = "BACK", 
    GFXStencilFace[GFXStencilFace.ALL = 2] = "ALL";
}(GFXStencilFace || (GFXStencilFace = {})), function(GFXQueueType) {
    GFXQueueType[GFXQueueType.GRAPHICS = 0] = "GRAPHICS", GFXQueueType[GFXQueueType.COMPUTE = 1] = "COMPUTE", 
    GFXQueueType[GFXQueueType.TRANSFER = 2] = "TRANSFER";
}(GFXQueueType || (GFXQueueType = {})), function(GFXClearFlag) {
    GFXClearFlag[GFXClearFlag.NONE = 0] = "NONE", GFXClearFlag[GFXClearFlag.COLOR = 1] = "COLOR", 
    GFXClearFlag[GFXClearFlag.DEPTH = 2] = "DEPTH", GFXClearFlag[GFXClearFlag.STENCIL = 4] = "STENCIL", 
    GFXClearFlag[GFXClearFlag.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", GFXClearFlag[GFXClearFlag.ALL = 7] = "ALL";
}(GFXClearFlag || (GFXClearFlag = {}));

var GFXFormatType, GFXTextureSubres = function GFXTextureSubres() {
    _classCallCheck(this, GFXTextureSubres), this.baseMipLevel = 0, this.levelCount = 1, 
    this.baseArrayLayer = 0, this.layerCount = 1;
}, GFXBufferTextureCopy = function GFXBufferTextureCopy() {
    _classCallCheck(this, GFXBufferTextureCopy), this.buffOffset = 0, this.buffStride = 0, 
    this.buffTexHeight = 0, this.texOffset = {
        x: 0,
        y: 0,
        z: 0
    }, this.texExtent = {
        width: 0,
        height: 0,
        depth: 0
    }, this.texSubres = new GFXTextureSubres();
};

!function(GFXFormatType) {
    GFXFormatType[GFXFormatType.NONE = 0] = "NONE", GFXFormatType[GFXFormatType.UNORM = 1] = "UNORM", 
    GFXFormatType[GFXFormatType.SNORM = 2] = "SNORM", GFXFormatType[GFXFormatType.UINT = 3] = "UINT", 
    GFXFormatType[GFXFormatType.INT = 4] = "INT", GFXFormatType[GFXFormatType.UFLOAT = 5] = "UFLOAT", 
    GFXFormatType[GFXFormatType.FLOAT = 6] = "FLOAT";
}(GFXFormatType || (GFXFormatType = {}));

var GFXFormatInfos = [ {
    name: "UNKNOWN",
    size: 0,
    count: 0,
    type: GFXFormatType.NONE,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "A8",
    size: 1,
    count: 1,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "L8",
    size: 1,
    count: 1,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "LA8",
    size: 1,
    count: 2,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8",
    size: 1,
    count: 1,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8SN",
    size: 1,
    count: 1,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8UI",
    size: 1,
    count: 1,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8I",
    size: 1,
    count: 1,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R16F",
    size: 2,
    count: 1,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R16UI",
    size: 2,
    count: 1,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R16I",
    size: 2,
    count: 1,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R32F",
    size: 4,
    count: 1,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R32UI",
    size: 4,
    count: 1,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R32I",
    size: 4,
    count: 1,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8",
    size: 2,
    count: 2,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8SN",
    size: 2,
    count: 2,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8UI",
    size: 2,
    count: 2,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8I",
    size: 2,
    count: 2,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG16F",
    size: 4,
    count: 2,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG16UI",
    size: 4,
    count: 2,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG16I",
    size: 4,
    count: 2,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG32F",
    size: 8,
    count: 2,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG32UI",
    size: 8,
    count: 2,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG32I",
    size: 8,
    count: 2,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8",
    size: 3,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "SRGB8",
    size: 3,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8SN",
    size: 3,
    count: 3,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8UI",
    size: 3,
    count: 3,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8I",
    size: 3,
    count: 3,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB16F",
    size: 6,
    count: 3,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB16UI",
    size: 6,
    count: 3,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB16I",
    size: 6,
    count: 3,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB32F",
    size: 12,
    count: 3,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB32UI",
    size: 12,
    count: 3,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB32I",
    size: 12,
    count: 3,
    type: GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8",
    size: 4,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "SRGB8_A8",
    size: 4,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8SN",
    size: 4,
    count: 4,
    type: GFXFormatType.SNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8UI",
    size: 4,
    count: 4,
    type: GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8I",
    size: 4,
    count: 4,
    type: GFXFormatType.INT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA16F",
    size: 8,
    count: 4,
    type: GFXFormatType.FLOAT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA16UI",
    size: 8,
    count: 4,
    type: GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA16I",
    size: 8,
    count: 4,
    type: GFXFormatType.INT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA32F",
    size: 16,
    count: 4,
    type: GFXFormatType.FLOAT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA32UI",
    size: 16,
    count: 4,
    type: GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA32I",
    size: 16,
    count: 4,
    type: GFXFormatType.INT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R5G6B5",
    size: 2,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R11G11B10F",
    size: 4,
    count: 3,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB5A1",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA4",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB10A2",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB10A2UI",
    size: 2,
    count: 4,
    type: GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB9E5",
    size: 2,
    count: 4,
    type: GFXFormatType.FLOAT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D16",
    size: 2,
    count: 1,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D16S8",
    size: 3,
    count: 2,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !0,
    isCompressed: !1
}, {
    name: "D24",
    size: 3,
    count: 1,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D24S8",
    size: 4,
    count: 2,
    type: GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !0,
    isCompressed: !1
}, {
    name: "D32F",
    size: 4,
    count: 1,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D32FS8",
    size: 5,
    count: 2,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !0,
    isCompressed: !1
}, {
    name: "BC1",
    size: 1,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC1_ALPHA",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC1_SRGB",
    size: 1,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC1_SRGB_ALPHA",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC2",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC2_SRGB",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC3",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC3_SRGB",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC4",
    size: 1,
    count: 1,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC4_SNORM",
    size: 1,
    count: 1,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC5",
    size: 1,
    count: 2,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC5_SNORM",
    size: 1,
    count: 2,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC6H_UF16",
    size: 1,
    count: 3,
    type: GFXFormatType.UFLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC6H_SF16",
    size: 1,
    count: 3,
    type: GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC7",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC7_SRGB",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC_RGB8",
    size: 1,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_RGB8",
    size: 1,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_SRGB8",
    size: 1,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_RGB8_A1",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_SRGB8_A1",
    size: 1,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_RGBA8",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_SRGB8_A8",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_R11",
    size: 1,
    count: 1,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_R11SN",
    size: 1,
    count: 1,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_RG11",
    size: 2,
    count: 2,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_RG11SN",
    size: 2,
    count: 2,
    type: GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGB2",
    size: 2,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGBA2",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGB4",
    size: 2,
    count: 3,
    type: GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGBA4",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC2_2BPP",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC2_4BPP",
    size: 2,
    count: 4,
    type: GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
} ];

function GFXFormatSize(format, width, height, depth) {
    if (!GFXFormatInfos[format].isCompressed) return width * height * depth * GFXFormatInfos[format].size;
    switch (format) {
      case GFXFormat.BC1:
      case GFXFormat.BC1_ALPHA:
      case GFXFormat.BC1_SRGB:
      case GFXFormat.BC1_SRGB_ALPHA:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

      case GFXFormat.BC2:
      case GFXFormat.BC2_SRGB:
      case GFXFormat.BC3:
      case GFXFormat.BC3_SRGB:
      case GFXFormat.BC4:
      case GFXFormat.BC4_SNORM:
      case GFXFormat.BC6H_SF16:
      case GFXFormat.BC6H_UF16:
      case GFXFormat.BC7:
      case GFXFormat.BC7_SRGB:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case GFXFormat.BC5:
      case GFXFormat.BC5_SNORM:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

      case GFXFormat.ETC_RGB8:
      case GFXFormat.ETC2_RGB8:
      case GFXFormat.ETC2_SRGB8:
      case GFXFormat.ETC2_RGB8_A1:
      case GFXFormat.ETC2_SRGB8_A1:
      case GFXFormat.EAC_R11:
      case GFXFormat.EAC_R11SN:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

      case GFXFormat.EAC_RG11:
      case GFXFormat.EAC_RG11SN:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case GFXFormat.PVRTC_RGB2:
      case GFXFormat.PVRTC_RGBA2:
      case GFXFormat.PVRTC2_2BPP:
        return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

      case GFXFormat.PVRTC_RGB4:
      case GFXFormat.PVRTC_RGBA4:
      case GFXFormat.PVRTC2_4BPP:
        return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 2) * depth;

      default:
        return 0;
    }
}

function GFXFormatSurfaceSize(format, width, height, depth, mips) {
    for (var size = 0, i = 0; i < mips; ++i) size += GFXFormatSize(format, width, height, depth), 
    width = Math.max(width >> 1, 1), height = Math.max(height >> 1, 1), depth = Math.max(depth >> 1, 1);
    return size;
}

function GFXGetTypeSize(type) {
    switch (type) {
      case GFXType.BOOL:
      case GFXType.INT:
      case GFXType.UINT:
      case GFXType.FLOAT:
        return 4;

      case GFXType.BOOL2:
      case GFXType.INT2:
      case GFXType.UINT2:
      case GFXType.FLOAT2:
        return 8;

      case GFXType.BOOL3:
      case GFXType.INT3:
      case GFXType.UINT3:
      case GFXType.FLOAT3:
        return 12;

      case GFXType.BOOL4:
      case GFXType.INT4:
      case GFXType.UINT4:
      case GFXType.FLOAT4:
      case GFXType.MAT2:
        return 16;

      case GFXType.MAT2X3:
        return 24;

      case GFXType.MAT2X4:
        return 32;

      case GFXType.MAT3X2:
        return 24;

      case GFXType.MAT3:
        return 36;

      case GFXType.MAT3X4:
        return 48;

      case GFXType.MAT4X2:
      case GFXType.MAT4X2:
        return 32;

      case GFXType.MAT4:
        return 64;

      case GFXType.SAMPLER1D:
      case GFXType.SAMPLER1D_ARRAY:
      case GFXType.SAMPLER2D:
      case GFXType.SAMPLER2D_ARRAY:
      case GFXType.SAMPLER3D:
      case GFXType.SAMPLER_CUBE:
        return 4;

      default:
        return 0;
    }
}

var PixelFormat, WrapMode, Filter, DepthStencilFormat, GFXAPI, GFXFeature, GFXDefines = Object.freeze({
    GFX_MAX_VERTEX_ATTRIBUTES: 16,
    GFX_MAX_TEXTURE_UNITS: 16,
    GFX_MAX_ATTACHMENTS: 4,
    GFX_MAX_BUFFER_BINDINGS: GFX_MAX_BUFFER_BINDINGS,
    get GFXObjectType() {
        return GFXObjectType;
    },
    get GFXStatus() {
        return GFXStatus;
    },
    GFXObject: GFXObject,
    get GFXAttributeName() {
        return GFXAttributeName;
    },
    get GFXType() {
        return GFXType;
    },
    get GFXFormat() {
        return GFXFormat;
    },
    get GFXBufferUsageBit() {
        return GFXBufferUsageBit;
    },
    get GFXMemoryUsageBit() {
        return GFXMemoryUsageBit;
    },
    get GFXBufferAccessBit() {
        return GFXBufferAccessBit;
    },
    get GFXPrimitiveMode() {
        return GFXPrimitiveMode;
    },
    get GFXPolygonMode() {
        return GFXPolygonMode;
    },
    get GFXShadeModel() {
        return GFXShadeModel;
    },
    get GFXCullMode() {
        return GFXCullMode;
    },
    get GFXComparisonFunc() {
        return GFXComparisonFunc;
    },
    get GFXStencilOp() {
        return GFXStencilOp;
    },
    get GFXBlendOp() {
        return GFXBlendOp;
    },
    get GFXBlendFactor() {
        return GFXBlendFactor;
    },
    get GFXColorMask() {
        return GFXColorMask;
    },
    get GFXFilter() {
        return GFXFilter;
    },
    get GFXAddress() {
        return GFXAddress;
    },
    get GFXTextureType() {
        return GFXTextureType;
    },
    get GFXTextureUsageBit() {
        return GFXTextureUsageBit;
    },
    get GFXSampleCount() {
        return GFXSampleCount;
    },
    get GFXTextureFlagBit() {
        return GFXTextureFlagBit;
    },
    get GFXTextureViewType() {
        return GFXTextureViewType;
    },
    get GFXShaderType() {
        return GFXShaderType;
    },
    get GFXBindingType() {
        return GFXBindingType;
    },
    get GFXCommandBufferType() {
        return GFXCommandBufferType;
    },
    get GFXLoadOp() {
        return GFXLoadOp;
    },
    get GFXStoreOp() {
        return GFXStoreOp;
    },
    get GFXTextureLayout() {
        return GFXTextureLayout;
    },
    get GFXPipelineBindPoint() {
        return GFXPipelineBindPoint;
    },
    get GFXDynamicState() {
        return GFXDynamicState;
    },
    get GFXStencilFace() {
        return GFXStencilFace;
    },
    get GFXQueueType() {
        return GFXQueueType;
    },
    get GFXClearFlag() {
        return GFXClearFlag;
    },
    GFXTextureSubres: GFXTextureSubres,
    GFXTextureCopy: function GFXTextureCopy() {
        _classCallCheck(this, GFXTextureCopy), this.srcSubres = new GFXTextureSubres(), 
        this.srcOffset = {
            x: 0,
            y: 0,
            z: 0
        }, this.dstSubres = new GFXTextureSubres(), this.dstOffset = {
            x: 0,
            y: 0,
            z: 0
        }, this.extent = {
            width: 0,
            height: 0,
            depth: 0
        };
    },
    GFXBufferTextureCopy: GFXBufferTextureCopy,
    get GFXFormatType() {
        return GFXFormatType;
    },
    GFXFormatInfos: GFXFormatInfos,
    GFXFormatSize: GFXFormatSize,
    GFXFormatSurfaceSize: GFXFormatSurfaceSize,
    GFXGetTypeSize: GFXGetTypeSize
});

!function(PixelFormat) {
    PixelFormat[PixelFormat.RGB565 = GFXFormat.R5G6B5] = "RGB565", PixelFormat[PixelFormat.RGB5A1 = GFXFormat.RGB5A1] = "RGB5A1", 
    PixelFormat[PixelFormat.RGBA4444 = GFXFormat.RGBA4] = "RGBA4444", PixelFormat[PixelFormat.RGB888 = GFXFormat.RGB8] = "RGB888", 
    PixelFormat[PixelFormat.RGBA8888 = GFXFormat.RGBA8] = "RGBA8888", PixelFormat[PixelFormat.RGBA32F = GFXFormat.RGBA32F] = "RGBA32F", 
    PixelFormat[PixelFormat.A8 = GFXFormat.A8] = "A8", PixelFormat[PixelFormat.I8 = GFXFormat.L8] = "I8", 
    PixelFormat[PixelFormat.AI8 = GFXFormat.LA8] = "AI8", PixelFormat[PixelFormat.RGB_PVRTC_2BPPV1 = GFXFormat.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1", 
    PixelFormat[PixelFormat.RGBA_PVRTC_2BPPV1 = GFXFormat.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1", 
    PixelFormat[PixelFormat.RGB_PVRTC_4BPPV1 = GFXFormat.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1", 
    PixelFormat[PixelFormat.RGBA_PVRTC_4BPPV1 = GFXFormat.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1", 
    PixelFormat[PixelFormat.RGB_ETC1 = GFXFormat.ETC_RGB8] = "RGB_ETC1", PixelFormat[PixelFormat.RGB_ETC2 = GFXFormat.ETC2_RGB8] = "RGB_ETC2", 
    PixelFormat[PixelFormat.RGBA_ETC2 = GFXFormat.ETC2_RGBA8] = "RGBA_ETC2";
}(PixelFormat || (PixelFormat = {})), function(WrapMode) {
    WrapMode[WrapMode.REPEAT = GFXAddress.WRAP] = "REPEAT", WrapMode[WrapMode.CLAMP_TO_EDGE = GFXAddress.CLAMP] = "CLAMP_TO_EDGE", 
    WrapMode[WrapMode.MIRRORED_REPEAT = GFXAddress.MIRROR] = "MIRRORED_REPEAT", WrapMode[WrapMode.CLAMP_TO_BORDER = GFXAddress.BORDER] = "CLAMP_TO_BORDER";
}(WrapMode || (WrapMode = {})), function(Filter) {
    Filter[Filter.NONE = GFXFilter.NONE] = "NONE", Filter[Filter.LINEAR = GFXFilter.LINEAR] = "LINEAR", 
    Filter[Filter.NEAREST = GFXFilter.POINT] = "NEAREST";
}(Filter || (Filter = {})), function(DepthStencilFormat) {
    DepthStencilFormat[DepthStencilFormat.NONE = GFXFormat.UNKNOWN] = "NONE", DepthStencilFormat[DepthStencilFormat.DEPTH_16 = GFXFormat.D16] = "DEPTH_16", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_24 = GFXFormat.D24] = "DEPTH_24", DepthStencilFormat[DepthStencilFormat.DEPTH_32 = GFXFormat.D32F] = "DEPTH_32", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_16_STENCIL_8 = GFXFormat.D16S8] = "DEPTH_16_STENCIL_8", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_24_STENCIL_8 = GFXFormat.D24S8] = "DEPTH_24_STENCIL_8", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_32_STENCIL_8 = GFXFormat.D32F_S8] = "DEPTH_32_STENCIL_8";
}(DepthStencilFormat || (DepthStencilFormat = {})), ccenum(GFXFormat), function(GFXAPI) {
    GFXAPI[GFXAPI.UNKNOWN = 0] = "UNKNOWN", GFXAPI[GFXAPI.WEBGL = 1] = "WEBGL", GFXAPI[GFXAPI.WEBGL2 = 2] = "WEBGL2";
}(GFXAPI || (GFXAPI = {})), function(GFXFeature) {
    GFXFeature[GFXFeature.COLOR_FLOAT = 0] = "COLOR_FLOAT", GFXFeature[GFXFeature.COLOR_HALF_FLOAT = 1] = "COLOR_HALF_FLOAT", 
    GFXFeature[GFXFeature.TEXTURE_FLOAT = 2] = "TEXTURE_FLOAT", GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT = 3] = "TEXTURE_HALF_FLOAT", 
    GFXFeature[GFXFeature.TEXTURE_FLOAT_LINEAR = 4] = "TEXTURE_FLOAT_LINEAR", GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR = 5] = "TEXTURE_HALF_FLOAT_LINEAR", 
    GFXFeature[GFXFeature.FORMAT_R11G11B10F = 6] = "FORMAT_R11G11B10F", GFXFeature[GFXFeature.FORMAT_D24S8 = 7] = "FORMAT_D24S8", 
    GFXFeature[GFXFeature.FORMAT_ETC1 = 8] = "FORMAT_ETC1", GFXFeature[GFXFeature.FORMAT_ETC2 = 9] = "FORMAT_ETC2", 
    GFXFeature[GFXFeature.FORMAT_DXT = 10] = "FORMAT_DXT", GFXFeature[GFXFeature.FORMAT_PVRTC = 11] = "FORMAT_PVRTC", 
    GFXFeature[GFXFeature.MSAA = 12] = "MSAA", GFXFeature[GFXFeature.COUNT = 13] = "COUNT";
}(GFXFeature || (GFXFeature = {}));

var _dec$5, _dec2$2, _class$5, _class2$4, _class3$3, _temp$4, SamplerInfoIndex, GFXDevice = function() {
    function GFXDevice() {
        _classCallCheck(this, GFXDevice), this._canvas = null, this._canvas2D = null, this._gfxAPI = GFXAPI.UNKNOWN, 
        this._deviceName = "", this._renderer = "", this._vendor = "", this._version = "", 
        this._features = new Array(GFXFeature.COUNT), this._queue = null, this._devicePixelRatio = 1, 
        this._width = 0, this._height = 0, this._nativeWidth = 0, this._nativeHeight = 0, 
        this._mainWindow = null, this._cmdAllocator = null, this._maxVertexAttributes = 0, 
        this._maxVertexUniformVectors = 0, this._maxFragmentUniformVectors = 0, this._maxTextureUnits = 0, 
        this._maxVertexTextureUnits = 0, this._maxUniformBufferBindings = GFX_MAX_BUFFER_BINDINGS, 
        this._maxUniformBlockSize = 0, this._depthBits = 0, this._stencilBits = 0, this._colorFmt = GFXFormat.UNKNOWN, 
        this._depthStencilFmt = GFXFormat.UNKNOWN, this._shaderIdGen = 0, this._macros = new Map(), 
        this._numDrawCalls = 0, this._numTris = 0, this._memoryStatus = {
            bufferSize: 0,
            textureSize: 0
        };
    }
    return _createClass(GFXDevice, [ {
        key: "hasFeature",
        value: function hasFeature(feature) {
            return this._features[feature];
        }
    }, {
        key: "genShaderId",
        value: function genShaderId() {
            return this._shaderIdGen++;
        }
    }, {
        key: "defineMacro",
        value: function defineMacro(macro, value) {
            var val = void 0 !== value ? value : "";
            this._macros.set(macro, val);
        }
    }, {
        key: "canvas",
        get: function get() {
            return this._canvas;
        }
    }, {
        key: "canvas2D",
        get: function get() {
            return this._canvas2D;
        }
    }, {
        key: "gfxAPI",
        get: function get() {
            return this._gfxAPI;
        }
    }, {
        key: "queue",
        get: function get() {
            return this._queue;
        }
    }, {
        key: "devicePixelRatio",
        get: function get() {
            return this._devicePixelRatio;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "nativeWidth",
        get: function get() {
            return this._nativeWidth;
        }
    }, {
        key: "nativeHeight",
        get: function get() {
            return this._nativeHeight;
        }
    }, {
        key: "mainWindow",
        get: function get() {
            return this._mainWindow;
        }
    }, {
        key: "commandAllocator",
        get: function get() {
            return this._cmdAllocator;
        }
    }, {
        key: "renderer",
        get: function get() {
            return this._renderer;
        }
    }, {
        key: "vendor",
        get: function get() {
            return this._vendor;
        }
    }, {
        key: "maxVertexAttributes",
        get: function get() {
            return this._maxVertexAttributes;
        }
    }, {
        key: "maxVertexUniformVectors",
        get: function get() {
            return this._maxVertexUniformVectors;
        }
    }, {
        key: "maxFragmentUniformVectors",
        get: function get() {
            return this._maxFragmentUniformVectors;
        }
    }, {
        key: "maxTextureUnits",
        get: function get() {
            return this._maxTextureUnits;
        }
    }, {
        key: "maxVertexTextureUnits",
        get: function get() {
            return this._maxVertexTextureUnits;
        }
    }, {
        key: "maxUniformBufferBindings",
        get: function get() {
            return this._maxUniformBufferBindings;
        }
    }, {
        key: "maxUniformBlockSize",
        get: function get() {
            return this._maxUniformBlockSize;
        }
    }, {
        key: "depthBits",
        get: function get() {
            return this._depthBits;
        }
    }, {
        key: "stencilBits",
        get: function get() {
            return this._stencilBits;
        }
    }, {
        key: "colorFormat",
        get: function get() {
            return this._colorFmt;
        }
    }, {
        key: "depthStencilFormat",
        get: function get() {
            return this._depthStencilFmt;
        }
    }, {
        key: "macros",
        get: function get() {
            return this._macros;
        }
    }, {
        key: "numDrawCalls",
        get: function get() {
            return this._numDrawCalls;
        }
    }, {
        key: "numTris",
        get: function get() {
            return this._numTris;
        }
    }, {
        key: "memoryStatus",
        get: function get() {
            return this._memoryStatus;
        }
    } ]), GFXDevice;
}(), ImageAsset = (_dec$5 = ccclass("cc.ImageAsset"), _dec2$2 = property({
    override: !0
}), _dec$5((_temp$4 = _class3$3 = function(_Asset) {
    function ImageAsset(nativeAsset) {
        var _this;
        return _classCallCheck(this, ImageAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ImageAsset).call(this)))._nativeData = void 0, 
        _this._url = void 0, _this._exportedExts = void 0, _this._format = PixelFormat.RGBA8888, 
        _this._width = 0, _this._height = 0, _this._url = "", _this.loaded = !1, _this._nativeData = {
            _data: null,
            width: 0,
            height: 0,
            format: 0,
            _compressed: !1
        }, void 0 !== nativeAsset && (_this._nativeAsset = nativeAsset), _this;
    }
    return _inherits(ImageAsset, Asset), _createClass(ImageAsset, [ {
        key: "_nativeAsset",
        get: function get() {
            return this._nativeData;
        },
        set: function set(value) {
            this.reset(value);
        }
    }, {
        key: "data",
        get: function get() {
            return "_data" in this._nativeData ? this._nativeData._data : this._nativeData;
        }
    }, {
        key: "width",
        get: function get() {
            return this._nativeData.width || this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._nativeData.height || this._height;
        }
    }, {
        key: "format",
        get: function get() {
            return this._format;
        }
    }, {
        key: "isCompressed",
        get: function get() {
            return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
        }
    }, {
        key: "url",
        get: function get() {
            return this._url;
        }
    } ]), _createClass(ImageAsset, [ {
        key: "reset",
        value: function reset(data) {
            var _this2 = this;
            data instanceof HTMLElement ? (this._nativeData = data, data.complete || data instanceof HTMLCanvasElement ? this._onDataComplete() : (this.loaded = !1, 
            data.addEventListener("load", function() {
                _this2._onDataComplete();
            }), data.addEventListener("error", function(err) {
                cc.warnID(3119, err.message);
            }))) : (this._nativeData = data, this._nativeData.format = this._format, this._onDataComplete());
        }
    }, {
        key: "_serialize",
        value: function _serialize() {
            var targetExtensions = this._exportedExts;
            if (!targetExtensions && this._native && (targetExtensions = [ this._native ]), 
            !targetExtensions) return "";
            var extensionIndices = [], _iterator = targetExtensions, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var targetExtension = _ref, extensionFormat = targetExtension.split("@"), i = ImageAsset.extnames.indexOf(extensionFormat[0]), exportedExtensionID = i < 0 ? targetExtension : "".concat(i);
                extensionFormat[1] && (exportedExtensionID += "@" + extensionFormat[1]), extensionIndices.push(exportedExtensionID);
            }
            return {
                fmt: extensionIndices.join("_"),
                w: this.width,
                h: this.height
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(data, handle) {
            var fmtStr = "";
            "string" == typeof data ? fmtStr = data : (this._width = data.w, this._height = data.h, 
            fmtStr = data.fmt);
            var device = function _getGlobalDevice() {
                return cc.director && cc.director.root ? cc.director.root.device : null;
            }(), extensionIDs = fmtStr.split("_"), preferedExtensionIndex = Number.MAX_VALUE, format = this._format, ext = "", SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS, _iterator2 = extensionIDs, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var extFormat = _ref2.split("@"), i = parseInt(extFormat[0], void 0), tmpExt = ImageAsset.extnames[i] || extFormat.join(), index = SupportTextureFormats.indexOf(tmpExt);
                if (-1 !== index && index < preferedExtensionIndex) {
                    var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;
                    if (!(".pvr" !== tmpExt || device && device.hasFeature(GFXFeature.FORMAT_PVRTC))) continue;
                    if (!(fmt !== PixelFormat.RGB_ETC1 || device && device.hasFeature(GFXFeature.FORMAT_ETC1))) continue;
                    if (!(fmt !== PixelFormat.RGB_ETC2 && fmt !== PixelFormat.RGBA_ETC2 || device && device.hasFeature(GFXFeature.FORMAT_ETC2))) continue;
                    if (".webp" === tmpExt && !cc.sys.capabilities.webp) continue;
                    preferedExtensionIndex = index, ext = tmpExt, format = fmt;
                }
            }
            ext && (this._setRawAsset(ext), this._format = format);
            var loadingItem = handle.customEnv, uuid = loadingItem && loadingItem.uuid;
            uuid && (this._uuid = uuid, this._url = this.nativeUrl);
        }
    }, {
        key: "_onDataComplete",
        value: function _onDataComplete() {
            this.loaded = !0, this.emit("load");
        }
    } ]), ImageAsset;
}(), _class3$3.extnames = [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ], 
_applyDecoratedDescriptor((_class2$4 = _temp$4).prototype, "_nativeAsset", [ _dec2$2 ], Object.getOwnPropertyDescriptor(_class2$4.prototype, "_nativeAsset"), _class2$4.prototype), 
_class$5 = _class2$4)) || _class$5);

cc.ImageAsset = ImageAsset, function(SamplerInfoIndex) {
    SamplerInfoIndex[SamplerInfoIndex.minFilter = 0] = "minFilter", SamplerInfoIndex[SamplerInfoIndex.magFilter = 1] = "magFilter", 
    SamplerInfoIndex[SamplerInfoIndex.mipFilter = 2] = "mipFilter", SamplerInfoIndex[SamplerInfoIndex.addressU = 3] = "addressU", 
    SamplerInfoIndex[SamplerInfoIndex.addressV = 4] = "addressV", SamplerInfoIndex[SamplerInfoIndex.addressW = 5] = "addressW", 
    SamplerInfoIndex[SamplerInfoIndex.maxAnisotropy = 6] = "maxAnisotropy", SamplerInfoIndex[SamplerInfoIndex.cmpFunc = 7] = "cmpFunc", 
    SamplerInfoIndex[SamplerInfoIndex.minLOD = 8] = "minLOD", SamplerInfoIndex[SamplerInfoIndex.maxLOD = 9] = "maxLOD", 
    SamplerInfoIndex[SamplerInfoIndex.mipLODBias = 10] = "mipLODBias", SamplerInfoIndex[SamplerInfoIndex.borderColor = 11] = "borderColor", 
    SamplerInfoIndex[SamplerInfoIndex.total = 15] = "total";
}(SamplerInfoIndex || (SamplerInfoIndex = {}));

var defaultInfo = [ GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.NONE, GFXAddress.WRAP, GFXAddress.WRAP, GFXAddress.WRAP, 16, GFXComparisonFunc.NEVER, 0, 0, 0, 0, 0, 0, 0 ], gfxInfo = {};

function genSamplerHash(info) {
    for (var value = 0, hash = 0, i = 0; i < defaultInfo.length; i++) switch (value = info[i] || defaultInfo[i], 
    i) {
      case SamplerInfoIndex.minFilter:
        hash |= value;
        break;

      case SamplerInfoIndex.magFilter:
        hash |= value << 2;
        break;

      case SamplerInfoIndex.mipFilter:
        hash |= value << 4;
        break;

      case SamplerInfoIndex.addressU:
        hash |= value << 6;
        break;

      case SamplerInfoIndex.addressV:
        hash |= value << 8;
        break;

      case SamplerInfoIndex.addressW:
        hash |= value << 10;
        break;

      case SamplerInfoIndex.maxAnisotropy:
        hash |= value << 12;
        break;

      case SamplerInfoIndex.cmpFunc:
        hash |= value << 16;
        break;

      case SamplerInfoIndex.minLOD:
        hash |= value << 20;
        break;

      case SamplerInfoIndex.maxLOD:
        hash |= value << 24;
        break;

      case SamplerInfoIndex.mipLODBias:
        hash |= value << 28;
    }
    return hash;
}

var _class$6, _class2$5, _descriptor$3, _descriptor2$2, _descriptor3$1, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _class3$4, _temp$5, samplerLib = new (function() {
    function SamplerLib() {
        _classCallCheck(this, SamplerLib), this._cache = {};
    }
    return _createClass(SamplerLib, [ {
        key: "getSampler",
        value: function getSampler(device, hash) {
            var cache = this._cache[hash];
            return cache || (0 === hash && (hash = genSamplerHash(defaultInfo)), gfxInfo.minFilter = 3 & hash, 
            gfxInfo.magFilter = hash >> 2 & 3, gfxInfo.mipFilter = hash >> 4 & 3, gfxInfo.addressU = hash >> 6 & 3, 
            gfxInfo.addressV = hash >> 8 & 3, gfxInfo.addressW = hash >> 10 & 3, gfxInfo.maxAnisotropy = hash >> 12 & 15, 
            gfxInfo.cmpFunc = hash >> 16 & 15, gfxInfo.minLOD = hash >> 20 & 15, gfxInfo.maxLOD = hash >> 24 & 15, 
            gfxInfo.mipLODBias = hash >> 28 & 15, gfxInfo.borderColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            }, this._cache[hash] = device.createSampler(gfxInfo));
        }
    } ]), SamplerLib;
}())(), idGenerator = new IDGenerator("Tex"), TextureBase = ccclass("cc.TextureBase")((_temp$5 = _class3$4 = function(_Asset) {
    function TextureBase() {
        var _this, flipY = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return _classCallCheck(this, TextureBase), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureBase).call(this)), "_format", _descriptor$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_premultiplyAlpha", _descriptor2$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_flipY", _descriptor3$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_minFilter", _descriptor4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_magFilter", _descriptor5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_mipFilter", _descriptor6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_wrapS", _descriptor7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_wrapT", _descriptor8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_wrapR", _descriptor9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_anisotropy", _descriptor10, _assertThisInitialized(_this)), 
        _this._width = 0, _this._height = 0, _this._id = void 0, _this._samplerInfo = [], 
        _this._samplerHash = 0, _this._flipY = flipY, _this._id = idGenerator.getNewId(), 
        _this.loaded = !1, _this;
    }
    return _inherits(TextureBase, Asset), _createClass(TextureBase, [ {
        key: "isCompressed",
        get: function get() {
            return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    } ]), _createClass(TextureBase, [ {
        key: "getId",
        value: function getId() {
            return this._id;
        }
    }, {
        key: "getPixelFormat",
        value: function getPixelFormat() {
            return this._format;
        }
    }, {
        key: "hasPremultipliedAlpha",
        value: function hasPremultipliedAlpha() {
            return this._premultiplyAlpha || !1;
        }
    }, {
        key: "getAnisotropy",
        value: function getAnisotropy() {
            return this._anisotropy;
        }
    }, {
        key: "setWrapMode",
        value: function setWrapMode(wrapS, wrapT, wrapR) {
            this._wrapS = wrapS, this._samplerInfo[SamplerInfoIndex.addressU] = wrapS, this._wrapT = wrapT, 
            this._samplerInfo[SamplerInfoIndex.addressV] = wrapT, void 0 !== wrapR && (this._wrapR = wrapR, 
            this._samplerInfo[SamplerInfoIndex.addressW] = wrapR), this._samplerHash = genSamplerHash(this._samplerInfo);
        }
    }, {
        key: "setFilters",
        value: function setFilters(minFilter, magFilter) {
            this._minFilter = minFilter, this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter, 
            this._magFilter = magFilter, this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter, 
            this._samplerHash = genSamplerHash(this._samplerInfo);
        }
    }, {
        key: "setMipFilter",
        value: function setMipFilter(mipFilter) {
            this._mipFilter = mipFilter, this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter, 
            this._samplerInfo[SamplerInfoIndex.maxLOD] = mipFilter === Filter.NONE ? 0 : 1e3, 
            this._samplerHash = genSamplerHash(this._samplerInfo);
        }
    }, {
        key: "setFlipY",
        value: function setFlipY(flipY) {
            this._flipY = flipY;
        }
    }, {
        key: "setPremultiplyAlpha",
        value: function setPremultiplyAlpha(premultiply) {
            this._premultiplyAlpha = premultiply;
        }
    }, {
        key: "setAnisotropy",
        value: function setAnisotropy(anisotropy) {
            this._anisotropy = anisotropy, this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy, 
            this._samplerHash = genSamplerHash(this._samplerInfo);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return _get(_getPrototypeOf(TextureBase.prototype), "destroy", this).call(this);
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return null;
        }
    }, {
        key: "getSamplerHash",
        value: function getSamplerHash() {
            return this._samplerHash;
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0) + "," + this._mipFilter + "," + this._anisotropy + "," + (this._flipY ? 1 : 0);
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializedData, handle) {
            var fields = serializedData.split(",");
            fields.unshift(""), fields.length >= 6 && (this.setFilters(parseInt(fields[1]), parseInt(fields[2])), 
            this.setWrapMode(parseInt(fields[3]), parseInt(fields[4])), this._premultiplyAlpha = 49 === fields[5].charCodeAt(0)), 
            fields.length >= 8 && (this.setMipFilter(parseInt(fields[6])), this.setAnisotropy(parseInt(fields[7]))), 
            fields.length >= 9 && (this._flipY = 49 === fields[8].charCodeAt(0));
        }
    }, {
        key: "_getGFXDevice",
        value: function _getGFXDevice() {
            return cc.director.root && cc.director.root.device;
        }
    }, {
        key: "_getGFXFormat",
        value: function _getGFXFormat() {
            return this._format;
        }
    }, {
        key: "_setGFXFormat",
        value: function _setGFXFormat(format) {
            this._format = void 0 === format ? PixelFormat.RGBA8888 : format;
        }
    } ]), TextureBase;
}(), _class3$4.PixelFormat = PixelFormat, _class3$4.WrapMode = WrapMode, _class3$4.Filter = Filter, 
_descriptor$3 = _applyDecoratedDescriptor((_class2$5 = _temp$5).prototype, "_format", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PixelFormat.RGBA8888;
    }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_premultiplyAlpha", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class2$5.prototype, "_flipY", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor4 = _applyDecoratedDescriptor(_class2$5.prototype, "_minFilter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Filter.LINEAR;
    }
}), _descriptor5 = _applyDecoratedDescriptor(_class2$5.prototype, "_magFilter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Filter.LINEAR;
    }
}), _descriptor6 = _applyDecoratedDescriptor(_class2$5.prototype, "_mipFilter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Filter.NONE;
    }
}), _descriptor7 = _applyDecoratedDescriptor(_class2$5.prototype, "_wrapS", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode.REPEAT;
    }
}), _descriptor8 = _applyDecoratedDescriptor(_class2$5.prototype, "_wrapT", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode.REPEAT;
    }
}), _descriptor9 = _applyDecoratedDescriptor(_class2$5.prototype, "_wrapR", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode.REPEAT;
    }
}), _descriptor10 = _applyDecoratedDescriptor(_class2$5.prototype, "_anisotropy", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 16;
    }
}), _class$6 = _class2$5)) || _class$6;

cc.TextureBase = TextureBase;

var url = {
    _rawAssets: "",
    normalize: function normalize(url) {
        return url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1))), 
        url;
    },
    raw: function raw(url) {
        if ((url = this.normalize(url)).startsWith("resources/")) {
            var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, null, !0);
            if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, !0) + cc.path.extname(url);
        } else cc.errorID(7002, url);
        return this._rawAssets + url;
    },
    _init: function _init(assets) {
        this._rawAssets = cc.path.stripSep(assets) + "/";
    }
};

cc.url = url;

var _qid = 0 | 998 * Math.random(), _queues = createMap(!0), _pool = [], ItemState = {
    WORKING: 1,
    COMPLETE: 2,
    ERROR: 3
}, _queueDeps = createMap(!0);

function _parseUrlParam(url) {
    if (url) {
        var split = url.split("?");
        if (split && split[0] && split[1]) {
            var urlParam = {};
            return split[1].split("&").forEach(function(item) {
                var itemSplit = item.split("=");
                urlParam[itemSplit[0]] = itemSplit[1];
            }), urlParam;
        }
    }
}

function createItem(id, queueId) {
    var url = "object" === _typeof(id) ? id.url : id, result = {
        queueId: queueId,
        id: url,
        url: url,
        rawUrl: void 0,
        urlParam: _parseUrlParam(url),
        type: "",
        error: null,
        content: null,
        complete: !1,
        states: {},
        deps: null,
        isScene: id.uuid && cc.game._sceneInfos.find(function(info) {
            return info.uuid === id.uuid;
        })
    };
    if ("object" === _typeof(id) && (mixin(result, id), id.skips)) for (var i = 0; i < id.skips.length; i++) {
        var skip = id.skips[i];
        result.states[skip] = ItemState.COMPLETE;
    }
    return result.rawUrl = result.url, url && !result.type && (result.type = extname(url).toLowerCase().substr(1)), 
    result;
}

var checkedIds = [];

function checkCircleReference(owner, item, recursiveCall) {
    if (!owner || !item) return !1;
    var result = !1;
    if (checkedIds.push(item.id), item.deps) {
        var i, subDep, deps = item.deps;
        for (i = 0; i < deps.length; i++) {
            if ((subDep = deps[i]).id === owner.id) {
                result = !0;
                break;
            }
            if (!(checkedIds.indexOf(subDep.id) >= 0) && (subDep.deps && checkCircleReference(owner, subDep, !0))) {
                result = !0;
                break;
            }
        }
    }
    return recursiveCall || (checkedIds.length = 0), result;
}

var LoadingItems = function(_CallbacksInvoker) {
    function LoadingItems(pipeline, urlList, onProgress, onComplete) {
        var _this;
        return _classCallCheck(this, LoadingItems), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingItems).call(this)))._id = ++_qid, 
        _queues[_this._id] = _assertThisInitialized(_this), _this._pipeline = pipeline, 
        _this._errorUrls = [], _this._appending = !1, _this._ownerQueue = null, _this.onProgress = onProgress, 
        _this.onComplete = onComplete, _this.map = createMap(!0), _this.completed = {}, 
        _this.totalCount = 0, _this.completedCount = 0, _this._pipeline ? _this.active = !0 : _this.active = !1, 
        urlList && (urlList.length > 0 ? _this.append(urlList) : _this.allComplete()), _this;
    }
    return _inherits(LoadingItems, CallbacksInvoker), _createClass(LoadingItems, [ {
        key: "append",
        value: function append(urlList, owner) {
            if (!this.active) return [];
            owner && !owner.deps && (owner.deps = []), this._appending = !0;
            var i, url, item, id, accepted = [];
            for (i = 0; i < urlList.length; ++i) if (!(url = urlList[i]).queueId || this.map[url.id]) {
                if ("string" == typeof ((id = url).url || id)) {
                    var key = (item = createItem(url, this._id)).id;
                    this.map[key] || (this.map[key] = item, this.totalCount++, owner && owner.deps.push(item), 
                    LoadingItems.registerQueueDep(owner || this._id, key), accepted.push(item));
                }
            } else {
                if (this.map[url.id] = url, owner && owner.deps.push(url), url.complete || checkCircleReference(owner, url)) {
                    this.totalCount++, this.itemComplete(url.id);
                    continue;
                }
                var self = this, queue = _queues[url.queueId];
                queue && (this.totalCount++, LoadingItems.registerQueueDep(owner || this._id, url.id), 
                queue.addListener(url.id, function(item) {
                    self.itemComplete(item.id);
                }));
            }
            return this._appending = !1, this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted), 
            accepted;
        }
    }, {
        key: "_childOnProgress",
        value: function _childOnProgress(item) {
            if (this.onProgress) {
                var dep = _queueDeps[this._id];
                this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
            }
        }
    }, {
        key: "allComplete",
        value: function allComplete() {
            var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
            this.onComplete && this.onComplete(errors, this);
        }
    }, {
        key: "isCompleted",
        value: function isCompleted() {
            return this.completedCount >= this.totalCount;
        }
    }, {
        key: "isItemCompleted",
        value: function isItemCompleted(id) {
            return !!this.completed[id];
        }
    }, {
        key: "exists",
        value: function exists(id) {
            return !!this.map[id];
        }
    }, {
        key: "getContent",
        value: function getContent(id) {
            var item = this.map[id], ret = null;
            return item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content)), 
            ret;
        }
    }, {
        key: "getError",
        value: function getError(id) {
            var item = this.map[id], ret = null;
            return item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error)), 
            ret;
        }
    }, {
        key: "removeItem",
        value: function removeItem(url) {
            var item = this.map[url];
            item && this.completed[item.alias || url] && (delete this.completed[url], delete this.map[url], 
            item.alias && (delete this.completed[item.alias.id], delete this.map[item.alias.id]), 
            this.completedCount--, this.totalCount--);
        }
    }, {
        key: "itemComplete",
        value: function itemComplete(id) {
            var item = this.map[id];
            if (item) {
                var errorListId = this._errorUrls.indexOf(id);
                if (item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1), 
                this.completed[id] = item, this.completedCount++, LoadingItems.finishDep(item.id), 
                this.onProgress) {
                    var dep = _queueDeps[this._id];
                    this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                }
                this.emit(id, item), this.removeAll(id), !this._appending && this.completedCount >= this.totalCount && this.allComplete();
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.active = !1, this._appending = !1, this._pipeline = null, this._ownerQueue = null, 
            this._errorUrls.length = 0, this.onProgress = null, this.onComplete = null, this.map = createMap(!0), 
            this.completed = {}, this.totalCount = 0, this.completedCount = 0, CallbacksInvoker.call(this), 
            _queues[this._id] = null, _queueDeps[this._id] && (_queueDeps[this._id].completed.length = 0, 
            _queueDeps[this._id].deps.length = 0), -1 === _pool.indexOf(this) && _pool.length < 10 && _pool.push(this);
        }
    } ], [ {
        key: "create",
        value: function create(pipeline, urlList, onProgress, onComplete) {
            void 0 === onProgress ? "function" == typeof urlList && (onComplete = urlList, urlList = onProgress = null) : void 0 === onComplete && ("function" == typeof urlList ? (onComplete = onProgress, 
            onProgress = urlList, urlList = null) : (onComplete = onProgress, onProgress = null));
            var queue = _pool.pop();
            return queue ? (queue._pipeline = pipeline, queue.onProgress = onProgress, queue.onComplete = onComplete, 
            _queues[queue._id] = queue, queue._pipeline && (queue.active = !0), urlList && queue.append(urlList)) : queue = new LoadingItems(pipeline, urlList, onProgress, onComplete), 
            queue;
        }
    }, {
        key: "getQueue",
        value: function getQueue(item) {
            return item.queueId ? _queues[item.queueId] : null;
        }
    }, {
        key: "itemComplete",
        value: function itemComplete(item) {
            var queue = _queues[item.queueId];
            queue && queue.itemComplete(item.id);
        }
    }, {
        key: "initQueueDeps",
        value: function initQueueDeps(queue) {
            var dep = _queueDeps[queue._id];
            dep ? (dep.completed.length = 0, dep.deps.length = 0) : dep = _queueDeps[queue._id] = {
                completed: [],
                deps: []
            };
        }
    }, {
        key: "registerQueueDep",
        value: function registerQueueDep(owner, depId) {
            var queueId = owner.queueId || owner;
            if (!queueId) return !1;
            var queueDepList = _queueDeps[queueId];
            if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
                var queue = _queueDeps[id];
                -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
            }
        }
    }, {
        key: "finishDep",
        value: function finishDep(depId) {
            for (var id in _queueDeps) {
                var queue = _queueDeps[id];
                -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
            }
        }
    } ]), LoadingItems;
}();

LoadingItems.ItemState = new cc.Enum(ItemState);

var proto = LoadingItems.prototype;

proto.addListener = CallbacksInvoker.prototype.on, proto.hasListener = CallbacksInvoker.prototype.hasEventListener, 
proto.removeListener = CallbacksInvoker.prototype.off, proto.removeAllListeners = CallbacksInvoker.prototype.removeAll, 
cc.LoadingItems = LoadingItems;

var ItemState$1 = LoadingItems.ItemState;

function flow(pipe, item) {
    var pipeId = pipe.id, itemState = item.states[pipeId], next = pipe.next, pipeline = pipe.pipeline;
    if (!item.error && itemState !== ItemState$1.WORKING && itemState !== ItemState$1.ERROR) if (itemState === ItemState$1.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
        item.states[pipeId] = ItemState$1.WORKING;
        var result = pipe.handle(item, function(err, result) {
            err ? (item.error = err, item.states[pipeId] = ItemState$1.ERROR, pipeline.flowOut(item)) : (result && (item.content = result), 
            item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
        });
        result instanceof Error ? (item.error = result, item.states[pipeId] = ItemState$1.ERROR, 
        pipeline.flowOut(item)) : void 0 !== result && (null !== result && (item.content = result), 
        item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
    }
}

var Pipeline = function() {
    function Pipeline(pipes) {
        _classCallCheck(this, Pipeline), this._pipes = pipes, this._cache = createMap(!0);
        for (var i = 0; i < pipes.length; ++i) {
            var pipe = pipes[i];
            pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null);
        }
    }
    return _createClass(Pipeline, [ {
        key: "insertPipe",
        value: function insertPipe(pipe, index) {
            if (!pipe.handle || !pipe.id || index > this._pipes.length) cc.warnID(4921); else if (this._pipes.indexOf(pipe) > 0) cc.warnID(4922); else {
                pipe.pipeline = this;
                var nextPipe = null;
                index < this._pipes.length && (nextPipe = this._pipes[index]);
                var previousPipe = null;
                index > 0 && (previousPipe = this._pipes[index - 1]), previousPipe && (previousPipe.next = pipe), 
                pipe.next = nextPipe, this._pipes.splice(index, 0, pipe);
            }
        }
    }, {
        key: "insertPipeAfter",
        value: function insertPipeAfter(refPipe, newPipe) {
            var index = this._pipes.indexOf(refPipe);
            index < 0 || this.insertPipe(newPipe, index + 1);
        }
    }, {
        key: "appendPipe",
        value: function appendPipe(pipe) {
            pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = null, this._pipes.length > 0 && (this._pipes[this._pipes.length - 1].next = pipe), 
            this._pipes.push(pipe));
        }
    }, {
        key: "flowIn",
        value: function flowIn(items) {
            var i, item, pipe = this._pipes[0];
            if (pipe) {
                for (i = 0; i < items.length; i++) (item = items[i]).isScene || (this._cache[item.id] = item);
                for (i = 0; i < items.length; i++) flow(pipe, item = items[i]);
            } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
        }
    }, {
        key: "flowInDeps",
        value: function flowInDeps(owner, urlList, callback) {
            return LoadingItems.create(this, function(errors, items) {
                callback(errors, items), items.destroy();
            }).append(urlList, owner);
        }
    }, {
        key: "flowOut",
        value: function flowOut(item) {
            item.error ? delete this._cache[item.id] : this._cache[item.id] || item.isScene || (this._cache[item.id] = item), 
            item.complete = !0, LoadingItems.itemComplete(item);
        }
    }, {
        key: "copyItemStates",
        value: function copyItemStates(srcItem, dstItems) {
            if (dstItems instanceof Array) for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states; else dstItems.states = srcItem.states;
        }
    }, {
        key: "getItem",
        value: function getItem(id) {
            var item = this._cache[id];
            return item ? (item.alias && (item = item.alias), item) : item;
        }
    }, {
        key: "removeItem",
        value: function removeItem(id) {
            var removed = this._cache[id];
            removed && removed.complete && delete this._cache[id];
            return removed;
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var id in this._cache) {
                var item = this._cache[id];
                delete this._cache[id], item.complete || (item.error = new Error("Canceled manually"), 
                this.flowOut(item));
            }
        }
    } ]), Pipeline;
}();

Pipeline.ItemState = ItemState$1, cc.Pipeline = Pipeline;

var JsonUnpacker = function() {
    function JsonUnpacker() {
        _classCallCheck(this, JsonUnpacker), this.jsons = {};
    }
    return _createClass(JsonUnpacker, [ {
        key: "load",
        value: function load(indices, packedJson) {
            packedJson.length !== indices.length && cc.errorID(4915);
            for (var i = 0; i < indices.length; i++) {
                var key = indices[i], json = packedJson[i];
                this.jsons[key] = json;
            }
        }
    }, {
        key: "retrieve",
        value: function retrieve(key) {
            return this.jsons[key] || null;
        }
    } ]), JsonUnpacker;
}(), TextureUnpacker = function() {
    function TextureUnpacker() {
        _classCallCheck(this, TextureUnpacker), this.contents = {};
    }
    return _createClass(TextureUnpacker, [ {
        key: "load",
        value: function load(indices, packedJson) {
            var datas = packedJson.data;
            datas.length !== indices.length && cc.errorID(4915);
            for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = {
                base: datas[i][0],
                mipmaps: datas[i][1]
            };
        }
    }, {
        key: "retrieve",
        value: function retrieve(key) {
            var content = this.contents[key];
            return content ? {
                __type__: cc.js._getClassId(cc.Texture2D),
                content: content
            } : null;
        }
    } ]), TextureUnpacker;
}();

var _noCacheRex = /\?/;

function urlAppendTimestamp(url) {
    return cc.game.config.noCache && "string" == typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date() - 0) : url += "?_t=" + (new Date() - 0)), 
    url;
}

function decompressJson(data, keys) {
    if (Array.isArray(data)) for (var i = 0, l = data.length; i < l; i++) decompressJson(data[i], keys); else if ("object" === _typeof(data)) for (var key in data) decompressJson(data[key], keys), 
    Number.isNaN(Number(key)) || (data[keys[key]] = data[key], delete data[key]);
    return null;
}

var PackState = {
    Invalid: 0,
    Removed: 1,
    Downloading: 2,
    Loaded: 3
};

function UnpackerData() {
    this.unpacker = null, this.state = PackState.Invalid;
}

var uuidToPack = {}, packIndices = {}, globalUnpackers = {};

function error$1(uuid, packUuid) {
    return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
}

function initPacks(packs) {
    for (var packUuid in packIndices = packs, packs) for (var uuids = packs[packUuid], i = 0; i < uuids.length; i++) {
        var uuid = uuids[i], pushFront = 1 === uuids.length;
        pushToMap(uuidToPack, uuid, packUuid, pushFront);
    }
}

function _loadNewPack(uuid, packUuid, callback) {
    var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
    cc.loader.load({
        url: packUrl,
        ignoreMaxConcurrency: !0
    }, function(err, packJson) {
        if (err) return cc.errorID(4916, uuid), callback(err);
        var res = _doLoadNewPack(uuid, packUuid, packJson);
        res ? callback(null, res) : callback(error$1(uuid, packUuid));
    });
}

function _doPreload(packUuid, packJson) {
    var unpackerData = globalUnpackers[packUuid];
    unpackerData || ((unpackerData = globalUnpackers[packUuid] = new UnpackerData()).state = PackState.Downloading), 
    unpackerData.state !== PackState.Loaded && (unpackerData.unpacker = new JsonUnpacker(), 
    unpackerData.unpacker.load(packIndices[packUuid], packJson), unpackerData.state = PackState.Loaded);
}

function _doLoadNewPack(uuid, packUuid, packedJson) {
    var unpackerData = globalUnpackers[packUuid];
    if (unpackerData.state !== PackState.Loaded) {
        if ("string" == typeof packedJson && (packedJson = JSON.parse(packedJson)), packedJson.keys && packedJson.data) {
            var keys = packedJson.keys;
            decompressJson(packedJson = packedJson.data, keys);
        }
        Array.isArray(packedJson) ? unpackerData.unpacker = new JsonUnpacker() : packedJson.type === cc.js._getClassId(cc.Texture2D) && (unpackerData.unpacker = new TextureUnpacker()), 
        unpackerData.unpacker.load(packIndices[packUuid], packedJson), unpackerData.state = PackState.Loaded;
    }
    return unpackerData.unpacker.retrieve(uuid);
}

function _selectLoadedPack(packUuids) {
    for (var existsPackState = PackState.Invalid, existsPackUuid = "", i = 0; i < packUuids.length; i++) {
        var packUuid = packUuids[i], unpackerData = globalUnpackers[packUuid];
        if (unpackerData) {
            var state = unpackerData.state;
            if (state === PackState.Loaded) return packUuid;
            state > existsPackState && (existsPackState = state, existsPackUuid = packUuid);
        }
    }
    return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
}

function load(item, callback) {
    var uuid = item.uuid, packUuid = uuidToPack[uuid];
    if (packUuid) {
        Array.isArray(packUuid) && (packUuid = _selectLoadedPack(packUuid));
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData && unpackerData.state === PackState.Loaded) {
            var json = unpackerData.unpacker.retrieve(uuid);
            return json || error$1(uuid, packUuid);
        }
        return unpackerData || (console.log("Create unpacker %s for %s", packUuid, uuid), 
        (unpackerData = globalUnpackers[packUuid] = new UnpackerData()).state = PackState.Downloading), 
        _loadNewPack(uuid, packUuid, callback), null;
    }
}

var PackDownloader = Object.freeze({
    initPacks: initPacks,
    _loadNewPack: _loadNewPack,
    _doPreload: _doPreload,
    _doLoadNewPack: _doLoadNewPack,
    _selectLoadedPack: _selectLoadedPack,
    load: load
});

function downloadBinary(item, callback) {
    var url = item.url, xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
    xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
        var arrayBuffer = xhr.response;
        arrayBuffer ? callback(null, arrayBuffer) : callback({
            status: xhr.status,
            errorMessage: errInfo + "(no response)"
        });
    }, xhr.onerror = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(error)"
        });
    }, xhr.ontimeout = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(time out)"
        });
    }, xhr.send(null);
}

function downloadText(item, callback) {
    var url = item.url;
    url = urlAppendTimestamp(url);
    var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url;
    xhr.open("GET", url, !0), xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8"), 
    xhr.onload = function() {
        4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
            status: xhr.status,
            errorMessage: errInfo + "(wrong status)"
        }) : callback({
            status: xhr.status,
            errorMessage: errInfo + "(wrong readyState)"
        });
    }, xhr.onerror = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(error)"
        });
    }, xhr.ontimeout = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(time out)"
        });
    }, xhr.send(null);
}

var _dec$7, _dec2$3, _class$7, _class2$6, _descriptor$4, _descriptor2$3, _class3$5, _temp$6, PlayingState = {
    INITIALIZING: 0,
    PLAYING: 1,
    STOPPED: 2
}, AudioPlayer = function() {
    function AudioPlayer(info) {
        _classCallCheck(this, AudioPlayer), this._state = PlayingState.STOPPED, this._duration = 0, 
        this._eventTarget = void 0, this._duration = info.duration, this._eventTarget = info.eventTarget;
    }
    return _createClass(AudioPlayer, [ {
        key: "getState",
        value: function getState() {
            return this._state;
        }
    }, {
        key: "getDuration",
        value: function getDuration() {
            return this._duration;
        }
    }, {
        key: "destroy",
        value: function destroy() {}
    } ]), AudioPlayer;
}(), AudioPlayerDOM = function(_AudioPlayer) {
    function AudioPlayerDOM(info) {
        var _this;
        return _classCallCheck(this, AudioPlayerDOM), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerDOM).call(this, info)))._volume = 1, 
        _this._loop = !1, _this._oneShoting = !1, _this._audio = void 0, _this._post_play = void 0, 
        _this._on_gesture = void 0, _this._alreadyDelayed = !1, _this._audio = info.clip, 
        _this._post_play = function() {
            _this._state = PlayingState.PLAYING, _this._eventTarget.emit("started");
        }, _this._on_gesture = function() {
            if (_this._audio) {
                var promise = _this._audio.play();
                promise ? promise.then(function() {
                    _this._alreadyDelayed ? _this._post_play() : (_this._audio.pause(), _this._audio.currentTime = 0), 
                    window.removeEventListener("touchend", _this._on_gesture), document.removeEventListener("mouseup", _this._on_gesture);
                }) : console.warn("no promise returned from HTMLMediaElement.play()");
            }
        }, _this._audio.volume = _this._volume, _this._audio.loop = _this._loop, _this._audio.addEventListener("ended", function() {
            _this._oneShoting || (_this._state = PlayingState.STOPPED, _this._audio.currentTime = 0, 
            _this._eventTarget.emit("ended"));
        }), window.addEventListener("touchend", _this._on_gesture), document.addEventListener("mouseup", _this._on_gesture), 
        _this;
    }
    return _inherits(AudioPlayerDOM, AudioPlayer), _createClass(AudioPlayerDOM, [ {
        key: "play",
        value: function play() {
            var _this2 = this;
            if (this._audio && this._state !== PlayingState.PLAYING) {
                var promise = this._audio.play();
                promise ? promise.then(this._post_play).catch(function() {
                    _this2._alreadyDelayed = !0;
                }) : console.warn("no promise returned from HTMLMediaElement.play()");
            }
        }
    }, {
        key: "pause",
        value: function pause() {
            this._audio && this._state === PlayingState.PLAYING && (this._audio.pause(), this._state = PlayingState.STOPPED, 
            this._oneShoting = !1);
        }
    }, {
        key: "stop",
        value: function stop() {
            this._audio && (this._audio.currentTime = 0, this._state === PlayingState.PLAYING && (this._audio.pause(), 
            this._state = PlayingState.STOPPED, this._oneShoting = !1));
        }
    }, {
        key: "playOneShot",
        value: function playOneShot() {
            var _this3 = this, volume = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, clip = this._audio;
            clip && (clip.currentTime = 0, clip.volume = volume, this._oneShoting || (clip.loop = !1, 
            this._oneShoting = !0, clip.play().then(function() {
                clip.addEventListener("ended", function() {
                    clip.currentTime = 0, clip.volume = _this3._volume, clip.loop = _this3._loop, _this3._oneShoting = !1;
                }, {
                    once: !0
                });
            }).catch(function() {
                _this3._oneShoting = !1;
            })));
        }
    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(val) {
            this._audio && (this._audio.currentTime = val);
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._audio ? this._audio.currentTime : 0;
        }
    }, {
        key: "setVolume",
        value: function setVolume(val, immediate) {
            this._volume = val, this._audio && (this._audio.volume = val);
        }
    }, {
        key: "getVolume",
        value: function getVolume() {
            return this._audio ? this._audio.volume : this._volume;
        }
    }, {
        key: "setLoop",
        value: function setLoop(val) {
            this._loop = val, this._audio && (this._audio.loop = val);
        }
    }, {
        key: "getLoop",
        value: function getLoop() {
            return this._loop;
        }
    }, {
        key: "destroy",
        value: function destroy() {}
    } ]), AudioPlayerDOM;
}(), audioSupport = sys.__audioSupport, AudioPlayerWeb = function(_AudioPlayer) {
    function AudioPlayerWeb(info) {
        var _this;
        return _classCallCheck(this, AudioPlayerWeb), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerWeb).call(this, info)))._startTime = 0, 
        _this._offset = 0, _this._volume = 1, _this._loop = !1, _this._currentTimer = 0, 
        _this._audio = void 0, _this._context = void 0, _this._sourceNode = void 0, _this._gainNode = void 0, 
        _this._on_ended = void 0, _this._do_play = void 0, _this._on_gesture = void 0, _this._alreadyDelayed = !1, 
        _this._audio = info.clip, _this._context = audioSupport.context, _this._sourceNode = _this._context.createBufferSource(), 
        _this._gainNode = _this._context.createGain(), _this._gainNode.connect(_this._context.destination), 
        _this._on_ended = function() {
            _this._offset = 0, _this._startTime = _this._context.currentTime, _this._sourceNode.loop || (_this._eventTarget.emit("ended"), 
            _this._state = PlayingState.STOPPED);
        }, _this._do_play = function() {
            _this._sourceNode = _this._context.createBufferSource(), _this._sourceNode.buffer = _this._audio, 
            _this._sourceNode.loop = _this._loop, _this._sourceNode.connect(_this._gainNode), 
            _this._sourceNode.start(0, _this._offset), _this._state = PlayingState.PLAYING, 
            _this._startTime = _this._context.currentTime, cc.director.once(cc.Director.EVENT_AFTER_UPDATE, function() {
                _this._eventTarget.emit("started");
            }), clearInterval(_this._currentTimer), _this._currentTimer = window.setInterval(function() {
                _this._on_ended(), clearInterval(_this._currentTimer), _this._sourceNode.loop && (_this._currentTimer = window.setInterval(_this._on_ended, 1e3 * _this._audio.duration));
            }, 1e3 * (_this._audio.duration - _this._offset));
        }, _this._on_gesture = function() {
            _this._context.resume().then(function() {
                _this._alreadyDelayed && _this._do_play(), window.removeEventListener("touchend", _this._on_gesture), 
                document.removeEventListener("mouseup", _this._on_gesture);
            });
        }, "running" === _this._context.state ? _possibleConstructorReturn(_this) : (window.addEventListener("touchend", _this._on_gesture), 
        document.addEventListener("mouseup", _this._on_gesture), _this);
    }
    return _inherits(AudioPlayerWeb, AudioPlayer), _createClass(AudioPlayerWeb, [ {
        key: "play",
        value: function play() {
            this._audio && this._state !== PlayingState.PLAYING && ("running" === this._context.state ? this._do_play() : this._alreadyDelayed = !0);
        }
    }, {
        key: "pause",
        value: function pause() {
            this._state === PlayingState.PLAYING && (this._sourceNode.stop(), this._offset += this._context.currentTime - this._startTime, 
            this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
        }
    }, {
        key: "stop",
        value: function stop() {
            this._offset = 0, this._state === PlayingState.PLAYING && (this._sourceNode.stop(), 
            this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
        }
    }, {
        key: "playOneShot",
        value: function playOneShot() {
            var volume = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            if (this._audio) {
                var gainNode = this._context.createGain();
                gainNode.connect(this._context.destination), gainNode.gain.value = volume;
                var sourceNode = this._context.createBufferSource();
                sourceNode.buffer = this._audio, sourceNode.loop = !1, sourceNode.connect(gainNode), 
                sourceNode.start();
            }
        }
    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(val) {
            this._offset = val, this._state === PlayingState.PLAYING && (this._sourceNode.stop(), 
            this._do_play());
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._state !== PlayingState.PLAYING ? this._offset : this._context.currentTime - this._startTime + this._offset;
        }
    }, {
        key: "setVolume",
        value: function setVolume(val, immediate) {
            this._volume = val, !immediate && this._gainNode.gain.setTargetAtTime ? this._gainNode.gain.setTargetAtTime(val, this._context.currentTime, .01) : this._gainNode.gain.value = val;
        }
    }, {
        key: "getVolume",
        value: function getVolume() {
            return this._volume;
        }
    }, {
        key: "setLoop",
        value: function setLoop(val) {
            this._loop = val, this._sourceNode.loop = val;
        }
    }, {
        key: "getLoop",
        value: function getLoop() {
            return this._loop;
        }
    }, {
        key: "destroy",
        value: function destroy() {}
    } ]), AudioPlayerWeb;
}(), AudioType = Enum({
    WEB_AUDIO: 0,
    DOM_AUDIO: 1,
    WX_GAME_AUDIO: 2,
    UNKNOWN_AUDIO: 3
}), AudioClip = (_dec$7 = ccclass("cc.AudioClip"), _dec2$3 = property({
    type: AudioType
}), _dec$7((_temp$6 = _class3$5 = function(_Asset) {
    function AudioClip() {
        var _this;
        return _classCallCheck(this, AudioClip), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioClip).call(this)), "_duration", _descriptor$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_loadMode", _descriptor2$3, _assertThisInitialized(_this)), 
        _this._audio = null, _this._player = null, _this.loaded = !1, _this;
    }
    return _inherits(AudioClip, Asset), _createClass(AudioClip, [ {
        key: "destroy",
        value: function destroy() {
            return this._player && this._player.destroy(), _get(_getPrototypeOf(AudioClip.prototype), "destroy", this).call(this);
        }
    }, {
        key: "play",
        value: function play() {
            this._player && this._player.play();
        }
    }, {
        key: "pause",
        value: function pause() {
            this._player && this._player.pause();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._player && this._player.stop();
        }
    }, {
        key: "playOneShot",
        value: function playOneShot(volume) {
            this._player && this._player.playOneShot(volume);
        }
    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(val) {
            this._player && this._player.setCurrentTime(val);
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._player ? this._player.getCurrentTime() : 0;
        }
    }, {
        key: "getDuration",
        value: function getDuration() {
            return this._player ? this._player.getDuration() : this._duration;
        }
    }, {
        key: "setVolume",
        value: function setVolume(val, immediate) {
            this._player && this._player.setVolume(val, immediate || !1);
        }
    }, {
        key: "getVolume",
        value: function getVolume() {
            return this._player ? this._player.getVolume() : 1;
        }
    }, {
        key: "setLoop",
        value: function setLoop(val) {
            this._player && this._player.setLoop(val);
        }
    }, {
        key: "getLoop",
        value: function getLoop() {
            return !!this._player && this._player.getLoop();
        }
    }, {
        key: "_nativeAsset",
        set: function set(clip) {
            var ctor;
            (this._audio = clip, clip) ? (clip instanceof AudioBuffer ? (ctor = AudioPlayerWeb, 
            this._loadMode = AudioType.WEB_AUDIO) : (ctor = AudioPlayerDOM, this._loadMode = AudioType.DOM_AUDIO), 
            this._player = new ctor({
                clip: clip,
                duration: this._duration,
                eventTarget: this
            }), this.loaded = !0, this.emit("load")) : (this._player = null, this._loadMode = AudioType.UNKNOWN_AUDIO, 
            this._duration = 0, this.loaded = !1);
        },
        get: function get() {
            return this._audio;
        }
    }, {
        key: "loadMode",
        get: function get() {
            return this._loadMode;
        }
    }, {
        key: "state",
        get: function get() {
            return this._player ? this._player.getState() : PlayingState.INITIALIZING;
        }
    } ]), AudioClip;
}(), _class3$5.PlayingState = PlayingState, _class3$5.AudioType = AudioType, _class3$5.preventDeferredLoadDependents = !0, 
_descriptor$4 = _applyDecoratedDescriptor((_class2$6 = _temp$6).prototype, "_duration", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "_loadMode", [ _dec2$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return AudioType.UNKNOWN_AUDIO;
    }
}), _class$7 = _class2$6)) || _class$7);

cc.AudioClip = AudioClip;

var __audioSupport$1 = sys.__audioSupport, formatSupport$1 = __audioSupport$1.format;

function loadDomAudio(item, callback) {
    var dom = document.createElement("audio");
    dom.src = item.url;
    var clearEvent = function clearEvent() {
        clearTimeout(timer), dom.removeEventListener("canplaythrough", success, !1), dom.removeEventListener("error", failure, !1), 
        __audioSupport$1.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
    }, timer = setTimeout(function() {
        0 === dom.readyState ? failure() : success();
    }, 8e3), success = function success() {
        clearEvent(), callback(null, dom);
    }, failure = function failure() {
        clearEvent();
        var message = "load audio failure - " + item.url;
        cc.log(message), callback(message);
    };
    dom.addEventListener("canplaythrough", success, !1), dom.addEventListener("error", failure, !1), 
    __audioSupport$1.USE_LOADER_EVENT && dom.addEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
}

function loadWebAudio(item, callback) {
    var context = __audioSupport$1.context;
    context || callback(new Error(getError(4926)));
    var request = cc.loader.getXMLHttpRequest();
    request.open("GET", item.url, !0), request.responseType = "arraybuffer", request.onload = function() {
        context.decodeAudioData(request.response, function(buffer) {
            callback(null, buffer);
        }, function() {
            callback("decode error - " + item.id, null);
        });
    }, request.onerror = function() {
        callback("request error - " + item.id, null);
    }, request.send();
}

function downloadAudio(item, callback) {
    if (0 === formatSupport$1.length) return new Error(getError(4927));
    (__audioSupport$1.WEB_AUDIO ? item._owner instanceof AudioClip ? item._owner.loadMode === AudioType.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam.useDom ? loadDomAudio : loadWebAudio : loadDomAudio)(item, callback);
}

function skip() {
    return null;
}

function downloadScript(item, callback, isAsync) {
    var url = item.url, d = document, s = document.createElement("script");
    function loadHandler() {
        s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), s.removeEventListener("error", errorHandler, !1), 
        callback(null, url);
    }
    function errorHandler() {
        s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), s.removeEventListener("error", errorHandler, !1), 
        callback(new Error(getError(4928, url)));
    }
    s.async = isAsync, s.src = urlAppendTimestamp(url), s.addEventListener("load", loadHandler, !1), 
    s.addEventListener("error", errorHandler, !1), d.body.appendChild(s);
}

function downloadImage(item, callback, isCrossOrigin, img) {
    void 0 === isCrossOrigin && (isCrossOrigin = !0);
    var url = urlAppendTimestamp(item.url);
    if (img = img || new Image(), isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null, 
    img.complete && img.naturalWidth > 0 && img.src === url) return img;
    var loadCallback = function loadCallback() {
        img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
        img.id = item.id, callback(null, img);
    }, errorCallback = function errorCallback() {
        img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
        "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, !1, img) : callback(new Error(getError(4930, url)));
    };
    img.addEventListener("load", loadCallback), img.addEventListener("error", errorCallback), 
    img.src = url;
}

var defaultMap = {
    js: downloadScript,
    png: downloadImage,
    jpg: downloadImage,
    bmp: downloadImage,
    jpeg: downloadImage,
    gif: downloadImage,
    ico: downloadImage,
    tiff: downloadImage,
    webp: function downloadWebp(item, callback, isCrossOrigin, img) {
        return cc.sys.capabilities.webp ? downloadImage(item, callback, isCrossOrigin, img) : new Error(getError(4929, item.url));
    },
    image: downloadImage,
    pvr: downloadBinary,
    pkm: downloadBinary,
    mp3: downloadAudio,
    ogg: downloadAudio,
    wav: downloadAudio,
    m4a: downloadAudio,
    txt: downloadText,
    xml: downloadText,
    vsh: downloadText,
    fsh: downloadText,
    atlas: downloadText,
    tmx: downloadText,
    tsx: downloadText,
    json: downloadText,
    ExportJson: downloadText,
    plist: downloadText,
    fnt: downloadText,
    font: skip,
    eot: skip,
    ttf: skip,
    woff: skip,
    svg: skip,
    ttc: skip,
    uuid: function downloadUuid(item, callback) {
        var result = load(item, callback);
        return void 0 === result ? this.extMap.json(item, callback) : result || void 0;
    },
    binary: downloadBinary,
    bin: downloadBinary,
    default: downloadText
}, ID = "Downloader", Downloader = function() {
    function Downloader(extMap) {
        _classCallCheck(this, Downloader), this.id = ID, this.async = !0, this.pipeline = null, 
        this._curConcurrent = 0, this._loadQueue = [], this._subpackages = {}, this.extMap = mixin(extMap, defaultMap);
    }
    return _createClass(Downloader, [ {
        key: "addHandlers",
        value: function addHandlers(extMap) {
            mixin(this.extMap, extMap);
        }
    }, {
        key: "_handleLoadQueue",
        value: function _handleLoadQueue() {
            for (;this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT; ) {
                var nextOne = this._loadQueue.shift();
                if (!nextOne) break;
                var syncRet = this.handle(nextOne.item, nextOne.callback);
                void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
            }
        }
    }, {
        key: "handle",
        value: function handle(item, callback) {
            var self = this, downloadFunc = this.extMap[item.type] || this.extMap.default, syncRet = void 0;
            if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                if (this._curConcurrent++, void 0 !== (syncRet = downloadFunc.call(this, item, function(err, result) {
                    self._curConcurrent = Math.max(0, self._curConcurrent - 1), self._handleLoadQueue(), 
                    callback && callback(err, result);
                }))) return this._curConcurrent = Math.max(0, this._curConcurrent - 1), this._handleLoadQueue(), 
                syncRet;
            } else if (item.ignoreMaxConcurrency) {
                if (void 0 !== (syncRet = downloadFunc.call(this, item, callback))) return syncRet;
            } else this._loadQueue.push({
                item: item,
                callback: callback
            });
        }
    }, {
        key: "loadSubpackage",
        value: function loadSubpackage(name, completeCallback) {
            var pac = this._subpackages[name];
            pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
                url: pac.path
            }, function(err) {
                err || (pac.loaded = !0), completeCallback && completeCallback(err);
            }) : completeCallback && completeCallback(new Error("Can't find subpackage ".concat(name)));
        }
    } ]), Downloader;
}();

Downloader.ID = ID, Downloader.PackDownloader = PackDownloader, Pipeline.Downloader = Downloader;

var SAXParser = function() {
    function SAXParser() {
        _classCallCheck(this, SAXParser), window.DOMParser ? (this._isSupportDOMParser = !0, 
        this._parser = new DOMParser()) : (this._isSupportDOMParser = !1, this._parser = null);
    }
    return _createClass(SAXParser, [ {
        key: "parse",
        value: function parse(xmlTxt) {
            return this._parseXML(xmlTxt);
        }
    }, {
        key: "_parseXML",
        value: function _parseXML(textxml) {
            var xmlDoc;
            return this._isSupportDOMParser ? xmlDoc = this._parser.parseFromString(textxml, "text/xml") : ((xmlDoc = new ActiveXObject("Microsoft.XMLDOM")).async = "false", 
            xmlDoc.loadXML(textxml)), xmlDoc;
        }
    } ]), SAXParser;
}(), plistParser = new (function(_SAXParser) {
    function PlistParser() {
        return _classCallCheck(this, PlistParser), _possibleConstructorReturn(this, _getPrototypeOf(PlistParser).apply(this, arguments));
    }
    return _inherits(PlistParser, SAXParser), _createClass(PlistParser, [ {
        key: "parse",
        value: function parse(xmlTxt) {
            var xmlDoc = this._parseXML(xmlTxt), plist = xmlDoc.documentElement;
            if ("plist" !== plist.tagName) return cc.warnID(5100), {};
            for (var node = null, i = 0, len = plist.childNodes.length; i < len && 1 !== (node = plist.childNodes[i]).nodeType; i++) ;
            return xmlDoc = null, this._parseNode(node);
        }
    }, {
        key: "_parseNode",
        value: function _parseNode(node) {
            var data = null, tagName = node.tagName;
            if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
                data = "";
                for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
            } else "false" === tagName ? data = !1 : "true" === tagName ? data = !0 : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
            return data;
        }
    }, {
        key: "_parseArray",
        value: function _parseArray(node) {
            for (var data = [], i = 0, len = node.childNodes.length; i < len; i++) {
                var child = node.childNodes[i];
                1 === child.nodeType && data.push(this._parseNode(child));
            }
            return data;
        }
    }, {
        key: "_parseDict",
        value: function _parseDict(node) {
            for (var data = {}, key = null, i = 0, len = node.childNodes.length; i < len; i++) {
                var child = node.childNodes[i];
                1 === child.nodeType && ("key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child));
            }
            return data;
        }
    } ]), PlistParser;
}())(), Details = function() {
    function Details() {
        _classCallCheck(this, Details), this.assignAssetsBy = void 0, this.uuidList = void 0, 
        this.uuidObjList = void 0, this.uuidPropList = void 0, this._stillUseUrl = void 0, 
        this.uuidList = [], this.uuidObjList = [], this.uuidPropList = [], this._stillUseUrl = createMap(!0);
    }
    return _createClass(Details, [ {
        key: "reset",
        value: function reset() {
            this.uuidList.length = 0, this.uuidObjList.length = 0, this.uuidPropList.length = 0, 
            clear(this._stillUseUrl);
        }
    }, {
        key: "push",
        value: function push(obj, propName, uuid, _stillUseUrl) {
            _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = !0), this.uuidList.push(uuid), 
            this.uuidObjList.push(obj), this.uuidPropList.push(propName);
        }
    } ]), Details;
}();

function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue, stillUseUrl) {
    if (defaultValue instanceof cc.ValueType) {
        assumeHavePropIfIsValue || sources.push("if(prop){");
        var ctorCode = getClassName(defaultValue);
        sources.push("s._deserializeTypedObject(o".concat(accessorToSet, ",prop,").concat(ctorCode, ");")), 
        assumeHavePropIfIsValue || sources.push("}else o" + accessorToSet + "=null;");
    } else sources.push("if(prop){"), sources.push("s._deserializeObjField(o,prop," + propNameLiteralToSet + ",null," + !!stillUseUrl + ");"), 
    sources.push("}else o" + accessorToSet + "=null;");
}

Details.pool = void 0, Details.pool = new Pool(function(obj) {
    obj.reset();
}, 10), Details.pool.get = function() {
    return this._get() || new Details();
};

var compileDeserialize = function(self, klass) {
    for (var TYPE = DELIMETER + "type", DEFAULT = DELIMETER + "default", SAVE_URL_AS_ASSET = DELIMETER + "saveUrlAsAsset", FORMERLY_SERIALIZED_AS = DELIMETER + "formerlySerializedAs", attrs = getClassAttrs(klass), props = klass.__values__, sources = [ "var prop;" ], fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass)), p = 0; p < props.length; p++) {
        var propName = props[p];
        0;
        var accessorToSet = void 0, propNameLiteralToSet = void 0;
        CCClass.IDENTIFIER_RE.test(propName) ? (propNameLiteralToSet = '"' + propName + '"', 
        accessorToSet = "." + propName) : accessorToSet = "[" + (propNameLiteralToSet = CCClass.escapeForJS(propName)) + "]";
        var accessorToGet = accessorToSet;
        if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
            var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];
            accessorToGet = CCClass.IDENTIFIER_RE.test(propNameToRead) ? "." + propNameToRead : "[" + CCClass.escapeForJS(propNameToRead) + "]";
        }
        sources.push("prop=d" + accessorToGet + ";"), sources.push("if(typeof ".concat("prop", '!=="undefined"){'));
        var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET], defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
        if (fastMode) {
            var isPrimitiveType = void 0, userType = attrs[propName + TYPE];
            if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
                var defaultType = _typeof(defaultValue);
                isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
            }
            isPrimitiveType ? sources.push("o".concat(accessorToSet, "=prop;")) : compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, !0, stillUseUrl);
        } else sources.push("if(typeof ".concat("prop", '!=="object"){') + "o" + accessorToSet + "=prop;}else{"), 
        compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, !1, stillUseUrl), 
        sources.push("}");
        sources.push("}");
    }
    (cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component)) && sources.push("d._id&&(o._id=d._id);");
    return "_$erialized" === props[props.length - 1] && (sources.push("o._$erialized=JSON.parse(JSON.stringify(d));"), 
    sources.push("s._deserializePrimitiveObject(o._$erialized,d);")), Function("s", "o", "d", "k", "t", sources.join(""));
};

function _deserializeFireClass(self, obj, serialized, klass, target) {
    var deserialize;
    klass.hasOwnProperty("__deserialize__") ? deserialize = klass.__deserialize__ : (deserialize = compileDeserialize(self, klass), 
    value(klass, "__deserialize__", deserialize, !0)), deserialize(self, obj, serialized, klass, target), 
    obj.__postDeserialize && obj.__postDeserialize();
}

var _Deserializer = function() {
    function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
        _classCallCheck(this, _Deserializer), this.result = void 0, this.customEnv = void 0, 
        this.deserializedList = void 0, this.deserializedData = void 0, this._classFinder = void 0, 
        this._target = void 0, this._ignoreEditorOnly = void 0, this._idList = void 0, this._idObjList = void 0, 
        this._idPropList = void 0, this.result = result, this.customEnv = customEnv, this.deserializedList = [], 
        this.deserializedData = null, this._classFinder = classFinder, this._idList = [], 
        this._idObjList = [], this._idPropList = [];
    }
    return _createClass(_Deserializer, [ {
        key: "deserialize",
        value: function deserialize(jsonObj) {
            if (Array.isArray(jsonObj)) {
                var jsonArray = jsonObj, refCount = jsonArray.length;
                this.deserializedList.length = refCount;
                for (var i = 0; i < refCount; i++) {
                    if (jsonArray[i]) this.deserializedList[i] = this._deserializeObject(jsonArray[i], !1);
                }
                this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
            } else this.deserializedList.length = 1, this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, !1) : null, 
            this.deserializedList[0] = this.deserializedData;
            return function _dereference(self) {
                var i, propName, id, deserializedList = self.deserializedList, idPropList = self._idPropList, idList = self._idList, idObjList = self._idObjList;
                for (self._classFinder && self._classFinder.onDereferenced, i = 0; i < idList.length; i++) propName = idPropList[i], 
                id = idList[i], idObjList[i][propName] = deserializedList[id];
            }(this), this.deserializedData;
        }
    }, {
        key: "_deserializeObject",
        value: function _deserializeObject(serialized, _stillUseUrl, target, owner, propName) {
            var prop, obj = null, klass = null, type = serialized.__type__;
            if ("TypedArray" === type) {
                var array = serialized.array;
                obj = new window[serialized.ctor](array.length);
                for (var i = 0; i < array.length; ++i) obj[i] = array[i];
                return obj;
            }
            if (type) {
                var deserializeByType = function deserializeByType() {
                    (obj = new klass())._deserialize ? obj._deserialize(serialized.content, self) : cc.Class._isCCClass(klass) ? _deserializeFireClass(self, obj, serialized, klass, target) : self._deserializeTypedObject(obj, serialized, klass);
                };
                if (!(klass = this._classFinder(type, serialized, owner, propName))) return this._classFinder === _getClassById && cc.deserialize.reportMissingClass(type), 
                null;
                var self = this;
                deserializeByType();
            } else if (Array.isArray(serialized)) {
                obj = new Array(serialized.length);
                for (var _i2 = 0; _i2 < serialized.length; _i2++) "object" === _typeof(prop = serialized[_i2]) && prop ? this._deserializeObjField(obj, prop, "" + _i2, null, _stillUseUrl) : obj[_i2] = prop;
            } else obj = {}, this._deserializePrimitiveObject(obj, serialized);
            return obj;
        }
    }, {
        key: "_deserializeObjField",
        value: function _deserializeObjField(obj, jsonObj, propName, target, _stillUseUrl) {
            var id = jsonObj.__id__;
            if (void 0 === id) {
                var uuid = jsonObj.__uuid__;
                uuid ? this.result.push(obj, propName, uuid, _stillUseUrl) : obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
            } else {
                var dObj = this.deserializedList[id];
                dObj ? obj[propName] = dObj : (this._idList.push(id), this._idObjList.push(obj), 
                this._idPropList.push(propName));
            }
        }
    }, {
        key: "_deserializePrimitiveObject",
        value: function _deserializePrimitiveObject(instance, serialized) {
            for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
                var prop = serialized[propName];
                "object" !== _typeof(prop) ? "__type__" !== propName && (instance[propName] = prop) : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null;
            }
        }
    }, {
        key: "_deserializeTypedObject",
        value: function _deserializeTypedObject(instance, serialized, klass) {
            if (klass === cc.Vec2) return instance.x = serialized.x || 0, void (instance.y = serialized.y || 0);
            if (klass === cc.Vec3) return instance.x = serialized.x || 0, instance.y = serialized.y || 0, 
            void (instance.z = serialized.z || 0);
            if (klass !== cc.Color) {
                if (klass === cc.Size) return instance.width = serialized.width || 0, void (instance.height = serialized.height || 0);
                for (var DEFAULT = DELIMETER + "default", attrs = getClassAttrs(klass), fastDefinedProps = klass.__props__ || Object.keys(instance), i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i], value = serialized[propName];
                    void 0 !== value && serialized.hasOwnProperty(propName) || (value = CCClass.getDefault(attrs[propName + DEFAULT])), 
                    "object" !== _typeof(value) ? instance[propName] = value : value ? this._deserializeObjField(instance, value, propName) : instance[propName] = null;
                }
            } else {
                instance.r = serialized.r || 0, instance.g = serialized.g || 0, instance.b = serialized.b || 0;
                var a = serialized.a;
                instance.a = void 0 === a ? 255 : a;
            }
        }
    } ]), _Deserializer;
}();

function deserialize(data, details, options) {
    var classFinder = (options = options || {}).classFinder || _getClassById, createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE, customEnv = options.customEnv, ignoreEditorOnly = options.ignoreEditorOnly;
    "string" == typeof data && (data = JSON.parse(data));
    var tempDetails = !details;
    details = details || Details.pool.get();
    var deserializer = _Deserializer.pool.get(details, !1, classFinder, customEnv, ignoreEditorOnly);
    cc.game._isCloning = !0;
    var res = deserializer.deserialize(data);
    return cc.game._isCloning = !1, _Deserializer.pool.put(deserializer), createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset), 
    tempDetails && Details.pool.put(details), res;
}

function isSceneObj(json) {
    return json && (json[0] && "cc.Scene" === json[0].__type__ || json[1] && "cc.Scene" === json[1].__type__ || json[0] && "cc.Prefab" === json[0].__type__);
}

function loadUuid(item, callback) {
    var json, classFinder;
    if ("string" == typeof item.content) try {
        if ((json = JSON.parse(item.content)).keys && json.data) {
            var keys = json.keys;
            decompressJson(json = json.data, keys);
        }
    } catch (e) {
        return new Error(getError(4923, item.id, e.stack));
    } else {
        if ("object" !== _typeof(item.content)) return new Error(getError(4924));
        json = item.content;
    }
    if (null == json) return new Error(getError(4923, item.id));
    var isScene = isSceneObj(json);
    classFinder = isScene ? cc._MissingScript.safeFindClass : function classFinder(id) {
        var cls = _getClassById(id);
        return cls || (cc.warnID(4903, id), Object);
    };
    var asset, tdInfo = cc.deserialize.Details.pool.get();
    try {
        asset = cc.deserialize(json, tdInfo, {
            classFinder: classFinder,
            target: item.existingAsset,
            customEnv: item
        });
    } catch (e) {
        return cc.deserialize.Details.pool.put(tdInfo), console.error(e), new Error("Failed to load asset ".concat(item.id, ", exception occurs during deserialization: ").concat(e.stack, "."));
    }
    asset._uuid = item.uuid;
    var deferredLoad = function canDeferredLoad(asset, item, isScene) {
        var res = item.deferredLoadRaw;
        return res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = !1) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets), 
        res;
    }(asset, item, isScene), depends = function parseDepends(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
        var depends, i, dependUuid, uuidList = tdInfo.uuidList, objList = tdInfo.uuidObjList, propList = tdInfo.uuidPropList, stillUseUrl = tdInfo._stillUseUrl, dependKeys = item.dependKeys = [];
        if (deferredLoadRawAssetsInRuntime) for (depends = [], i = 0; i < uuidList.length; i++) {
            dependUuid = uuidList[i];
            var obj = objList[i], prop = propList[i], info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
            if (info.raw) {
                var url = info.url;
                obj[prop] = url, dependKeys.push(url);
            } else depends.push({
                type: "uuid",
                uuid: dependUuid,
                deferredLoadRaw: !0,
                _owner: obj,
                _ownerProp: prop,
                _stillUseUrl: stillUseUrl[i]
            });
        } else {
            for (depends = new Array(uuidList.length), i = 0; i < uuidList.length; i++) dependUuid = uuidList[i], 
            depends[i] = {
                type: "uuid",
                uuid: dependUuid,
                _owner: objList[i],
                _ownerProp: propList[i],
                _stillUseUrl: stillUseUrl[i]
            };
            asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
                url: asset.nativeUrl,
                _owner: asset,
                _ownerProp: "_nativeAsset"
            });
        }
        return depends;
    }(item, asset, tdInfo, deferredLoad);
    cc.deserialize.Details.pool.put(tdInfo);
    var wrappedCallback = function wrappedCallback(err, asset) {
        if (!err && asset.onLoaded) try {
            asset.onLoaded();
        } catch (error) {
            err = error;
        }
        callback(err, asset);
    };
    if (0 === depends.length) return wrappedCallback(null, asset);
    !function loadDepends(pipeline, item, asset, depends, callback) {
        item.content = asset;
        var dependKeys = item.dependKeys;
        pipeline.flowInDeps(item, depends, function(errors, items) {
            var item, itemsMap = items.map;
            for (var src in itemsMap) (item = itemsMap[src]).uuid && item.content && (item.content._uuid = item.uuid);
            for (var i = 0; i < depends.length; i++) {
                var loadCallback = function loadCallback(item) {
                    var value = item.content;
                    this._stillUseUrl && (value = value ? value.nativeUrl : item.rawUrl), this._owner[this._ownerProp] = value, 
                    item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
                }, dep = depends[i], dependSrc = dep.uuid, dependUrl = dep.url;
                dep._owner, dep._ownerProp;
                if (item = itemsMap[dependUrl]) {
                    var loadCallbackCtx = dep;
                    if (item.complete || item.content) {
                        if (item.error) cc._throw(item.error); else loadCallback.call(loadCallbackCtx, item);
                    } else {
                        var queue = LoadingItems.getQueue(item), list = queue._callbackTable[dependSrc];
                        list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
                    }
                }
            }
            callback(errors, asset);
        });
    }(this.pipeline, item, asset, depends, wrappedCallback);
}

_Deserializer.pool = void 0, _Deserializer.pool = new Pool(function(obj) {
    obj.result = null, obj.customEnv = null, obj.deserializedList.length = 0, obj.deserializedData = null, 
    obj._classFinder = null, obj._idList.length = 0, obj._idObjList.length = 0, obj._idPropList.length = 0;
}, 1), _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
    var cache = this._get();
    return cache ? (cache.result = result, cache.customEnv = customEnv, cache._classFinder = classFinder, 
    cache) : new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
}, deserialize.Details = Details, deserialize.reportMissingClass = function(id) {
    cc.warnID(5302, id);
}, cc.deserialize = deserialize, loadUuid.isSceneObj = isSceneObj;

var WORD_REG = /([a-zA-Z0-9--]+|\S)/, SYMBOL_REG = /^[!,.:;'}\]%\?>]/, LAST_WORD_REG = /([a-zA-Z0-9--]+|\S)$/, LAST_ENGLISH_REG = /[a-zA-Z0-9--]+$/, FIRST_ENGLISH_REG = /^[a-zA-Z0-9--]/;

function isUnicodeCJK(ch) {
    return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(ch) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(ch) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(ch);
}

function isUnicodeSpace(ch) {
    var chCode = ch.charCodeAt(0);
    return chCode >= 9 && chCode <= 13 || 32 === chCode || 133 === chCode || 160 === chCode || 5760 === chCode || chCode >= 8192 && chCode <= 8202 || 8232 === chCode || 8233 === chCode || 8239 === chCode || 8287 === chCode || 12288 === chCode;
}

function safeMeasureText(ctx, string) {
    var metric = ctx.measureText(string);
    return metric && metric.width || 0;
}

function fragmentText(stringToken, allWidth, maxWidth, measureText) {
    var wrappedWords = [];
    if (0 === stringToken.length || maxWidth < 0) return wrappedWords.push(""), wrappedWords;
    for (var text = stringToken; allWidth > maxWidth && text.length > 1; ) {
        for (var fuzzyLen = text.length * (maxWidth / allWidth) | 0, tmpText = text.substr(fuzzyLen), width = allWidth - measureText(tmpText), sLine = tmpText, pushNum = 0, checkWhile = 0; width > maxWidth && checkWhile++ < 10; ) fuzzyLen *= maxWidth / width, 
        fuzzyLen |= 0, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
        for (checkWhile = 0; width <= maxWidth && checkWhile++ < 10; ) {
            if (tmpText) {
                var exec = WORD_REG.exec(tmpText);
                pushNum = exec ? exec[0].length : 1, sLine = tmpText;
            }
            fuzzyLen += pushNum, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
        }
        0 === (fuzzyLen -= pushNum) && (fuzzyLen = 1, sLine = sLine.substr(1));
        var sText = text.substr(0, fuzzyLen), result = void 0;
        SYMBOL_REG.test(sLine || tmpText) && (0 === (fuzzyLen -= (result = LAST_WORD_REG.exec(sText)) ? result[0].length : 0) && (fuzzyLen = 1), 
        sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), FIRST_ENGLISH_REG.test(sLine) && (result = LAST_ENGLISH_REG.exec(sText)) && sText !== result[0] && (fuzzyLen -= result[0].length, 
        sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), 0 === wrappedWords.length ? wrappedWords.push(sText) : (sText = sText.trim()).length > 0 && wrappedWords.push(sText), 
        allWidth = measureText(text = sLine || tmpText);
    }
    return 0 === wrappedWords.length ? wrappedWords.push(text) : (text = text.trim()).length > 0 && wrappedWords.push(text), 
    wrappedWords;
}

var _canvasContext = null, _testString = "BES bswy:->@", _fontFaces = {}, _intervalId = -1, _loadingFonts = [], _timeout = 6e4;

function _checkFontLoaded() {
    for (var allFontsLoaded = !0, now = Date.now(), i = _loadingFonts.length - 1; i >= 0; i--) {
        var fontLoadHandle = _loadingFonts[i], fontFamily = fontLoadHandle.fontFamilyName;
        if (now - fontLoadHandle.startTime > _timeout) cc.warnID(4933, fontFamily), fontLoadHandle.callback(null, fontFamily), 
        _loadingFonts.splice(i, 1); else {
            var oldWidth = fontLoadHandle.refWidth;
            _canvasContext.font = "40px " + fontFamily, oldWidth !== safeMeasureText(_canvasContext, _testString) ? (_loadingFonts.splice(i, 1), 
            fontLoadHandle.callback(null, fontFamily)) : allFontsLoaded = !1;
        }
    }
    allFontsLoaded && (clearInterval(_intervalId), _intervalId = -1);
}

function loadFont(item, callback) {
    var url = item.url, fontFamilyName = function _getFontFamily(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf(".ttf");
        if (-1 === ttfIndex) return fontHandle;
        var fontFamilyName, slashPos = fontHandle.lastIndexOf("/");
        fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
        return fontFamilyName;
    }(url);
    if (_fontFaces[fontFamilyName]) return fontFamilyName;
    if (!_canvasContext) {
        var labelCanvas = document.createElement("canvas");
        labelCanvas.width = 100, labelCanvas.height = 100, _canvasContext = labelCanvas.getContext("2d");
    }
    var fontDesc = "40px " + fontFamilyName;
    _canvasContext.font = fontDesc;
    var refWidth = safeMeasureText(_canvasContext, _testString), fontStyle = document.createElement("style");
    fontStyle.type = "text/css";
    var fontStr = "";
    isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:", 
    fontStr += "url('" + url + "');", fontStyle.textContent = fontStr + "}", document.body.appendChild(fontStyle);
    var preloadDiv = document.createElement("div"), divStyle = preloadDiv.style;
    divStyle.fontFamily = fontFamilyName, preloadDiv.innerHTML = ".", divStyle.position = "absolute", 
    divStyle.left = "-100px", divStyle.top = "-100px", document.body.appendChild(preloadDiv);
    var fontLoadHandle = {
        fontFamilyName: fontFamilyName,
        refWidth: refWidth,
        callback: callback,
        startTime: Date.now()
    };
    _loadingFonts.push(fontLoadHandle), _fontFaces[fontFamilyName] = fontStyle, -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
}

function loadJSON(item) {
    if ("string" != typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
    try {
        return JSON.parse(item.content);
    } catch (e) {
        return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
    }
}

function loadImage(item) {
    if (item._owner instanceof cc.Asset) return null;
    var image = item.content;
    if (!(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
    var rawUrl = item.rawUrl, imageAsset = item.imageAsset || new ImageAsset();
    return imageAsset._uuid = item.uuid, imageAsset._url = rawUrl, imageAsset._setRawAsset(rawUrl, !1), 
    imageAsset._nativeAsset = image, imageAsset;
}

function loadAudioAsAsset(item, callback) {
    if (item._owner instanceof cc.Asset) return null;
    var audioClip = new cc.AudioClip();
    return audioClip._setRawAsset(item.rawUrl, !1), audioClip._nativeAsset = item.content, 
    audioClip;
}

function loadBinary(item) {
    return item.load ? item.load(item.content) : item.content;
}

var PVR_HEADER_LENGTH = 13, PVR_MAGIC = 55727696, PVR_HEADER_MAGIC = 0, PVR_HEADER_HEIGHT = 6, PVR_HEADER_WIDTH = 7, PVR_HEADER_METADATA = 12;

var ETC_PKM_HEADER_SIZE = 16, ETC_PKM_FORMAT_OFFSET = 6, ETC_PKM_ENCODED_WIDTH_OFFSET = 8, ETC_PKM_ENCODED_HEIGHT_OFFSET = 10, ETC_PKM_WIDTH_OFFSET = 12, ETC_PKM_HEIGHT_OFFSET = 14, ETC1_RGB_NO_MIPMAPS = 0, ETC2_RGB_NO_MIPMAPS = 1, ETC2_RGBA_NO_MIPMAPS = 3;

function readBEUint16(header, offset) {
    return header[offset] << 8 | header[offset + 1];
}

var defaultMap$1 = {
    png: loadImage,
    jpg: loadImage,
    bmp: loadImage,
    jpeg: loadImage,
    gif: loadImage,
    ico: loadImage,
    tiff: loadImage,
    webp: loadImage,
    image: loadImage,
    pvr: function loadPVRTex(item) {
        var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);
        if (header[PVR_HEADER_MAGIC] === PVR_MAGIC) {
            var _width = header[PVR_HEADER_WIDTH], _height = header[PVR_HEADER_HEIGHT], dataOffset = header[PVR_HEADER_METADATA] + 52;
            return buffer = buffer.slice(dataOffset, buffer.byteLength), {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: _width,
                height: _height
            };
        }
        if (559044176 === header[11]) {
            var headerLength = header[0], height = header[1], width = header[2];
            return buffer = buffer.slice(headerLength, buffer.byteLength), {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: width,
                height: height
            };
        }
        return new Error("Invalid magic number in PVR header");
    },
    pkm: function loadPKMTex(item) {
        var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Uint8Array(buffer), format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);
        if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) return new Error("Invalid magic number in ETC header");
        var width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET), height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
        return readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET), readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET), 
        buffer = buffer.slice(ETC_PKM_HEADER_SIZE, buffer.byteLength), {
            _data: new Uint8Array(buffer),
            _compressed: !0,
            width: width,
            height: height
        };
    },
    mp3: loadAudioAsAsset,
    ogg: loadAudioAsAsset,
    wav: loadAudioAsAsset,
    m4a: loadAudioAsAsset,
    json: loadJSON,
    ExportJson: loadJSON,
    plist: function loadPlist(item) {
        if ("string" != typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
        var result = plistParser.parse(item.content);
        return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
    },
    uuid: loadUuid,
    prefab: loadUuid,
    fire: loadUuid,
    scene: loadUuid,
    binary: loadBinary,
    bin: loadBinary,
    font: loadFont,
    eot: loadFont,
    ttf: loadFont,
    woff: loadFont,
    svg: loadFont,
    ttc: loadFont,
    default: function loadNothing() {
        return null;
    }
}, ID$1 = "Loader", Loader = function() {
    function Loader(extMap) {
        _classCallCheck(this, Loader), this.id = ID$1, this.async = !0, this.pipeline = null, 
        this.extMap = mixin(extMap, defaultMap$1);
    }
    return _createClass(Loader, [ {
        key: "addHandlers",
        value: function addHandlers(extMap) {
            this.extMap = mixin(this.extMap, extMap);
        }
    }, {
        key: "handle",
        value: function handle(item, callback) {
            return (this.extMap[item.type] || this.extMap.default).call(this, item, callback);
        }
    } ]), Loader;
}();

Loader.ID = ID$1, Pipeline.Loader = Loader;

var ID$2 = "AssetLoader", reusedArray = [], AssetLoader = function() {
    function AssetLoader(extMap) {
        _classCallCheck(this, AssetLoader), this.id = ID$2, this.async = !0, this.pipeline = null;
    }
    return _createClass(AssetLoader, [ {
        key: "handle",
        value: function handle(item, callback) {
            var uuid = item.uuid;
            if (!uuid) return item.content || null;
            cc.AssetLibrary.queryAssetInfo(uuid, function(error, url, isRawAsset) {
                if (error) callback(error); else if (item.url = item.rawUrl = url, item.isRawAsset = isRawAsset, 
                isRawAsset) {
                    var ext = extname(url).toLowerCase();
                    if (!ext) return void callback(new Error(getError(4931, uuid)));
                    ext = ext.substr(1);
                    var queue = LoadingItems.getQueue(item);
                    reusedArray[0] = {
                        queueId: item.queueId,
                        id: url,
                        url: url,
                        type: ext,
                        error: null,
                        alias: item,
                        complete: !0
                    }, queue.append(reusedArray), item.type = ext, callback(null, item.content);
                } else item.type = "uuid", callback(null, item.content);
            });
        }
    } ]), AssetLoader;
}();

function Entry(uuid, type) {
    this.uuid = uuid, this.type = type;
}

function isMatchByWord(path, test) {
    return !(path.length > test.length) || 47 === path.charCodeAt(test.length);
}

AssetLoader.ID = ID$2, Pipeline.AssetLoader = AssetLoader;

var AssetTable = function() {
    function AssetTable() {
        _classCallCheck(this, AssetTable), this._pathToUuid = createMap(!0);
    }
    return _createClass(AssetTable, [ {
        key: "getUuid",
        value: function getUuid(path, type) {
            path = cc.url.normalize(path);
            var item = this._pathToUuid[path];
            if (item) if (Array.isArray(item)) {
                if (!type) return item[0].uuid;
                for (var i = 0; i < item.length; i++) {
                    var entry = item[i];
                    if (isChildClassOf(entry.type, type)) return entry.uuid;
                }
            } else {
                if (!type || isChildClassOf(item.type, type)) return item.uuid;
            }
            return "";
        }
    }, {
        key: "getUuidArray",
        value: function getUuidArray(path, type, out_urls) {
            "/" === (path = cc.url.normalize(path))[path.length - 1] && (path = path.slice(0, -1));
            var path2uuid = this._pathToUuid, uuids = [];
            for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                var item = path2uuid[p];
                if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                    var entry = item[i];
                    (!type || isChildClassOf(entry.type, type)) && (uuids.push(entry.uuid), out_urls && out_urls.push(p));
                } else (!type || isChildClassOf(item.type, type)) && (uuids.push(item.uuid), out_urls && out_urls.push(p));
            }
            return uuids;
        }
    }, {
        key: "add",
        value: function add(path, uuid, type, isMainAsset) {
            isMainAsset && (path = path.substring(0, path.length - cc.path.extname(path).length));
            var newEntry = new Entry(uuid, type);
            pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
        }
    }, {
        key: "_getInfo_DEBUG",
        value: function _getInfo_DEBUG(uuid, out_info) {
            for (var path2uuid = this._pathToUuid, paths = Object.keys(path2uuid), p = 0; p < paths.length; ++p) {
                var path = paths[p], item = path2uuid[path];
                if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                    var entry = item[i];
                    if (entry.uuid === uuid) return out_info.path = path, out_info.type = entry.type, 
                    !0;
                } else if (item.uuid === uuid) return out_info.path = path, out_info.type = item.type, 
                !0;
            }
            return !1;
        }
    }, {
        key: "reset",
        value: function reset() {
            this._pathToUuid = createMap(!0);
        }
    } ]), AssetTable;
}();

function parseDepends$1(key, parsed) {
    var item = cc.loader.getItem(key);
    if (item) {
        var depends = item.dependKeys;
        if (depends) for (var i = 0; i < depends.length; i++) {
            var depend = depends[i];
            parsed[depend] || (parsed[depend] = !0, parseDepends$1(depend, parsed));
        }
    }
}

function visitAsset(asset, excludeMap) {
    if (asset._uuid) {
        var key = cc.loader._getReferenceKey(asset);
        excludeMap[key] || (excludeMap[key] = !0, parseDepends$1(key, excludeMap));
    }
}

function visitComponent(comp, excludeMap) {
    for (var props = Object.getOwnPropertyNames(comp), i = 0; i < props.length; i++) {
        var value = comp[props[i]];
        if ("object" === _typeof(value) && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
            var val = value[j];
            val instanceof cc.RawAsset && visitAsset(val, excludeMap);
        } else if (value.constructor && value.constructor !== Object) value instanceof cc.RawAsset && visitAsset(value, excludeMap); else for (var keys = Object.getOwnPropertyNames(value), _j = 0; _j < keys.length; _j++) {
            var _val = value[keys[_j]];
            _val instanceof cc.RawAsset && visitAsset(_val, excludeMap);
        }
    }
}

function visitNode(node, excludeMap) {
    for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
    for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
}

function getDependsRecursively(key) {
    var depends = {};
    return parseDepends$1(key, depends), Object.keys(depends);
}

var assetTables = Object.create(null);

function getXMLHttpRequest() {
    return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
}

assetTables.assets = new AssetTable(), assetTables.internal = new AssetTable();

var _info = {
    url: null,
    raw: !1
};

function getResWithUrl(res) {
    var id, result, isUuid;
    if ("object" === _typeof(res)) {
        if (result = res, res.url) return result;
        id = res.uuid;
    } else result = {}, id = res;
    return isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id), 
    cc.AssetLibrary._getAssetInfoInRuntime(id, _info), result.url = isUuid ? _info.url : id, 
    _info.url && "uuid" === result.type && _info.raw ? (result.type = null, result.isRawAsset = !0) : isUuid || (result.isRawAsset = !0), 
    result;
}

var _sharedResources = [], _sharedList = [], CCLoader = function(_Pipeline) {
    function CCLoader() {
        var _this;
        _classCallCheck(this, CCLoader);
        var assetLoader = new AssetLoader(), downloader = new Downloader(), loader = new Loader();
        return (_this = _possibleConstructorReturn(this, _getPrototypeOf(CCLoader).call(this, [ assetLoader, downloader, loader ]))).getXMLHttpRequest = void 0, 
        _this.assetLoader = void 0, _this.md5Pipe = void 0, _this.downloader = void 0, _this.loader = void 0, 
        _this.onProgress = void 0, _this._assetTables = void 0, _this._autoReleaseSetting = void 0, 
        _this._releasedAssetChecker_DEBUG = void 0, _this.getXMLHttpRequest = getXMLHttpRequest, 
        _this.assetLoader = assetLoader, _this.md5Pipe = null, _this.downloader = downloader, 
        _this.loader = loader, _this.onProgress = null, _this._assetTables = assetTables, 
        _this._autoReleaseSetting = createMap(!0), _this;
    }
    return _inherits(CCLoader, Pipeline), _createClass(CCLoader, [ {
        key: "init",
        value: function init(director) {}
    }, {
        key: "addDownloadHandlers",
        value: function addDownloadHandlers(extMap) {
            this.downloader.addHandlers(extMap);
        }
    }, {
        key: "addLoadHandlers",
        value: function addLoadHandlers(extMap) {
            this.loader.addHandlers(extMap);
        }
    }, {
        key: "load",
        value: function load(resources, progressCallback, completeCallback) {
            void 0 === completeCallback && (completeCallback = progressCallback, progressCallback = this.onProgress || null);
            var res, self = this, singleRes = !1;
            resources instanceof Array || (resources ? (singleRes = !0, resources = [ resources ]) : resources = []), 
            _sharedResources.length = 0;
            for (var i = 0; i < resources.length; ++i) {
                var resource = resources[i];
                if (resource && resource.id && (cc.warnID(4920, resource.id), resource.uuid || resource.url || (resource.url = resource.id)), 
                (res = getResWithUrl(resource)).url || res.uuid) {
                    var item = this._cache[res.url];
                    _sharedResources.push(item || res);
                }
            }
            var queue = LoadingItems.create(this, progressCallback, function(errors, items) {
                callInNextTick(function() {
                    if (completeCallback) {
                        if (singleRes) {
                            var id = res.url;
                            completeCallback.call(self, items.getError(id), items.getContent(id));
                        } else completeCallback.call(self, errors, items);
                        completeCallback = null;
                    }
                    items.destroy();
                });
            });
            LoadingItems.initQueueDeps(queue), queue.append(_sharedResources), _sharedResources.length = 0;
        }
    }, {
        key: "flowInDeps",
        value: function flowInDeps(owner, urlList, callback) {
            _sharedList.length = 0;
            for (var i = 0; i < urlList.length; ++i) {
                var res = getResWithUrl(urlList[i]);
                if (res.url || res.uuid) {
                    var item = this._cache[res.url];
                    item ? _sharedList.push(item) : _sharedList.push(res);
                }
            }
            var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
                queue._ownerQueue && queue._ownerQueue.onProgress && queue._ownerQueue._childOnProgress(item);
            } : null, function(errors, items) {
                callback(errors, items), owner && owner.deps && (owner.deps.length = 0), items.destroy();
            });
            if (owner) {
                var ownerQueue = LoadingItems.getQueue(owner);
                queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
            }
            var accepted = queue.append(_sharedList, owner);
            return _sharedList.length = 0, accepted;
        }
    }, {
        key: "loadRes",
        value: function loadRes(url, type, mount, progressCallback, completeCallback) {
            5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
            mount = "assets");
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
            var self = this, uuid = self._getResUuid(url, type, mount, !0);
            uuid ? this.load({
                type: "uuid",
                uuid: uuid
            }, progressCallback, function(err, asset) {
                asset && self.setAutoReleaseRecursively(uuid, !1), completeCallback && completeCallback(err, asset);
            }) : self._urlNotFound(url, type, completeCallback);
        }
    }, {
        key: "loadResDir",
        value: function loadResDir(url, type, mount, progressCallback, completeCallback) {
            if (5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
            mount = "assets"), assetTables[mount]) {
                var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                var urls = [], uuids = assetTables[mount].getUuidArray(url, type, urls);
                this._loadResUuids(uuids, progressCallback, function(errors, assetRes, urlRes) {
                    for (var assetResLength = assetRes.length, i = 0; i < assetResLength; ++i) if (assetRes[i] instanceof cc.SpriteAtlas) {
                        var spriteFrames = assetRes[i].getSpriteFrames();
                        for (var k in spriteFrames) {
                            var sf = spriteFrames[k];
                            assetRes.push(sf), urlRes && urlRes.push("".concat(urlRes[i], "/").concat(sf.name));
                        }
                    }
                    completeCallback && completeCallback(errors, assetRes, urlRes);
                }, urls);
            }
        }
    }, {
        key: "loadResArray",
        value: function loadResArray(urls, type, mount, progressCallback, completeCallback) {
            5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
            mount = "assets");
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
            for (var uuids = [], i = 0; i < urls.length; i++) {
                var _url = urls[i], uuid = this._getResUuid(_url, type, mount, !0);
                if (!uuid) return void this._urlNotFound(_url, type, completeCallback);
                uuids.push(uuid);
            }
            this._loadResUuids(uuids, progressCallback, completeCallback);
        }
    }, {
        key: "getRes",
        value: function getRes(url, type) {
            var item = this._cache[url];
            if (!item) {
                var uuid = this._getResUuid(url, type, null, !0);
                if (!uuid) return null;
                var ref = this._getReferenceKey(uuid);
                item = this._cache[ref];
            }
            return item && item.alias && (item = item.alias), item && item.complete ? item.content : null;
        }
    }, {
        key: "getResCount",
        value: function getResCount() {
            return Object.keys(this._cache).length;
        }
    }, {
        key: "getDependsRecursively",
        value: function getDependsRecursively$1(owner) {
            if (owner) {
                var key = this._getReferenceKey(owner), assets = getDependsRecursively(key);
                return assets.push(key), assets;
            }
            return [];
        }
    }, {
        key: "release",
        value: function release(asset) {
            if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
                var key = asset[i];
                this.release(key);
            } else if (asset) {
                var id = this._getReferenceKey(asset), item = this.getItem(id);
                if (item) {
                    this.removeItem(id);
                    if ((asset = item.content) instanceof cc.Asset) {
                        var nativeUrl = asset.nativeUrl;
                        nativeUrl && this.release(nativeUrl), asset.destroy();
                    }
                    0;
                }
            }
        }
    }, {
        key: "releaseAsset",
        value: function releaseAsset(asset) {
            var uuid = asset._uuid;
            uuid && this.release(uuid);
        }
    }, {
        key: "releaseRes",
        value: function releaseRes(url, type, mount) {
            var uuid = this._getResUuid(url, type, mount, !0);
            uuid ? this.release(uuid) : cc.errorID(4914, url);
        }
    }, {
        key: "releaseResDir",
        value: function releaseResDir(url, type, mount) {
            if (assetTables[mount = mount || "assets"]) for (var uuids = assetTables[mount].getUuidArray(url, type), i = 0; i < uuids.length; i++) {
                var uuid = uuids[i];
                this.release(uuid);
            }
        }
    }, {
        key: "releaseAll",
        value: function releaseAll() {
            for (var id in this._cache) this.release(id);
        }
    }, {
        key: "removeItem",
        value: function removeItem(key) {
            var removed = Pipeline.prototype.removeItem.call(this, key);
            return delete this._autoReleaseSetting[key], removed;
        }
    }, {
        key: "setAutoRelease",
        value: function setAutoRelease(assetOrUrlOrUuid, autoRelease) {
            var key = this._getReferenceKey(assetOrUrlOrUuid);
            key && (this._autoReleaseSetting[key] = !!autoRelease);
        }
    }, {
        key: "setAutoReleaseRecursively",
        value: function setAutoReleaseRecursively(assetOrUrlOrUuid, autoRelease) {
            autoRelease = !!autoRelease;
            var key = this._getReferenceKey(assetOrUrlOrUuid);
            if (key) {
                this._autoReleaseSetting[key] = autoRelease;
                for (var depends = getDependsRecursively(key), i = 0; i < depends.length; i++) {
                    var depend = depends[i];
                    this._autoReleaseSetting[depend] = autoRelease;
                }
            } else 0;
        }
    }, {
        key: "isAutoRelease",
        value: function isAutoRelease(assetOrUrl) {
            var key = this._getReferenceKey(assetOrUrl);
            return !!key && !!this._autoReleaseSetting[key];
        }
    }, {
        key: "_getResUuid",
        value: function _getResUuid(url, type, mount, quiet) {
            var assetTable = assetTables[mount = mount || "assets"];
            if (!url || !assetTable) return null;
            var index = url.indexOf("?");
            -1 !== index && (url = url.substr(0, index));
            var uuid = assetTable.getUuid(url, type);
            if (!uuid) {
                var extname = cc.path.extname(url);
                extname && (url = url.slice(0, -extname.length), (uuid = assetTable.getUuid(url, type)) && !quiet && cc.warnID(4901, url, extname));
            }
            return uuid;
        }
    }, {
        key: "_getReferenceKey",
        value: function _getReferenceKey(assetOrUrlOrUuid) {
            var key;
            return "object" === _typeof(assetOrUrlOrUuid) ? key = assetOrUrlOrUuid._uuid || null : "string" == typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, null, !0) || assetOrUrlOrUuid), 
            key ? (cc.AssetLibrary._getAssetInfoInRuntime(key, _info), this._cache[_info.url] ? _info.url : key) : (cc.warnID(4800, assetOrUrlOrUuid), 
            key);
        }
    }, {
        key: "_urlNotFound",
        value: function _urlNotFound(url, type, completeCallback) {
            callInNextTick(function() {
                url = cc.url.normalize(url);
                var info = "".concat(type ? getClassName(type) : "Asset", ' in "resources/').concat(url, '" does not exist.');
                completeCallback && completeCallback(new Error(info), []);
            });
        }
    }, {
        key: "_parseLoadResArgs",
        value: function _parseLoadResArgs(type, onProgress, onComplete) {
            if (void 0 === onComplete) {
                var isValidType = isChildClassOf(type, cc.RawAsset);
                onProgress ? (onComplete = onProgress, isValidType && (onProgress = this.onProgress || null)) : void 0 !== onProgress || isValidType || (onComplete = type, 
                onProgress = this.onProgress || null, type = null), void 0 === onProgress || isValidType || (onProgress = type, 
                type = null);
            }
            return {
                type: type,
                onProgress: onProgress,
                onComplete: onComplete
            };
        }
    }, {
        key: "_loadResUuids",
        value: function _loadResUuids(uuids, progressCallback, completeCallback, urls) {
            if (uuids.length > 0) {
                var self = this, res = uuids.map(function(uuid) {
                    return {
                        type: "uuid",
                        uuid: uuid
                    };
                });
                this.load(res, progressCallback, function(errors, items) {
                    if (completeCallback) {
                        for (var assetRes = [], urlRes = urls && [], i = 0; i < res.length; ++i) {
                            var uuid = res[i].uuid, id = self._getReferenceKey(uuid), item = items.getContent(id);
                            item && (self.setAutoReleaseRecursively(uuid, !1), assetRes.push(item), urlRes && urlRes.push(urls[i]));
                        }
                        urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
                    }
                });
            } else completeCallback && callInNextTick(function() {
                urls ? completeCallback(null, [], []) : completeCallback(null, []);
            });
        }
    } ]), CCLoader;
}(), loader = cc.loader = new CCLoader();

function postLoadImage(imageAsset, callback) {
    imageAsset.loaded ? callback && callback() : imageAsset.nativeUrl ? loader.load({
        url: imageAsset.nativeUrl,
        skips: imageAsset.isCompressed ? void 0 : [ "Loader" ]
    }, function(err, image) {
        image && (imageAsset.loaded || (imageAsset._nativeAsset = image)), callback && callback(err);
    }) : callback && callback();
}

var _class$8, _dec$9, _dec2$4, _class$9, _class2$7, _descriptor$5, textureUtil = Object.freeze({
    loadImage: function loadImage$1(url, callback, target) {
        assertID(!!url, 3103);
        var imageAsset = loader.getRes(url);
        return imageAsset ? imageAsset.loaded ? (callback && callback.call(target, null, imageAsset), 
        imageAsset) : (imageAsset.once("load", function() {
            callback && callback.call(target, null, imageAsset);
        }, target), imageAsset) : (imageAsset = new ImageAsset(), loader.load({
            url: url,
            imageAsset: imageAsset
        }, function(err, asset) {
            if (err) return callback && callback.call(target, err || new Error("Unknown error")), 
            imageAsset;
            callback && callback.call(target, null, asset);
        }), imageAsset);
    },
    cacheImage: function cacheImage(url, image) {
        if (url && image) {
            var imageAsset = new ImageAsset(image), item = {
                id: url,
                url: url,
                error: null,
                content: imageAsset,
                complete: !1
            };
            return loader.flowOut(item), imageAsset;
        }
    },
    postLoadImage: postLoadImage
}), _regions = [ {
    buffOffset: 0,
    buffStride: 0,
    buffTexHeight: 0,
    texOffset: {
        x: 0,
        y: 0,
        z: 0
    },
    texExtent: {
        width: 1,
        height: 1,
        depth: 1
    },
    texSubres: {
        baseMipLevel: 1,
        levelCount: 1,
        baseArrayLayer: 0,
        layerCount: 1
    }
} ], SimpleTexture = ccclass("cc.SimpleTexture")(_class$8 = function(_TextureBase) {
    function SimpleTexture() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SimpleTexture);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SimpleTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._mipmapLevel = 1, 
        _this._gfxTexture = null, _this._gfxTextureView = null, _this;
    }
    return _inherits(SimpleTexture, TextureBase), _createClass(SimpleTexture, [ {
        key: "getGFXTexture",
        value: function getGFXTexture() {
            return this._gfxTexture;
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return this._gfxTextureView;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._tryDestroyTexture(), _get(_getPrototypeOf(SimpleTexture.prototype), "destroy", this).call(this);
        }
    }, {
        key: "updateImage",
        value: function updateImage() {
            this.updateMipmaps(0);
        }
    }, {
        key: "updateMipmaps",
        value: function updateMipmaps() {}
    }, {
        key: "uploadData",
        value: function uploadData(source) {
            var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, arrayIndex = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            if (this._gfxTexture && !(this._gfxTexture.mipLevel <= level)) {
                var gfxDevice = this._getGFXDevice();
                if (gfxDevice) {
                    var region = _regions[0];
                    region.texExtent.width = this._gfxTexture.width >> level, region.texExtent.height = this._gfxTexture.height >> level, 
                    region.texSubres.baseMipLevel = level, region.texSubres.baseArrayLayer = arrayIndex, 
                    source instanceof ArrayBuffer ? gfxDevice.copyBuffersToTexture([ source ], this._gfxTexture, _regions) : gfxDevice.copyTexImagesToTexture([ source ], this._gfxTexture, _regions);
                }
            }
        }
    }, {
        key: "_assignImage",
        value: function _assignImage(image, level, arrayIndex) {
            var _this2 = this, upload = function upload() {
                var source, data = image.data;
                data && (source = ArrayBuffer.isView(data) ? data.buffer : data, _this2.uploadData(source, level, arrayIndex), 
                _this2._checkTextureLoaded());
            };
            if (image.loaded) upload(); else {
                if (image.once("load", function() {
                    upload();
                }), !this.isCompressed) {
                    var defaultImg = cc.builtinResMgr.get("black-texture").image;
                    this.uploadData(defaultImg.data, level, arrayIndex);
                }
                postLoadImage(image);
            }
        }
    }, {
        key: "_checkTextureLoaded",
        value: function _checkTextureLoaded() {
            this._textureReady();
        }
    }, {
        key: "_textureReady",
        value: function _textureReady() {
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "_setMipmapLevel",
        value: function _setMipmapLevel(value) {
            this._mipmapLevel = value < 1 ? 1 : value;
        }
    }, {
        key: "_getGfxTextureCreateInfo",
        value: function _getGfxTextureCreateInfo(presumed) {
            return null;
        }
    }, {
        key: "_getGfxTextureViewCreateInfo",
        value: function _getGfxTextureViewCreateInfo(texture) {
            return null;
        }
    }, {
        key: "_tryReset",
        value: function _tryReset() {
            this._tryDestroyTexture();
            var device = this._getGFXDevice();
            device && this._createTexture(device);
        }
    }, {
        key: "_createTexture",
        value: function _createTexture(device) {
            var textureCreateInfo = this._getGfxTextureCreateInfo({
                usage: GFXTextureUsageBit.SAMPLED | GFXTextureUsageBit.TRANSFER_DST,
                format: this._getGFXFormat(),
                mipLevel: this._mipmapLevel,
                flags: this._mipFilter !== Filter.NONE ? GFXTextureFlagBit.GEN_MIPMAP : GFXTextureFlagBit.NONE
            });
            if (textureCreateInfo) {
                var texture = device.createTexture(textureCreateInfo), textureViewCreateInfo = this._getGfxTextureViewCreateInfo({
                    texture: texture,
                    format: this._getGFXFormat()
                });
                if (textureViewCreateInfo) {
                    var view = device.createTextureView(textureViewCreateInfo);
                    view ? (this._gfxTexture = texture, this._gfxTextureView = view) : texture.destroy();
                } else texture.destroy();
            }
        }
    }, {
        key: "_tryDestroyTexture",
        value: function _tryDestroyTexture() {
            this._gfxTexture && (this._gfxTexture.destroy(), this._gfxTexture = null), this._gfxTextureView && (this._gfxTextureView.destroy(), 
            this._gfxTextureView = null);
        }
    } ]), SimpleTexture;
}()) || _class$8;

cc.SimpleTexture = SimpleTexture;

var _class$a, _class2$8, _descriptor$6, _class3$6, _temp$9, Texture2D = (_dec$9 = ccclass("cc.Texture2D"), 
_dec2$4 = property([ ImageAsset ]), _dec$9((_descriptor$5 = _applyDecoratedDescriptor((_class2$7 = function(_SimpleTexture) {
    function Texture2D() {
        var _this;
        return _classCallCheck(this, Texture2D), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Texture2D).call(this, !0)), "_mipmaps", _descriptor$5, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(Texture2D, SimpleTexture), _createClass(Texture2D, [ {
        key: "mipmaps",
        get: function get() {
            return this._mipmaps;
        },
        set: function set(value) {
            var _this2 = this;
            if (this._mipmaps = value, this._mipmaps.length > 0) {
                var imageAsset = this._mipmaps[0];
                this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                }), this._mipmaps.forEach(function(mipmap, level) {
                    _this2._assignImage(mipmap, level);
                });
            } else this.reset({
                width: 0,
                height: 0,
                mipmapLevel: this._mipmaps.length
            });
        }
    }, {
        key: "image",
        get: function get() {
            return 0 === this._mipmaps.length ? null : this._mipmaps[0];
        },
        set: function set(value) {
            this.mipmaps = value ? [ value ] : [];
        }
    } ]), _createClass(Texture2D, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.initialize();
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
            this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
        }
    }, {
        key: "create",
        value: function create(width, height) {
            var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888, mipmapLevel = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            this.reset({
                width: width,
                height: height,
                format: format,
                mipmapLevel: mipmapLevel
            });
        }
    }, {
        key: "toString",
        value: function toString() {
            return 0 !== this._mipmaps.length ? this._mipmaps[0].url : "";
        }
    }, {
        key: "updateMipmaps",
        value: function updateMipmaps() {
            var firstLevel = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, count = arguments.length > 1 ? arguments[1] : void 0;
            if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), i = 0; i < nUpdate; ++i) {
                var level = firstLevel + i;
                this._assignImage(this._mipmaps[level], level);
            }
        }
    }, {
        key: "getHtmlElementObj",
        value: function getHtmlElementObj() {
            return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._mipmaps = [], _get(_getPrototypeOf(Texture2D.prototype), "destroy", this).call(this);
        }
    }, {
        key: "description",
        value: function description() {
            var url = this._mipmaps[0] ? this._mipmaps[0].url : "";
            return "<cc.Texture2D | Name = ".concat(url, " | Dimension = ").concat(this.width, " x ").concat(this.height, ">");
        }
    }, {
        key: "releaseTexture",
        value: function releaseTexture() {
            this.destroy();
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return {
                base: _get(_getPrototypeOf(Texture2D.prototype), "_serialize", this).call(this, exporting),
                mipmaps: this._mipmaps.map(function(mipmap) {
                    return exporting ? Editor.Utils.UuidUtils.compressUuid(mipmap._uuid, !0) : mipmap._uuid;
                })
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializedData, handle) {
            var data = serializedData;
            _get(_getPrototypeOf(Texture2D.prototype), "_deserialize", this).call(this, data.base, handle), 
            this._mipmaps = new Array(data.mipmaps.length);
            for (var i = 0; i < data.mipmaps.length; ++i) {
                this._mipmaps[i] = new ImageAsset();
                var mipmapUUID = data.mipmaps[i];
                handle.result.push(this._mipmaps, "".concat(i), mipmapUUID);
            }
        }
    }, {
        key: "initialize",
        value: function initialize() {
            this.mipmaps = this._mipmaps;
        }
    }, {
        key: "_getGfxTextureCreateInfo",
        value: function _getGfxTextureCreateInfo(presumed) {
            return Object.assign({
                type: GFXTextureType.TEX2D,
                width: this._width,
                height: this._height
            }, presumed);
        }
    }, {
        key: "_getGfxTextureViewCreateInfo",
        value: function _getGfxTextureViewCreateInfo(presumed) {
            return Object.assign({
                type: GFXTextureViewType.TV2D
            }, presumed);
        }
    }, {
        key: "_checkTextureLoaded",
        value: function _checkTextureLoaded() {
            for (var ready = !0, i = 0; i < this._mipmaps.length; ++i) {
                if (!this._mipmaps[i].loaded) {
                    ready = !1;
                    break;
                }
            }
            ready && _get(_getPrototypeOf(Texture2D.prototype), "_textureReady", this).call(this);
        }
    } ]), Texture2D;
}()).prototype, "_mipmaps", [ _dec2$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$9 = _class2$7)) || _class$9);

cc.Texture2D = Texture2D, ccenum(DepthStencilFormat);

var _class$b, RenderTexture = ccclass("cc.RenderTexture")((_temp$9 = _class3$6 = function(_TextureBase) {
    function RenderTexture(info) {
        var _this;
        return _classCallCheck(this, RenderTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RenderTexture).call(this, !0)))._window = null, 
        _initializerDefineProperty(_this, "_depthStencilFormat", _descriptor$6, _assertThisInitialized(_this)), 
        _this._cameras = [], info && _this.reset(info), _this;
    }
    return _inherits(RenderTexture, TextureBase), _createClass(RenderTexture, [ {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(value) {
            this._width = value, this.reset();
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(value) {
            this._height = value, this.reset();
        }
    }, {
        key: "depthStencilFormat",
        get: function get() {
            return this._depthStencilFormat;
        },
        set: function set(value) {
            this._depthStencilFormat = value, this.reset();
        }
    } ]), _createClass(RenderTexture, [ {
        key: "getGFXWindow",
        value: function getGFXWindow() {
            return this._window;
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return this._window ? this._window.colorTexView : null;
        }
    }, {
        key: "getGFXStencilTexture",
        value: function getGFXStencilTexture() {
            return this._window ? this._window.depthStencilTexView : null;
        }
    }, {
        key: "reset",
        value: function reset(info) {
            info && (this._width = info.width, this._height = info.height, this._format = info.colorFormat, 
            this._depthStencilFormat = info.depthStencilFormat), this._tryReset();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._tryDestroyWindow(), this._cameras.forEach(function(ca) {
                ca.changeTargetWindow();
            }), this._cameras.length = 0, _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this);
        }
    }, {
        key: "addCamera",
        value: function addCamera(camera) {
            -1 === this._cameras.findIndex(function(ca) {
                return ca === camera;
            }) && this._cameras.push(camera);
        }
    }, {
        key: "removeCamera",
        value: function removeCamera(camera) {
            var findIdx = this._cameras.findIndex(function(ca) {
                return ca === camera;
            });
            this._cameras.splice(findIdx, 1);
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this._tryReset(), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return {
                base: _get(_getPrototypeOf(RenderTexture.prototype), "_serialize", this).call(this),
                name: this._name,
                width: this._width,
                height: this._height,
                colorFormat: this._format,
                depthStencilFormat: this._depthStencilFormat
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializeData, handle) {
            _get(_getPrototypeOf(RenderTexture.prototype), "_deserialize", this).call(this, serializeData.base, handle);
            var data = serializeData;
            this.name = data.name || "", this._width = data.width, this._height = data.height, 
            this._format = data.colorFormat, this._depthStencilFormat = data.depthStencilFormat;
        }
    }, {
        key: "_tryReset",
        value: function _tryReset() {
            var _this2 = this;
            this._tryDestroyWindow();
            var device = this._getGFXDevice();
            device && (this._window = this._createWindow(device), this._cameras.forEach(function(ca) {
                ca.changeTargetWindow(_this2._window);
            }));
        }
    }, {
        key: "_createWindow",
        value: function _createWindow(device) {
            return cc.director.root.createWindow({
                title: this.name,
                isOffscreen: !0,
                width: this._width,
                height: this._height,
                colorFmt: this._format,
                depthStencilFmt: this._depthStencilFormat
            });
        }
    }, {
        key: "_tryDestroyWindow",
        value: function _tryDestroyWindow() {
            this._window && (cc.director.root.destroyWindow(this._window), this._window = null);
        }
    } ]), RenderTexture;
}(), _class3$6.DepthStencilFormat = DepthStencilFormat, _descriptor$6 = _applyDecoratedDescriptor((_class2$8 = _temp$9).prototype, "_depthStencilFormat", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return DepthStencilFormat.NONE;
    }
}), _applyDecoratedDescriptor(_class2$8.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$8.prototype, "width"), _class2$8.prototype), 
_applyDecoratedDescriptor(_class2$8.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$8.prototype, "height"), _class2$8.prototype), 
_applyDecoratedDescriptor(_class2$8.prototype, "depthStencilFormat", [ property ], Object.getOwnPropertyDescriptor(_class2$8.prototype, "depthStencilFormat"), _class2$8.prototype), 
_class$a = _class2$8)) || _class$a;

cc.RenderTexture = RenderTexture;

var _class$c, _class2$9, _descriptor$7, temp_uvs = [ {
    u: 0,
    v: 0
}, {
    u: 0,
    v: 0
}, {
    u: 0,
    v: 0
}, {
    u: 0,
    v: 0
} ], SpriteFrame = ccclass("cc.SpriteFrame")(_class$b = function(_Asset) {
    function SpriteFrame() {
        var _this;
        return _classCallCheck(this, SpriteFrame), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpriteFrame).call(this))).vertices = null, 
        _this.uv = [], _this.uvHash = 0, _this.uvSliced = [], _this._rect = new Rect(), 
        _this._offset = new Vec2(), _this._originalSize = new Size(), _this._rotated = !1, 
        _this._capInsets = [ 0, 0, 0, 0 ], _this._image = null, _this._original = null, 
        _this._atlasUuid = "", _this._texture = void 0, _this._flipUv = !1, _this._texture = new Texture2D(), 
        _this._texture.on("load", _this._textureLoaded, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SpriteFrame, Asset), _createClass(SpriteFrame, [ {
        key: "insetTop",
        get: function get() {
            return this._capInsets[1];
        },
        set: function set(value) {
            this._capInsets[1] = value, this._calculateSlicedUV();
        }
    }, {
        key: "insetBottom",
        get: function get() {
            return this._capInsets[3];
        },
        set: function set(value) {
            this._capInsets[3] = value, this.image && this._calculateSlicedUV();
        }
    }, {
        key: "insetLeft",
        get: function get() {
            return this._capInsets[0];
        },
        set: function set(value) {
            this._capInsets[0] = value, this.image && this._calculateSlicedUV();
        }
    }, {
        key: "insetRight",
        get: function get() {
            return this._capInsets[2];
        },
        set: function set(value) {
            this._capInsets[2] = value, this.image && this._calculateSlicedUV();
        }
    }, {
        key: "rect",
        get: function get() {
            return this._rect;
        },
        set: function set(value) {
            this._rect.set(value), this.image && this._calculateSlicedUV();
        }
    }, {
        key: "originalSize",
        get: function get() {
            return this._originalSize;
        },
        set: function set(value) {
            this._originalSize.set(value), this.image && this._calculateSlicedUV();
        }
    }, {
        key: "image",
        get: function get() {
            return this._image;
        },
        set: function set(value) {
            this._image = value;
            var tex = this._texture;
            value instanceof RenderTexture ? (this._texture.off("load"), (tex = new Texture2D()).image = value, 
            this._texture.on("load", this._textureLoaded, this)) : tex.image = value, this._textureLoaded();
        }
    }, {
        key: "_imageSource",
        set: function set(value) {
            this._image = value, this._texture.image = this._image, this._calculateUV();
        }
    }, {
        key: "texture",
        get: function get() {
            return this._texture;
        },
        set: function set(value) {
            value ? (this.reset({
                texture: value
            }, !0), this.emit("updated")) : console.warn("Error Texture in ".concat(this.name));
        }
    }, {
        key: "atlasUuid",
        get: function get() {
            return this._atlasUuid;
        },
        set: function set(value) {
            this._atlasUuid = value;
        }
    }, {
        key: "original",
        get: function get() {
            return this._original;
        }
    }, {
        key: "width",
        get: function get() {
            return this._texture.width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._texture.height;
        }
    } ], [ {
        key: "create",
        value: function create(config) {
            var spriteframe = new SpriteFrame();
            return spriteframe.initialize(config), spriteframe.onLoaded(), spriteframe;
        }
    } ]), _createClass(SpriteFrame, [ {
        key: "initialize",
        value: function initialize(info) {
            this.reset(info), this.onLoaded();
        }
    }, {
        key: "textureLoaded",
        value: function textureLoaded() {
            return this.loaded;
        }
    }, {
        key: "isRotated",
        value: function isRotated() {
            return this._rotated;
        }
    }, {
        key: "setRotated",
        value: function setRotated(rotated) {
            this._rotated = rotated;
        }
    }, {
        key: "getRect",
        value: function getRect(out) {
            return out ? (out.set(this._rect), out) : this._rect.clone();
        }
    }, {
        key: "setRect",
        value: function setRect(rect) {
            this._rect.set(rect);
        }
    }, {
        key: "getOriginalSize",
        value: function getOriginalSize(out) {
            return out ? (out.set(this._originalSize), out) : this._originalSize.clone();
        }
    }, {
        key: "setOriginalSize",
        value: function setOriginalSize(size) {
            this._originalSize.set(size);
        }
    }, {
        key: "getOffset",
        value: function getOffset(out) {
            return out ? (out.set(this._offset), out) : this._offset.clone();
        }
    }, {
        key: "setOffset",
        value: function setOffset(offsets) {
            this._offset.set(offsets);
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return this._texture.getGFXTextureView();
        }
    }, {
        key: "setGFXTextureView",
        value: function setGFXTextureView(value) {}
    }, {
        key: "clone",
        value: function clone() {
            var cap = this._capInsets, cloneSprite = new SpriteFrame();
            cloneSprite.name = this.name, cloneSprite.atlasUuid = this.atlasUuid, cloneSprite._image = this._image;
            var config = {
                originalSize: this._originalSize.clone(),
                rect: this._rect.clone(),
                offset: this._offset.clone(),
                borderLeft: cap[0],
                borderRight: cap[2],
                borderTop: cap[1],
                borderBottom: cap[3],
                isRotate: this._rotated,
                isFlipUv: this._flipUv
            };
            if (this._texture instanceof RenderTexture) config.texture = this._texture; else {
                var tex = new Texture2D();
                tex.image = this._image, config.texture = tex;
            }
            return cloneSprite.reset(config), cloneSprite.onLoaded(), cloneSprite;
        }
    }, {
        key: "ensureLoadTexture",
        value: function ensureLoadTexture() {}
    }, {
        key: "updateImage",
        value: function updateImage() {
            this._texture instanceof Texture2D && this._texture._assignImage(this._image, 0);
        }
    }, {
        key: "reset",
        value: function reset(info) {
            var clearData = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], calUV = !1;
            clearData && (this._originalSize.set(0, 0), this._rect.set(0, 0, 0, 0), this._offset.set(0, 0), 
            this._capInsets = [ 0, 0, 0, 0 ], this._rotated = !1, calUV = !0), info && (info.texture && (this._rect.x = this._rect.y = 0, 
            this._rect.width = info.texture.width, this._rect.height = info.texture.height, 
            this._texture.off("load"), this._texture = info.texture, this.checkRect(this._texture), 
            this._texture.on("load", this._textureLoaded, this)), info.originalSize && this._originalSize.set(info.originalSize), 
            info.rect && this._rect.set(info.rect), info.offset && this._offset.set(info.offset), 
            void 0 !== info.borderTop && (this._capInsets[1] = info.borderTop), void 0 !== info.borderBottom && (this._capInsets[3] = info.borderBottom), 
            void 0 !== info.borderLeft && (this._capInsets[0] = info.borderLeft), void 0 !== info.borderRight && (this._capInsets[2] = info.borderRight), 
            this._rotated = !!info.isRotate, this._flipUv = !!info.isFlipUv, this._texture instanceof RenderTexture && (this._flipUv = !0), 
            calUV = !0), calUV && this._calculateUV();
        }
    }, {
        key: "checkRect",
        value: function checkRect(texture) {
            var rect = this._rect, maxX = rect.x, maxY = rect.y;
            return this._rotated ? (maxX += rect.height, maxY += rect.width) : (maxX += rect.width, 
            maxY += rect.height), maxX > texture.width ? (cc.errorID(3300, this.name + "/" + texture.name, maxX, texture.width), 
            !1) : !(maxY > texture.height) || (cc.errorID(3400, this.name + "/" + texture.name, maxY, texture.height), 
            !1);
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "_refreshTexture",
        value: function _refreshTexture(image) {}
    }, {
        key: "_calculateSlicedUV",
        value: function _calculateSlicedUV() {
            var rect = this._rect, atlasWidth = this._texture.width, atlasHeight = this._texture.height, leftWidth = this._capInsets[0], rightWidth = this._capInsets[2], centerWidth = rect.width - leftWidth - rightWidth, topHeight = this._capInsets[1], bottomHeight = this._capInsets[3], centerHeight = rect.height - topHeight - bottomHeight, uvSliced = this.uvSliced;
            if (uvSliced.length = 0, this._rotated) {
                temp_uvs[0].u = (rect.x + rect.height) / atlasWidth, temp_uvs[1].u = (rect.x + bottomHeight + centerHeight) / atlasWidth, 
                temp_uvs[2].u = (rect.x + bottomHeight) / atlasWidth, temp_uvs[3].u = rect.x / atlasWidth, 
                temp_uvs[3].v = (rect.y + rect.width) / atlasHeight, temp_uvs[2].v = (rect.y + leftWidth + centerWidth) / atlasHeight, 
                temp_uvs[1].v = (rect.y + leftWidth) / atlasHeight, temp_uvs[0].v = rect.y / atlasHeight;
                for (var row = 0; row < 4; ++row) for (var rowD = temp_uvs[row], col = 0; col < 4; ++col) {
                    var colD = temp_uvs[3 - col];
                    uvSliced.push({
                        u: rowD.u,
                        v: colD.v
                    });
                }
            } else {
                temp_uvs[0].u = rect.x / atlasWidth, temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth, 
                temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth, temp_uvs[3].u = (rect.x + rect.width) / atlasWidth, 
                temp_uvs[3].v = rect.y / atlasHeight, temp_uvs[2].v = (rect.y + topHeight) / atlasHeight, 
                temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight, temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
                for (var _row = 0; _row < 4; ++_row) for (var _rowD = temp_uvs[_row], _col = 0; _col < 4; ++_col) {
                    var _colD = temp_uvs[_col];
                    uvSliced.push({
                        u: _colD.u,
                        v: _rowD.v
                    });
                }
            }
        }
    }, {
        key: "_setDynamicAtlasFrame",
        value: function _setDynamicAtlasFrame(frame) {
            frame && (this._original = {
                spriteframe: this,
                x: this._rect.x,
                y: this._rect.y
            }, this._rect.x = frame._rect.x, this._rect.y = frame._rect.y, this._image = frame.image, 
            this._calculateUV());
        }
    }, {
        key: "_resetDynamicAtlasFrame",
        value: function _resetDynamicAtlasFrame() {
            this._original && (this._rect.x = this._original.x, this._rect.y = this._original.y, 
            this._image = this._original.spriteframe.image, this._original = null, this._calculateUV());
        }
    }, {
        key: "_calculateUV",
        value: function _calculateUV() {
            var rect = this._rect, uv = this.uv, texw = this._texture.width, texh = this._texture.height;
            if (this._rotated) {
                var l = 0 === texw ? 0 : rect.x / texw, r = 0 === texw ? 0 : (rect.x + rect.height) / texw, b = 0 === texh ? 0 : (rect.y + rect.width) / texh, t = 0 === texh ? 0 : rect.y / texh;
                this._flipUv ? (uv[0] = l, uv[1] = t, uv[2] = l, uv[3] = b, uv[4] = r, uv[5] = t, 
                uv[6] = r, uv[7] = b) : (uv[0] = r, uv[1] = b, uv[2] = r, uv[3] = t, uv[4] = l, 
                uv[5] = b, uv[6] = l, uv[7] = t);
            } else {
                var _l = 0 === texw ? 0 : rect.x / texw, _r = 0 === texw ? 0 : (rect.x + rect.width) / texw, _b = 0 === texh ? 0 : (rect.y + rect.height) / texh, _t = 0 === texh ? 0 : rect.y / texh;
                this._flipUv ? (uv[0] = _l, uv[1] = _t, uv[2] = _r, uv[3] = _t, uv[4] = _l, uv[5] = _b, 
                uv[6] = _r, uv[7] = _b) : (uv[0] = _l, uv[1] = _b, uv[2] = _r, uv[3] = _b, uv[4] = _l, 
                uv[5] = _t, uv[6] = _r, uv[7] = _t);
            }
            for (var uvHashStr = "", i = 0; i < uv.length; i++) uvHashStr += uv[i];
            this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
            var vertices = this.vertices;
            if (vertices) {
                vertices.nu.length = 0, vertices.nv.length = 0;
                for (var _i = 0; _i < vertices.u.length; _i++) vertices.nu[_i] = vertices.u[_i] / texw, 
                vertices.nv[_i] = vertices.v[_i] / texh;
            }
            this._calculateSlicedUV();
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            var vertices, rect = this._rect, offset = this._offset, originalSize = this._originalSize, uuid = this._uuid;
            return uuid && exporting && (uuid = Editor.Utils.UuidUtils.compressUuid(uuid, !0)), 
            this.vertices && (vertices = {
                triangles: this.vertices.triangles,
                x: this.vertices.x,
                y: this.vertices.y,
                u: this.vertices.u,
                v: this.vertices.v
            }), {
                image: this._image ? exporting ? Editor.Utils.UuidUtils.compressUuid(this._image._uuid, !0) : this._image._uuid : void 0,
                name: this._name,
                atlas: exporting ? void 0 : this._atlasUuid,
                rect: rect,
                offset: offset,
                originalSize: originalSize,
                rotated: this._rotated,
                capInsets: this._capInsets,
                vertices: vertices
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializeData, handle) {
            var data = serializeData, rect = data.rect;
            rect && this.setRect(new Rect(rect.x, rect.y, rect.width, rect.height));
            var offset = data.offset;
            data.offset && this.setOffset(new Vec2(offset.x, offset.y));
            var originalSize = data.originalSize;
            data.originalSize && this.setOriginalSize(new Size(originalSize.width, originalSize.height)), 
            this._rotated = !!data.rotated, this._name = data.name;
            var capInsets = data.capInsets;
            capInsets && (this._capInsets[0] = capInsets[0], this._capInsets[1] = capInsets[1], 
            this._capInsets[2] = capInsets[2], this._capInsets[3] = capInsets[3]), handle.result.push(this, "_imageSource", data.image), 
            this.vertices = data.vertices, this.vertices && (this.vertices.nu = [], this.vertices.nv = []);
        }
    }, {
        key: "_textureLoaded",
        value: function _textureLoaded() {
            var tex = this._texture, config = {}, isReset = !1;
            0 !== this._rect.width && 0 !== this._rect.height && this.checkRect(tex) || (config.rect = new Rect(0, 0, tex.width, tex.height), 
            isReset = !0), (0 === this._originalSize.width || 0 === this._originalSize.height || this._originalSize.width > tex.width || this._originalSize.height > tex.height) && (config.originalSize = new Size(tex.width, tex.height), 
            isReset = !0), isReset && (this.reset(config), this.emit("updated"));
        }
    } ]), SpriteFrame;
}()) || _class$b;

cc.SpriteFrame = SpriteFrame;

var _class$d, _class2$a, _descriptor$8, SpriteAtlas = ccclass("cc.SpriteAtlas")((_descriptor$7 = _applyDecoratedDescriptor((_class2$9 = function(_Asset) {
    function SpriteAtlas() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SpriteAtlas);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteAtlas)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spriteFrames", _descriptor$7, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SpriteAtlas, Asset), _createClass(SpriteAtlas, [ {
        key: "getTexture",
        value: function getTexture() {
            var keys = Object.keys(this.spriteFrames);
            if (keys.length > 0) {
                var spriteFrame = this.spriteFrames[keys[0]];
                return spriteFrame ? spriteFrame.image : null;
            }
            return null;
        }
    }, {
        key: "getSpriteFrame",
        value: function getSpriteFrame(key) {
            var sf = this.spriteFrames[key];
            return sf ? (sf.name || (sf.name = key), sf) : null;
        }
    }, {
        key: "getSpriteFrames",
        value: function getSpriteFrames() {
            for (var frames = [], spriteFrames = this.spriteFrames, _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                var _key2 = _Object$keys[_i];
                frames.push(spriteFrames[_key2]);
            }
            return frames;
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            for (var frames = [], _i2 = 0, _Object$keys2 = Object.keys(this.spriteFrames); _i2 < _Object$keys2.length; _i2++) {
                var _key3 = _Object$keys2[_i2], spriteFrame = this.spriteFrames[_key3], id = spriteFrame ? spriteFrame._uuid : "";
                id && exporting && (id = Editor.Utils.UuidUtils.compressUuid(id, !0)), frames.push(_key3), 
                frames.push(id);
            }
            return {
                name: this._name,
                spriteFrames: frames
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializeData, handle) {
            var data = serializeData;
            this._name = data.name;
            var frames = data.spriteFrames;
            this.spriteFrames = createMap();
            for (var i = 0; i < frames.length; i += 2) handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
        }
    } ]), SpriteAtlas;
}()).prototype, "spriteFrames", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return createMap();
    }
}), _class$c = _class2$9)) || _class$c;

cc.SpriteAtlas = SpriteAtlas;

var _class$e, _class2$b, _descriptor$9, TextAsset = ccclass("cc.TextAsset")((_descriptor$8 = _applyDecoratedDescriptor((_class2$a = function(_Asset) {
    function TextAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TextAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "text", _descriptor$8, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(TextAsset, Asset), _createClass(TextAsset, [ {
        key: "toString",
        value: function toString() {
            return this.text;
        }
    } ]), TextAsset;
}()).prototype, "text", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$d = _class2$a)) || _class$d;

cc.TextAsset = TextAsset;

var JsonAsset = ccclass("cc.JsonAsset")((_descriptor$9 = _applyDecoratedDescriptor((_class2$b = function(_Asset) {
    function JsonAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, JsonAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(JsonAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "json", _descriptor$9, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(JsonAsset, Asset), JsonAsset;
}()).prototype, "json", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$e = _class2$b)) || _class$e;

cc.JsonAsset = JsonAsset;

var HexChars = "0123456789abcdef".split(""), _t = [ "", "", "", "" ], UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t), Indices = UuidTemplate.map(function(x, i) {
    return "-" === x ? NaN : i;
}).filter(isFinite);

function decodeUuid(base64) {
    var uuid = base64.split("@")[0];
    if (22 !== uuid.length) return base64;
    UuidTemplate[0] = base64[0], UuidTemplate[1] = base64[1];
    for (var i = 2, j = 2; i < 22; i += 2) {
        var lhs = BASE64_VALUES[base64.charCodeAt(i)], rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
        UuidTemplate[Indices[j++]] = HexChars[lhs >> 2], UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4], 
        UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
    }
    return base64.replace(uuid, UuidTemplate.join(""));
}

var decodeUuid$1 = Object.freeze({
    default: decodeUuid
}), ID$3 = "MD5Pipe", ExtnameRegex = /(\.[^.\n\\\/]*)$/, UuidRegex = /([^\/\\]*)\.[^\.]*$/;

var MD5Pipe = function() {
    function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
        _classCallCheck(this, MD5Pipe), this.id = ID$3, this.async = !1, this.pipeline = null, 
        this.md5AssetsMap = md5AssetsMap, this.md5NativeAssetsMap = md5NativeAssetsMap, 
        this.libraryBase = libraryBase;
    }
    return _createClass(MD5Pipe, [ {
        key: "handle",
        value: function handle(item) {
            var hashPatchInFolder = !1;
            return "ttf" === item.type && (hashPatchInFolder = !0), item.url = this.transformURL(item.url, hashPatchInFolder), 
            item;
        }
    }, {
        key: "transformURL",
        value: function transformURL(url, hashPatchInFolder) {
            var uuid = function getUuidFromURL(url) {
                var matches = url.match(UuidRegex);
                return matches ? matches[1] : "";
            }(url);
            if (uuid) {
                var hashValue = (!url.match(this.libraryBase) ? this.md5NativeAssetsMap : this.md5AssetsMap)[uuid];
                if (hashValue) if (hashPatchInFolder) {
                    var dirname = cc.path.dirname(url), basename = cc.path.basename(url);
                    url = "".concat(dirname, ".").concat(hashValue, "/").concat(basename);
                } else {
                    var matched = !1;
                    url = url.replace(ExtnameRegex, function(match, p1) {
                        return matched = !0, "." + hashValue + p1;
                    }), matched || (url = url + "." + hashValue);
                }
            }
            return url;
        }
    } ]), MD5Pipe;
}();

function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}

function createCommonjsModule(fn, module) {
    return fn(module = {
        exports: {}
    }, module.exports), module.exports;
}

MD5Pipe.ID = ID$3, Pipeline.MD5Pipe = MD5Pipe;

var decodeUuid$2 = function getCjsExportFromNamespace(n) {
    return n && n.default || n;
}(decodeUuid$1), subpackagePipe = createCommonjsModule(function(module) {
    var ID = "SubPackPipe", UuidRegex = /([^\/\\]*)\.[^\.]*$/;
    var _uuidToSubPack = Object.create(null), SubPackPipe = function SubPackPipe(subpackage) {
        for (var packName in this.id = ID, this.async = !1, this.pipeline = null, subpackage) {
            var pack = subpackage[packName];
            pack.uuids && pack.uuids.forEach(function(val) {
                var uuid = decodeUuid$2(val);
                _uuidToSubPack[uuid] = pack.path;
            });
        }
    };
    SubPackPipe.ID = ID, SubPackPipe.prototype.handle = function(item) {
        return item.url = this.transformURL(item.url), null;
    }, SubPackPipe.prototype.transformURL = function(url) {
        var uuid = function getUuidFromURL(url) {
            var matches = url.match(UuidRegex);
            return matches ? matches[1] : "";
        }(url);
        if (uuid) {
            var subpackage = _uuidToSubPack[uuid];
            if (subpackage) return url.replace("res/raw-assets/", subpackage + "raw-assets/");
        }
        return url;
    }, Pipeline.SubPackPipe = module.exports = SubPackPipe;
}), _libraryBase = "", _rawAssetsBase = "", _uuidToRawAsset = createMap(!0);

function RawAssetEntry(url, type) {
    this.url = url, this.type = type;
}

var _class$f, AssetLibrary = {
    _uuidToAsset: {},
    loadAsset: function loadAsset(uuid, callback, options) {
        if ("string" != typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
        var item = {
            uuid: uuid,
            type: "uuid"
        };
        options && options.existingAsset && (item.existingAsset = options.existingAsset), 
        cc.loader.load(item, function(error, asset) {
            if (error || !asset) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error ? error.message : "Unknown error")); else if (asset.constructor === cc.SceneAsset) {
                var key = cc.loader._getReferenceKey(uuid);
                asset.scene.dependAssets = getDependsRecursively(key);
            }
            callback && callback(error, asset);
        });
    },
    getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
        var uuids = uuid.split("@").map(function(name) {
            return encodeURIComponent(name);
        });
        return uuid = uuids.join("@"), _libraryBase + uuid.slice(0, 2) + "/" + uuid;
    },
    _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
        0;
    },
    _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
        result = result || {
            url: null,
            raw: !1
        };
        var info = _uuidToRawAsset[uuid];
        return info && !isChildClassOf(info.type, cc.Asset) ? (result.url = _rawAssetsBase + info.url, 
        result.raw = !0) : (result.url = this.getLibUrlNoExt(uuid) + ".json", result.raw = !1), 
        result;
    },
    _uuidInSettings: function _uuidInSettings(uuid) {
        return uuid in _uuidToRawAsset;
    },
    queryAssetInfo: function queryAssetInfo(uuid, callback) {
        var info = this._getAssetInfoInRuntime(uuid);
        callback(null, info.url, info.raw);
    },
    parseUuidInEditor: function parseUuidInEditor(url) {},
    loadJson: function loadJson(json, callback) {
        var randomUuid = "" + (new Date().getTime() + Math.random()), item = {
            uuid: randomUuid,
            type: "uuid",
            content: json,
            skips: [ cc.loader.assetLoader.id, cc.loader.downloader.id ]
        };
        cc.loader.load(item, function(error, asset) {
            if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
                if (asset.constructor === cc.SceneAsset) {
                    var key = cc.loader._getReferenceKey(randomUuid);
                    asset.scene.dependAssets = getDependsRecursively(key);
                }
                if (function isScene(asset) {
                    return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
                }(asset)) {
                    var id = cc.loader._getReferenceKey(randomUuid);
                    cc.loader.removeItem(id);
                }
            }
            asset._uuid = "", callback && callback(error, asset);
        });
    },
    getAssetByUuid: function getAssetByUuid(uuid) {
        return AssetLibrary._uuidToAsset[uuid] || null;
    },
    init: function init(options) {
        var libraryPath = options.libraryPath;
        libraryPath = libraryPath.replace(/\\/g, "/"), _libraryBase = cc.path.stripSep(libraryPath) + "/", 
        _rawAssetsBase = options.rawAssetsBase;
        var md5AssetsMap = options.md5AssetsMap;
        if (md5AssetsMap && md5AssetsMap.import) {
            var i = 0, md5ImportMap = createMap(!0), md5Entries = md5AssetsMap.import;
            for (i = 0; i < md5Entries.length; i += 2) md5ImportMap[decodeUuid(md5Entries[i])] = md5Entries[i + 1];
            var md5RawAssetsMap = createMap(!0);
            for (md5Entries = md5AssetsMap["raw-assets"], i = 0; i < md5Entries.length; i += 2) md5RawAssetsMap[decodeUuid(md5Entries[i])] = md5Entries[i + 1];
            var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
            cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe), cc.loader.md5Pipe = md5Pipe;
        }
        if (options.subpackages) {
            var subPackPipe = new subpackagePipe(options.subpackages);
            cc.loader.insertPipeAfter(cc.loader.assetLoader, subPackPipe), cc.loader.subPackPipe = subPackPipe;
        }
        var assetTables = loader._assetTables;
        for (var mount in assetTables) assetTables[mount].reset();
        var rawAssets = options.rawAssets;
        if (rawAssets) for (var mountPoint in rawAssets) {
            var assets = rawAssets[mountPoint];
            for (var _uuid in assets) {
                var info = assets[_uuid], url = info[0], typeId = info[1], type = _getClassById(typeId);
                if (type) {
                    _uuidToRawAsset[_uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
                    var isSubAsset = 1 === info[2];
                    assetTables[mountPoint] || (assetTables[mountPoint] = new AssetTable()), assetTables[mountPoint].add(url, _uuid, type, !isSubAsset);
                } else cc.error("Cannot get", typeId);
            }
        }
        options.packedAssets && initPacks(options.packedAssets), cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
    }
};

cc.AssetLibrary = AssetLibrary;

var _dec$g, _dec2$5, _class$g, _class2$c, _descriptor$a, Font = ccclass("cc.Font")(_class$f = function(_Asset) {
    function Font() {
        return _classCallCheck(this, Font), _possibleConstructorReturn(this, _getPrototypeOf(Font).apply(this, arguments));
    }
    return _inherits(Font, Asset), Font;
}()) || _class$f;

cc.Font = Font;

var _dec$h, _dec2$6, _class$h, _class2$d, _descriptor$b, _descriptor2$4, _descriptor3$2, _descriptor4$1, TTFFont = (_dec$g = ccclass("cc.TTFFont"), 
_dec2$5 = property({
    type: cc.String,
    override: !0
}), _dec$g((_descriptor$a = _applyDecoratedDescriptor((_class2$c = function(_Font) {
    function TTFFont() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TTFFont);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TTFFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_fontFamily", _descriptor$a, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(TTFFont, Font), _createClass(TTFFont, [ {
        key: "_nativeAsset",
        get: function get() {
            return this._fontFamily;
        },
        set: function set(value) {
            this._fontFamily = value || "Arial";
        }
    } ]), TTFFont;
}()).prototype, "_fontFamily", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$c.prototype, "_nativeAsset", [ _dec2$5 ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "_nativeAsset"), _class2$c.prototype), 
_class$g = _class2$c)) || _class$g);

cc.TTFFont = TTFFont;

var _class$i, BitmapFont = (_dec$h = ccclass("cc.BitmapFont"), _dec2$6 = property({
    type: SpriteFrame
}), _dec$h((_descriptor$b = _applyDecoratedDescriptor((_class2$d = function(_Font) {
    function BitmapFont() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, BitmapFont);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BitmapFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "fntDataStr", _descriptor$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "spriteFrame", _descriptor2$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "fontSize", _descriptor3$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "fntConfig", _descriptor4$1, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(BitmapFont, Font), BitmapFont;
}()).prototype, "fntDataStr", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor2$4 = _applyDecoratedDescriptor(_class2$d.prototype, "spriteFrame", [ _dec2$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$2 = _applyDecoratedDescriptor(_class2$d.prototype, "fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class2$d.prototype, "fntConfig", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$h = _class2$d)) || _class$h);

cc.BitmapFont = BitmapFont;

var _dec$j, _dec2$7, _dec3$1, _dec4, _dec5, _dec6, _dec7, _class$j, _class2$e, _descriptor$c, _descriptor2$5, _class3$7, _temp$g, LabelAtlas = ccclass("cc.LabelAtlas")(_class$i = function(_BitmapFont) {
    function LabelAtlas() {
        return _classCallCheck(this, LabelAtlas), _possibleConstructorReturn(this, _getPrototypeOf(LabelAtlas).apply(this, arguments));
    }
    return _inherits(LabelAtlas, BitmapFont), LabelAtlas;
}()) || _class$i;

cc.LabelAtlas = LabelAtlas;

var idGenerator$1 = new IDGenerator("Comp"), IsOnLoadCalled$1 = (CCObject.Flags.IsOnEnableCalled, 
CCObject.Flags.IsOnLoadCalled), Component = (_dec$j = ccclass("cc.Component"), _dec2$7 = property({
    visible: !1
}), _dec3$1 = property({
    visible: !1
}), _dec4 = property({
    displayName: "Script",
    type: Script,
    tooltip: void 0
}), _dec5 = property({
    visible: !1
}), _dec6 = property({
    visible: !1
}), _dec7 = property({
    visible: !1
}), _dec$j((_temp$g = _class3$7 = function(_CCObject) {
    function Component() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Component);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "node", _descriptor$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_enabled", _descriptor2$5, _assertThisInitialized(_this)), 
        _this._sceneGetter = null, _this._id = idGenerator$1.getNewId(), _this._eventTargets = [], 
        _this;
    }
    return _inherits(Component, CCObject), _createClass(Component, [ {
        key: "_getRenderScene",
        value: function _getRenderScene() {
            return this._sceneGetter ? this._sceneGetter() : this.node.scene._renderScene;
        }
    }, {
        key: "addComponent",
        value: function addComponent(typeOrClassName) {
            return this.node.addComponent(typeOrClassName);
        }
    }, {
        key: "getComponent",
        value: function getComponent(typeOrClassName) {
            return this.node.getComponent(typeOrClassName);
        }
    }, {
        key: "getComponents",
        value: function getComponents(typeOrClassName) {
            return this.node.getComponents(typeOrClassName);
        }
    }, {
        key: "getComponentInChildren",
        value: function getComponentInChildren(typeOrClassName) {
            return this.node.getComponentInChildren(typeOrClassName);
        }
    }, {
        key: "getComponentsInChildren",
        value: function getComponentsInChildren(typeOrClassName) {
            return this.node.getComponentsInChildren(typeOrClassName);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _get(_getPrototypeOf(Component.prototype), "destroy", this).call(this) && this._enabled && this.node.activeInHierarchy && cc.director._compScheduler.disableComp(this);
        }
    }, {
        key: "_onPreDestroy",
        value: function _onPreDestroy() {
            this.unscheduleAllCallbacks();
            for (var eventTargets = this._eventTargets, i = 0, l = eventTargets.length; i < l; ++i) {
                var target = eventTargets[i];
                target && target.targetOff(this);
            }
            eventTargets.length = 0, cc.director._nodeActivator.destroyComp(this), this.node._removeComponent(this);
        }
    }, {
        key: "_instantiate",
        value: function _instantiate(cloned) {
            return cloned || (cloned = cc.instantiate._clone(this, this)), cloned.node = null, 
            cloned;
        }
    }, {
        key: "schedule",
        value: function schedule(callback) {
            var interval = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, repeat = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : cc.macro.REPEAT_FOREVER, delay = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            cc.assertID(callback, 1619), cc.assertID(interval >= 0, 1620), interval = interval || 0, 
            repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat, delay = delay || 0;
            var scheduler = cc.director.getScheduler(), paused = scheduler.isTargetPaused(this);
            scheduler.schedule(callback, this, interval, repeat, delay, paused);
        }
    }, {
        key: "scheduleOnce",
        value: function scheduleOnce(callback) {
            var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            this.schedule(callback, 0, 0, delay);
        }
    }, {
        key: "unschedule",
        value: function unschedule(callback_fn) {
            callback_fn && cc.director.getScheduler().unschedule(callback_fn, this);
        }
    }, {
        key: "unscheduleAllCallbacks",
        value: function unscheduleAllCallbacks() {
            cc.director.getScheduler().unscheduleAllForTarget(this);
        }
    }, {
        key: "name",
        get: function get() {
            if (this._name) return this._name;
            var className = getClassName(this), trimLeft = className.lastIndexOf(".");
            return trimLeft >= 0 && (className = className.slice(trimLeft + 1)), this.node.name + "<" + className + ">";
        },
        set: function set(value) {
            this._name = value;
        }
    }, {
        key: "uuid",
        get: function get() {
            return this._id;
        }
    }, {
        key: "__scriptAsset",
        get: function get() {
            return null;
        }
    }, {
        key: "enabled",
        get: function get() {
            return this._enabled;
        },
        set: function set(value) {
            if (this._enabled !== value && (this._enabled = value, this.node.activeInHierarchy)) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
            }
        }
    }, {
        key: "enabledInHierarchy",
        get: function get() {
            return this._enabled && this.node && this.node.activeInHierarchy;
        }
    }, {
        key: "_isOnLoadCalled",
        get: function get() {
            return this._objFlags & IsOnLoadCalled$1;
        }
    } ]), Component;
}(), _class3$7.system = null, _applyDecoratedDescriptor((_class2$e = _temp$g).prototype, "name", [ _dec2$7 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "name"), _class2$e.prototype), 
_applyDecoratedDescriptor(_class2$e.prototype, "uuid", [ _dec3$1 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "uuid"), _class2$e.prototype), 
_applyDecoratedDescriptor(_class2$e.prototype, "__scriptAsset", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "__scriptAsset"), _class2$e.prototype), 
_applyDecoratedDescriptor(_class2$e.prototype, "enabled", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "enabled"), _class2$e.prototype), 
_applyDecoratedDescriptor(_class2$e.prototype, "enabledInHierarchy", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2$e.prototype, "enabledInHierarchy"), _class2$e.prototype), 
_descriptor$c = _applyDecoratedDescriptor(_class2$e.prototype, "node", [ _dec7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_enabled", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _class$j = _class2$e)) || _class$j), proto$1 = Component.prototype;

proto$1.update = null, proto$1.lateUpdate = null, proto$1.__preload = null, proto$1.onLoad = null, 
proto$1.start = null, proto$1.onEnable = null, proto$1.onDisable = null, proto$1.onDestroy = null, 
proto$1.onFocusInEditor = null, proto$1.onLostFocusInEditor = null, proto$1.resetInEditor = null, 
proto$1._getLocalBounds = null, proto$1.onRestore = null, Component._requireComponent = null, 
Component._executionOrder = 0, value(Component, "_registerEditorProps", function(cls, props) {
    var reqComp = props.requireComponent;
    reqComp && (cls._requireComponent = reqComp);
    var order = props.executionOrder;
    order && "number" == typeof order && (cls._executionOrder = order);
}), cc.Component = Component;

var _class$k, _class2$f, _descriptor$d, _descriptor2$6, _descriptor3$3, _descriptor4$2, _descriptor5$1, _class3$8, _temp$h;

CCObject.Flags.Destroying;

var Destroying$2 = CCObject.Flags.Destroying, DontDestroy$1 = CCObject.Flags.DontDestroy, Deactivating$1 = CCObject.Flags.Deactivating, idGenerator$2 = new IDGenerator("Node"), NullScene = null;

function getConstructor(typeOrClassName) {
    return typeOrClassName ? "string" == typeof typeOrClassName ? getClassByName(typeOrClassName) : typeOrClassName : (cc.errorID(3804), 
    null);
}

var BaseNode = ccclass("cc._BaseNode")((_temp$h = _class3$8 = function(_CCObject) {
    function BaseNode(name) {
        var _this;
        return _classCallCheck(this, BaseNode), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name)), "_parent", _descriptor$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_children", _descriptor2$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_active", _descriptor3$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_components", _descriptor4$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_prefab", _descriptor5$1, _assertThisInitialized(_this)), 
        _this._scene = NullScene, _this._activeInHierarchy = !1, _this._id = idGenerator$2.getNewId(), 
        _this.__eventTargets = [], _this._siblingIndex = 0, _this._name = void 0 !== name ? name : "New Node", 
        cc.director && cc.director._scheduler && cc.director._scheduler.enableForTarget(_assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(BaseNode, CCObject), _createClass(BaseNode, [ {
        key: "components",
        get: function get() {
            return this._components;
        }
    }, {
        key: "_persistNode",
        get: function get() {
            return (this._objFlags & DontDestroy$1) > 0;
        },
        set: function set(value) {
            value ? this._objFlags |= DontDestroy$1 : this._objFlags &= ~DontDestroy$1;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        },
        set: function set(value) {
            this._name = value;
        }
    }, {
        key: "uuid",
        get: function get() {
            return this._id;
        }
    }, {
        key: "children",
        get: function get() {
            return this._children;
        }
    }, {
        key: "active",
        get: function get() {
            return this._active;
        },
        set: function set(isActive) {
            if (this._active !== isActive) {
                this._active = isActive;
                var parent = this._parent;
                if (parent) parent._activeInHierarchy && cc.director._nodeActivator.activateNode(this, isActive);
            }
        }
    }, {
        key: "activeInHierarchy",
        get: function get() {
            return this._activeInHierarchy;
        }
    }, {
        key: "parent",
        get: function get() {
            return this._parent;
        },
        set: function set(value) {
            this.setParent(value);
        }
    }, {
        key: "scene",
        get: function get() {
            return this._scene;
        }
    } ], [ {
        key: "_setScene",
        value: function _setScene(node) {
            node instanceof cc.Scene ? node._scene = node : null == node._parent ? cc.error("Node %s(%s) has not attached to a scene.", node.name, node.uuid) : node._scene = node._parent._scene;
        }
    }, {
        key: "_findComponent",
        value: function _findComponent(node, constructor) {
            var cls = constructor, comps = node._components;
            if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                var comp = comps[i];
                if (comp.constructor === constructor) return comp;
            } else for (var _i = 0; _i < comps.length; ++_i) {
                var _comp = comps[_i];
                if (_comp instanceof constructor) return _comp;
            }
            return null;
        }
    }, {
        key: "_findComponents",
        value: function _findComponents(node, constructor, components) {
            var cls = constructor, comps = node._components;
            if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                var comp = comps[i];
                comp.constructor === constructor && components.push(comp);
            } else for (var _i2 = 0; _i2 < comps.length; ++_i2) {
                var _comp2 = comps[_i2];
                _comp2 instanceof constructor && components.push(_comp2);
            }
        }
    }, {
        key: "_findChildComponent",
        value: function _findChildComponent(children, constructor) {
            for (var i = 0; i < children.length; ++i) {
                var node = children[i], comp = BaseNode._findComponent(node, constructor);
                if (comp) return comp;
                if (node._children.length > 0 && (comp = BaseNode._findChildComponent(node._children, constructor))) return comp;
            }
            return null;
        }
    }, {
        key: "_findChildComponents",
        value: function _findChildComponents(children, constructor, components) {
            for (var i = 0; i < children.length; ++i) {
                var node = children[i];
                BaseNode._findComponents(node, constructor, components), node._children.length > 0 && BaseNode._findChildComponents(node._children, constructor, components);
            }
        }
    } ]), _createClass(BaseNode, [ {
        key: "getParent",
        value: function getParent() {
            return this._parent;
        }
    }, {
        key: "setParent",
        value: function setParent(value) {
            var keepWorldTransform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (this._parent !== value) {
                var oldParent = this._parent;
                if (this._parent = value, this._siblingIndex = 0, this._onSetParent(oldParent, keepWorldTransform), 
                value && (value._children.push(this), this._siblingIndex = value._children.length - 1, 
                value.emit && value.emit(SystemEventType.CHILD_ADDED, this)), oldParent && !(oldParent._objFlags & Destroying$2)) {
                    var removeAt = oldParent._children.indexOf(this);
                    0, oldParent._children.splice(removeAt, 1), oldParent._updateSiblingIndex(), oldParent.emit && oldParent.emit(SystemEventType.CHILD_REMOVED, this);
                }
                this._onHierarchyChanged(oldParent);
            }
        }
    }, {
        key: "attr",
        value: function attr(attrs) {
            mixin(this, attrs);
        }
    }, {
        key: "getChildByUuid",
        value: function getChildByUuid(uuid) {
            if (!uuid) return cc.log("Invalid uuid"), null;
            for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
            return null;
        }
    }, {
        key: "getChildByName",
        value: function getChildByName(name) {
            if (!name) return cc.log("Invalid name"), null;
            for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
            return null;
        }
    }, {
        key: "getChildByPath",
        value: function getChildByPath(path) {
            for (var segments = path.split("/"), lastNode = this, _loop = function _loop(i) {
                var segment = segments[i];
                if (0 === segment.length) return "continue";
                var next = lastNode.children.find(function(childNode) {
                    return childNode.name === segment;
                });
                if (!next) return {
                    v: null
                };
                lastNode = next;
            }, i = 0; i < segments.length; ++i) {
                var _ret = _loop(i);
                switch (_ret) {
                  case "continue":
                    continue;

                  default:
                    if ("object" === _typeof(_ret)) return _ret.v;
                }
            }
            return lastNode;
        }
    }, {
        key: "addChild",
        value: function addChild(child) {
            cc.assertID(child, 1606), cc.assertID(null === child._parent, 1605), child.setParent(this);
        }
    }, {
        key: "insertChild",
        value: function insertChild(child, siblingIndex) {
            child.parent = this, child.setSiblingIndex(siblingIndex);
        }
    }, {
        key: "getSiblingIndex",
        value: function getSiblingIndex() {
            return this._siblingIndex;
        }
    }, {
        key: "setSiblingIndex",
        value: function setSiblingIndex(index) {
            if (this._parent) if (this._parent._objFlags & Deactivating$1) cc.errorID(3821); else {
                var siblings = this._parent._children;
                index = -1 !== index ? index : siblings.length - 1;
                var oldIndex = siblings.indexOf(this);
                index !== oldIndex && (siblings.splice(oldIndex, 1), index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this), 
                this._parent._updateSiblingIndex(), this._onSiblingIndexChanged && this._onSiblingIndexChanged(index));
            }
        }
    }, {
        key: "_updateSiblingIndex",
        value: function _updateSiblingIndex() {
            for (var i = 0; i < this._children.length; ++i) this._children[i]._siblingIndex = i;
        }
    }, {
        key: "walk",
        value: function walk(prefunc, postfunc) {
            var index = 1, children = null, curr = null, i = 0, stack = BaseNode._stacks[BaseNode._stackId];
            stack || (stack = [], BaseNode._stacks.push(stack)), BaseNode._stackId++, stack.length = 0, 
            stack[0] = this;
            for (var parent = null, afterChildren = !1; index; ) if (curr = stack[--index]) if (!afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr), 
            stack[index] = null, afterChildren) {
                if (afterChildren = !1, children) if (children[++i]) stack[index] = children[i], 
                index++; else if (parent && (stack[index] = parent, index++, afterChildren = !0, 
                parent._parent ? (i = (children = parent._parent._children).indexOf(parent), parent = parent._parent) : (parent = null, 
                children = null), i < 0)) break;
            } else curr._children.length > 0 ? (parent = curr, children = curr._children, i = 0, 
            stack[index] = children[i], index++) : (stack[index] = curr, index++, afterChildren = !0);
            stack.length = 0, BaseNode._stackId--;
        }
    }, {
        key: "removeFromParent",
        value: function removeFromParent() {
            this._parent && this._parent.removeChild(this);
        }
    }, {
        key: "removeChild",
        value: function removeChild(child) {
            this._children.indexOf(child) > -1 && (child.parent = null);
        }
    }, {
        key: "removeAllChildren",
        value: function removeAllChildren() {
            for (var children = this._children, i = children.length - 1; i >= 0; i--) {
                var node = children[i];
                node && (node.parent = null);
            }
            this._children.length = 0;
        }
    }, {
        key: "isChildOf",
        value: function isChildOf(parent) {
            var child = this;
            do {
                if (child === parent) return !0;
                child = child._parent;
            } while (child);
            return !1;
        }
    }, {
        key: "getComponent",
        value: function getComponent(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName);
            return constructor ? BaseNode._findComponent(this, constructor) : null;
        }
    }, {
        key: "getComponents",
        value: function getComponents(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName), components = [];
            return constructor && BaseNode._findComponents(this, constructor, components), components;
        }
    }, {
        key: "getComponentInChildren",
        value: function getComponentInChildren(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName);
            return constructor ? BaseNode._findChildComponent(this._children, constructor) : null;
        }
    }, {
        key: "getComponentsInChildren",
        value: function getComponentsInChildren(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName), components = [];
            return constructor && (BaseNode._findComponents(this, constructor, components), 
            BaseNode._findChildComponents(this._children, constructor, components)), components;
        }
    }, {
        key: "addComponent",
        value: function addComponent(typeOrClassName) {
            var constructor;
            if ("string" == typeof typeOrClassName) {
                if (!(constructor = getClassByName(typeOrClassName))) return cc.errorID(3807, typeOrClassName), 
                cc._RF.peek() && cc.errorID(3808, typeOrClassName), null;
            } else {
                if (!typeOrClassName) return cc.errorID(3804), null;
                constructor = typeOrClassName;
            }
            if ("function" != typeof constructor) return cc.errorID(3809), null;
            if (!isChildClassOf(constructor, cc.Component)) return cc.errorID(3810), null;
            var ReqComp = constructor._requireComponent;
            if (ReqComp && !this.getComponent(ReqComp) && !this.addComponent(ReqComp)) return null;
            var component = new constructor();
            return component.node = this, this._components.push(component), this._activeInHierarchy && cc.director._nodeActivator.activateComp(component), 
            component;
        }
    }, {
        key: "removeComponent",
        value: function removeComponent(component) {
            if (component) {
                var componentInstance = null;
                (componentInstance = component instanceof Component ? component : this.getComponent(component)) && componentInstance.destroy();
            } else cc.errorID(3813);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return !!_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this) && (this._activeInHierarchy && this._disableChildComps(), 
            !0);
        }
    }, {
        key: "destroyAllChildren",
        value: function destroyAllChildren() {
            for (var children = this._children, i = 0; i < children.length; ++i) children[i].destroy();
        }
    }, {
        key: "_removeComponent",
        value: function _removeComponent(component) {
            if (component) {
                if (!(this._objFlags & Destroying$2)) {
                    var i = this._components.indexOf(component);
                    -1 !== i ? this._components.splice(i, 1) : component.node !== this && cc.errorID(3815);
                }
            } else cc.errorID(3814);
        }
    }, {
        key: "_onSetParent",
        value: function _onSetParent(oldParent) {
            this._parent && (null != oldParent && oldParent._scene === this._parent._scene || null == this._parent._scene || this.walk(function(node) {
                BaseNode._setScene(node);
            }));
        }
    }, {
        key: "_onPostActivated",
        value: function _onPostActivated(active) {}
    }, {
        key: "_onBatchRestored",
        value: function _onBatchRestored() {}
    }, {
        key: "_onBatchCreated",
        value: function _onBatchCreated() {
            this._parent && (this._siblingIndex = this._parent.children.indexOf(this));
        }
    }, {
        key: "_onPreDestroy",
        value: function _onPreDestroy() {
            this._onPreDestroyBase();
        }
    }, {
        key: "_onHierarchyChanged",
        value: function _onHierarchyChanged(oldParent) {
            return this._onHierarchyChangedBase(oldParent);
        }
    }, {
        key: "_instantiate",
        value: function _instantiate(cloned) {
            cloned || (cloned = cc.instantiate._clone(this, this));
            var thisPrefabInfo = this._prefab;
            thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
            return cloned._parent = null, cloned._onBatchRestored(), cloned;
        }
    }, {
        key: "_onHierarchyChangedBase",
        value: function _onHierarchyChangedBase(oldParent) {
            var newParent = this._parent;
            !this._persistNode || newParent instanceof cc.Scene || cc.game.removePersistRootNode(this);
            var shouldActiveNow = this._active && !(!newParent || !newParent._activeInHierarchy);
            this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
        }
    }, {
        key: "_onPreDestroyBase",
        value: function _onPreDestroyBase() {
            this._objFlags |= Destroying$2;
            var parent = this._parent, destroyByParent = null !== parent && 0 != (parent._objFlags & Destroying$2);
            for (var children = this._children, i = 0; i < children.length; ++i) children[i]._destroyImmediate();
            for (var comps = this._components, _i3 = 0; _i3 < comps.length; ++_i3) comps[_i3]._destroyImmediate();
            for (var eventTargets = this.__eventTargets, _i4 = 0; _i4 < eventTargets.length; ++_i4) {
                var et = eventTargets[_i4];
                et && et.targetOff(this);
            }
            if (eventTargets.length = 0, this._persistNode && cc.game.removePersistRootNode(this), 
            !destroyByParent && parent) {
                var childIndex = parent._children.indexOf(this);
                parent._children.splice(childIndex, 1), this._siblingIndex = 0, parent.emit && parent.emit("child-removed", this);
            }
            return destroyByParent;
        }
    }, {
        key: "_disableChildComps",
        value: function _disableChildComps() {
            for (var comps = this._components, i = 0; i < comps.length; ++i) {
                var component = comps[i];
                component._enabled && cc.director._compScheduler.disableComp(component);
            }
            for (var children = this._children, _i5 = 0; _i5 < children.length; ++_i5) {
                var node = children[_i5];
                node._active && node._disableChildComps();
            }
        }
    } ]), BaseNode;
}(), _class3$8.idGenerator = idGenerator$2, _class3$8._stacks = [ [] ], _class3$8._stackId = 0, 
_applyDecoratedDescriptor((_class2$f = _temp$h).prototype, "_persistNode", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "_persistNode"), _class2$f.prototype), 
_applyDecoratedDescriptor(_class2$f.prototype, "name", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "name"), _class2$f.prototype), 
_applyDecoratedDescriptor(_class2$f.prototype, "uuid", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "uuid"), _class2$f.prototype), 
_applyDecoratedDescriptor(_class2$f.prototype, "children", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "children"), _class2$f.prototype), 
_applyDecoratedDescriptor(_class2$f.prototype, "active", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "active"), _class2$f.prototype), 
_applyDecoratedDescriptor(_class2$f.prototype, "activeInHierarchy", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "activeInHierarchy"), _class2$f.prototype), 
_applyDecoratedDescriptor(_class2$f.prototype, "parent", [ property ], Object.getOwnPropertyDescriptor(_class2$f.prototype, "parent"), _class2$f.prototype), 
_descriptor$d = _applyDecoratedDescriptor(_class2$f.prototype, "_parent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class2$f.prototype, "_children", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$3 = _applyDecoratedDescriptor(_class2$f.prototype, "_active", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$2 = _applyDecoratedDescriptor(_class2$f.prototype, "_components", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class2$f.prototype, "_prefab", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$k = _class2$f)) || _class$k;

cc._BaseNode = BaseNode;

var NodeSpace, TransformDirtyBit, _dec$l, _dec2$8, _class$l, _class2$g, _descriptor$e, _descriptor2$7, _descriptor3$4, _descriptor4$3, _descriptor5$2, _class3$9, _temp$i, Layers = function() {
    function Layers() {
        _classCallCheck(this, Layers);
    }
    return _createClass(Layers, null, [ {
        key: "addLayer",
        value: function addLayer(name) {
            if (!(Layers._nextAvailable > 31)) return Layers[name] = 1 << Layers._nextAvailable++, 
            Layers[name];
            console.warn("maximum layers reached.");
        }
    }, {
        key: "makeInclusiveMask",
        value: function makeInclusiveMask(includes) {
            var mask = 0, _iterator = includes, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                mask |= _ref;
            }
            return mask;
        }
    }, {
        key: "makeExclusiveMask",
        value: function makeExclusiveMask(excludes) {
            return ~Layers.makeInclusiveMask(excludes);
        }
    }, {
        key: "check",
        value: function check(layer, mask) {
            return (layer & mask) === layer;
        }
    } ]), Layers;
}();

Layers.Default = 1, Layers.IgnoreRaycast = 2, Layers.Gizmos = 4, Layers.Editor = 8, 
Layers.UI = 16, Layers.All = Layers.makeExclusiveMask([ Layers.Gizmos, Layers.Editor ]), 
Layers.RaycastMask = Layers.makeExclusiveMask([ Layers.Gizmos, Layers.Editor, Layers.IgnoreRaycast ]), 
Layers._nextAvailable = 8, cc.Layers = Layers, function(NodeSpace) {
    NodeSpace[NodeSpace.LOCAL = 0] = "LOCAL", NodeSpace[NodeSpace.WORLD = 1] = "WORLD";
}(NodeSpace || (NodeSpace = {})), function(TransformDirtyBit) {
    TransformDirtyBit[TransformDirtyBit.NONE = 0] = "NONE", TransformDirtyBit[TransformDirtyBit.POSITION = 1] = "POSITION", 
    TransformDirtyBit[TransformDirtyBit.ROTATION = 2] = "ROTATION", TransformDirtyBit[TransformDirtyBit.SCALE = 4] = "SCALE", 
    TransformDirtyBit[TransformDirtyBit.RS = TransformDirtyBit.ROTATION | TransformDirtyBit.SCALE] = "RS", 
    TransformDirtyBit[TransformDirtyBit.TRS = TransformDirtyBit.POSITION | TransformDirtyBit.ROTATION | TransformDirtyBit.SCALE] = "TRS", 
    TransformDirtyBit[TransformDirtyBit.TRS_MASK = ~TransformDirtyBit.TRS] = "TRS_MASK";
}(TransformDirtyBit || (TransformDirtyBit = {}));

var _class$m, _class2$h, _descriptor$f, _class3$a, _temp$j, FaceIndex, v3_a = new Vec3(), q_a = new Quat(), q_b = new Quat(), array_a = new Array(10), qt_1$1 = new Quat(), m3_1$2 = new Mat3(), m3_2 = new Mat3(), Node$1 = (_dec$l = ccclass("cc.Node"), 
_dec2$8 = property({
    type: Vec3
}), _dec$l((_temp$i = _class3$9 = function(_BaseNode) {
    function Node() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Node);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._pos = new Vec3(), 
        _this._rot = new Quat(), _this._scale = new Vec3(1, 1, 1), _this._mat = new Mat4(), 
        _initializerDefineProperty(_this, "_lpos", _descriptor$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lrot", _descriptor2$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lscale", _descriptor3$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_layer", _descriptor4$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_euler", _descriptor5$2, _assertThisInitialized(_this)), 
        _this._dirtyFlags = TransformDirtyBit.NONE, _this._hasChangedFlags = TransformDirtyBit.NONE, 
        _this._eulerDirty = !1, _this._eventProcessor = new cc.NodeEventProcessor(_assertThisInitialized(_this)), 
        _this._eventMask = 0, _this._uiTransfromComp = null, _this._uiComp = null, _this;
    }
    return _inherits(Node, BaseNode), _createClass(Node, [ {
        key: "setParent",
        value: function setParent(value) {
            var keepWorldTransform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            keepWorldTransform && this.updateWorldTransform(), _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
        }
    }, {
        key: "_onSetParent",
        value: function _onSetParent(oldParent, keepWorldTransform) {
            if (_get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform), 
            keepWorldTransform) {
                var parent = this._parent, local = this._lpos;
                parent ? (parent.updateWorldTransform(), Vec3.subtract(local, this._pos, parent._pos), 
                Vec3.transformQuat(local, local, Quat.conjugate(q_a, parent._rot)), Vec3.divide(local, local, parent._scale), 
                Quat.multiply(this._lrot, Quat.conjugate(q_a, parent._rot), this._rot), Vec3.divide(this._lscale, this._scale, parent._scale)) : (Vec3.copy(this._lpos, this._pos), 
                Quat.copy(this._lrot, this._rot), Vec3.copy(this._lscale, this._scale)), this._eulerDirty = !0;
            }
            this._onBatchCreated();
        }
    }, {
        key: "_onBatchCreated",
        value: function _onBatchCreated() {
            _get(_getPrototypeOf(Node.prototype), "_onBatchCreated", this).call(this), this._dirtyFlags = this._hasChangedFlags = TransformDirtyBit.TRS;
            for (var len = this._children.length, i = 0; i < len; ++i) this._children[i]._onBatchCreated();
        }
    }, {
        key: "_onBatchRestored",
        value: function _onBatchRestored() {
            this._onBatchCreated();
        }
    }, {
        key: "_onBeforeSerialize",
        value: function _onBeforeSerialize() {
            this.eulerAngles;
        }
    }, {
        key: "translate",
        value: function translate(trans, ns) {
            var space = ns || NodeSpace.LOCAL;
            if (space === NodeSpace.LOCAL) Vec3.transformQuat(v3_a, trans, this._lrot), this._lpos.x += v3_a.x, 
            this._lpos.y += v3_a.y, this._lpos.z += v3_a.z; else if (space === NodeSpace.WORLD) if (this._parent) {
                Quat.invert(q_a, this.worldRotation), Vec3.transformQuat(v3_a, trans, q_a);
                var _scale = this.worldScale;
                this._lpos.x += v3_a.x / _scale.x, this._lpos.y += v3_a.y / _scale.y, this._lpos.z += v3_a.z / _scale.z;
            } else this._lpos.x += trans.x, this._lpos.y += trans.y, this._lpos.z += trans.z;
            this.invalidateChildren(TransformDirtyBit.POSITION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART);
        }
    }, {
        key: "rotate",
        value: function rotate(rot, ns) {
            var space = ns || NodeSpace.LOCAL;
            if (Quat.normalize(q_a, rot), space === NodeSpace.LOCAL) Quat.multiply(this._lrot, this._lrot, q_a); else if (space === NodeSpace.WORLD) {
                var worldRot = this.worldRotation;
                Quat.multiply(q_b, q_a, worldRot), Quat.invert(q_a, worldRot), Quat.multiply(q_b, q_a, q_b), 
                Quat.multiply(this._lrot, this._lrot, q_b);
            }
            this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
        }
    }, {
        key: "lookAt",
        value: function lookAt(pos, up) {
            this.getWorldPosition(v3_a), Vec3.subtract(v3_a, v3_a, pos), Vec3.normalize(v3_a, v3_a), 
            Quat.fromViewUp(q_a, v3_a, up), this.setWorldRotation(q_a);
        }
    }, {
        key: "resetHasChangedFlags",
        value: function resetHasChangedFlags() {
            this._hasChangedFlags = TransformDirtyBit.NONE;
            for (var len = this._children.length, i = 0; i < len; ++i) this._children[i].resetHasChangedFlags();
        }
    }, {
        key: "invalidateChildren",
        value: function invalidateChildren(dirtyBit) {
            if ((this._dirtyFlags & this._hasChangedFlags & dirtyBit) !== dirtyBit) {
                this._dirtyFlags |= dirtyBit, this._hasChangedFlags |= dirtyBit, dirtyBit |= TransformDirtyBit.POSITION;
                for (var len = this._children.length, i = 0; i < len; ++i) this._children[i].invalidateChildren(dirtyBit);
            }
        }
    }, {
        key: "updateWorldTransform",
        value: function updateWorldTransform() {
            if (this._dirtyFlags) {
                for (var child, cur = this, i = 0; cur && cur._dirtyFlags; ) array_a[i++] = cur, 
                cur = cur._parent;
                for (var dirtyBits = 0; i; ) dirtyBits |= (child = array_a[--i])._dirtyFlags, cur ? (dirtyBits & TransformDirtyBit.POSITION && (Vec3.transformRTS(child._pos, child._lpos, cur._rot, cur._pos, cur._scale), 
                child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                dirtyBits & TransformDirtyBit.RS && (Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale), 
                Mat4.multiply(child._mat, cur._mat, child._mat), dirtyBits & TransformDirtyBit.ROTATION && Quat.multiply(child._rot, cur._rot, child._lrot), 
                Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot)), Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat), 
                child._scale.x = m3_1$2.m00, child._scale.y = m3_1$2.m04, child._scale.z = m3_1$2.m08)) : (dirtyBits & TransformDirtyBit.POSITION && (Vec3.copy(child._pos, child._lpos), 
                child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                dirtyBits & TransformDirtyBit.RS && (dirtyBits & TransformDirtyBit.ROTATION ? Quat.copy(child._rot, child._lrot) : Vec3.copy(child._scale, child._lscale), 
                Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale))), child._dirtyFlags = TransformDirtyBit.NONE, 
                cur = child;
            }
        }
    }, {
        key: "setPosition",
        value: function setPosition(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._lpos, val) : Vec3.set(this._lpos, val, y, z), 
            this.invalidateChildren(TransformDirtyBit.POSITION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART);
        }
    }, {
        key: "getPosition",
        value: function getPosition(out) {
            return out ? Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z) : Vec3.copy(new Vec3(), this._lpos);
        }
    }, {
        key: "setRotation",
        value: function setRotation(val, y, z, w) {
            void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._lrot, val) : Quat.set(this._lrot, val, y, z, w), 
            this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
        }
    }, {
        key: "setRotationFromEuler",
        value: function setRotationFromEuler(x, y, z) {
            Vec3.set(this._euler, x, y, z), Quat.fromEuler(this._lrot, x, y, z), this._eulerDirty = !1, 
            this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
        }
    }, {
        key: "getRotation",
        value: function getRotation(out) {
            return out ? Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w) : Quat.copy(new Quat(), this._lrot);
        }
    }, {
        key: "setScale",
        value: function setScale(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._lscale, val) : Vec3.set(this._lscale, val, y, z), 
            this.invalidateChildren(TransformDirtyBit.SCALE), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.SCALE_PART);
        }
    }, {
        key: "getScale",
        value: function getScale(out) {
            return out ? Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z) : Vec3.copy(new Vec3(), this._lscale);
        }
    }, {
        key: "setWorldPosition",
        value: function setWorldPosition(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._pos, val) : Vec3.set(this._pos, val, y, z);
            var parent = this._parent, local = this._lpos;
            parent ? (parent.updateWorldTransform(), Vec3.subtract(local, this._pos, parent._pos), 
            Vec3.transformQuat(local, local, Quat.conjugate(q_a, parent._rot)), Vec3.divide(local, local, parent._scale)) : Vec3.copy(local, this._pos), 
            this.invalidateChildren(TransformDirtyBit.POSITION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART);
        }
    }, {
        key: "getWorldPosition",
        value: function getWorldPosition(out) {
            return this.updateWorldTransform(), out ? Vec3.copy(out, this._pos) : Vec3.copy(new Vec3(), this._pos);
        }
    }, {
        key: "setWorldRotation",
        value: function setWorldRotation(val, y, z, w) {
            void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._rot, val) : Quat.set(this._rot, val, y, z, w), 
            this._parent ? (this._parent.updateWorldTransform(), Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
            this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
        }
    }, {
        key: "setWorldRotationFromEuler",
        value: function setWorldRotationFromEuler(x, y, z) {
            Quat.fromEuler(this._rot, x, y, z), this._parent ? (this._parent.updateWorldTransform(), 
            Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
            this._eulerDirty = !0, this.invalidateChildren(TransformDirtyBit.ROTATION), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART);
        }
    }, {
        key: "getWorldRotation",
        value: function getWorldRotation(out) {
            return this.updateWorldTransform(), out ? Quat.copy(out, this._rot) : Quat.copy(new Quat(), this._rot);
        }
    }, {
        key: "setWorldScale",
        value: function setWorldScale(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._scale, val) : Vec3.set(this._scale, val, y, z);
            var parent = this._parent;
            parent ? (parent.updateWorldTransform(), Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot)), 
            Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat), Mat3.fromScaling(m3_2, this._scale), 
            Mat3.multiply(m3_1$2, m3_2, Mat3.invert(m3_1$2, m3_1$2)), this._lscale.x = m3_1$2.m00, 
            this._lscale.y = m3_1$2.m04, this._lscale.z = m3_1$2.m08) : Vec3.copy(this._lscale, this._scale), 
            this.invalidateChildren(TransformDirtyBit.SCALE), 1 & this._eventMask && this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.SCALE_PART);
        }
    }, {
        key: "getWorldScale",
        value: function getWorldScale(out) {
            return this.updateWorldTransform(), out ? Vec3.copy(out, this._scale) : Vec3.copy(new Vec3(), this._scale);
        }
    }, {
        key: "getWorldMatrix",
        value: function getWorldMatrix(out) {
            return this.updateWorldTransform(), out || (out = new Mat4()), Mat4.copy(out, this._mat);
        }
    }, {
        key: "getWorldRS",
        value: function getWorldRS(out) {
            return this.updateWorldTransform(), out || (out = new Mat4()), Mat4.copy(out, this._mat), 
            out.m12 = 0, out.m13 = 0, out.m14 = 0, out;
        }
    }, {
        key: "getWorldRT",
        value: function getWorldRT(out) {
            return this.updateWorldTransform(), out || (out = new Mat4()), Mat4.fromRT(out, this._rot, this._pos);
        }
    }, {
        key: "getAnchorPoint",
        value: function getAnchorPoint(out) {
            return out || (out = new Vec2()), out.set(this.uiTransfromComp.anchorPoint), out;
        }
    }, {
        key: "setAnchorPoint",
        value: function setAnchorPoint(point, y) {
            this.uiTransfromComp.setAnchorPoint(point, y);
        }
    }, {
        key: "getContentSize",
        value: function getContentSize(out) {
            return out || (out = new Size()), out.set(this.uiTransfromComp.contentSize), out;
        }
    }, {
        key: "setContentSize",
        value: function setContentSize(size, height) {
            this.uiTransfromComp.setContentSize(size, height);
        }
    }, {
        key: "on",
        value: function on(type, callback, target, useCapture) {
            switch (type) {
              case SystemEventType.TRANSFORM_CHANGED:
                this._eventMask |= 1;
            }
            this._eventProcessor.on(type, callback, target, useCapture);
        }
    }, {
        key: "off",
        value: function off(type, callback, target, useCapture) {
            if (this._eventProcessor.off(type, callback, target, useCapture), !this._eventProcessor.hasEventListener(type)) switch (type) {
              case SystemEventType.TRANSFORM_CHANGED:
                this._eventMask &= -2;
            }
        }
    }, {
        key: "once",
        value: function once(type, callback, target, useCapture) {
            this._eventProcessor.once(type, callback, target, useCapture);
        }
    }, {
        key: "emit",
        value: function emit(type) {
            for (var _this$_eventProcessor, _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
            (_this$_eventProcessor = this._eventProcessor).emit.apply(_this$_eventProcessor, [ type ].concat(args));
        }
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
            this._eventProcessor.dispatchEvent(event);
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(type) {
            return this._eventProcessor.hasEventListener(type);
        }
    }, {
        key: "targetOff",
        value: function targetOff(target) {
            this._eventProcessor.targetOff(target), 1 & this._eventMask && !this._eventProcessor.hasEventListener(SystemEventType.TRANSFORM_CHANGED) && (this._eventMask &= -2);
        }
    }, {
        key: "pauseSystemEvents",
        value: function pauseSystemEvents(recursive) {
            eventManager.pauseTarget(this, recursive);
        }
    }, {
        key: "resumeSystemEvents",
        value: function resumeSystemEvents(recursive) {
            eventManager.resumeTarget(this, recursive);
        }
    }, {
        key: "_onPostActivated",
        value: function _onPostActivated(active) {
            active ? (eventManager.resumeTarget(this), this.eventProcessor.reattach()) : eventManager.pauseTarget(this);
        }
    }, {
        key: "_onPreDestroy",
        value: function _onPreDestroy() {
            this._eventProcessor.destroy(), _get(_getPrototypeOf(Node.prototype), "_onPreDestroy", this).call(this);
        }
    }, {
        key: "position",
        get: function get() {
            return this._lpos;
        },
        set: function set(val) {
            this.setPosition(val);
        }
    }, {
        key: "worldPosition",
        get: function get() {
            return this.updateWorldTransform(), this._pos;
        },
        set: function set(val) {
            this.setWorldPosition(val);
        }
    }, {
        key: "rotation",
        get: function get() {
            return this._lrot;
        },
        set: function set(val) {
            this.setRotation(val);
        }
    }, {
        key: "eulerAngles",
        set: function set(val) {
            this.setRotationFromEuler(val.x, val.y, val.z);
        },
        get: function get() {
            return this._eulerDirty && (Quat.toEuler(this._euler, this._lrot), this._eulerDirty = !1), 
            this._euler;
        }
    }, {
        key: "worldRotation",
        get: function get() {
            return this.updateWorldTransform(), this._rot;
        },
        set: function set(val) {
            this.setWorldRotation(val);
        }
    }, {
        key: "scale",
        get: function get() {
            return this._lscale;
        },
        set: function set(val) {
            this.setScale(val);
        }
    }, {
        key: "worldScale",
        get: function get() {
            return this.updateWorldTransform(), this._scale;
        },
        set: function set(val) {
            this.setWorldScale(val);
        }
    }, {
        key: "matrix",
        set: function set(val) {
            Mat4.toRTS(val, this._lrot, this._lpos, this._lscale), this.invalidateChildren(TransformDirtyBit.TRS), 
            1 & this._eventMask && (this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.POSITION_PART), 
            this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.ROTATION_PART), this.emit(SystemEventType.TRANSFORM_CHANGED, SystemEventType.SCALE_PART));
        }
    }, {
        key: "worldMatrix",
        get: function get() {
            return this.updateWorldTransform(), this._mat;
        }
    }, {
        key: "forward",
        get: function get() {
            return this.getWorldRotation(q_a), Vec3.transformQuat(new Vec3(), Vec3.UNIT_Z, q_a);
        },
        set: function set(dir) {
            var len = dir.length();
            Vec3.multiplyScalar(v3_a, dir, -1 / len), Quat.fromViewUp(q_a, v3_a), this.setWorldRotation(q_a);
        }
    }, {
        key: "layer",
        set: function set(l) {
            this._layer = l;
        },
        get: function get() {
            return this._layer;
        }
    }, {
        key: "hasChangedFlags",
        get: function get() {
            return this._hasChangedFlags;
        }
    }, {
        key: "uiTransfromComp",
        get: function get() {
            return this._uiTransfromComp || (this._uiTransfromComp = this.getComponent("cc.UITransformComponent")), 
            this._uiTransfromComp;
        },
        set: function set(value) {
            this._uiTransfromComp = value;
        }
    }, {
        key: "width",
        get: function get() {
            return this.uiTransfromComp.width;
        },
        set: function set(value) {
            this.uiTransfromComp.width = value;
        }
    }, {
        key: "height",
        get: function get() {
            return this.uiTransfromComp.height;
        },
        set: function set(value) {
            this.uiTransfromComp.height = value;
        }
    }, {
        key: "anchorX",
        get: function get() {
            return this.uiTransfromComp.anchorX;
        },
        set: function set(value) {
            this.uiTransfromComp.anchorX = value;
        }
    }, {
        key: "anchorY",
        get: function get() {
            return this.uiTransfromComp.anchorY;
        },
        set: function set(value) {
            this.uiTransfromComp.anchorY = value;
        }
    }, {
        key: "eventProcessor",
        get: function get() {
            return this._eventProcessor;
        }
    } ], [ {
        key: "isNode",
        value: function isNode(obj) {
            return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        }
    } ]), Node;
}(), _class3$9.EventType = SystemEventType, _class3$9.NodeSpace = NodeSpace, _class3$9.TransformDirtyBit = TransformDirtyBit, 
_descriptor$e = _applyDecoratedDescriptor((_class2$g = _temp$i).prototype, "_lpos", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3();
    }
}), _descriptor2$7 = _applyDecoratedDescriptor(_class2$g.prototype, "_lrot", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Quat();
    }
}), _descriptor3$4 = _applyDecoratedDescriptor(_class2$g.prototype, "_lscale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class2$g.prototype, "_layer", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Layers.Default;
    }
}), _descriptor5$2 = _applyDecoratedDescriptor(_class2$g.prototype, "_euler", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3();
    }
}), _applyDecoratedDescriptor(_class2$g.prototype, "eulerAngles", [ _dec2$8 ], Object.getOwnPropertyDescriptor(_class2$g.prototype, "eulerAngles"), _class2$g.prototype), 
_applyDecoratedDescriptor(_class2$g.prototype, "layer", [ property ], Object.getOwnPropertyDescriptor(_class2$g.prototype, "layer"), _class2$g.prototype), 
_class$l = _class2$g)) || _class$l);

cc.Node = Node$1, function(FaceIndex) {
    FaceIndex[FaceIndex.right = 0] = "right", FaceIndex[FaceIndex.left = 1] = "left", 
    FaceIndex[FaceIndex.top = 2] = "top", FaceIndex[FaceIndex.bottom = 3] = "bottom", 
    FaceIndex[FaceIndex.front = 4] = "front", FaceIndex[FaceIndex.back = 5] = "back";
}(FaceIndex || (FaceIndex = {}));

var TextureCube = ccclass("cc.TextureCube")((_temp$j = _class3$a = function(_TrivialTexture) {
    function TextureCube() {
        var _this;
        return _classCallCheck(this, TextureCube), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this)), "_mipmaps", _descriptor$f, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(TextureCube, SimpleTexture), _createClass(TextureCube, [ {
        key: "mipmaps",
        get: function get() {
            return this._mipmaps;
        },
        set: function set(value) {
            var _this2 = this;
            if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                var imageAsset = this._mipmaps[0].front;
                this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                }), this._mipmaps.forEach(function(mipmap, level) {
                    _forEachFace(mipmap, function(face, faceIndex) {
                        _this2._assignImage(face, level, faceIndex);
                    });
                });
            } else this.reset({
                width: 0,
                height: 0,
                mipmapLevel: this._mipmaps.length
            });
        }
    }, {
        key: "image",
        get: function get() {
            return 0 === this._mipmaps.length ? null : this._mipmaps[0];
        },
        set: function set(value) {
            this.mipmaps = value ? [ value ] : [];
        }
    } ], [ {
        key: "fromTexture2DArray",
        value: function fromTexture2DArray(textures, out) {
            for (var mipmaps = [], nMipmaps = textures.length / 6, i = 0; i < nMipmaps; i++) {
                var x = 6 * i;
                mipmaps.push({
                    front: textures[x + FaceIndex.front].image,
                    back: textures[x + FaceIndex.back].image,
                    left: textures[x + FaceIndex.left].image,
                    right: textures[x + FaceIndex.right].image,
                    top: textures[x + FaceIndex.top].image,
                    bottom: textures[x + FaceIndex.bottom].image
                });
            }
            return (out = out || new TextureCube()).mipmaps = mipmaps, out;
        }
    } ]), _createClass(TextureCube, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.mipmaps = this._mipmaps, this.loaded = !0, this.emit("load");
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
            this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
        }
    }, {
        key: "updateMipmaps",
        value: function updateMipmaps() {
            var _this3 = this, firstLevel = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, count = arguments.length > 1 ? arguments[1] : void 0;
            if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), _loop = function _loop(i) {
                var level = firstLevel + i;
                _forEachFace(_this3._mipmaps[level], function(face, faceIndex) {
                    _this3._assignImage(face, level, faceIndex);
                });
            }, i = 0; i < nUpdate; ++i) _loop(i);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._mipmaps = [], _get(_getPrototypeOf(TextureCube.prototype), "destroy", this).call(this);
        }
    }, {
        key: "releaseTexture",
        value: function releaseTexture() {
            this.mipmaps = [];
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return {
                base: _get(_getPrototypeOf(TextureCube.prototype), "_serialize", this).call(this),
                mipmaps: this._mipmaps.map(function(mipmap) {
                    return exporting ? {
                        front: Editor.Utils.UuidUtils.compressUuid(mipmap.front._uuid, !0),
                        back: Editor.Utils.UuidUtils.compressUuid(mipmap.back._uuid, !0),
                        left: Editor.Utils.UuidUtils.compressUuid(mipmap.left._uuid, !0),
                        right: Editor.Utils.UuidUtils.compressUuid(mipmap.right._uuid, !0),
                        top: Editor.Utils.UuidUtils.compressUuid(mipmap.top._uuid, !0),
                        bottom: Editor.Utils.UuidUtils.compressUuid(mipmap.bottom._uuid, !0)
                    } : {
                        front: mipmap.front._uuid,
                        back: mipmap.back._uuid,
                        left: mipmap.left._uuid,
                        right: mipmap.right._uuid,
                        top: mipmap.top._uuid,
                        bottom: mipmap.bottom._uuid
                    };
                })
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializedData, handle) {
            var data = serializedData;
            _get(_getPrototypeOf(TextureCube.prototype), "_deserialize", this).call(this, data.base, handle), 
            this._mipmaps = new Array(data.mipmaps.length);
            for (var i = 0; i < data.mipmaps.length; ++i) {
                this._mipmaps[i] = {
                    front: new ImageAsset(),
                    back: new ImageAsset(),
                    left: new ImageAsset(),
                    right: new ImageAsset(),
                    top: new ImageAsset(),
                    bottom: new ImageAsset()
                };
                var mipmap = data.mipmaps[i];
                handle.result.push(this._mipmaps[i], "front", mipmap.front), handle.result.push(this._mipmaps[i], "back", mipmap.back), 
                handle.result.push(this._mipmaps[i], "left", mipmap.left), handle.result.push(this._mipmaps[i], "right", mipmap.right), 
                handle.result.push(this._mipmaps[i], "top", mipmap.top), handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom);
            }
        }
    }, {
        key: "_getGfxTextureCreateInfo",
        value: function _getGfxTextureCreateInfo(presumed) {
            var result = Object.assign({
                type: GFXTextureType.TEX2D,
                width: this._width,
                height: this._height,
                arrayLayer: 6
            }, presumed);
            return result.flags = (result.flags || 0) | GFXTextureFlagBit.CUBEMAP, result;
        }
    }, {
        key: "_getGfxTextureViewCreateInfo",
        value: function _getGfxTextureViewCreateInfo(presumed) {
            return Object.assign({
                type: GFXTextureViewType.CUBE,
                layerCount: 6
            }, presumed);
        }
    } ]), TextureCube;
}(), _class3$a.FaceIndex = FaceIndex, _descriptor$f = _applyDecoratedDescriptor((_class2$h = _temp$j).prototype, "_mipmaps", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$m = _class2$h)) || _class$m;

function _forEachFace(mipmap, callback) {
    callback(mipmap.front, FaceIndex.front), callback(mipmap.back, FaceIndex.back), 
    callback(mipmap.left, FaceIndex.left), callback(mipmap.right, FaceIndex.right), 
    callback(mipmap.top, FaceIndex.top), callback(mipmap.bottom, FaceIndex.bottom);
}

cc.TextureCube = TextureCube;

var _dec$n, _dec2$9, _dec3$2, _dec4$1, _class$n, _class2$i, _descriptor$g, _descriptor2$8, _descriptor3$5, _dec5$1, _dec6$1, _dec7$1, _dec8, _dec9, _dec10, _class4, _class5, _descriptor4$4, _descriptor5$3, _descriptor6$1, _descriptor7$1, _dec11, _dec12, _dec13, _dec14, _dec15, _class7, _class8, _descriptor8$1, _descriptor9$1, _descriptor10$1, _descriptor11, _dec16, _dec17, _dec18, _dec19, _class10, _class11, _descriptor12, _descriptor13, _descriptor14, Ambient = function() {
    function Ambient(scene) {
        _classCallCheck(this, Ambient), this._enabled = !0, this._skyColor = Float32Array.from([ .2, .5, .8, 1 ]), 
        this._skyIllum = Ambient.SKY_ILLUM, this._groundAlbedo = Float32Array.from([ .2, .2, .2, 1 ]), 
        this._scene = void 0, this._scene = scene;
    }
    return _createClass(Ambient, [ {
        key: "enabled",
        set: function set(val) {
            this._enabled = val;
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "skyColor",
        get: function get() {
            return this._skyColor;
        },
        set: function set(color) {
            this._skyColor = color;
        }
    }, {
        key: "skyIllum",
        set: function set(illum) {
            this._skyIllum = illum;
        },
        get: function get() {
            return this._skyIllum;
        }
    }, {
        key: "groundAlbedo",
        get: function get() {
            return this._groundAlbedo;
        },
        set: function set(color) {
            this._groundAlbedo = color;
        }
    } ]), _createClass(Ambient, [ {
        key: "update",
        value: function update() {}
    } ]), Ambient;
}();

Ambient.SUN_ILLUM = 65e3, Ambient.SKY_ILLUM = 2e4;

var _up = new Vec3(0, 1, 0), _v3 = new Vec3(), _qt = new Quat(), AmbientInfo = (_dec$n = ccclass("cc.AmbientInfo"), 
_dec2$9 = property({
    type: Color
}), _dec3$2 = property({
    type: CCFloat
}), _dec4$1 = property({
    type: Color
}), _dec$n((_descriptor$g = _applyDecoratedDescriptor((_class2$i = function() {
    function AmbientInfo() {
        _classCallCheck(this, AmbientInfo), _initializerDefineProperty(this, "_skyColor", _descriptor$g, this), 
        _initializerDefineProperty(this, "_skyIllum", _descriptor2$8, this), _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$5, this), 
        this._resource = null;
    }
    return _createClass(AmbientInfo, [ {
        key: "skyColor",
        set: function set(val) {
            this._skyColor.set(val), this._resource && Color.array(this._resource.skyColor, this.skyColor);
        },
        get: function get() {
            return this._skyColor;
        }
    }, {
        key: "skyIllum",
        set: function set(val) {
            this._skyIllum = val, this._resource && (this._resource.skyIllum = this.skyIllum);
        },
        get: function get() {
            return this._skyIllum;
        }
    }, {
        key: "groundAlbedo",
        set: function set(val) {
            this._groundAlbedo.set(val), this._resource && Color.array(this._resource.groundAlbedo, this.groundAlbedo);
        },
        get: function get() {
            return this._groundAlbedo;
        }
    }, {
        key: "renderScene",
        set: function set(rs) {
            this._resource = rs.ambient, this.skyColor = this._skyColor, this.skyIllum = this._skyIllum, 
            this.groundAlbedo = this._groundAlbedo;
        }
    } ]), AmbientInfo;
}()).prototype, "_skyColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(51, 128, 204, 1);
    }
}), _descriptor2$8 = _applyDecoratedDescriptor(_class2$i.prototype, "_skyIllum", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Ambient.SKY_ILLUM;
    }
}), _descriptor3$5 = _applyDecoratedDescriptor(_class2$i.prototype, "_groundAlbedo", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(51, 51, 51, 255);
    }
}), _applyDecoratedDescriptor(_class2$i.prototype, "skyColor", [ _dec2$9 ], Object.getOwnPropertyDescriptor(_class2$i.prototype, "skyColor"), _class2$i.prototype), 
_applyDecoratedDescriptor(_class2$i.prototype, "skyIllum", [ _dec3$2 ], Object.getOwnPropertyDescriptor(_class2$i.prototype, "skyIllum"), _class2$i.prototype), 
_applyDecoratedDescriptor(_class2$i.prototype, "groundAlbedo", [ _dec4$1 ], Object.getOwnPropertyDescriptor(_class2$i.prototype, "groundAlbedo"), _class2$i.prototype), 
_class$n = _class2$i)) || _class$n);

cc.AmbientInfo = AmbientInfo;

var SkyboxInfo = (_dec5$1 = ccclass("cc.SkyboxInfo"), _dec6$1 = property(TextureCube), 
_dec7$1 = property({
    type: CCBoolean
}), _dec8 = property({
    type: CCBoolean
}), _dec9 = property({
    type: TextureCube
}), _dec10 = property({
    type: CCBoolean
}), _dec5$1((_descriptor4$4 = _applyDecoratedDescriptor((_class5 = function() {
    function SkyboxInfo() {
        _classCallCheck(this, SkyboxInfo), _initializerDefineProperty(this, "_envmap", _descriptor4$4, this), 
        _initializerDefineProperty(this, "_isRGBE", _descriptor5$3, this), _initializerDefineProperty(this, "_enabled", _descriptor6$1, this), 
        _initializerDefineProperty(this, "_useIBL", _descriptor7$1, this), this._resource = null;
    }
    return _createClass(SkyboxInfo, [ {
        key: "enabled",
        set: function set(val) {
            this._enabled = val, this._resource && (this._resource.enabled = this._enabled);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "useIBL",
        set: function set(val) {
            this._useIBL = val, this._resource && (this._resource.useIBL = this._useIBL);
        },
        get: function get() {
            return this._useIBL;
        }
    }, {
        key: "envmap",
        set: function set(val) {
            this._envmap = val, this._resource && (this._resource.envmap = this._envmap);
        },
        get: function get() {
            return this._envmap;
        }
    }, {
        key: "isRGBE",
        set: function set(val) {
            this._isRGBE = val, this._resource && (this._resource.isRGBE = this._isRGBE);
        },
        get: function get() {
            return this._isRGBE;
        }
    }, {
        key: "renderScene",
        set: function set(val) {
            this._resource = val.skybox, this.isRGBE = this._isRGBE, this.envmap = this._envmap, 
            this.enabled = this._enabled, this.useIBL = this._useIBL;
        }
    } ]), SkyboxInfo;
}()).prototype, "_envmap", [ _dec6$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor5$3 = _applyDecoratedDescriptor(_class5.prototype, "_isRGBE", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class5.prototype, "_enabled", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor7$1 = _applyDecoratedDescriptor(_class5.prototype, "_useIBL", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class5.prototype, "enabled", [ _dec7$1 ], Object.getOwnPropertyDescriptor(_class5.prototype, "enabled"), _class5.prototype), 
_applyDecoratedDescriptor(_class5.prototype, "useIBL", [ _dec8 ], Object.getOwnPropertyDescriptor(_class5.prototype, "useIBL"), _class5.prototype), 
_applyDecoratedDescriptor(_class5.prototype, "envmap", [ _dec9 ], Object.getOwnPropertyDescriptor(_class5.prototype, "envmap"), _class5.prototype), 
_applyDecoratedDescriptor(_class5.prototype, "isRGBE", [ _dec10 ], Object.getOwnPropertyDescriptor(_class5.prototype, "isRGBE"), _class5.prototype), 
_class4 = _class5)) || _class4);

cc.SkyboxInfo = SkyboxInfo;

var PlanarShadowInfo = (_dec11 = ccclass("cc.PlanarShadowInfo"), _dec12 = property({
    type: CCBoolean
}), _dec13 = property({
    type: Vec3
}), _dec14 = property({
    type: CCFloat
}), _dec15 = property({
    type: Color
}), _dec11((_descriptor8$1 = _applyDecoratedDescriptor((_class8 = function() {
    function PlanarShadowInfo() {
        _classCallCheck(this, PlanarShadowInfo), _initializerDefineProperty(this, "_enabled", _descriptor8$1, this), 
        _initializerDefineProperty(this, "_normal", _descriptor9$1, this), _initializerDefineProperty(this, "_distance", _descriptor10$1, this), 
        _initializerDefineProperty(this, "_shadowColor", _descriptor11, this), this._resource = null;
    }
    return _createClass(PlanarShadowInfo, [ {
        key: "setPlaneFromNode",
        value: function setPlaneFromNode(node) {
            node.getWorldRotation(_qt), this.normal = Vec3.transformQuat(_v3, _up, _qt), node.getWorldPosition(_v3), 
            this.distance = Vec3.dot(this._normal, _v3);
        }
    }, {
        key: "enabled",
        set: function set(val) {
            this._enabled = val, this._resource && (this._resource.enabled = val);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "normal",
        set: function set(val) {
            Vec3.copy(this._normal, val), this._resource && (this._resource.normal = val);
        },
        get: function get() {
            return this._normal;
        }
    }, {
        key: "distance",
        set: function set(val) {
            this._distance = val, this._resource && (this._resource.distance = val);
        },
        get: function get() {
            return this._distance;
        }
    }, {
        key: "shadowColor",
        set: function set(val) {
            this._shadowColor.set(val), this._resource && (this._resource.shadowColor = val);
        },
        get: function get() {
            return this._shadowColor;
        }
    }, {
        key: "renderScene",
        set: function set(val) {
            this._resource = val.planarShadows, this.normal = this._normal, this.distance = this._distance, 
            this.shadowColor = this._shadowColor, this.enabled = this._enabled;
        }
    } ]), PlanarShadowInfo;
}()).prototype, "_enabled", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class8.prototype, "_normal", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 1, 0);
    }
}), _descriptor10$1 = _applyDecoratedDescriptor(_class8.prototype, "_distance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11 = _applyDecoratedDescriptor(_class8.prototype, "_shadowColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(0, 0, 0, 76);
    }
}), _applyDecoratedDescriptor(_class8.prototype, "enabled", [ _dec12 ], Object.getOwnPropertyDescriptor(_class8.prototype, "enabled"), _class8.prototype), 
_applyDecoratedDescriptor(_class8.prototype, "normal", [ _dec13 ], Object.getOwnPropertyDescriptor(_class8.prototype, "normal"), _class8.prototype), 
_applyDecoratedDescriptor(_class8.prototype, "distance", [ _dec14 ], Object.getOwnPropertyDescriptor(_class8.prototype, "distance"), _class8.prototype), 
_applyDecoratedDescriptor(_class8.prototype, "shadowColor", [ _dec15 ], Object.getOwnPropertyDescriptor(_class8.prototype, "shadowColor"), _class8.prototype), 
_class7 = _class8)) || _class7);

cc.PlanarShadowInfo = PlanarShadowInfo;

var _class$o, _class2$j, _descriptor$h, _descriptor2$9, SceneGlobals = (_dec16 = ccclass("cc.SceneGlobals"), 
_dec17 = property({
    type: AmbientInfo
}), _dec18 = property({
    type: SkyboxInfo
}), _dec19 = property({
    type: PlanarShadowInfo
}), _dec16((_descriptor12 = _applyDecoratedDescriptor((_class11 = function() {
    function SceneGlobals() {
        _classCallCheck(this, SceneGlobals), _initializerDefineProperty(this, "ambient", _descriptor12, this), 
        _initializerDefineProperty(this, "skybox", _descriptor13, this), _initializerDefineProperty(this, "planarShadows", _descriptor14, this);
    }
    return _createClass(SceneGlobals, [ {
        key: "renderScene",
        set: function set(rs) {
            this.ambient.renderScene = rs, this.skybox.renderScene = rs, this.planarShadows.renderScene = rs;
        }
    } ]), SceneGlobals;
}()).prototype, "ambient", [ _dec17 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AmbientInfo();
    }
}), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "skybox", [ _dec18 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new SkyboxInfo();
    }
}), _descriptor14 = _applyDecoratedDescriptor(_class11.prototype, "planarShadows", [ _dec19 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new PlanarShadowInfo();
    }
}), _class10 = _class11)) || _class10);

cc.SceneGlobals = SceneGlobals;

var _class$p, Scene = ccclass("cc.Scene")((_descriptor$h = _applyDecoratedDescriptor((_class2$j = function(_Node) {
    function Scene(name) {
        var _this;
        return _classCallCheck(this, Scene), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, name)), "autoReleaseAssets", _descriptor$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_globals", _descriptor2$9, _assertThisInitialized(_this)), 
        _this._renderScene = null, _this.dependAssets = null, _this._inited = void 0, _this._prefabSyncedInLiveReload = !1, 
        _this._activeInHierarchy = !1, cc.director && cc.director.root && (_this._renderScene = cc.director.root.createScene({})), 
        _this._inited = !cc.game || !cc.game._isCloning, _this;
    }
    return _inherits(Scene, Node$1), _createClass(Scene, [ {
        key: "renderScene",
        get: function get() {
            return this._renderScene;
        }
    }, {
        key: "globals",
        get: function get() {
            return this._globals;
        }
    } ]), _createClass(Scene, [ {
        key: "destroy",
        value: function destroy() {
            var success = _get(_getPrototypeOf(Scene.prototype), "destroy", this).call(this);
            return cc.director.root.destroyScene(this._renderScene), this._activeInHierarchy = !1, 
            success;
        }
    }, {
        key: "_onHierarchyChanged",
        value: function _onHierarchyChanged() {}
    }, {
        key: "_instantiate",
        value: function _instantiate() {}
    }, {
        key: "_load",
        value: function _load() {
            this._inited || (this._onBatchCreated(), this._inited = !0), this.walk(BaseNode._setScene);
        }
    }, {
        key: "_activate",
        value: function _activate(active) {
            active = !1 !== active, cc.director._nodeActivator.activateNode(this, active), this._globals.renderScene = this._renderScene;
        }
    } ]), Scene;
}()).prototype, "autoReleaseAssets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$9 = _applyDecoratedDescriptor(_class2$j.prototype, "_globals", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new SceneGlobals();
    }
}), _class$o = _class2$j)) || _class$o;

function find(path, referenceNode) {
    if (referenceNode) 0; else {
        var scene = cc.director.getScene();
        if (!scene) return null;
        referenceNode = scene;
    }
    return referenceNode.getChildByPath(path);
}

cc.Scene = Scene, cc.find = find;

var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy, PrivateNode = ccclass("cc.PrivateNode")(_class$p = function(_Node) {
    function PrivateNode(name) {
        var _this;
        return _classCallCheck(this, PrivateNode), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PrivateNode).call(this, name)))._objFlags |= HideInHierarchy$1, 
        _this;
    }
    return _inherits(PrivateNode, Node$1), PrivateNode;
}()) || _class$p;

cc.PrivateNode = PrivateNode;

var fastRemoveAt$2 = array.fastRemoveAt, IsStartCalled$1 = CCObject.Flags.IsStartCalled, IsOnEnableCalled$2 = CCObject.Flags.IsOnEnableCalled, callStart = (CCObject.Flags.IsEditorOnEnableCalled, 
"c.start();c._objFlags|=" + IsStartCalled$1);

function sortedIndex(array, comp) {
    for (var order = comp.constructor._executionOrder, id = comp._id, l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m], testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
            var testId = test._id;
            if (testId > id) h = m - 1; else {
                if (!(testId < id)) return m;
                l = m + 1;
            }
        }
    }
    return ~l;
}

function stableRemoveInactive(iterator, flagToClear) {
    for (var array = iterator.array, next = iterator.i + 1; next < array.length; ) {
        var comp = array[next];
        comp._enabled && comp.node._activeInHierarchy ? ++next : (iterator.removeAt(next), 
        flagToClear && (comp._objFlags &= ~flagToClear));
    }
}

var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
    _classCallCheck(this, LifeCycleInvoker), this._zero = void 0, this._neg = void 0, 
    this._pos = void 0, this._invoke = void 0;
    var Iterator = MutableForwardIterator;
    this._zero = new Iterator([]), this._neg = new Iterator([]), this._pos = new Iterator([]), 
    this._invoke = invokeFunc;
};

function compareOrder(a, b) {
    return a.constructor._executionOrder - b.constructor._executionOrder;
}

LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

var OneOffInvoker = function(_LifeCycleInvoker) {
    function OneOffInvoker() {
        return _classCallCheck(this, OneOffInvoker), _possibleConstructorReturn(this, _getPrototypeOf(OneOffInvoker).apply(this, arguments));
    }
    return _inherits(OneOffInvoker, LifeCycleInvoker), _createClass(OneOffInvoker, [ {
        key: "add",
        value: function add(comp) {
            var order = comp.constructor._executionOrder;
            (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
        }
    }, {
        key: "remove",
        value: function remove(comp) {
            var order = comp.constructor._executionOrder;
            (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
        }
    }, {
        key: "cancelInactive",
        value: function cancelInactive(flagToClear) {
            stableRemoveInactive(this._zero, flagToClear), stableRemoveInactive(this._neg, flagToClear), 
            stableRemoveInactive(this._pos, flagToClear);
        }
    }, {
        key: "invoke",
        value: function invoke() {
            var compsNeg = this._neg;
            compsNeg.array.length > 0 && (compsNeg.array.sort(compareOrder), this._invoke(compsNeg), 
            compsNeg.array.length = 0), this._invoke(this._zero), this._zero.array.length = 0;
            var compsPos = this._pos;
            compsPos.array.length > 0 && (compsPos.array.sort(compareOrder), this._invoke(compsPos), 
            compsPos.array.length = 0);
        }
    } ]), OneOffInvoker;
}(), ReusableInvoker = function(_LifeCycleInvoker2) {
    function ReusableInvoker() {
        return _classCallCheck(this, ReusableInvoker), _possibleConstructorReturn(this, _getPrototypeOf(ReusableInvoker).apply(this, arguments));
    }
    return _inherits(ReusableInvoker, LifeCycleInvoker), _createClass(ReusableInvoker, [ {
        key: "add",
        value: function add(comp) {
            var order = comp.constructor._executionOrder;
            if (0 === order) this._zero.array.push(comp); else {
                var _array = order < 0 ? this._neg.array : this._pos.array, i = sortedIndex(_array, comp);
                i < 0 && _array.splice(~i, 0, comp);
            }
        }
    }, {
        key: "remove",
        value: function remove(comp) {
            var order = comp.constructor._executionOrder;
            if (0 === order) this._zero.fastRemove(comp); else {
                var iterator = order < 0 ? this._neg : this._pos, i = sortedIndex(iterator.array, comp);
                i >= 0 && iterator.removeAt(i);
            }
        }
    }, {
        key: "invoke",
        value: function invoke(dt) {
            this._neg.array.length > 0 && this._invoke(this._neg, dt), this._invoke(this._zero, dt), 
            this._pos.array.length > 0 && this._invoke(this._pos, dt);
        }
    } ]), ReusableInvoker;
}();

function createInvokeImpl(funcOrCode, useDt) {
    if ("function" == typeof funcOrCode) return useDt ? function(iterator, dt) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            funcOrCode(comp, dt);
        }
    } : function(iterator) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            funcOrCode(comp);
        }
    };
    var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
    return useDt ? Function("it", "dt", body) : Function("it", body);
}

var ComponentScheduler = function() {
    function ComponentScheduler() {
        _classCallCheck(this, ComponentScheduler), this.startInvoker = void 0, this.updateInvoker = void 0, 
        this.lateUpdateInvoker = void 0, this.scheduleInNextFrame = void 0, this._updating = void 0, 
        this.unscheduleAll();
    }
    return _createClass(ComponentScheduler, [ {
        key: "unscheduleAll",
        value: function unscheduleAll() {
            this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart)), this.updateInvoker = new ReusableInvoker(createInvokeImpl("c.update(dt)", !0)), 
            this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl("c.lateUpdate(dt)", !0)), 
            this.scheduleInNextFrame = [], this._updating = !1;
        }
    }, {
        key: "_onEnabled",
        value: function _onEnabled(comp) {
            cc.director.getScheduler().resumeTarget(comp), comp._objFlags |= IsOnEnableCalled$2, 
            this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
        }
    }, {
        key: "_onDisabled",
        value: function _onDisabled(comp) {
            cc.director.getScheduler().pauseTarget(comp), comp._objFlags &= ~IsOnEnableCalled$2;
            var index = this.scheduleInNextFrame.indexOf(comp);
            index >= 0 ? fastRemoveAt$2(this.scheduleInNextFrame, index) : (!comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.remove(comp), 
            comp.update && this.updateInvoker.remove(comp), comp.lateUpdate && this.lateUpdateInvoker.remove(comp));
        }
    }, {
        key: "enableComp",
        value: function enableComp(comp, invoker) {
            if (!(comp._objFlags & IsOnEnableCalled$2)) {
                if (comp.onEnable) {
                    if (invoker) return void invoker.add(comp);
                    if (comp.onEnable(), !comp.node._activeInHierarchy) return;
                }
                this._onEnabled(comp);
            }
        }
    }, {
        key: "disableComp",
        value: function disableComp(comp) {
            comp._objFlags & IsOnEnableCalled$2 && (comp.onDisable && comp.onDisable(), this._onDisabled(comp));
        }
    }, {
        key: "startPhase",
        value: function startPhase() {
            this._updating = !0, this.scheduleInNextFrame.length > 0 && this._deferredSchedule(), 
            this.startInvoker.invoke();
        }
    }, {
        key: "updatePhase",
        value: function updatePhase(dt) {
            this.updateInvoker.invoke(dt);
        }
    }, {
        key: "lateUpdatePhase",
        value: function lateUpdatePhase(dt) {
            this.lateUpdateInvoker.invoke(dt), this._updating = !1;
        }
    }, {
        key: "_scheduleImmediate",
        value: function _scheduleImmediate(comp) {
            !comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.add(comp), 
            comp.update && this.updateInvoker.add(comp), comp.lateUpdate && this.lateUpdateInvoker.add(comp);
        }
    }, {
        key: "_deferredSchedule",
        value: function _deferredSchedule() {
            for (var comps = this.scheduleInNextFrame, i = 0, len = comps.length; i < len; i++) {
                var comp = comps[i];
                this._scheduleImmediate(comp);
            }
            comps.length = 0;
        }
    } ]), ComponentScheduler;
}();

ComponentScheduler.LifeCycleInvoker = LifeCycleInvoker, ComponentScheduler.OneOffInvoker = OneOffInvoker, 
ComponentScheduler.createInvokeImpl = createInvokeImpl, ComponentScheduler.invokeOnEnable = function(iterator) {
    var compScheduler = cc.director._compScheduler, array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var comp = array[iterator.i];
        if (comp._enabled) comp.onEnable(), !comp.node._activeInHierarchy || compScheduler._onEnabled(comp);
    }
};

var IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted, IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted, IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled, Deactivating$2 = CCObject.Flags.Deactivating, callOnLoad = "c.onLoad();c._objFlags|=" + IsOnLoadCalled$2, UnsortedInvoker = function(_ComponentScheduler$L) {
    function UnsortedInvoker() {
        return _classCallCheck(this, UnsortedInvoker), _possibleConstructorReturn(this, _getPrototypeOf(UnsortedInvoker).apply(this, arguments));
    }
    return _inherits(UnsortedInvoker, ComponentScheduler.LifeCycleInvoker), _createClass(UnsortedInvoker, [ {
        key: "add",
        value: function add(comp) {
            this._zero.array.push(comp);
        }
    }, {
        key: "remove",
        value: function remove(comp) {
            this._zero.fastRemove(comp);
        }
    }, {
        key: "cancelInactive",
        value: function cancelInactive(flagToClear) {
            ComponentScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
        }
    }, {
        key: "invoke",
        value: function invoke() {
            this._invoke(this._zero), this._zero.array.length = 0;
        }
    } ]), UnsortedInvoker;
}(), invokePreload = ComponentScheduler.createInvokeImpl("c.__preload();"), invokeOnLoad = ComponentScheduler.createInvokeImpl(callOnLoad), activateTasksPool = new Pool(4);

function _componentCorrupted(node, comp, index) {
    comp ? node._removeComponent(comp) : array.removeAt(node._components, index);
}

activateTasksPool.get = function getActivateTask() {
    var task = this._get() || {
        preload: new UnsortedInvoker(invokePreload),
        onLoad: new ComponentScheduler.OneOffInvoker(invokeOnLoad),
        onEnable: new ComponentScheduler.OneOffInvoker(ComponentScheduler.invokeOnEnable)
    };
    task.preload._zero.i = -1;
    var invoker = task.onLoad;
    return invoker._zero.i = -1, invoker._neg.i = -1, invoker._pos.i = -1, (invoker = task.onEnable)._zero.i = -1, 
    invoker._neg.i = -1, invoker._pos.i = -1, task;
};

var NodeActivator = function() {
    function NodeActivator() {
        _classCallCheck(this, NodeActivator), this.resetComp = void 0, this._activatingStack = void 0, 
        this.reset();
    }
    return _createClass(NodeActivator, [ {
        key: "reset",
        value: function reset() {
            this._activatingStack = [];
        }
    }, {
        key: "activateNode",
        value: function activateNode(node, active) {
            if (active) {
                var task = activateTasksPool.get();
                this._activatingStack.push(task), this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable), 
                task.preload.invoke(), task.onLoad.invoke(), task.onEnable.invoke(), this._activatingStack.pop(), 
                activateTasksPool.put(task);
            } else {
                this._deactivateNodeRecursively(node);
                var _iterator = this._activatingStack, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var lastTask = _ref;
                    lastTask.preload.cancelInactive(IsPreloadStarted$1), lastTask.onLoad.cancelInactive(IsOnLoadStarted$1), 
                    lastTask.onEnable.cancelInactive();
                }
            }
            node.emit("active-in-hierarchy-changed", node);
        }
    }, {
        key: "activateComp",
        value: function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
            if (comp._objFlags & IsPreloadStarted$1 || (comp._objFlags |= IsPreloadStarted$1, 
            comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload())), 
            comp._objFlags & IsOnLoadStarted$1 || (comp._objFlags |= IsOnLoadStarted$1, comp.onLoad ? onLoadInvoker ? onLoadInvoker.add(comp) : (comp.onLoad(), 
            comp._objFlags |= IsOnLoadCalled$2) : comp._objFlags |= IsOnLoadCalled$2), comp._enabled) {
                if (!comp.node._activeInHierarchy) return;
                cc.director._compScheduler.enableComp(comp, onEnableInvoker);
            }
        }
    }, {
        key: "destroyComp",
        value: function destroyComp(comp) {
            cc.director._compScheduler.disableComp(comp), comp.onDestroy && comp._objFlags & IsOnLoadCalled$2 && comp.onDestroy();
        }
    }, {
        key: "_activateNodeRecursively",
        value: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
            if (node._objFlags & Deactivating$2) cc.errorID(3816, node.name); else {
                node._activeInHierarchy = !0;
                for (var originCount = node._components.length, i = 0; i < originCount; ++i) {
                    var component = node._components[i];
                    component instanceof cc.Component ? this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker) : (_componentCorrupted(node, component, i), 
                    --i, --originCount);
                }
                node._childArrivalOrder = node._children.length;
                for (var _i2 = 0, len = node._children.length; _i2 < len; ++_i2) {
                    var child = node._children[_i2];
                    child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                }
                node._onPostActivated(!0);
            }
        }
    }, {
        key: "_deactivateNodeRecursively",
        value: function _deactivateNodeRecursively(node) {
            node._objFlags |= Deactivating$2, node._activeInHierarchy = !1;
            for (var originCount = node._components.length, c = 0; c < originCount; ++c) {
                var component = node._components[c];
                if (component._enabled && (cc.director._compScheduler.disableComp(component), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
            }
            for (var i = 0, len = node._children.length; i < len; ++i) {
                var child = node._children[i];
                if (child._activeInHierarchy && (this._deactivateNodeRecursively(child), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
            }
            node._onPostActivated(!1), node._objFlags &= ~Deactivating$2;
        }
    } ]), NodeActivator;
}();

replaceProperty(BaseNode.prototype, "BaseNode", [ {
    name: "childrenCount",
    newName: "children.length",
    customGetter: function customGetter() {
        return this.children.length;
    }
} ]);

var _class$q, _class2$k, _descriptor$i, _descriptor2$a, _descriptor3$6, _descriptor4$5, _descriptor5$4, eventRegx = /^(click)(\s)*=|(param)(\s)*=/, imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/, HtmlTextParser = function() {
    function HtmlTextParser() {
        _classCallCheck(this, HtmlTextParser), this._specialSymbolArray = [], this._stack = [], 
        this._resultObjectArray = [], this._specialSymbolArray.push([ /&lt;/g, "<" ]), this._specialSymbolArray.push([ /&gt;/g, ">" ]), 
        this._specialSymbolArray.push([ /&amp;/g, "&" ]), this._specialSymbolArray.push([ /&quot;/g, '"' ]), 
        this._specialSymbolArray.push([ /&apos;/g, "'" ]);
    }
    return _createClass(HtmlTextParser, [ {
        key: "parse",
        value: function parse(htmlString) {
            this._resultObjectArray.length = 0, this._stack.length = 0;
            for (var startIndex = 0, length = htmlString.length; startIndex < length; ) {
                var tagBeginIndex = htmlString.indexOf("<", startIndex);
                if (tagBeginIndex < 0) this._stack.pop(), this._processResult(htmlString.substring(startIndex)), 
                startIndex = length; else {
                    this._processResult(htmlString.substring(startIndex, tagBeginIndex));
                    var tagEndIndex = htmlString.indexOf(">", startIndex);
                    -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex)), 
                    startIndex = tagEndIndex + 1;
                }
            }
            return this._resultObjectArray;
        }
    }, {
        key: "_attributeToObject",
        value: function _attributeToObject(attribute) {
            var obj = {}, header = (attribute = attribute.trim()).match(/^(color|size)(\s)*=/), tagName = "", nextSpace = 0, eventHanlderString = "";
            if (header) {
                if (tagName = header[0], "" === (attribute = attribute.substring(tagName.length).trim())) return obj;
                switch (nextSpace = attribute.indexOf(" "), tagName[0]) {
                  case "c":
                    obj.color = nextSpace > -1 ? attribute.substring(0, nextSpace).trim() : attribute;
                    break;

                  case "s":
                    obj.size = parseInt(attribute);
                }
                return nextSpace > -1 && (eventHanlderString = attribute.substring(nextSpace + 1).trim(), 
                obj.event = this._processEventHandler(eventHanlderString)), obj;
            }
            if ((header = attribute.match(/^(br(\s)*\/)/)) && header[0].length > 0 && (tagName = header[0].trim()).startsWith("br") && "/" === tagName[tagName.length - 1]) return obj.isNewLine = !0, 
            this._resultObjectArray.push({
                text: "",
                style: {
                    newline: !0
                }
            }), obj;
            var remainingArgument = "";
            if ((header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/)) && header[0].length > 0 && (tagName = header[0].trim()).startsWith("img") && "/" === tagName[tagName.length - 1]) {
                var tagValue;
                header = attribute.match(imageAttrReg);
                for (var isValidImageTag = !1; header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                tagValue = (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                attribute = remainingArgument.substring(nextSpace).trim(), "src" === tagName ? (obj.isImage = !0, 
                tagValue.endsWith("/") && (tagValue = tagValue.substring(0, tagValue.length - 1)), 
                0 === tagValue.indexOf("'") ? (isValidImageTag = !0, tagValue = tagValue.substring(1, tagValue.length - 1)) : 0 === tagValue.indexOf('"') && (isValidImageTag = !0, 
                tagValue = tagValue.substring(1, tagValue.length - 1)), obj.src = tagValue) : "height" === tagName ? obj.imageHeight = parseInt(tagValue) : "width" === tagName ? obj.imageWidth = parseInt(tagValue) : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue)), 
                obj.event && "param" === tagName && (obj.event[tagName] = tagValue.replace(/^\"|\"$/g, "")), 
                header = attribute.match(imageAttrReg);
                return isValidImageTag && obj.isImage && this._resultObjectArray.push({
                    text: "",
                    style: obj
                }), {};
            }
            if (header = attribute.match(/^(outline(\s)*[^>]*)/)) {
                var defaultOutlineObject = {
                    color: "#ffffff",
                    width: 1
                };
                if (attribute = header[0].substring("outline".length).trim()) {
                    var _tagValue, outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                    for (header = attribute.match(outlineAttrReg); header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                    _tagValue = (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                    tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                    attribute = remainingArgument.substring(nextSpace).trim(), "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + _tagValue) : "color" === tagName ? defaultOutlineObject.color = _tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(_tagValue)), 
                    obj.event && "param" === tagName && (obj.event[tagName] = _tagValue.replace(/^\"|\"$/g, "")), 
                    header = attribute.match(outlineAttrReg);
                }
                obj.outline = defaultOutlineObject;
            }
            if ((header = attribute.match(/^(on|u|b|i)(\s)*/)) && header[0].length > 0) {
                switch (tagName = header[0], attribute = attribute.substring(tagName.length).trim(), 
                tagName[0]) {
                  case "u":
                    obj.underline = !0;
                    break;

                  case "i":
                    obj.italic = !0;
                    break;

                  case "b":
                    obj.bold = !0;
                }
                if ("" === attribute) return obj;
                obj.event = this._processEventHandler(attribute);
            }
            return obj;
        }
    }, {
        key: "_processEventHandler",
        value: function _processEventHandler(eventString) {
            for (var index = 0, obj = new Map(), eventNames = eventString.match(eventRegx), isValidTag = !1; eventNames; ) {
                var eventName = eventNames[0], eventValue = "";
                if (isValidTag = !1, '"' === (eventString = eventString.substring(eventName.length).trim()).charAt(0)) (index = eventString.indexOf('"', 1)) > -1 && (eventValue = eventString.substring(1, index).trim(), 
                isValidTag = !0), index++; else if ("'" === eventString.charAt(0)) (index = eventString.indexOf("'", 1)) > -1 && (eventValue = eventString.substring(1, index).trim(), 
                isValidTag = !0), index++; else {
                    var match = eventString.match(/(\S)+/);
                    index = (eventValue = match ? match[0] : "").length;
                }
                isValidTag && (obj[eventName = eventName.substring(0, eventName.length - 1).trim()] = eventValue), 
                eventNames = (eventString = eventString.substring(index).trim()).match(eventRegx);
            }
            return obj;
        }
    }, {
        key: "_addToStack",
        value: function _addToStack(attribute) {
            var obj = this._attributeToObject(attribute);
            if (0 === this._stack.length) this._stack.push(obj); else {
                if (obj.isNewLine || obj.isImage) return;
                var previousTagObj = this._stack[this._stack.length - 1];
                for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
                this._stack.push(obj);
            }
        }
    }, {
        key: "_processResult",
        value: function _processResult(value) {
            0 !== value.length && (value = this._escapeSpecialSymbol(value), this._stack.length > 0 ? this._resultObjectArray.push({
                text: value,
                style: this._stack[this._stack.length - 1]
            }) : this._resultObjectArray.push({
                text: value
            }));
        }
    }, {
        key: "_escapeSpecialSymbol",
        value: function _escapeSpecialSymbol(str) {
            var _iterator = this._specialSymbolArray, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var symbolArr = _ref, key = symbolArr[0], value = symbolArr[1];
                str = str.replace(key, value);
            }
            return str;
        }
    } ]), HtmlTextParser;
}();

var PrefabInfo = ccclass("cc.PrefabInfo")((_descriptor$i = _applyDecoratedDescriptor((_class2$k = function PrefabInfo() {
    _classCallCheck(this, PrefabInfo), _initializerDefineProperty(this, "root", _descriptor$i, this), 
    _initializerDefineProperty(this, "asset", _descriptor2$a, this), _initializerDefineProperty(this, "fileId", _descriptor3$6, this), 
    _initializerDefineProperty(this, "sync", _descriptor4$5, this), _initializerDefineProperty(this, "_synced", _descriptor5$4, this);
}).prototype, "root", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$a = _applyDecoratedDescriptor(_class2$k.prototype, "asset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class2$k.prototype, "fileId", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor4$5 = _applyDecoratedDescriptor(_class2$k.prototype, "sync", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class2$k.prototype, "_synced", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return {
            default: !1,
            serializable: !1
        };
    }
}), _class$q = _class2$k)) || _class$q;

cc._PrefabInfo = PrefabInfo;

var Destroyed$2 = CCObject.Flags.Destroyed, PersistentMask$2 = CCObject.Flags.PersistentMask, objsToClearTmpVar = [];

function instantiate(original, internal_force) {
    if (!internal_force) {
        if ("object" !== _typeof(original) || Array.isArray(original)) return null;
        if (!original) return null;
        if (!cc.isValid(original)) return null;
        0;
    }
    var clone;
    if (original instanceof CCObject) {
        if ((original = original)._instantiate) return cc.game._isCloning = !0, clone = original._instantiate(), 
        cc.game._isCloning = !1, clone;
        if (original instanceof cc.Asset) return null;
    }
    return cc.game._isCloning = !0, clone = doInstantiate(original), cc.game._isCloning = !1, 
    clone;
}

function doInstantiate(obj, parent) {
    if (Array.isArray(obj)) return null;
    if (isDomNode && isDomNode(obj)) return null;
    var clone;
    if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
        clone = new (0, obj.constructor)();
    } else clone = Object.create(null);
    enumerateObject(obj, clone, parent);
    for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
    return objsToClearTmpVar.length = 0, clone;
}

function enumerateObject(obj, clone, parent) {
    value(obj, "_iN$t", clone, !0), objsToClearTmpVar.push(obj);
    var klass = obj.constructor;
    if (cc.Class._isCCClass(klass)) !function enumerateCCClass(klass, obj, clone, parent) {
        for (var props = klass.__values__, p = 0; p < props.length; p++) {
            var key = props[p], value = obj[key];
            if ("object" === _typeof(value) && value) {
                var initValue = clone[key];
                initValue instanceof ValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
            } else clone[key] = value;
        }
    }(klass, obj, clone, parent); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
        var value$1 = obj[key];
        if ("object" === _typeof(value$1) && value$1) {
            if (value$1 === clone) continue;
            clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
        } else clone[key] = value$1;
    }
    obj instanceof CCObject && (clone._objFlags &= PersistentMask$2);
}

function instantiateObj(obj, parent) {
    if (obj instanceof ValueType) return obj.clone();
    if (obj instanceof cc.Asset) return obj;
    var clone;
    if (Array.isArray(obj)) {
        var len = obj.length;
        clone = new Array(len), obj._iN$t = clone;
        for (var i = 0; i < len; ++i) {
            var value = obj[i];
            "object" === _typeof(value) && value ? clone[i] = value._iN$t || instantiateObj(value, parent) : clone[i] = value;
        }
        return objsToClearTmpVar.push(obj), clone;
    }
    if (obj._objFlags & Destroyed$2) return null;
    var ctor = obj.constructor;
    if (cc.Class._isCCClass(ctor)) {
        if (parent) if (parent instanceof cc.Component) {
            if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
        } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
            if (!obj.isChildOf(parent)) return obj;
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
        clone = new ctor();
    } else if (ctor === Object) clone = {}; else {
        if (ctor) return obj;
        clone = Object.create(null);
    }
    return enumerateObject(obj, clone, parent), clone;
}

instantiate._clone = doInstantiate, cc.instantiate = instantiate, cc._decorator = _decorator;

var visibleRect = {
    topLeft: cc.v2(0, 0),
    topRight: cc.v2(0, 0),
    top: cc.v2(0, 0),
    bottomLeft: cc.v2(0, 0),
    bottomRight: cc.v2(0, 0),
    bottom: cc.v2(0, 0),
    center: cc.v2(0, 0),
    left: cc.v2(0, 0),
    right: cc.v2(0, 0),
    width: 0,
    height: 0,
    init: function init(visibleRect_) {
        var w = this.width = visibleRect_.width, h = this.height = visibleRect_.height, l = visibleRect_.x, b = visibleRect_.y, t = b + h, r = l + w;
        this.topLeft.x = l, this.topLeft.y = t, this.topRight.x = r, this.topRight.y = t, 
        this.top.x = l + w / 2, this.top.y = t, this.bottomLeft.x = l, this.bottomLeft.y = b, 
        this.bottomRight.x = r, this.bottomRight.y = b, this.bottom.x = l + w / 2, this.bottom.y = b, 
        this.center.x = l + w / 2, this.center.y = b + h / 2, this.left.x = l, this.left.y = b + h / 2, 
        this.right.x = r, this.right.y = b + h / 2;
    }
};

cc.visibleRect = visibleRect;

var Game = function(_EventTarget) {
    function Game() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Game);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Game)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).frame = null, 
        _this.container = null, _this.canvas = null, _this.renderType = -1, _this.eventTargetOn = _get(_getPrototypeOf(Game.prototype), "on", _assertThisInitialized(_this)), 
        _this.eventTargetOnce = _get(_getPrototypeOf(Game.prototype), "once", _assertThisInitialized(_this)), 
        _this.config = {}, _this.onStart = null, _this._persistRootNodes = {}, _this._paused = !0, 
        _this._configLoaded = !1, _this._isCloning = !1, _this._prepared = !1, _this._rendererInitialized = !1, 
        _this._gfxDevice = null, _this._intervalId = null, _this._lastTime = null, _this._frameTime = null, 
        _this._sceneInfos = [], _this.collisionMatrix = [], _this.groupList = [], _this;
    }
    return _inherits(Game, EventTarget), _createClass(Game, [ {
        key: "setFrameRate",
        value: function setFrameRate(frameRate) {
            var config = this.config;
            "number" != typeof frameRate && (frameRate = parseInt(frameRate), isNaN(frameRate) && (frameRate = 60)), 
            config.frameRate = frameRate, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
            this._intervalId = 0, this._paused = !0, this._setAnimFrame(), this._runMainLoop();
        }
    }, {
        key: "getFrameRate",
        value: function getFrameRate() {
            return this.config.frameRate;
        }
    }, {
        key: "step",
        value: function step() {
            cc.director.mainLoop();
        }
    }, {
        key: "pause",
        value: function pause() {
            this._paused || (this._paused = !0, this._intervalId && window.cancelAnimationFrame(this._intervalId), 
            this._intervalId = 0);
        }
    }, {
        key: "resume",
        value: function resume() {
            this._paused && (this._paused = !1, this._runMainLoop());
        }
    }, {
        key: "isPaused",
        value: function isPaused() {
            return this._paused;
        }
    }, {
        key: "restart",
        value: function restart() {
            cc.director.once(cc.Director.EVENT_AFTER_DRAW, function() {
                for (var id in cc.game._persistRootNodes) cc.game.removePersistRootNode(cc.game._persistRootNodes[id]);
                cc.director.getScene().destroy(), cc.Object._deferredDestroy(), cc.director.purgeDirector(), 
                cc.director.reset(), cc.game.onStart();
            });
        }
    }, {
        key: "end",
        value: function end() {
            this._gfxDevice && (this._gfxDevice.destroy(), this._gfxDevice = null), close();
        }
    }, {
        key: "on",
        value: function on(type, callback, target) {
            this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target);
        }
    }, {
        key: "once",
        value: function once(type, callback, target) {
            this._prepared && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
        }
    }, {
        key: "run",
        value: function run(config, onStart) {
            this._initConfig(config), this.onStart = onStart, this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game));
        }
    }, {
        key: "addPersistRootNode",
        value: function addPersistRootNode(node) {
            if (cc.Node.isNode(node) && node.uuid) {
                var id = node.uuid;
                if (!this._persistRootNodes[id]) {
                    var scene = cc.director._scene;
                    if (cc.isValid(scene)) if (node.parent) {
                        if (!(node.parent instanceof cc.Scene)) return void cc.warnID(3801);
                        if (node.parent !== scene) return void cc.warnID(3802);
                    } else node.parent = scene;
                    this._persistRootNodes[id] = node, node._persistNode = !0;
                }
            } else cc.warnID(3800);
        }
    }, {
        key: "removePersistRootNode",
        value: function removePersistRootNode(node) {
            var id = node.uuid || "";
            node === this._persistRootNodes[id] && (delete this._persistRootNodes[id], node._persistNode = !1);
        }
    }, {
        key: "isPersistRootNode",
        value: function isPersistRootNode(node) {
            return node._persistNode;
        }
    }, {
        key: "prepare",
        value: function prepare(cb) {
            if (this._prepared) cb && cb(); else {
                var jsList = this.config.jsList;
                if (jsList && jsList.length > 0) {
                    var self = this;
                    cc.loader.load(jsList, function(err) {
                        if (err) throw new Error(JSON.stringify(err));
                        self._prepareFinished(cb);
                    });
                } else this._prepareFinished(cb);
            }
        }
    }, {
        key: "_initEngine",
        value: function _initEngine() {
            this._rendererInitialized || (this._initRenderer(), this._initEvents(), this.emit(Game.EVENT_ENGINE_INITED));
        }
    }, {
        key: "_prepareFinished",
        value: function _prepareFinished(cb) {
            this._prepared = !0, this._initEngine(), console.log("Cocos Creator 3D v" + cc.ENGINE_VERSION), 
            this._setAnimFrame(), this._runMainLoop(), this.emit(Game.EVENT_GAME_INITED), cb && cb();
        }
    }, {
        key: "_setAnimFrame",
        value: function _setAnimFrame() {
            this._lastTime = new Date();
            var frameRate = cc.game.config.frameRate;
            this._frameTime = 1e3 / frameRate, 60 !== frameRate && 30 !== frameRate ? (window.requestAnimationFrame = this._stTime, 
            window.cancelAnimationFrame = this._ctTime) : (window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, 
            window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime);
        }
    }, {
        key: "_stTime",
        value: function _stTime(callback) {
            var currTime = new Date().getTime(), timeToCall = Math.max(0, cc.game._frameTime - (currTime - cc.game._lastTime)), id = window.setTimeout(function() {
                callback();
            }, timeToCall);
            return cc.game._lastTime = currTime + timeToCall, id;
        }
    }, {
        key: "_ctTime",
        value: function _ctTime(id) {
            window.clearTimeout(id);
        }
    }, {
        key: "_runMainLoop",
        value: function _runMainLoop() {
            var _callback, self = this, config = self.config, director = cc.director, skip = !0, frameRate = config.frameRate;
            setDisplayStats(config.showFPS), _callback = function callback(time) {
                if (!self._paused) {
                    if (self._intervalId = window.requestAnimationFrame(_callback), 30 === frameRate && (skip = !skip)) return;
                    director.mainLoop(time);
                }
            }, self._intervalId = window.requestAnimationFrame(_callback), self._paused = !1;
        }
    }, {
        key: "_initConfig",
        value: function _initConfig(config) {
            "number" != typeof config.debugMode && (config.debugMode = 0), config.exposeClassName = !!config.exposeClassName, 
            "number" != typeof config.frameRate && (config.frameRate = 60);
            var renderMode = config.renderMode;
            ("number" != typeof renderMode || renderMode > 2 || renderMode < 0) && (config.renderMode = 0), 
            "boolean" != typeof config.registerSystemEvent && (config.registerSystemEvent = !0), 
            config.showFPS = !!config.showFPS, this._sceneInfos = config.scenes || [], this.collisionMatrix = config.collisionMatrix || [], 
            this.groupList = config.groupList || [], _resetDebugSetting(config.debugMode), this.config = config, 
            this._configLoaded = !0;
        }
    }, {
        key: "_determineRenderType",
        value: function _determineRenderType() {
            var config = this.config, userRenderMode = parseInt(config.renderMode) || 0;
            this.renderType = Game.RENDER_TYPE_CANVAS;
            var supportRender = !1;
            if (0 === userRenderMode ? cc.sys.capabilities.opengl ? (this.renderType = Game.RENDER_TYPE_WEBGL, 
            supportRender = !0) : cc.sys.capabilities.canvas && (this.renderType = Game.RENDER_TYPE_CANVAS, 
            supportRender = !0) : 1 === userRenderMode && cc.sys.capabilities.canvas ? (this.renderType = Game.RENDER_TYPE_CANVAS, 
            supportRender = !0) : 2 === userRenderMode && cc.sys.capabilities.opengl && (this.renderType = Game.RENDER_TYPE_WEBGL, 
            supportRender = !0), !supportRender) throw new Error(getError(3820, userRenderMode));
        }
    }, {
        key: "_initRenderer",
        value: function _initRenderer() {
            if (!this._rendererInitialized) {
                var width, height, localCanvas, localContainer, el = this.config.id, isWeChatGame = cc.sys.platform === cc.sys.WECHAT_GAME, isQQPlay = cc.sys.platform === cc.sys.QQ_PLAY;
                if (isWeChatGame) this.container = localContainer = document.createElement("div"), 
                this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode, 
                localCanvas = cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? window.sharedCanvas || wx.getSharedCanvas() : window.canvas, 
                this.canvas = localCanvas; else if (isQQPlay) this.container = cc.container = document.createElement("div"), 
                this.frame = document.documentElement, this.canvas = localCanvas = window.canvas; else {
                    var element = el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el);
                    "CANVAS" === element.tagName ? (width = element.width, height = element.height, 
                    this.canvas = localCanvas = element, this.container = localContainer = document.createElement("div"), 
                    localCanvas && localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas)) : ("DIV" !== element.tagName && cc.warnID(3819), 
                    width = element.clientWidth, height = element.clientHeight, this.canvas = localCanvas = document.createElement("CANVAS"), 
                    this.container = localContainer = document.createElement("div"), element.appendChild(localContainer)), 
                    localContainer.setAttribute("id", "Cocos3dGameContainer"), localContainer.appendChild(localCanvas), 
                    this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode, 
                    function addClass(element, name) {
                        (" " + element.className + " ").indexOf(" " + name + " ") > -1 || (element.className && (element.className += " "), 
                        element.className += name);
                    }(localCanvas, "gameCanvas"), localCanvas.setAttribute("width", width || "480"), 
                    localCanvas.setAttribute("height", height || "320"), localCanvas.setAttribute("tabindex", "99");
                }
                if (this._determineRenderType(), this.renderType === Game.RENDER_TYPE_WEBGL) {
                    var useWebGL2 = !!window.WebGL2RenderingContext, userAgent = navigator.userAgent.toLowerCase();
                    -1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") && (useWebGL2 = !1), 
                    useWebGL2 && cc.WebGL2GFXDevice ? this._gfxDevice = new cc.WebGL2GFXDevice() : cc.WebGLGFXDevice && (this._gfxDevice = new cc.WebGLGFXDevice());
                    var opts = {
                        canvasElm: localCanvas,
                        debug: !0,
                        devicePixelRatio: window.devicePixelRatio,
                        nativeWidth: Math.floor(screen.width * cc.view._devicePixelRatio),
                        nativeHeight: Math.floor(screen.height * cc.view._devicePixelRatio)
                    };
                    !this._gfxDevice.initialize(opts) && useWebGL2 && (this._gfxDevice = new cc.WebGLGFXDevice(), 
                    this._gfxDevice.initialize(opts));
                }
                if (!this._gfxDevice) return console.error("can not support canvas rendering in 3D"), 
                void (this.renderType = Game.RENDER_TYPE_CANVAS);
                this.canvas.oncontextmenu = function() {
                    if (!cc._isContextMenuEnable) return !1;
                }, this._rendererInitialized = !0;
            }
        }
    }, {
        key: "_initEvents",
        value: function _initEvents() {
            var hiddenPropName, win = window;
            this.config.registerSystemEvent && inputManager.registerSystemEvent(this.canvas), 
            void 0 !== document.hidden ? hiddenPropName = "hidden" : void 0 !== document.mozHidden ? hiddenPropName = "mozHidden" : void 0 !== document.msHidden ? hiddenPropName = "msHidden" : void 0 !== document.webkitHidden && (hiddenPropName = "webkitHidden");
            var hidden = !1;
            function onHidden() {
                hidden || (hidden = !0, cc.game.emit(Game.EVENT_HIDE));
            }
            function onShown() {
                hidden && (hidden = !1, cc.game.emit(Game.EVENT_SHOW));
            }
            if (hiddenPropName) for (var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ], i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], function(event) {
                var visible = document[hiddenPropName];
                (visible = visible || event.hidden) ? onHidden() : onShown();
            }); else win.addEventListener("blur", onHidden), win.addEventListener("focus", onShown);
            navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown), "onpageshow" in window && "onpagehide" in window && (win.addEventListener("pagehide", onHidden), 
            win.addEventListener("pageshow", onShown), document.addEventListener("pagehide", onHidden), 
            document.addEventListener("pageshow", onShown)), this.on(Game.EVENT_HIDE, function() {
                cc.game.pause();
            }), this.on(Game.EVENT_SHOW, function() {
                cc.game.resume();
            });
        }
    } ]), Game;
}();

Game.EVENT_HIDE = "game_on_hide", Game.EVENT_SHOW = "game_on_show", Game.EVENT_GAME_INITED = "game_inited", 
Game.EVENT_ENGINE_INITED = "engine_inited", Game.EVENT_RENDERER_INITED = "engine_inited", 
Game.RENDER_TYPE_CANVAS = 0, Game.RENDER_TYPE_WEBGL = 1, Game.RENDER_TYPE_OPENGL = 2;

var game = new Game();

cc.Game = Game, cc.game = game;

var _currentFrame = 0, __BrowserGetter = new (function() {
    function BrowserGetter() {
        _classCallCheck(this, BrowserGetter), this.html = void 0, this.meta = {
            width: "device-width"
        }, this.adaptationType = cc.sys.browserType;
    }
    return _createClass(BrowserGetter, [ {
        key: "init",
        value: function init() {
            this.html = document.getElementsByTagName("html")[0];
        }
    }, {
        key: "availWidth",
        value: function availWidth(frame) {
            return cc.sys.isMobile || !frame || frame === this.html ? window.innerWidth : frame.clientWidth;
        }
    }, {
        key: "availHeight",
        value: function availHeight(frame) {
            return cc.sys.isMobile || !frame || frame === this.html ? window.innerHeight : frame.clientHeight;
        }
    } ]), BrowserGetter;
}())();

switch (cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI), 
__BrowserGetter.adaptationType) {
  case cc.sys.BROWSER_TYPE_SAFARI:
    __BrowserGetter.meta["minimal-ui"] = "true";

  case cc.sys.BROWSER_TYPE_SOUGOU:
  case cc.sys.BROWSER_TYPE_WECHAT_GAME:
    __BrowserGetter.availWidth = function() {
        return window.innerWidth;
    }, __BrowserGetter.availHeight = function() {
        return window.innerHeight;
    };
    break;

  case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
    var sharedCanvas = window.sharedCanvas || wx.getSharedCanvas();
    __BrowserGetter.availWidth = function() {
        return sharedCanvas.width;
    }, __BrowserGetter.availHeight = function() {
        return sharedCanvas.height;
    };
}

var _scissorRect = null, View = function(_EventTarget) {
    function View() {
        var _this;
        _classCallCheck(this, View), (_this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this)))._frameSize = void 0, 
        _this._designResolutionSize = void 0, _this._originalDesignResolutionSize = void 0, 
        _this._scaleX = void 0, _this._scaleY = void 0, _this._viewportRect = void 0, _this._visibleRect = void 0, 
        _this._autoFullScreen = void 0, _this._devicePixelRatio = void 0, _this._retinaEnabled = void 0, 
        _this._resizeCallback = void 0, _this._resizing = void 0, _this._resizeWithBrowserSize = void 0, 
        _this._orientationChanging = void 0, _this._isRotated = void 0, _this._orientation = void 0, 
        _this._isAdjustViewport = void 0, _this._antiAliasEnabled = void 0, _this._resolutionPolicy = void 0, 
        _this._rpExactFit = void 0, _this._rpShowAll = void 0, _this._rpNoBorder = void 0, 
        _this._rpFixedHeight = void 0, _this._rpFixedWidth = void 0;
        _assertThisInitialized(_this);
        var _strategyer = ContainerStrategy, _strategy = ContentStrategy;
        return _this._frameSize = new Size(0, 0), _this._designResolutionSize = new Size(0, 0), 
        _this._originalDesignResolutionSize = new Size(0, 0), _this._scaleX = 1, _this._scaleY = 1, 
        _this._viewportRect = new Rect(0, 0, 0, 0), _this._visibleRect = new Rect(0, 0, 0, 0), 
        _this._autoFullScreen = !1, _this._devicePixelRatio = 1, _this._retinaEnabled = !1, 
        _this._resizeCallback = null, _this._resizing = !1, _this._resizeWithBrowserSize = !1, 
        _this._orientationChanging = !0, _this._isRotated = !1, _this._orientation = cc.macro.ORIENTATION_AUTO, 
        _this._isAdjustViewport = !0, _this._antiAliasEnabled = !1, _this._resolutionPolicy = null, 
        _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT), 
        _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL), 
        _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER), 
        _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT), 
        _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH), 
        cc.game.once(Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(View, EventTarget), _createClass(View, [ {
        key: "init",
        value: function init() {
            __BrowserGetter.init(), this._initFrameSize(), this.enableAntiAlias(!0);
            var w = cc.game.canvas.width, h = cc.game.canvas.height;
            this._designResolutionSize.width = w, this._designResolutionSize.height = h, this._originalDesignResolutionSize.width = w, 
            this._originalDesignResolutionSize.height = h, this._viewportRect.width = w, this._viewportRect.height = h, 
            this._visibleRect.width = w, this._visibleRect.height = h, cc.winSize.width = this._visibleRect.width, 
            cc.winSize.height = this._visibleRect.height, cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        }
    }, {
        key: "resizeWithBrowserSize",
        value: function resizeWithBrowserSize(enabled) {
            enabled ? this._resizeWithBrowserSize || (this._resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), 
            window.addEventListener("orientationchange", this._orientationChange)) : this._resizeWithBrowserSize && (this._resizeWithBrowserSize = !1, 
            window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._orientationChange));
        }
    }, {
        key: "setResizeCallback",
        value: function setResizeCallback(callback) {
            "function" != typeof callback && null != callback || (this._resizeCallback = callback);
        }
    }, {
        key: "setOrientation",
        value: function setOrientation(orientation) {
            (orientation &= cc.macro.ORIENTATION_AUTO) && this._orientation !== orientation && (this._orientation = orientation);
        }
    }, {
        key: "adjustViewportMeta",
        value: function adjustViewportMeta(enabled) {
            this._isAdjustViewport = enabled;
        }
    }, {
        key: "enableRetina",
        value: function enableRetina(enabled) {
            this._retinaEnabled = !!enabled;
        }
    }, {
        key: "isRetinaEnabled",
        value: function isRetinaEnabled() {
            return this._retinaEnabled;
        }
    }, {
        key: "enableAntiAlias",
        value: function enableAntiAlias(enabled) {
            if (this._antiAliasEnabled !== enabled) if (this._antiAliasEnabled = enabled, cc.game.renderType === Game.RENDER_TYPE_WEBGL) {
                var cache = cc.loader._cache;
                for (var key in cache) {
                    var item = cache[key], tex = item && item.content instanceof cc.Texture2D ? item.content : null;
                    if (tex) {
                        var Filter = cc.Texture2D.Filter;
                        enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
                    }
                }
            } else if (cc.game.renderType === Game.RENDER_TYPE_CANVAS) {
                var ctx = cc.game.canvas.getContext("2d");
                ctx.imageSmoothingEnabled = enabled, ctx.mozImageSmoothingEnabled = enabled;
            }
        }
    }, {
        key: "isAntiAliasEnabled",
        value: function isAntiAliasEnabled() {
            return this._antiAliasEnabled;
        }
    }, {
        key: "enableAutoFullScreen",
        value: function enableAutoFullScreen(enabled) {
            enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT ? (this._autoFullScreen = !0, 
            cc.screen.autoFullScreen(cc.game.frame)) : this._autoFullScreen = !1;
        }
    }, {
        key: "isAutoFullScreenEnabled",
        value: function isAutoFullScreenEnabled() {
            return this._autoFullScreen;
        }
    }, {
        key: "setCanvasSize",
        value: function setCanvasSize(width, height) {
            var canvas = cc.game.canvas, container = cc.game.container;
            canvas.width = width * this._devicePixelRatio, canvas.height = height * this._devicePixelRatio, 
            canvas.style.width = width + "px", canvas.style.height = height + "px", container.style.width = width + "px", 
            container.style.height = height + "px", this._resizeEvent();
        }
    }, {
        key: "getCanvasSize",
        value: function getCanvasSize() {
            return cc.size(cc.game.canvas.width, cc.game.canvas.height);
        }
    }, {
        key: "getFrameSize",
        value: function getFrameSize() {
            return cc.size(this._frameSize.width, this._frameSize.height);
        }
    }, {
        key: "setFrameSize",
        value: function setFrameSize(width, height) {
            this._frameSize.width = width, this._frameSize.height = height, cc.frame.style.width = width + "px", 
            cc.frame.style.height = height + "px", this._resizeEvent();
        }
    }, {
        key: "getVisibleSize",
        value: function getVisibleSize() {
            return cc.size(this._visibleRect.width, this._visibleRect.height);
        }
    }, {
        key: "getVisibleSizeInPixel",
        value: function getVisibleSizeInPixel() {
            return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
        }
    }, {
        key: "getVisibleOrigin",
        value: function getVisibleOrigin() {
            return cc.v2(this._visibleRect.x, this._visibleRect.y);
        }
    }, {
        key: "getVisibleOriginInPixel",
        value: function getVisibleOriginInPixel() {
            return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
        }
    }, {
        key: "getResolutionPolicy",
        value: function getResolutionPolicy() {
            return this._resolutionPolicy;
        }
    }, {
        key: "setResolutionPolicy",
        value: function setResolutionPolicy(resolutionPolicy) {
            var _t = this;
            if (resolutionPolicy instanceof ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
                var _locPolicy = ResolutionPolicy;
                resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit), 
                resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll), 
                resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder), 
                resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight), 
                resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
            }
        }
    }, {
        key: "setDesignResolutionSize",
        value: function setDesignResolutionSize(width, height, resolutionPolicy) {
            if (width > 0 || height > 0) {
                this.setResolutionPolicy(resolutionPolicy);
                var policy = this._resolutionPolicy;
                if (policy && policy.preApply(this), cc.sys.isMobile && this._adjustViewportMeta(), 
                this._orientationChanging = !0, this._resizing || this._initFrameSize(), policy) {
                    this._originalDesignResolutionSize.width = this._designResolutionSize.width = width, 
                    this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                    var result = policy.apply(this, this._designResolutionSize);
                    if (result.scale && 2 === result.scale.length && (this._scaleX = result.scale[0], 
                    this._scaleY = result.scale[1]), result.viewport) {
                        var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
                        vp.x = rv.x, vp.y = rv.y, vp.width = rv.width, vp.height = rv.height, vb.x = 0, 
                        vb.y = 0, vb.width = rv.width / this._scaleX, vb.height = rv.height / this._scaleY;
                    }
                    policy.postApply(this), cc.winSize.width = this._visibleRect.width, cc.winSize.height = this._visibleRect.height, 
                    cc.visibleRect && cc.visibleRect.init(this._visibleRect), this.emit("design-resolution-changed");
                } else cc.logID(2201);
            } else cc.logID(2200);
        }
    }, {
        key: "getDesignResolutionSize",
        value: function getDesignResolutionSize() {
            return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
        }
    }, {
        key: "setRealPixelResolution",
        value: function setRealPixelResolution(width, height, resolutionPolicy) {
            this._setViewportMeta({
                width: width
            }, !0), document.documentElement.style.width = width + "px", document.body.style.width = width + "px", 
            document.body.style.left = "0px", document.body.style.top = "0px", this.setDesignResolutionSize(width, height, resolutionPolicy);
        }
    }, {
        key: "setViewportInPoints",
        value: function setViewportInPoints(x, y, w, h) {
            var locScaleX = this._scaleX, locScaleY = this._scaleY;
            cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
        }
    }, {
        key: "setScissorInPoints",
        value: function setScissorInPoints(x, y, w, h) {
            var scaleX = this._scaleX, scaleY = this._scaleY, sx = Math.ceil(x * scaleX + this._viewportRect.x), sy = Math.ceil(y * scaleY + this._viewportRect.y), sw = Math.ceil(w * scaleX), sh = Math.ceil(h * scaleY), gl = cc.game._renderContext;
            if (!_scissorRect) {
                var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
            }
            _scissorRect.x === sx && _scissorRect.y === sy && _scissorRect.width === sw && _scissorRect.height === sh || (_scissorRect.x = sx, 
            _scissorRect.y = sy, _scissorRect.width = sw, _scissorRect.height = sh, gl.scissor(sx, sy, sw, sh));
        }
    }, {
        key: "isScissorEnabled",
        value: function isScissorEnabled() {
            var gl = cc.game._renderContext;
            return gl.isEnabled(gl.SCISSOR_TEST);
        }
    }, {
        key: "getScissorRect",
        value: function getScissorRect() {
            var gl = cc.game._renderContext;
            if (!_scissorRect) {
                var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                _scissorRect = new Rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
            }
            var scaleXFactor = 1 / this._scaleX, scaleYFactor = 1 / this._scaleY;
            return new Rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
        }
    }, {
        key: "getViewportRect",
        value: function getViewportRect() {
            return this._viewportRect;
        }
    }, {
        key: "getScaleX",
        value: function getScaleX() {
            return this._scaleX;
        }
    }, {
        key: "getScaleY",
        value: function getScaleY() {
            return this._scaleY;
        }
    }, {
        key: "getDevicePixelRatio",
        value: function getDevicePixelRatio() {
            return this._devicePixelRatio;
        }
    }, {
        key: "convertToLocationInView",
        value: function convertToLocationInView(tx, ty, relatedPos, out) {
            var result = out || cc.v2(), x = this._devicePixelRatio * (tx - relatedPos.left), y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
            return this._isRotated ? (result.x = cc.game.canvas.width - y, result.y = x) : (result.x = x, 
            result.y = y), result;
        }
    }, {
        key: "_resizeEvent",
        value: function _resizeEvent() {
            var frameId = cc.director.getTotalFrames();
            if (_currentFrame !== frameId) {
                var view;
                _currentFrame = frameId;
                var prevFrameW = (view = this.setDesignResolutionSize ? this : cc.view)._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
                if (cc.sys.isMobile) {
                    var containerStyle = cc.game.container.style, margin = containerStyle.margin;
                    containerStyle.margin = "0", containerStyle.display = "none", view._initFrameSize(), 
                    containerStyle.margin = margin, containerStyle.display = "block";
                } else view._initFrameSize();
                if (view._orientationChanging || view._isRotated !== prevRotated || view._frameSize.width !== prevFrameW || view._frameSize.height !== prevFrameH) {
                    var width = view._originalDesignResolutionSize.width, height = view._originalDesignResolutionSize.height;
                    view._resizing = !0, width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy), 
                    view._resizing = !1, view._resizeCallback && view._resizeCallback.call();
                }
            }
        }
    }, {
        key: "_orientationChange",
        value: function _orientationChange() {
            cc.view._orientationChanging = !0, cc.view._resizeEvent();
        }
    }, {
        key: "_initFrameSize",
        value: function _initFrameSize() {
            var locFrameSize = this._frameSize, w = __BrowserGetter.availWidth(cc.game.frame), h = __BrowserGetter.availHeight(cc.game.frame), isLandscape = w >= h;
            !cc.sys.isMobile || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT ? (locFrameSize.width = w, 
            locFrameSize.height = h, cc.game.container.style["-webkit-transform"] = "rotate(0deg)", 
            cc.game.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (locFrameSize.width = h, 
            locFrameSize.height = w, cc.game.container.style["-webkit-transform"] = "rotate(90deg)", 
            cc.game.container.style.transform = "rotate(90deg)", cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px", 
            cc.game.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0, cc.game.canvas.style["-webkit-transform"] = "translateZ(0px)", 
            cc.game.canvas.style.transform = "translateZ(0px)"), this._orientationChanging && setTimeout(function() {
                cc.view._orientationChanging = !1;
            }, 1e3);
        }
    }, {
        key: "_adjustSizeKeepCanvasSize",
        value: function _adjustSizeKeepCanvasSize() {
            var designWidth = this._originalDesignResolutionSize.width, designHeight = this._originalDesignResolutionSize.height;
            designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
        }
    }, {
        key: "_setViewportMeta",
        value: function _setViewportMeta(metas, overwrite) {
            var vp = document.getElementById("cocosMetaElement");
            vp && overwrite && document.head.removeChild(vp);
            var content, key, pattern, elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null;
            for (key in content = currentVP ? currentVP.content : "", (vp = vp || document.createElement("meta")).id = "cocosMetaElement", 
            vp.name = "viewport", vp.content = "", metas) -1 === content.indexOf(key) ? content += "," + key + "=" + metas[key] : overwrite && (pattern = new RegExp(key + "s*=s*[^,]+"), 
            content.replace(pattern, key + "=" + metas[key]));
            /^,/.test(content) && (content = content.substr(1)), vp.content = content, currentVP && (currentVP.content = content), 
            document.head.appendChild(vp);
        }
    }, {
        key: "_adjustViewportMeta",
        value: function _adjustViewportMeta() {
            this._isAdjustViewport && (this._setViewportMeta(__BrowserGetter.meta, !1), this._isAdjustViewport = !1);
        }
    }, {
        key: "_convertMouseToLocation",
        value: function _convertMouseToLocation(in_out_point, relatedPos) {
            in_out_point.x = this._devicePixelRatio * (in_out_point.x - relatedPos.left), in_out_point.y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y);
        }
    }, {
        key: "_convertPointWithScale",
        value: function _convertPointWithScale(point) {
            var viewport = this._viewportRect;
            point.x = (point.x - viewport.x) / this._scaleX, point.y = (point.y - viewport.y) / this._scaleY;
        }
    }, {
        key: "_convertTouchWidthScale",
        value: function _convertTouchWidthScale(selTouch) {
            var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY;
            selTouch._point.x = (selTouch._point.x - viewport.x) / scaleX, selTouch._point.y = (selTouch._point.y - viewport.y) / scaleY, 
            selTouch._prevPoint.x = (selTouch._prevPoint.x - viewport.x) / scaleX, selTouch._prevPoint.y = (selTouch._prevPoint.y - viewport.y) / scaleY;
        }
    }, {
        key: "_convertTouchesWithScale",
        value: function _convertTouchesWithScale(touches) {
            for (var selPoint, selPrePoint, viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, i = 0; i < touches.length; i++) {
                var selTouch = touches[i];
                selPoint = selTouch._point, selPrePoint = selTouch._prevPoint, selPoint.x = (selPoint.x - viewport.x) / scaleX, 
                selPoint.y = (selPoint.y - viewport.y) / scaleY, selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX, 
                selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
            }
        }
    } ]), View;
}(), ContainerStrategy = function() {
    function ContainerStrategy() {
        _classCallCheck(this, ContainerStrategy), this.name = "ContainerStrategy";
    }
    return _createClass(ContainerStrategy, [ {
        key: "preApply",
        value: function preApply(view) {}
    }, {
        key: "apply",
        value: function apply(view, designedResolution) {}
    }, {
        key: "postApply",
        value: function postApply(view) {}
    }, {
        key: "_setupContainer",
        value: function _setupContainer(view, w, h) {
            var locCanvas = cc.game.canvas, locContainer = cc.game.container;
            cc.sys.platform !== cc.sys.WECHAT_GAME && (cc.sys.os === cc.sys.OS_ANDROID && (document.body.style.width = (view._isRotated ? h : w) + "px", 
            document.body.style.height = (view._isRotated ? w : h) + "px"), locContainer.style.width = locCanvas.style.width = w + "px", 
            locContainer.style.height = locCanvas.style.height = h + "px");
            var devicePixelRatio = view._devicePixelRatio = 1;
            view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1)), 
            locCanvas.width = w * devicePixelRatio, locCanvas.height = h * devicePixelRatio;
        }
    }, {
        key: "_fixContainer",
        value: function _fixContainer() {
            document.body.insertBefore(cc.game.container, document.body.firstChild);
            var bs = document.body.style;
            bs.width = window.innerWidth + "px", bs.height = window.innerHeight + "px", bs.overflow = "hidden";
            var contStyle = cc.game.container.style;
            contStyle.position = "fixed", contStyle.left = contStyle.top = "0px", document.body.scrollTop = 0;
        }
    } ]), ContainerStrategy;
}();

ContainerStrategy.EQUAL_TO_FRAME = void 0, ContainerStrategy.PROPORTION_TO_FRAME = void 0;

var ContentStrategy = function() {
    function ContentStrategy() {
        _classCallCheck(this, ContentStrategy), this.name = "ContentStrategy", this._result = void 0, 
        this._result = {
            scale: [ 1, 1 ],
            viewport: null
        };
    }
    return _createClass(ContentStrategy, [ {
        key: "preApply",
        value: function preApply(view) {}
    }, {
        key: "apply",
        value: function apply(view, designedResolution) {
            return {
                scale: [ 1, 1 ]
            };
        }
    }, {
        key: "postApply",
        value: function postApply(view) {}
    }, {
        key: "_buildResult",
        value: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
            Math.abs(containerW - contentW) < 2 && (contentW = containerW), Math.abs(containerH - contentH) < 2 && (contentH = containerH);
            var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
            return cc.game.renderType, Game.RENDER_TYPE_CANVAS, this._result.scale = [ scaleX, scaleY ], 
            this._result.viewport = viewport, this._result;
        }
    } ]), ContentStrategy;
}();

ContentStrategy.EXACT_FIT = void 0, ContentStrategy.SHOW_ALL = void 0, ContentStrategy.NO_BORDER = void 0, 
ContentStrategy.FIXED_HEIGHT = void 0, ContentStrategy.FIXED_WIDTH = void 0, function() {
    var EqualToFrame = function(_ContainerStrategy) {
        function EqualToFrame() {
            var _getPrototypeOf2, _this2;
            _classCallCheck(this, EqualToFrame);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EqualToFrame)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).name = "EqualToFrame", 
            _this2;
        }
        return _inherits(EqualToFrame, ContainerStrategy), _createClass(EqualToFrame, [ {
            key: "apply",
            value: function apply(view) {
                var frameH = view._frameSize.height, containerStyle = cc.game.container.style;
                this._setupContainer(view, view._frameSize.width, view._frameSize.height), view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                containerStyle.padding = "0px";
            }
        } ]), EqualToFrame;
    }(), ProportionalToFrame = function(_ContainerStrategy2) {
        function ProportionalToFrame() {
            var _getPrototypeOf3, _this3;
            _classCallCheck(this, ProportionalToFrame);
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
            return (_this3 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ProportionalToFrame)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).name = "ProportionalToFrame", 
            _this3;
        }
        return _inherits(ProportionalToFrame, ContainerStrategy), _createClass(ProportionalToFrame, [ {
            key: "apply",
            value: function apply(view, designedResolution) {
                var containerW, containerH, frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH;
                scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
                containerH = frameH);
                var offx = Math.round((frameW - containerW) / 2), offy = Math.round((frameH - containerH) / 2);
                containerW = frameW - 2 * offx, containerH = frameH - 2 * offy, this._setupContainer(view, containerW, containerH), 
                view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                containerStyle.paddingLeft = offx + "px", containerStyle.paddingRight = offx + "px", 
                containerStyle.paddingTop = offy + "px", containerStyle.paddingBottom = offy + "px";
            }
        } ]), ProportionalToFrame;
    }();
    ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame(), ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
    var ExactFit = function(_ContentStrategy) {
        function ExactFit() {
            var _getPrototypeOf4, _this4;
            _classCallCheck(this, ExactFit);
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
            return (_this4 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(ExactFit)).call.apply(_getPrototypeOf4, [ this ].concat(args)))).name = "ExactFit", 
            _this4;
        }
        return _inherits(ExactFit, ContentStrategy), _createClass(ExactFit, [ {
            key: "apply",
            value: function apply(view, designedResolution) {
                var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
            }
        } ]), ExactFit;
    }(), ShowAll = function(_ContentStrategy2) {
        function ShowAll() {
            var _getPrototypeOf5, _this5;
            _classCallCheck(this, ShowAll);
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
            return (_this5 = _possibleConstructorReturn(this, (_getPrototypeOf5 = _getPrototypeOf(ShowAll)).call.apply(_getPrototypeOf5, [ this ].concat(args)))).name = "ShowAll", 
            _this5;
        }
        return _inherits(ShowAll, ContentStrategy), _createClass(ShowAll, [ {
            key: "apply",
            value: function apply(view, designedResolution) {
                var contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0;
                return scaleX < scaleY ? (contentW = containerW, contentH = designH * (scale = scaleX)) : (contentW = designW * (scale = scaleY), 
                contentH = containerH), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), ShowAll;
    }(), NoBorder = function(_ContentStrategy3) {
        function NoBorder() {
            var _getPrototypeOf6, _this6;
            _classCallCheck(this, NoBorder);
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
            return (_this6 = _possibleConstructorReturn(this, (_getPrototypeOf6 = _getPrototypeOf(NoBorder)).call.apply(_getPrototypeOf6, [ this ].concat(args)))).name = "NoBorder", 
            _this6;
        }
        return _inherits(NoBorder, ContentStrategy), _createClass(NoBorder, [ {
            key: "apply",
            value: function apply(view, designedResolution) {
                var scale, contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH;
                return scaleX < scaleY ? (contentW = designW * (scale = scaleY), contentH = containerH) : (contentW = containerW, 
                contentH = designH * (scale = scaleX)), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), NoBorder;
    }(), FixedHeight = function(_ContentStrategy4) {
        function FixedHeight() {
            var _getPrototypeOf7, _this7;
            _classCallCheck(this, FixedHeight);
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
            return (_this7 = _possibleConstructorReturn(this, (_getPrototypeOf7 = _getPrototypeOf(FixedHeight)).call.apply(_getPrototypeOf7, [ this ].concat(args)))).name = "FixedHeight", 
            _this7;
        }
        return _inherits(FixedHeight, ContentStrategy), _createClass(FixedHeight, [ {
            key: "apply",
            value: function apply(view, designedResolution) {
                var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerH / designedResolution.height, contentW = containerW, contentH = containerH;
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), FixedHeight;
    }(), FixedWidth = function(_ContentStrategy5) {
        function FixedWidth() {
            var _getPrototypeOf8, _this8;
            _classCallCheck(this, FixedWidth);
            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
            return (_this8 = _possibleConstructorReturn(this, (_getPrototypeOf8 = _getPrototypeOf(FixedWidth)).call.apply(_getPrototypeOf8, [ this ].concat(args)))).name = "FixedWidth", 
            _this8;
        }
        return _inherits(FixedWidth, ContentStrategy), _createClass(FixedWidth, [ {
            key: "apply",
            value: function apply(view, designedResolution) {
                var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerW / designedResolution.width, contentW = containerW, contentH = containerH;
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), FixedWidth;
    }();
    ContentStrategy.EXACT_FIT = new ExactFit(), ContentStrategy.SHOW_ALL = new ShowAll(), 
    ContentStrategy.NO_BORDER = new NoBorder(), ContentStrategy.FIXED_HEIGHT = new FixedHeight(), 
    ContentStrategy.FIXED_WIDTH = new FixedWidth();
}();

var ResolutionPolicy = function() {
    function ResolutionPolicy(containerStg, contentStg) {
        _classCallCheck(this, ResolutionPolicy), this.name = "ResolutionPolicy", this._containerStrategy = void 0, 
        this._contentStrategy = void 0, this._containerStrategy = null, this._contentStrategy = null, 
        this.setContainerStrategy(containerStg), this.setContentStrategy(contentStg);
    }
    return _createClass(ResolutionPolicy, [ {
        key: "preApply",
        value: function preApply(view) {
            this._containerStrategy.preApply(view), this._contentStrategy.preApply(view);
        }
    }, {
        key: "apply",
        value: function apply(view, designedResolution) {
            return this._containerStrategy.apply(view, designedResolution), this._contentStrategy.apply(view, designedResolution);
        }
    }, {
        key: "postApply",
        value: function postApply(view) {
            this._containerStrategy.postApply(view), this._contentStrategy.postApply(view);
        }
    }, {
        key: "setContainerStrategy",
        value: function setContainerStrategy(containerStg) {
            containerStg instanceof ContainerStrategy && (this._containerStrategy = containerStg);
        }
    }, {
        key: "setContentStrategy",
        value: function setContentStrategy(contentStg) {
            contentStg instanceof ContentStrategy && (this._contentStrategy = contentStg);
        }
    }, {
        key: "canvasSize",
        get: function get() {
            return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
        }
    } ]), ResolutionPolicy;
}();

ResolutionPolicy.EXACT_FIT = void 0, ResolutionPolicy.SHOW_ALL = void 0, ResolutionPolicy.NO_BORDER = void 0, 
ResolutionPolicy.FIXED_HEIGHT = void 0, ResolutionPolicy.FIXED_WIDTH = void 0, ResolutionPolicy.UNKNOWN = void 0, 
ResolutionPolicy.ContainerStrategy = void 0, ResolutionPolicy.ContentStrategy = void 0, 
ResolutionPolicy.EXACT_FIT = 0, ResolutionPolicy.NO_BORDER = 1, ResolutionPolicy.SHOW_ALL = 2, 
ResolutionPolicy.FIXED_HEIGHT = 3, ResolutionPolicy.FIXED_WIDTH = 4, ResolutionPolicy.UNKNOWN = 5, 
ResolutionPolicy.ContainerStrategy = ContainerStrategy, ResolutionPolicy.ContentStrategy = ContentStrategy, 
cc.ResolutionPolicy = ResolutionPolicy;

cc.view = new View();

cc.winSize = cc.v2();

var screen$1 = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
    init: function init() {
        this._fn = {};
        var i, l, val, valL, map = this._fnMap;
        for (i = 0, l = map.length; i < l; i++) if ((val = map[i]) && void 0 !== document[val[1]]) {
            for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
            break;
        }
        this._supportsFullScreen = void 0 !== this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
    },
    fullScreen: function fullScreen() {
        return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
    },
    requestFullScreen: function requestFullScreen(element, onFullScreenChange) {
        if (this._supportsFullScreen) {
            if (element = element || document.documentElement, onFullScreenChange) {
                var eventName = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange), 
                this._preOnFullScreenChange = onFullScreenChange, document.addEventListener(eventName, onFullScreenChange, !1);
            }
            return element[this._fn.requestFullscreen]();
        }
    },
    exitFullScreen: function exitFullScreen() {
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
    },
    autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
        element = element || document.body;
        var touchTarget = cc.game.canvas || element, theScreen = this;
        this.requestFullScreen(element, onFullScreenChange), touchTarget.addEventListener(this._touchEvent, function callback() {
            touchTarget.removeEventListener(theScreen._touchEvent, callback), theScreen.requestFullScreen(element, onFullScreenChange);
        });
    }
};

screen$1.init(), cc.screen = screen$1;

var idGenerator$3 = new IDGenerator("Scheduler"), ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
    _classCallCheck(this, ListEntry), this.target = void 0, this.priority = void 0, 
    this.paused = void 0, this.markedForDeletion = void 0, this.target = target, this.priority = priority, 
    this.paused = paused, this.markedForDeletion = markedForDeletion;
};

ListEntry.get = function(target, priority, paused, markedForDeletion) {
    var result = ListEntry._listEntries.pop();
    return result ? (result.target = target, result.priority = priority, result.paused = paused, 
    result.markedForDeletion = markedForDeletion) : result = new ListEntry(target, priority, paused, markedForDeletion), 
    result;
}, ListEntry.put = function(entry) {
    ListEntry._listEntries.length < 20 && (entry.target = null, ListEntry._listEntries.push(entry));
}, ListEntry._listEntries = [];

var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
    _classCallCheck(this, HashUpdateEntry), this.list = void 0, this.entry = void 0, 
    this.target = void 0, this.callback = void 0, this.list = list, this.entry = entry, 
    this.target = target, this.callback = callback;
};

HashUpdateEntry.get = function(list, entry, target, callback) {
    var result = HashUpdateEntry._hashUpdateEntries.pop();
    return result ? (result.list = list, result.entry = entry, result.target = target, 
    result.callback = callback) : result = new HashUpdateEntry(list, entry, target, callback), 
    result;
}, HashUpdateEntry.put = function(entry) {
    HashUpdateEntry._hashUpdateEntries.length < 20 && (entry.list = entry.entry = entry.target = entry.callback = null, 
    HashUpdateEntry._hashUpdateEntries.push(entry));
}, HashUpdateEntry._hashUpdateEntries = [];

var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
    _classCallCheck(this, HashTimerEntry), this.timers = void 0, this.target = void 0, 
    this.timerIndex = void 0, this.currentTimer = void 0, this.currentTimerSalvaged = void 0, 
    this.paused = void 0, this.timers = timers, this.target = target, this.timerIndex = timerIndex, 
    this.currentTimer = currentTimer, this.currentTimerSalvaged = currentTimerSalvaged, 
    this.paused = paused;
};

HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
    var result = HashTimerEntry._hashTimerEntries.pop();
    return result ? (result.timers = timers, result.target = target, result.timerIndex = timerIndex, 
    result.currentTimer = currentTimer, result.currentTimerSalvaged = currentTimerSalvaged, 
    result.paused = paused) : result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused), 
    result;
}, HashTimerEntry.put = function(entry) {
    HashTimerEntry._hashTimerEntries.length < 20 && (entry.timers = entry.target = entry.currentTimer = null, 
    HashTimerEntry._hashTimerEntries.push(entry));
}, HashTimerEntry._hashTimerEntries = [];

var CallbackTimer = function() {
    function CallbackTimer() {
        _classCallCheck(this, CallbackTimer), this._lock = void 0, this._scheduler = void 0, 
        this._elapsed = void 0, this._runForever = void 0, this._useDelay = void 0, this._timesExecuted = void 0, 
        this._repeat = void 0, this._delay = void 0, this._interval = void 0, this._target = void 0, 
        this._callback = void 0, this._lock = !1, this._scheduler = null, this._elapsed = -1, 
        this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, 
        this._delay = 0, this._interval = 0, this._target = null, this._callback = null;
    }
    return _createClass(CallbackTimer, [ {
        key: "initWithCallback",
        value: function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
            return this._lock = !1, this._scheduler = scheduler, this._target = target, this._callback = callback, 
            this._elapsed = -1, this._interval = seconds, this._delay = delay, this._useDelay = this._delay > 0, 
            this._repeat = repeat, this._runForever = this._repeat === cc.macro.REPEAT_FOREVER, 
            !0;
        }
    }, {
        key: "getInterval",
        value: function getInterval() {
            return this._interval;
        }
    }, {
        key: "setInterval",
        value: function setInterval(interval) {
            this._interval = interval;
        }
    }, {
        key: "update",
        value: function update(dt) {
            -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += dt, 
            this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), 
            this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), 
            this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), 
            this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
        }
    }, {
        key: "getCallback",
        value: function getCallback() {
            return this._callback;
        }
    }, {
        key: "trigger",
        value: function trigger() {
            this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), 
            this._lock = !1);
        }
    }, {
        key: "cancel",
        value: function cancel() {
            this._scheduler.unschedule(this._callback, this._target);
        }
    } ]), CallbackTimer;
}();

CallbackTimer._timers = [], CallbackTimer.get = function() {
    return CallbackTimer._timers.pop() || new CallbackTimer();
}, CallbackTimer.put = function(timer) {
    CallbackTimer._timers.length < 20 && !timer._lock && (timer._scheduler = timer._target = timer._callback = null, 
    CallbackTimer._timers.push(timer));
};

var Scheduler = function() {
    function Scheduler() {
        _classCallCheck(this, Scheduler), this._timeScale = void 0, this._updatesNegList = void 0, 
        this._updates0List = void 0, this._updatesPosList = void 0, this._hashForUpdates = void 0, 
        this._hashForTimers = void 0, this._currentTarget = void 0, this._currentTargetSalvaged = void 0, 
        this._updateHashLocked = void 0, this._arrayForTimers = void 0, this._timeScale = 1, 
        this._updatesNegList = [], this._updates0List = [], this._updatesPosList = [], this._hashForUpdates = createMap(!0), 
        this._hashForTimers = createMap(!0), this._currentTarget = null, this._currentTargetSalvaged = !1, 
        this._updateHashLocked = !1, this._arrayForTimers = [];
    }
    return _createClass(Scheduler, [ {
        key: "enableForTarget",
        value: function enableForTarget(target) {
            target._id || (target.__instanceId ? cc.warnID(1513) : target._id = idGenerator$3.getNewId());
        }
    }, {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
            this._timeScale = timeScale;
        }
    }, {
        key: "getTimeScale",
        value: function getTimeScale() {
            return this._timeScale;
        }
    }, {
        key: "update",
        value: function update(dt) {
            var i, list, len, entry, elt;
            for (this._updateHashLocked = !0, 1 !== this._timeScale && (dt *= this._timeScale), 
            i = 0, len = (list = this._updatesNegList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
            for (i = 0, len = (list = this._updates0List).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
            for (i = 0, len = (list = this._updatesPosList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
            var arr = this._arrayForTimers;
            for (i = 0; i < arr.length; i++) {
                if (elt = arr[i], this._currentTarget = elt, this._currentTargetSalvaged = !1, !elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) elt.currentTimer = elt.timers[elt.timerIndex], 
                elt.currentTimerSalvaged = !1, elt.currentTimer.update(dt), elt.currentTimer = null;
                this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), 
                --i);
            }
            for (i = 0, list = this._updatesNegList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
            for (i = 0, list = this._updates0List; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
            for (i = 0, list = this._updatesPosList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
            this._updateHashLocked = !1, this._currentTarget = null;
        }
    }, {
        key: "schedule",
        value: function schedule(callback, target, interval, repeat, delay, paused) {
            if ("function" != typeof callback) {
                var tmp = callback;
                callback = target, target = tmp;
            }
            4 !== arguments.length && 5 !== arguments.length || (paused = !!repeat, repeat = cc.macro.REPEAT_FOREVER, 
            delay = 0), cc.assertID(target, 1502);
            var targetId = target._id;
            targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
            var timer, i, element = this._hashForTimers[targetId];
            if (element ? element.paused !== paused && cc.warnID(1511) : (element = HashTimerEntry.get(null, target, 0, null, null, paused), 
            this._arrayForTimers.push(element), this._hashForTimers[targetId] = element), null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) if ((timer = element.timers[i]) && callback === timer._callback) return cc.logID(1507, timer.getInterval(), interval), 
            void (timer._interval = interval);
            (timer = CallbackTimer.get()).initWithCallback(this, callback, target, interval, repeat, delay), 
            element.timers.push(timer), this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1);
        }
    }, {
        key: "scheduleUpdate",
        value: function scheduleUpdate(target, priority, paused) {
            var targetId = target._id;
            targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
            var hashElement = this._hashForUpdates[targetId];
            if (hashElement && hashElement.entry) {
                if (hashElement.entry.priority === priority) return hashElement.entry.markedForDeletion = !1, 
                void (hashElement.entry.paused = paused);
                if (this._updateHashLocked) return cc.logID(1506), hashElement.entry.markedForDeletion = !1, 
                void (hashElement.entry.paused = paused);
                this.unscheduleUpdate(target);
            }
            var ppList, listElement = ListEntry.get(target, priority, paused, !1);
            0 === priority ? (ppList = this._updates0List, this._appendIn(ppList, listElement)) : (ppList = priority < 0 ? this._updatesNegList : this._updatesPosList, 
            this._priorityIn(ppList, listElement, priority)), this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
        }
    }, {
        key: "unschedule",
        value: function unschedule(callback, target) {
            if (target && callback) {
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForTimers[targetId];
                if (element) for (var timers = element.timers, i = 0, li = timers.length; i < li; i++) {
                    var timer = timers[i];
                    if (callback === timer._callback) return timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = !0), 
                    timers.splice(i, 1), CallbackTimer.put(timer), element.timerIndex >= i && element.timerIndex--, 
                    void (0 === timers.length && (this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element)));
                }
            }
        }
    }, {
        key: "unscheduleUpdate",
        value: function unscheduleUpdate(target) {
            if (target) {
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForUpdates[targetId];
                element && (this._updateHashLocked ? element.entry.markedForDeletion = !0 : this._removeUpdateFromHash(element.entry));
            }
        }
    }, {
        key: "unscheduleAllForTarget",
        value: function unscheduleAllForTarget(target) {
            if (target) {
                var targetId = target._id;
                targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
                var element = this._hashForTimers[targetId];
                if (element) {
                    var timers = element.timers;
                    timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = !0);
                    for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
                    timers.length = 0, this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element);
                }
                this.unscheduleUpdate(target);
            }
        }
    }, {
        key: "unscheduleAll",
        value: function unscheduleAll() {
            this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
        }
    }, {
        key: "unscheduleAllWithMinPriority",
        value: function unscheduleAllWithMinPriority(minPriority) {
            var i, element, entry, arr = this._arrayForTimers;
            for (i = arr.length - 1; i >= 0; i--) element = arr[i], this.unscheduleAllForTarget(element.target);
            var temp_length = 0;
            if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) temp_length = this._updatesNegList.length, 
            (entry = this._updatesNegList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
            temp_length === this._updatesNegList.length && i++;
            if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) temp_length = this._updates0List.length, 
            (entry = this._updates0List[i]) && this.unscheduleUpdate(entry.target), temp_length === this._updates0List.length && i++;
            for (i = 0; i < this._updatesPosList.length; ) temp_length = this._updatesPosList.length, 
            (entry = this._updatesPosList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
            temp_length === this._updatesPosList.length && i++;
        }
    }, {
        key: "isScheduled",
        value: function isScheduled(callback, target) {
            cc.assertID(callback, 1508), cc.assertID(target, 1509);
            var targetId = target._id;
            targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
            var element = this._hashForTimers[targetId];
            if (!element) return !1;
            if (null == element.timers) return !1;
            for (var timers = element.timers, i = 0; i < timers.length; ++i) {
                if (callback === timers[i]._callback) return !0;
            }
            return !1;
        }
    }, {
        key: "pauseAllTargets",
        value: function pauseAllTargets() {
            return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
        }
    }, {
        key: "pauseAllTargetsWithMinPriority",
        value: function pauseAllTargetsWithMinPriority(minPriority) {
            var element, i, li, entry, idsWithSelectors = [], locArrayForTimers = this._arrayForTimers;
            for (i = 0, li = locArrayForTimers.length; i < li; i++) (element = locArrayForTimers[i]) && (element.paused = !0, 
            idsWithSelectors.push(element.target));
            if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) (entry = this._updatesNegList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
            idsWithSelectors.push(entry.target));
            if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) (entry = this._updates0List[i]) && (entry.paused = !0, 
            idsWithSelectors.push(entry.target));
            for (i = 0; i < this._updatesPosList.length; i++) (entry = this._updatesPosList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
            idsWithSelectors.push(entry.target));
            return idsWithSelectors;
        }
    }, {
        key: "resumeTargets",
        value: function resumeTargets(targetsToResume) {
            if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
        }
    }, {
        key: "pauseTarget",
        value: function pauseTarget(target) {
            cc.assertID(target, 1503);
            var targetId = target._id;
            targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
            var element = this._hashForTimers[targetId];
            element && (element.paused = !0);
            var elementUpdate = this._hashForUpdates[targetId];
            elementUpdate && (elementUpdate.entry.paused = !0);
        }
    }, {
        key: "resumeTarget",
        value: function resumeTarget(target) {
            cc.assertID(target, 1504);
            var targetId = target._id;
            targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
            var element = this._hashForTimers[targetId];
            element && (element.paused = !1);
            var elementUpdate = this._hashForUpdates[targetId];
            elementUpdate && (elementUpdate.entry.paused = !1);
        }
    }, {
        key: "isTargetPaused",
        value: function isTargetPaused(target) {
            cc.assertID(target, 1505);
            var targetId = target._id;
            targetId || (target.__instanceId ? (cc.warnID(1513), targetId = target._id = target.__instanceId) : cc.errorID(1510));
            var element = this._hashForTimers[targetId];
            if (element) return element.paused;
            var elementUpdate = this._hashForUpdates[targetId];
            return !!elementUpdate && elementUpdate.entry.paused;
        }
    }, {
        key: "_removeHashElement",
        value: function _removeHashElement(element) {
            delete this._hashForTimers[element.target._id];
            for (var arr = this._arrayForTimers, i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
                arr.splice(i, 1);
                break;
            }
            HashTimerEntry.put(element);
        }
    }, {
        key: "_removeUpdateFromHash",
        value: function _removeUpdateFromHash(entry) {
            var targetId = entry.target._id, element = this._hashForUpdates[targetId];
            if (element) {
                for (var list = element.list, listEntry = element.entry, i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
                    list.splice(i, 1);
                    break;
                }
                delete this._hashForUpdates[targetId], ListEntry.put(listEntry), HashUpdateEntry.put(element);
            }
        }
    }, {
        key: "_priorityIn",
        value: function _priorityIn(ppList, listElement, priority) {
            for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) return void ppList.splice(i, 0, listElement);
            ppList.push(listElement);
        }
    }, {
        key: "_appendIn",
        value: function _appendIn(ppList, listElement) {
            ppList.push(listElement);
        }
    } ]), Scheduler;
}();

Scheduler.PRIORITY_SYSTEM = 1 << 31, Scheduler.PRIORITY_NON_SYSTEM = Scheduler.PRIORITY_SYSTEM + 1, 
cc.Scheduler = Scheduler;

var DEFAULT_MIN_MERGE = 32, DEFAULT_MIN_GALLOPING = 7, DEFAULT_TMP_STORAGE_LENGTH = 256, POWERS_OF_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];

function log10$1(x) {
    return x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
}

function alphabeticalCompare(a, b) {
    if (a === b) return 0;
    if (~~a === a && ~~b === b) {
        if (0 === a || 0 === b) return a < b ? -1 : 1;
        if (a < 0 || b < 0) {
            if (b >= 0) return -1;
            if (a >= 0) return 1;
            a = -a, b = -b;
        }
        var al = log10$1(a), bl = log10$1(b), t = 0;
        return al < bl ? (a *= POWERS_OF_TEN[bl - al - 1], b /= 10, t = -1) : al > bl && (b *= POWERS_OF_TEN[al - bl - 1], 
        a /= 10, t = 1), a === b ? t : a < b ? -1 : 1;
    }
    var aStr = String(a), bStr = String(b);
    return aStr === bStr ? 0 : aStr < bStr ? -1 : 1;
}

function makeAscendingRun(array, lo, hi, compare) {
    var runHi = lo + 1;
    if (runHi === hi) return 1;
    if (compare(array[runHi++], array[lo]) < 0) {
        for (;runHi < hi && compare(array[runHi], array[runHi - 1]) < 0; ) runHi++;
        !function reverseRun(array, lo, hi) {
            hi--;
            for (;lo < hi; ) {
                var t = array[lo];
                array[lo++] = array[hi], array[hi--] = t;
            }
        }(array, lo, runHi);
    } else for (;runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0; ) runHi++;
    return runHi - lo;
}

function binaryInsertionSort(array, lo, hi, start, compare) {
    for (start === lo && start++; start < hi; start++) {
        for (var pivot = array[start], left = lo, right = start; left < right; ) {
            var mid = left + right >>> 1;
            compare(pivot, array[mid]) < 0 ? right = mid : left = mid + 1;
        }
        var n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];

          case 2:
            array[left + 2] = array[left + 1];

          case 1:
            array[left + 1] = array[left];
            break;

          default:
            for (;n > 0; ) array[left + n] = array[left + n - 1], n--;
        }
        array[left] = pivot;
    }
}

function gallopLeft(value, array, start, length, hint, compare) {
    var lastOffset = 0, maxOffset = 0, offset = 1;
    if (compare(value, array[start + hint]) > 0) {
        for (maxOffset = length - hint; offset < maxOffset && compare(value, array[start + hint + offset]) > 0; ) lastOffset = offset, 
        (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
        offset > maxOffset && (offset = maxOffset), lastOffset += hint, offset += hint;
    } else {
        for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) <= 0; ) lastOffset = offset, 
        (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset, offset = hint - tmp;
    }
    for (lastOffset++; lastOffset < offset; ) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) > 0 ? lastOffset = m + 1 : offset = m;
    }
    return offset;
}

function gallopRight(value, array, start, length, hint, compare) {
    var lastOffset = 0, maxOffset = 0, offset = 1;
    if (compare(value, array[start + hint]) < 0) {
        for (maxOffset = hint + 1; offset < maxOffset && compare(value, array[start + hint - offset]) < 0; ) lastOffset = offset, 
        (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset, offset = hint - tmp;
    } else {
        for (maxOffset = length - hint; offset < maxOffset && compare(value, array[start + hint + offset]) >= 0; ) lastOffset = offset, 
        (offset = 1 + (offset << 1)) <= 0 && (offset = maxOffset);
        offset > maxOffset && (offset = maxOffset), lastOffset += hint, offset += hint;
    }
    for (lastOffset++; lastOffset < offset; ) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
    }
    return offset;
}

var TimSort = function() {
    function TimSort(array, compare) {
        _classCallCheck(this, TimSort), this.array = void 0, this.compare = void 0, this.minGallop = void 0, 
        this.length = void 0, this.tmpStorageLength = void 0, this.tmp = void 0, this.stackLength = void 0, 
        this.runStart = void 0, this.runLength = void 0, this.stackSize = void 0, this.array = array, 
        this.compare = compare, this.minGallop = DEFAULT_MIN_GALLOPING, this.length = array.length, 
        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH, this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH && (this.tmpStorageLength = this.length >>> 1), 
        this.tmp = new Array(this.tmpStorageLength), this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40, 
        this.runStart = new Array(this.stackLength), this.runLength = new Array(this.stackLength), 
        this.stackSize = 0;
    }
    return _createClass(TimSort, [ {
        key: "pushRun",
        value: function pushRun(runStart, runLength) {
            this.runStart[this.stackSize] = runStart, this.runLength[this.stackSize] = runLength, 
            this.stackSize += 1;
        }
    }, {
        key: "mergeRuns",
        value: function mergeRuns() {
            for (;this.stackSize > 1; ) {
                var n = this.stackSize - 2;
                if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) this.runLength[n - 1] < this.runLength[n + 1] && n--; else if (this.runLength[n] > this.runLength[n + 1]) break;
                this.mergeAt(n);
            }
        }
    }, {
        key: "forceMergeRuns",
        value: function forceMergeRuns() {
            for (;this.stackSize > 1; ) {
                var n = this.stackSize - 2;
                n > 0 && this.runLength[n - 1] < this.runLength[n + 1] && n--, this.mergeAt(n);
            }
        }
    }, {
        key: "mergeAt",
        value: function mergeAt(i) {
            var compare = this.compare, array = this.array, start1 = this.runStart[i], length1 = this.runLength[i], start2 = this.runStart[i + 1], length2 = this.runLength[i + 1];
            this.runLength[i] = length1 + length2, i === this.stackSize - 3 && (this.runStart[i + 1] = this.runStart[i + 2], 
            this.runLength[i + 1] = this.runLength[i + 2]), this.stackSize--;
            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
            start1 += k, 0 !== (length1 -= k) && 0 !== (length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)) && (length1 <= length2 ? this.mergeLow(start1, length1, start2, length2) : this.mergeHigh(start1, length1, start2, length2));
        }
    }, {
        key: "mergeLow",
        value: function mergeLow(start1, length1, start2, length2) {
            var compare = this.compare, array = this.array, tmp = this.tmp, i = 0;
            for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
            var cursor1 = 0, cursor2 = start2, dest = start1;
            if (array[dest++] = array[cursor2++], 0 != --length2) if (1 !== length1) {
                for (var minGallop = this.minGallop; ;) {
                    var count1 = 0, count2 = 0, exit = !1;
                    do {
                        if (compare(array[cursor2], tmp[cursor1]) < 0) {
                            if (array[dest++] = array[cursor2++], count2++, count1 = 0, 0 == --length2) {
                                exit = !0;
                                break;
                            }
                        } else if (array[dest++] = tmp[cursor1++], count1++, count2 = 0, 1 == --length1) {
                            exit = !0;
                            break;
                        }
                    } while ((count1 | count2) < minGallop);
                    if (exit) break;
                    do {
                        if (0 !== (count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare))) {
                            for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
                            if (dest += count1, cursor1 += count1, (length1 -= count1) <= 1) {
                                exit = !0;
                                break;
                            }
                        }
                        if (array[dest++] = array[cursor2++], 0 == --length2) {
                            exit = !0;
                            break;
                        }
                        if (0 !== (count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare))) {
                            for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
                            if (dest += count2, cursor2 += count2, 0 === (length2 -= count2)) {
                                exit = !0;
                                break;
                            }
                        }
                        if (array[dest++] = tmp[cursor1++], 1 == --length1) {
                            exit = !0;
                            break;
                        }
                        minGallop--;
                    } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
                    if (exit) break;
                    minGallop < 0 && (minGallop = 0), minGallop += 2;
                }
                if (this.minGallop = minGallop, minGallop < 1 && (this.minGallop = 1), 1 === length1) {
                    for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                    array[dest + length2] = tmp[cursor1];
                } else {
                    if (0 === length1) throw new Error("mergeLow preconditions were not respected");
                    for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
                }
            } else {
                for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
                array[dest + length2] = tmp[cursor1];
            } else for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
        }
    }, {
        key: "mergeHigh",
        value: function mergeHigh(start1, length1, start2, length2) {
            var compare = this.compare, array = this.array, tmp = this.tmp, i = 0;
            for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
            var cursor1 = start1 + length1 - 1, cursor2 = length2 - 1, dest = start2 + length2 - 1, customCursor = 0, customDest = 0;
            if (array[dest--] = array[cursor1--], 0 != --length1) if (1 !== length2) {
                for (var minGallop = this.minGallop; ;) {
                    var count1 = 0, count2 = 0, exit = !1;
                    do {
                        if (compare(tmp[cursor2], array[cursor1]) < 0) {
                            if (array[dest--] = array[cursor1--], count1++, count2 = 0, 0 == --length1) {
                                exit = !0;
                                break;
                            }
                        } else if (array[dest--] = tmp[cursor2--], count2++, count1 = 0, 1 == --length2) {
                            exit = !0;
                            break;
                        }
                    } while ((count1 | count2) < minGallop);
                    if (exit) break;
                    do {
                        if (0 !== (count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare))) {
                            for (length1 -= count1, customDest = (dest -= count1) + 1, customCursor = (cursor1 -= count1) + 1, 
                            i = count1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
                            if (0 === length1) {
                                exit = !0;
                                break;
                            }
                        }
                        if (array[dest--] = tmp[cursor2--], 1 == --length2) {
                            exit = !0;
                            break;
                        }
                        if (0 !== (count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare))) {
                            for (length2 -= count2, customDest = (dest -= count2) + 1, customCursor = (cursor2 -= count2) + 1, 
                            i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
                            if (length2 <= 1) {
                                exit = !0;
                                break;
                            }
                        }
                        if (array[dest--] = array[cursor1--], 0 == --length1) {
                            exit = !0;
                            break;
                        }
                        minGallop--;
                    } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
                    if (exit) break;
                    minGallop < 0 && (minGallop = 0), minGallop += 2;
                }
                if (this.minGallop = minGallop, minGallop < 1 && (this.minGallop = 1), 1 === length2) {
                    for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                    i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
                    array[dest] = tmp[cursor2];
                } else {
                    if (0 === length2) throw new Error("mergeHigh preconditions were not respected");
                    for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
                }
            } else {
                for (customDest = (dest -= length1) + 1, customCursor = (cursor1 -= length1) + 1, 
                i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
                array[dest] = tmp[cursor2];
            } else for (customCursor = dest - (length2 - 1), i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
        }
    } ]), TimSort;
}();

function _sort(array, lo, hi, compare) {
    if (!Array.isArray(array)) throw new TypeError("Can only sort arrays");
    void 0 === lo && (lo = 0), void 0 === hi && (hi = array.length), void 0 === compare && (compare = alphabeticalCompare);
    var remaining = hi - lo;
    if (!(remaining < 2)) {
        var runLength = 0;
        if (remaining < DEFAULT_MIN_MERGE) binaryInsertionSort(array, lo, hi, lo + (runLength = makeAscendingRun(array, lo, hi, compare)), compare); else {
            var ts = new TimSort(array, compare), minRun = function minRunLength(n) {
                for (var r = 0; n >= DEFAULT_MIN_MERGE; ) r |= 1 & n, n >>= 1;
                return n + r;
            }(remaining);
            do {
                if ((runLength = makeAscendingRun(array, lo, hi, compare)) < minRun) {
                    var force = remaining;
                    force > minRun && (force = minRun), binaryInsertionSort(array, lo, lo + force, lo + runLength, compare), 
                    runLength = force;
                }
                ts.pushRun(lo, runLength), ts.mergeRuns(), remaining -= runLength, lo += runLength;
            } while (0 !== remaining);
            ts.forceMergeRuns();
        }
    }
}

var RenderPassStage, RenderPriority, RecyclePool = function() {
    function RecyclePool(fn, size) {
        _classCallCheck(this, RecyclePool), this._fn = void 0, this._count = 0, this._data = void 0, 
        this._fn = fn, this._data = new Array(size);
        for (var i = 0; i < size; ++i) this._data[i] = fn();
    }
    return _createClass(RecyclePool, [ {
        key: "reset",
        value: function reset() {
            this._count = 0;
        }
    }, {
        key: "resize",
        value: function resize(size) {
            if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
        }
    }, {
        key: "add",
        value: function add() {
            return this._count >= this._data.length && this.resize(2 * this._data.length), this._data[this._count++];
        }
    }, {
        key: "removeAt",
        value: function removeAt(idx) {
            if (!(idx >= this._count)) {
                var last = this._count - 1, tmp = this._data[idx];
                this._data[idx] = this._data[last], this._data[last] = tmp, this._count -= 1;
            }
        }
    }, {
        key: "sort",
        value: function sort(compare) {
            return _sort(this._data, 0, this._count, compare);
        }
    }, {
        key: "length",
        get: function get() {
            return this._count;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    } ]), RecyclePool;
}(), BaseRenderData = function BaseRenderData() {
    _classCallCheck(this, BaseRenderData), this.material = null, this.vertexCount = 0, 
    this.indiceCount = 0;
}, RenderData = function(_BaseRenderData) {
    function RenderData() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RenderData);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderData)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).vData = null, 
        _this.uvDirty = !0, _this.vertDirty = !0, _this._datas = [], _this._indices = [], 
        _this._pivotX = 0, _this._pivotY = 0, _this._width = 0, _this._height = 0, _this;
    }
    return _inherits(RenderData, BaseRenderData), _createClass(RenderData, [ {
        key: "updateSizeNPivot",
        value: function updateSizeNPivot(width, height, pivotX, pivotY) {
            width === this._width && height === this._height && pivotX === this._pivotX && pivotY === this._pivotY || (this._width = width, 
            this._height = height, this._pivotX = pivotX, this._pivotY = pivotY, this.vertDirty = !0);
        }
    }, {
        key: "clear",
        value: function clear() {
            this._datas.length = 0, this._indices.length = 0, this._pivotX = 0, this._pivotY = 0, 
            this._width = 0, this._height = 0, this.uvDirty = !0, this.vertDirty = !0, this.material = null, 
            this.vertexCount = 0, this.indiceCount = 0;
        }
    }, {
        key: "dataLength",
        get: function get() {
            return this._datas.length;
        },
        set: function set(length) {
            var data = this._datas;
            if (data.length !== length) {
                var value = data.length, i = 0;
                for (i = length; i < value; i++) _dataPool.free(data[i]);
                for (i = value; i < length; i++) data[i] = _dataPool.alloc();
                data.length = length;
            }
        }
    }, {
        key: "datas",
        get: function get() {
            return this._datas;
        }
    } ], [ {
        key: "add",
        value: function add() {
            return _pool$1.add();
        }
    }, {
        key: "remove",
        value: function remove(data) {
            var idx = _pool$1.data.indexOf(data);
            -1 !== idx && (_pool$1.data[idx].clear(), _pool$1.removeAt(idx));
        }
    } ]), RenderData;
}(), IARenderData = function(_BaseRenderData2) {
    function IARenderData() {
        var _getPrototypeOf3, _this2;
        _classCallCheck(this, IARenderData);
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
        return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(IARenderData)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).vData = new Float32Array(2304 * Float32Array.BYTES_PER_ELEMENT), 
        _this2.iData = new Uint16Array(1536), _this2.vertexStart = 0, _this2.indiceStart = 0, 
        _this2.byteStart = 0, _this2.byteCount = 0, _this2._formatByte = 9 * Float32Array.BYTES_PER_ELEMENT, 
        _this2;
    }
    return _inherits(IARenderData, BaseRenderData), _createClass(IARenderData, [ {
        key: "request",
        value: function request(vertexCount, indiceCount) {
            var byteOffset = this.byteCount + vertexCount * this._formatByte, indiceOffset = this.indiceCount + indiceCount;
            if (vertexCount + this.vertexCount > 65535) return !1;
            var byteLength = this.vData.byteLength, indiceLength = this.iData.length, vCount = this.vData.length, iCount = this.iData.length;
            if (byteOffset > byteLength || indiceOffset > indiceLength) {
                for (;byteLength < byteOffset || indiceLength < indiceOffset; ) byteLength = 4 * (vCount *= 2), 
                indiceLength = iCount *= 2;
                var oldvData = new Float32Array(this.vData.buffer);
                this.vData = new Float32Array(vCount), this.vData.set(oldvData, 0);
                var oldiData = new Uint16Array(this.iData.buffer);
                this.iData = new Uint16Array(iCount), this.iData.set(oldiData, 0);
            }
            return this.vertexCount += vertexCount, this.indiceCount += indiceCount, this.byteCount = byteOffset, 
            !0;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.vertexCount = 0, this.indiceCount = 0, this.byteCount = 0, this.vertexStart = 0, 
            this.indiceStart = 0, this.byteStart = 0;
        }
    } ]), IARenderData;
}(), _dataPool = new Pool$1(function() {
    return {
        x: 0,
        y: 0,
        z: 0,
        u: 0,
        v: 0,
        color: Color.WHITE.clone()
    };
}, 128), _pool$1 = new RecyclePool(function() {
    return new RenderData();
}, 32);

!function(RenderPassStage) {
    RenderPassStage[RenderPassStage.DEFAULT = 100] = "DEFAULT";
}(RenderPassStage || (RenderPassStage = {})), function(RenderPriority) {
    RenderPriority[RenderPriority.MIN = 0] = "MIN", RenderPriority[RenderPriority.MAX = 255] = "MAX", 
    RenderPriority[RenderPriority.DEFAULT = 128] = "DEFAULT";
}(RenderPriority || (RenderPriority = {}));

var UniformBinding;

!function(UniformBinding) {
    UniformBinding[UniformBinding.UBO_GLOBAL = 23] = "UBO_GLOBAL", UniformBinding[UniformBinding.UBO_SHADOW = 22] = "UBO_SHADOW", 
    UniformBinding[UniformBinding.UBO_LOCAL = 21] = "UBO_LOCAL", UniformBinding[UniformBinding.UBO_FORWARD_LIGHTS = 20] = "UBO_FORWARD_LIGHTS", 
    UniformBinding[UniformBinding.UBO_SKINNING = 19] = "UBO_SKINNING", UniformBinding[UniformBinding.UBO_SKINNING_TEXTURE = 18] = "UBO_SKINNING_TEXTURE", 
    UniformBinding[UniformBinding.UBO_UI = 17] = "UBO_UI", UniformBinding[UniformBinding.SAMPLER_JOINTS = 25] = "SAMPLER_JOINTS", 
    UniformBinding[UniformBinding.SAMPLER_ENVIRONMENT = 26] = "SAMPLER_ENVIRONMENT", 
    UniformBinding[UniformBinding.CUSTUM_UBO_BINDING_END_POINT = 17] = "CUSTUM_UBO_BINDING_END_POINT", 
    UniformBinding[UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT = 30] = "CUSTOM_SAMPLER_BINDING_START_POINT";
}(UniformBinding || (UniformBinding = {}));

var UBOGlobal = function UBOGlobal() {
    _classCallCheck(this, UBOGlobal), this.view = new Float32Array(UBOGlobal.COUNT);
};

UBOGlobal.TIME_OFFSET = 0, UBOGlobal.SCREEN_SIZE_OFFSET = UBOGlobal.TIME_OFFSET + 4, 
UBOGlobal.SCREEN_SCALE_OFFSET = UBOGlobal.SCREEN_SIZE_OFFSET + 4, UBOGlobal.NATIVE_SIZE_OFFSET = UBOGlobal.SCREEN_SCALE_OFFSET + 4, 
UBOGlobal.MAT_VIEW_OFFSET = UBOGlobal.NATIVE_SIZE_OFFSET + 4, UBOGlobal.MAT_VIEW_INV_OFFSET = UBOGlobal.MAT_VIEW_OFFSET + 16, 
UBOGlobal.MAT_PROJ_OFFSET = UBOGlobal.MAT_VIEW_INV_OFFSET + 16, UBOGlobal.MAT_PROJ_INV_OFFSET = UBOGlobal.MAT_PROJ_OFFSET + 16, 
UBOGlobal.MAT_VIEW_PROJ_OFFSET = UBOGlobal.MAT_PROJ_INV_OFFSET + 16, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET = UBOGlobal.MAT_VIEW_PROJ_OFFSET + 16, 
UBOGlobal.CAMERA_POS_OFFSET = UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET + 16, UBOGlobal.EXPOSURE_OFFSET = UBOGlobal.CAMERA_POS_OFFSET + 4, 
UBOGlobal.MAIN_LIT_DIR_OFFSET = UBOGlobal.EXPOSURE_OFFSET + 4, UBOGlobal.MAIN_LIT_COLOR_OFFSET = UBOGlobal.MAIN_LIT_DIR_OFFSET + 4, 
UBOGlobal.AMBIENT_SKY_OFFSET = UBOGlobal.MAIN_LIT_COLOR_OFFSET + 4, UBOGlobal.AMBIENT_GROUND_OFFSET = UBOGlobal.AMBIENT_SKY_OFFSET + 4, 
UBOGlobal.COUNT = UBOGlobal.AMBIENT_GROUND_OFFSET + 4, UBOGlobal.SIZE = 4 * UBOGlobal.COUNT, 
UBOGlobal.BLOCK = {
    binding: UniformBinding.UBO_GLOBAL,
    name: "CCGlobal",
    members: [ {
        name: "cc_time",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_screenSize",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_screenScale",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_nativeSize",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_matView",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matViewInv",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matProj",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matProjInv",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matViewProj",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matViewProjInv",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_cameraPos",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_exposure",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_mainLitDir",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_mainLitColor",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_ambientSky",
        type: GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_ambientGround",
        type: GFXType.FLOAT4,
        count: 1
    } ]
};

var UBOShadow = function UBOShadow() {
    _classCallCheck(this, UBOShadow), this.view = new Float32Array(UBOShadow.COUNT);
};

UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0, UBOShadow.SHADOW_COLOR_OFFSET = UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET + 16, 
UBOShadow.COUNT = UBOShadow.SHADOW_COLOR_OFFSET + 4, UBOShadow.SIZE = 4 * UBOShadow.COUNT, 
UBOShadow.BLOCK = {
    binding: UniformBinding.UBO_SHADOW,
    name: "CCShadow",
    members: [ {
        name: "cc_matLightPlaneProj",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_shadowColor",
        type: GFXType.FLOAT4,
        count: 1
    } ]
};

var UNIFORM_ENVIRONMENT = {
    binding: UniformBinding.SAMPLER_ENVIRONMENT,
    name: "cc_environment",
    type: GFXType.SAMPLER_CUBE,
    count: 1
}, localBindingsDesc = new Map(), UBOLocal = function UBOLocal() {
    _classCallCheck(this, UBOLocal), this.view = new Float32Array(UBOLocal.COUNT);
};

UBOLocal.MAT_WORLD_OFFSET = 0, UBOLocal.MAT_WORLD_IT_OFFSET = UBOLocal.MAT_WORLD_OFFSET + 16, 
UBOLocal.COUNT = UBOLocal.MAT_WORLD_IT_OFFSET + 16, UBOLocal.SIZE = 4 * UBOLocal.COUNT, 
UBOLocal.BLOCK = {
    binding: UniformBinding.UBO_LOCAL,
    name: "CCLocal",
    members: [ {
        name: "cc_matWorld",
        type: GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matWorldIT",
        type: GFXType.MAT4,
        count: 1
    } ]
}, localBindingsDesc.set(UBOLocal.BLOCK.name, {
    type: GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOLocal.BLOCK
});

var UBOForwardLight = function UBOForwardLight() {
    _classCallCheck(this, UBOForwardLight), this.view = new Float32Array(UBOForwardLight.COUNT);
};

UBOForwardLight.MAX_SPHERE_LIGHTS = 2, UBOForwardLight.MAX_SPOT_LIGHTS = 2, UBOForwardLight.SPHERE_LIGHT_POS_OFFSET = 0, 
UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET = UBOForwardLight.SPHERE_LIGHT_POS_OFFSET + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS, 
UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET = UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS, 
UBOForwardLight.SPOT_LIGHT_POS_OFFSET = UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET + 4 * UBOForwardLight.MAX_SPOT_LIGHTS, 
UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET = UBOForwardLight.SPOT_LIGHT_POS_OFFSET + 4 * UBOForwardLight.MAX_SPOT_LIGHTS, 
UBOForwardLight.SPOT_LIGHT_DIR_OFFSET = UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * UBOForwardLight.MAX_SPOT_LIGHTS, 
UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET = UBOForwardLight.SPOT_LIGHT_DIR_OFFSET + 4 * UBOForwardLight.MAX_SPOT_LIGHTS, 
UBOForwardLight.COUNT = UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET + 4 * UBOForwardLight.MAX_SPOT_LIGHTS, 
UBOForwardLight.SIZE = 4 * UBOForwardLight.COUNT, UBOForwardLight.BLOCK = {
    binding: UniformBinding.UBO_FORWARD_LIGHTS,
    name: "CCForwardLight",
    members: [ {
        name: "cc_sphereLitPos",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPHERE_LIGHTS
    }, {
        name: "cc_sphereLitSizeRange",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPHERE_LIGHTS
    }, {
        name: "cc_sphereLitColor",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPHERE_LIGHTS
    }, {
        name: "cc_spotLitPos",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    }, {
        name: "cc_spotLitSizeRangeAngle",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    }, {
        name: "cc_spotLitDir",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    }, {
        name: "cc_spotLitColor",
        type: GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    } ]
}, localBindingsDesc.set(UBOForwardLight.BLOCK.name, {
    type: GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOForwardLight.BLOCK
});

var UBOSkinningTexture = function UBOSkinningTexture() {
    _classCallCheck(this, UBOSkinningTexture);
};

UBOSkinningTexture.SIZE = 4 * (UBOSkinningTexture.COUNT = (UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0) + 4), 
UBOSkinningTexture.BLOCK = {
    binding: UniformBinding.UBO_SKINNING_TEXTURE,
    name: "CCSkinningTexture",
    members: [ {
        name: "cc_jointsTextureInfo",
        type: GFXType.FLOAT4,
        count: 1
    } ]
}, localBindingsDesc.set(UBOSkinningTexture.BLOCK.name, {
    type: GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOSkinningTexture.BLOCK
});

var UNIFORM_JOINTS_TEXTURE = {
    binding: UniformBinding.SAMPLER_JOINTS,
    name: "cc_jointsTexture",
    type: GFXType.SAMPLER2D,
    count: 1
};

localBindingsDesc.set(UNIFORM_JOINTS_TEXTURE.name, {
    type: GFXBindingType.SAMPLER,
    samplerInfo: UNIFORM_JOINTS_TEXTURE
});

var _class$r, _class2$l, _descriptor$j, _descriptor2$b, _descriptor3$7, _class3$b, _temp$n, _shdID = 0, getBitCount = function getBitCount(cnt) {
    return Math.ceil(Math.log2(Math.max(cnt, 2)));
}, mapDefine = function mapDefine(info, def) {
    switch (info.type) {
      case "boolean":
        return def ? "1" : "0";

      case "string":
        return void 0 !== def ? def : info.options[0];

      case "number":
        return (void 0 !== def ? def : info.range[0]) + "";
    }
    return console.warn("unknown define type '".concat(info.type, "'")), "-1";
}, getShaderInstanceName = function getShaderInstanceName(name, defs) {
    return name + defs.reduce(function(acc, cur) {
        return "0" !== cur.result ? "".concat(acc, "|").concat(cur.name).concat(cur.result) : acc;
    }, "");
}, insertBuiltinBindings = function insertBuiltinBindings(tmpl, source, type) {
    var target = tmpl.builtins[type], blocks = tmpl.blocks, _iterator3 = target.blocks, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
        var _ref3;
        if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
        } else {
            if ((_i3 = _iterator3.next()).done) break;
            _ref3 = _i3.value;
        }
        var b = _ref3, info = source.get(b.name);
        if (info && info.type === GFXBindingType.UNIFORM_BUFFER) {
            var builtin = Object.assign({
                defines: b.defines
            }, info.blockInfo);
            blocks.push(builtin);
        } else console.warn("builtin UBO '".concat(b.name, "' not available!"));
    }
    var samplers = tmpl.samplers, _iterator4 = target.samplers, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
        var _ref4;
        if (_isArray4) {
            if (_i4 >= _iterator4.length) break;
            _ref4 = _iterator4[_i4++];
        } else {
            if ((_i4 = _iterator4.next()).done) break;
            _ref4 = _i4.value;
        }
        var s = _ref4, _info = source.get(s.name);
        if (_info && _info.type === GFXBindingType.SAMPLER) {
            var _builtin = Object.assign({
                defines: s.defines
            }, _info.samplerInfo);
            samplers.push(_builtin);
        } else console.warn("builtin sampler '".concat(s.name, "' not available!"));
    }
}, programLib = new (function() {
    function ProgramLib() {
        _classCallCheck(this, ProgramLib), this._templates = void 0, this._cache = void 0, 
        this._templates = {}, this._cache = {};
    }
    return _createClass(ProgramLib, [ {
        key: "define",
        value: function define(prog) {
            var cur = this._templates[prog.name];
            if (!cur || cur.hash !== prog.hash) {
                var tmpl = Object.assign({
                    id: ++_shdID
                }, prog);
                tmpl.localsInited || (insertBuiltinBindings(tmpl, localBindingsDesc, "locals"), 
                tmpl.localsInited = !0);
                var offset = 0, _loop = function _loop() {
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) return "break";
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) return "break";
                        _ref5 = _i5.value;
                    }
                    var def = _ref5, cnt = 1;
                    if ("number" === def.type) {
                        var range = def.range;
                        cnt = getBitCount(range[1] - range[0]), def._map = function(value) {
                            return value - range[0] << def._offset;
                        };
                    } else if ("string" === def.type) {
                        var _range = [ 0, def.options.length - 1 ];
                        cnt = getBitCount(_range[1] - _range[0]), def._map = function(value) {
                            return Math.max(0, def.options.findIndex(function(s) {
                                return s === value;
                            })) << def._offset;
                        };
                    } else "boolean" === def.type && (def._map = function(value) {
                        return value ? 1 << def._offset : 0;
                    });
                    def._offset = offset, offset += cnt;
                }, _iterator5 = tmpl.defines, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if ("break" === _loop()) break;
                }
                this._templates[prog.name] = tmpl;
            }
        }
    }, {
        key: "getTemplate",
        value: function getTemplate(name) {
            return this._templates[name];
        }
    }, {
        key: "hasProgram",
        value: function hasProgram(name) {
            return void 0 !== this._templates[name];
        }
    }, {
        key: "getKey",
        value: function getKey(name, defines) {
            var tmpl = this._templates[name], key = 0, _iterator6 = tmpl.defines, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    if ((_i6 = _iterator6.next()).done) break;
                    _ref6 = _i6.value;
                }
                var tmplDef = _ref6, _value = defines[tmplDef.name];
                void 0 !== _value && tmplDef._map && (key |= tmplDef._map(_value));
            }
            return key << 8 | 255 & tmpl.id;
        }
    }, {
        key: "destroyShaderByDefines",
        value: function destroyShaderByDefines(defines) {
            var _this = this, defs = Object.keys(defines);
            if (defs.length) {
                var regexes = defs.map(function(cur) {
                    var val = defs[cur];
                    return "boolean" == typeof val && (val = val ? "1" : "0"), new RegExp(cur + val);
                }), _iterator7 = Object.keys(this._cache).filter(function(k) {
                    return regexes.every(function(re) {
                        return re.test(_this._cache[k].name);
                    });
                }), _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) break;
                        _ref7 = _i7.value;
                    }
                    var k = _ref7;
                    console.log("destroyed shader ".concat(this._cache[k].name)), this._cache[k].destroy(), 
                    delete this._cache[k];
                }
            }
        }
    }, {
        key: "getGFXShader",
        value: function getGFXShader(device, name, defines, pipeline) {
            Object.assign(defines, pipeline.macros);
            var key = this.getKey(name, defines), program = this._cache[key];
            if (void 0 !== program) return program;
            var tmpl = this._templates[name];
            tmpl.globalsInited || (insertBuiltinBindings(tmpl, pipeline.globalBindings, "globals"), 
            tmpl.globalsInited = !0);
            var defs = function prepareDefines(defs, tDefs) {
                var defines = [], _iterator = tDefs, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var tmpl = _ref, name = tmpl.name, result = mapDefine(tmpl, defs[name]);
                    defines.push({
                        name: name,
                        result: result
                    });
                }
                return defines;
            }(defines, tmpl.defines);
            !function validateDefines(defines, device, deps) {
                var _iterator2 = defines, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var info = _ref2, name = info.name;
                    "0" !== info.result && deps[name] && !device[deps[name]] && (console.warn("".concat(deps[name], " not supported on this platform, disabled ").concat(name)), 
                    info.result = "0");
                }
            }(defs, device, tmpl.dependencies);
            var customDef = defs.reduce(function(acc, cur) {
                return "".concat(acc, "#define ").concat(cur.name, " ").concat(cur.result, "\n");
            }, ""), vert = "", frag = "";
            return device.gfxAPI === GFXAPI.WEBGL2 ? (vert = "#version 300 es\n".concat(customDef, "\n").concat(tmpl.glsl3.vert), 
            frag = "#version 300 es\n".concat(customDef, "\n").concat(tmpl.glsl3.frag)) : (vert = "#version 100\n".concat(customDef, "\n").concat(tmpl.glsl1.vert), 
            frag = "#version 100\n".concat(customDef, "\n").concat(tmpl.glsl1.frag)), program = device.createShader({
                name: getShaderInstanceName(name, defs),
                blocks: tmpl.blocks,
                samplers: tmpl.samplers,
                stages: [ {
                    type: GFXShaderType.VERTEX,
                    source: vert
                }, {
                    type: GFXShaderType.FRAGMENT,
                    source: frag
                } ]
            }), this._cache[key] = program, program;
        }
    } ]), ProgramLib;
}())();

cc.programLib = programLib;

var effects = {}, EffectAsset = ccclass("cc.EffectAsset")((_temp$n = _class3$b = function(_Asset) {
    function EffectAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, EffectAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EffectAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "techniques", _descriptor$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "shaders", _descriptor2$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "combinations", _descriptor3$7, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(EffectAsset, Asset), _createClass(EffectAsset, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.shaders.forEach(function(s) {
                return programLib.define(s);
            }), cc.game.once(cc.Game.EVENT_ENGINE_INITED, this._precompile, this), EffectAsset.register(this);
        }
    }, {
        key: "_precompile",
        value: function _precompile() {
            for (var _this2 = this, root = cc.director.root, _loop = function _loop(i) {
                var shader = _this2.shaders[i], combination = _this2.combinations[i];
                if (!combination) return "continue";
                Object.keys(combination).reduce(function(out, name) {
                    return out.reduce(function(acc, cur) {
                        var choices = combination[name], next = [ cur ].concat(_toConsumableArray(Array(choices.length - 1)).map(function() {
                            return Object.assign({}, cur);
                        }));
                        return next.forEach(function(defines, idx) {
                            return defines[name] = choices[idx];
                        }), acc.concat(next);
                    }, []);
                }, [ {} ]).forEach(function(defines) {
                    return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
                });
            }, i = 0; i < this.shaders.length; i++) _loop(i);
        }
    } ], [ {
        key: "register",
        value: function register(asset) {
            effects[asset.name] = asset;
        }
    }, {
        key: "remove",
        value: function remove(name) {
            if (effects[name]) delete effects[name]; else for (var n in effects) if (effects[n]._uuid === name) return void delete effects[n];
        }
    }, {
        key: "get",
        value: function get(name) {
            if (effects[name]) return effects[name];
            for (var n in effects) if (effects[n]._uuid === name) return effects[n];
            return null;
        }
    }, {
        key: "getAll",
        value: function getAll() {
            return effects;
        }
    } ]), EffectAsset;
}(), _class3$b._effects = {}, _descriptor$j = _applyDecoratedDescriptor((_class2$l = _temp$n).prototype, "techniques", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$b = _applyDecoratedDescriptor(_class2$l.prototype, "shaders", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$7 = _applyDecoratedDescriptor(_class2$l.prototype, "combinations", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$r = _class2$l)) || _class$r;

cc.EffectAsset = EffectAsset;

var _class$s, _class2$m, _descriptor$k, _descriptor2$c, GFXTextureView = function(_GFXObject) {
    function GFXTextureView(device) {
        var _this;
        return _classCallCheck(this, GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTextureView).call(this, GFXObjectType.TEXTURE_VIEW)))._device = void 0, 
        _this._texture = null, _this._type = GFXTextureViewType.TV2D, _this._format = GFXFormat.UNKNOWN, 
        _this._baseLevel = 0, _this._levelCount = 1, _this._baseLayer = 0, _this._layerCount = 1, 
        _this._device = device, _this;
    }
    return _inherits(GFXTextureView, GFXObject), _createClass(GFXTextureView, [ {
        key: "texture",
        get: function get() {
            return this._texture;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "format",
        get: function get() {
            return this._format;
        }
    }, {
        key: "baseLevel",
        get: function get() {
            return this._baseLevel;
        }
    }, {
        key: "levelCount",
        get: function get() {
            return this._levelCount;
        }
    }, {
        key: "baseLayer",
        get: function get() {
            return this._baseLayer;
        }
    }, {
        key: "layerCount",
        get: function get() {
            return this._layerCount;
        }
    } ]), GFXTextureView;
}(), GFX_DRAW_INFO_SIZE = 56, GFXBuffer = function(_GFXObject) {
    function GFXBuffer(device) {
        var _this;
        return _classCallCheck(this, GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBuffer).call(this, GFXObjectType.BUFFER)))._device = void 0, 
        _this._usage = GFXBufferUsageBit.NONE, _this._memUsage = GFXMemoryUsageBit.NONE, 
        _this._size = 0, _this._stride = 1, _this._count = 0, _this._device = device, _this;
    }
    return _inherits(GFXBuffer, GFXObject), _createClass(GFXBuffer, [ {
        key: "usage",
        get: function get() {
            return this._usage;
        }
    }, {
        key: "memUsage",
        get: function get() {
            return this._memUsage;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        }
    }, {
        key: "stride",
        get: function get() {
            return this._stride;
        }
    }, {
        key: "count",
        get: function get() {
            return this._count;
        }
    } ]), GFXBuffer;
}(), GFXCommandBuffer = function(_GFXObject) {
    function GFXCommandBuffer(device) {
        var _this;
        return _classCallCheck(this, GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandBuffer).call(this, GFXObjectType.COMMAND_BUFFER)))._device = void 0, 
        _this._allocator = null, _this._type = GFXCommandBufferType.PRIMARY, _this._numDrawCalls = 0, 
        _this._numTris = 0, _this._device = device, _this;
    }
    return _inherits(GFXCommandBuffer, GFXObject), _createClass(GFXCommandBuffer, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "numDrawCalls",
        get: function get() {
            return this._numDrawCalls;
        }
    }, {
        key: "numTris",
        get: function get() {
            return this._numTris;
        }
    } ]), GFXCommandBuffer;
}(), GFXFramebuffer = function(_GFXObject) {
    function GFXFramebuffer(device) {
        var _this;
        return _classCallCheck(this, GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXFramebuffer).call(this, GFXObjectType.FRAMEBUFFER)))._device = void 0, 
        _this._renderPass = null, _this._colorViews = [], _this._depthStencilView = null, 
        _this._isOffscreen = !0, _this._device = device, _this;
    }
    return _inherits(GFXFramebuffer, GFXObject), _createClass(GFXFramebuffer, [ {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    }, {
        key: "colorViews",
        get: function get() {
            return this._colorViews;
        }
    }, {
        key: "depthStencilView",
        get: function get() {
            return this._depthStencilView;
        }
    }, {
        key: "isOffscreen",
        get: function get() {
            return this._isOffscreen;
        }
    } ]), GFXFramebuffer;
}(), BufferBlob = function() {
    function BufferBlob() {
        _classCallCheck(this, BufferBlob), this._arrayBufferOrPaddings = [], this._length = 0;
    }
    return _createClass(BufferBlob, [ {
        key: "setNextAlignment",
        value: function setNextAlignment(align) {
            if (0 !== align) {
                var remainder = this._length % align;
                if (0 !== remainder) {
                    var padding = align - remainder;
                    this._arrayBufferOrPaddings.push(padding), this._length += padding;
                }
            }
        }
    }, {
        key: "addBuffer",
        value: function addBuffer(arrayBuffer) {
            var result = this._length;
            return this._arrayBufferOrPaddings.push(arrayBuffer), this._length += arrayBuffer.byteLength, 
            result;
        }
    }, {
        key: "getLength",
        value: function getLength() {
            return this._length;
        }
    }, {
        key: "getCombined",
        value: function getCombined() {
            var result = new Uint8Array(this._length), counter = 0;
            return this._arrayBufferOrPaddings.forEach(function(arrayBufferOrPadding) {
                "number" == typeof arrayBufferOrPadding ? counter += arrayBufferOrPadding : (result.set(new Uint8Array(arrayBufferOrPadding), counter), 
                counter += arrayBufferOrPadding.byteLength);
            }), result.buffer;
        }
    } ]), BufferBlob;
}();

var RenderingMesh = function() {
    function RenderingMesh(_subMeshes) {
        _classCallCheck(this, RenderingMesh), this._subMeshes = _subMeshes;
    }
    return _createClass(RenderingMesh, [ {
        key: "getSubmesh",
        value: function getSubmesh(index) {
            return this._subMeshes[index];
        }
    }, {
        key: "clearSubMeshes",
        value: function clearSubMeshes() {
            var _iterator = this._subMeshes, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var subMesh = _ref, _iterator2 = subMesh.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.destroy();
                }
                subMesh.indexBuffer && subMesh.indexBuffer.destroy();
            }
            this._subMeshes.splice(0);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.clearSubMeshes(), this._subMeshes.length = 0;
        }
    }, {
        key: "subMeshes",
        get: function get() {
            return this._subMeshes;
        }
    }, {
        key: "subMeshCount",
        get: function get() {
            return this._subMeshes.length;
        }
    } ]), RenderingMesh;
}(), Mesh = ccclass("cc.Mesh")((_descriptor$k = _applyDecoratedDescriptor((_class2$m = function(_Asset) {
    function Mesh() {
        var _this;
        return _classCallCheck(this, Mesh), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)), "_struct", _descriptor$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_dataLength", _descriptor2$c, _assertThisInitialized(_this)), 
        _this._data = null, _this._initialized = !1, _this._renderingMesh = null, _this.loaded = !1, 
        _this;
    }
    return _inherits(Mesh, Asset), _createClass(Mesh, [ {
        key: "_nativeAsset",
        get: function get() {
            return this._data.buffer;
        },
        set: function set(value) {
            this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
            cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "subMeshCount",
        get: function get() {
            var renderingMesh = this.renderingMesh;
            return renderingMesh ? renderingMesh.subMeshCount : 0;
        }
    }, {
        key: "minPosition",
        get: function get() {
            return this.struct.minPosition;
        }
    }, {
        key: "maxPosition",
        get: function get() {
            return this.struct.maxPosition;
        }
    }, {
        key: "struct",
        get: function get() {
            return this._struct;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    } ]), _createClass(Mesh, [ {
        key: "initialize",
        value: function initialize() {
            var _this2 = this;
            if (!this._initialized) {
                this._initialized = !0, this._data || (this._data = new Uint8Array(this._dataLength), 
                function postLoadMesh(mesh, callback) {
                    mesh.loaded ? callback && callback() : mesh.nativeUrl ? cc.loader.load({
                        url: mesh.nativeUrl
                    }, function(err, arrayBuffer) {
                        arrayBuffer && (mesh.loaded || (mesh._nativeAsset = arrayBuffer)), callback && callback(err);
                    }) : callback && callback();
                }(this));
                var buffer = this._data.buffer, gfxDevice = cc.director.root.device, vertexBuffers = this._createVertexBuffers(gfxDevice, buffer), submeshes = [], _loop2 = function _loop2() {
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) return "break";
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) return "break";
                        _ref3 = _i3.value;
                    }
                    var prim = _ref3;
                    if (0 === prim.vertexBundelIndices.length) return "continue";
                    var indexBuffer = null, ib = null;
                    if (prim.indexView) {
                        var idxView = prim.indexView;
                        indexBuffer = gfxDevice.createBuffer({
                            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                            size: idxView.length,
                            stride: idxView.stride
                        }), ib = new (function getIndexStrideCtor(stride) {
                            switch (stride) {
                              case 1:
                                return Uint8Array;

                              case 2:
                                return Uint16Array;

                              case 4:
                                return Uint32Array;
                            }
                            return Uint8Array;
                        }(idxView.stride))(buffer, idxView.offset, idxView.count), _this2.loaded ? indexBuffer.update(ib) : _this2.once("load", function() {
                            indexBuffer.update(ib);
                        });
                    }
                    var vbReference = prim.vertexBundelIndices.map(function(i) {
                        return vertexBuffers[i];
                    }), gfxAttributes = [];
                    if (prim.vertexBundelIndices.length > 0) {
                        var idx = prim.vertexBundelIndices[0];
                        gfxAttributes = _this2._struct.vertexBundles[idx].attributes;
                    }
                    var subMesh = {
                        primitiveMode: prim.primitiveMode,
                        vertexBuffers: vbReference,
                        indexBuffer: indexBuffer,
                        attributes: gfxAttributes
                    };
                    if (prim.geometricInfo) {
                        var info = prim.geometricInfo, positions = new Float32Array(buffer, info.view.offset, info.view.length / 4);
                        subMesh.geometricInfo = {
                            indices: ib,
                            positions: positions
                        };
                    }
                    submeshes.push(subMesh);
                };
                var _iterator3 = this._struct.primitives, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                _loop: for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    switch (_loop2()) {
                      case "break":
                        break _loop;

                      case "continue":
                        continue;
                    }
                }
                this._renderingMesh = new RenderingMesh(submeshes);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this.destroyRenderingMesh(), _get(_getPrototypeOf(Mesh.prototype), "destroy", this).call(this);
        }
    }, {
        key: "destroyRenderingMesh",
        value: function destroyRenderingMesh() {
            this._renderingMesh && (this._renderingMesh.destroy(), this._renderingMesh = null, 
            this._data = null, this._initialized = !1);
        }
    }, {
        key: "assign",
        value: function assign(struct, data) {
            this.reset({
                struct: struct,
                data: data
            });
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this.destroyRenderingMesh(), this._struct = info.struct, this._data = info.data, 
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "getSubMesh",
        value: function getSubMesh(index) {
            return this.renderingMesh.getSubmesh(index);
        }
    }, {
        key: "merge",
        value: function merge(mesh, validate) {
            if (void 0 !== validate && validate && (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh))) return !1;
            if (!this._initialized && mesh._data) {
                var struct = JSON.parse(JSON.stringify(mesh._struct)), data = mesh._data.slice();
                return this.reset({
                    struct: struct,
                    data: data
                }), this.initialize(), !0;
            }
            for (var vb, vbView, srcVBView, dstVBView, dstAttrView, bufferBlob = new BufferBlob(), vertCount = 0, vertStride = 0, srcOffset = 0, dstOffset = 0, srcAttrOffset = 0, srcVBOffset = 0, dstVBOffset = 0, attrSize = 0, hasAttr = !1, vertexBundles = new Array(this._struct.vertexBundles.length), i = 0; i < this._struct.vertexBundles.length; ++i) {
                var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                srcOffset = bundle.view.offset, dstOffset = dstBundle.view.offset, vertStride = bundle.view.stride, 
                vertCount = bundle.view.count + dstBundle.view.count, vb = new ArrayBuffer(vertCount * vertStride), 
                vbView = new Uint8Array(vb), srcOffset += (srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length)).length, 
                dstOffset += (dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length)).length, 
                vbView.set(srcVBView), srcAttrOffset = 0;
                var _iterator4 = bundle.attributes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var attr = _ref4;
                    dstVBOffset = 0, hasAttr = !1;
                    var _iterator5 = dstBundle.attributes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        var dstAttr = _ref5;
                        if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                            hasAttr = !0;
                            break;
                        }
                        dstVBOffset += GFXFormatInfos[dstAttr.format].size;
                    }
                    if (hasAttr) {
                        attrSize = GFXFormatInfos[attr.format].size, srcVBOffset = bundle.view.length + srcAttrOffset;
                        for (var v = 0; v < dstBundle.view.count; ++v) dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize), 
                        vbView.set(dstAttrView, srcVBOffset), srcVBOffset += bundle.view.stride, dstVBOffset += dstBundle.view.stride;
                    }
                    srcAttrOffset += GFXFormatInfos[attr.format].size;
                }
                vertexBundles[i] = {
                    attributes: bundle.attributes,
                    view: {
                        offset: bufferBlob.getLength(),
                        length: vb.byteLength,
                        count: vertCount,
                        stride: vertStride
                    }
                }, bufferBlob.addBuffer(vb);
            }
            for (var ibView, srcIBView, dstIBView, idxCount = 0, idxStride = 2, vertBatchCount = 0, primitives = new Array(this._struct.primitives.length), _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
                var prim = this._struct.primitives[_i6], dstPrim = mesh._struct.primitives[_i6];
                primitives[_i6] = {
                    primitiveMode: prim.primitiveMode,
                    vertexBundelIndices: prim.vertexBundelIndices
                };
                var _iterator6 = prim.vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i7 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i7++];
                    } else {
                        if ((_i7 = _iterator6.next()).done) break;
                        _ref6 = _i7.value;
                    }
                    var bundleIdx = _ref6;
                    vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                }
                if (prim.indexView && dstPrim.indexView) {
                    idxCount = prim.indexView.count, idxCount += dstPrim.indexView.count, srcOffset = prim.indexView.offset, 
                    dstOffset = dstPrim.indexView.offset, idxStride = idxCount < 256 ? 1 : idxCount < 65536 ? 2 : 4;
                    var ib = new ArrayBuffer(idxCount * idxStride);
                    if (ibView = 2 === idxStride ? new Uint16Array(ib) : 1 === idxStride ? new Uint8Array(ib) : new Uint32Array(ib), 
                    srcIBView = 2 === prim.indexView.stride ? new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count) : 1 === prim.indexView.stride ? new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count) : new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count), 
                    idxStride === prim.indexView.stride) ibView.set(srcIBView); else for (var n = 0; n < prim.indexView.count; ++n) ibView[n] = srcIBView[n];
                    srcOffset += prim.indexView.length, dstIBView = 2 === dstPrim.indexView.stride ? new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : 1 === dstPrim.indexView.stride ? new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    for (var _n = 0; _n < dstPrim.indexView.count; ++_n) ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                    dstOffset += dstPrim.indexView.length, primitives[_i6].indexView = {
                        offset: bufferBlob.getLength(),
                        length: ib.byteLength,
                        count: idxCount,
                        stride: idxStride
                    }, bufferBlob.setNextAlignment(idxStride), bufferBlob.addBuffer(ib);
                }
                if (prim.geometricInfo && dstPrim.geometricInfo) {
                    var geomBuffSize = prim.geometricInfo.view.length + dstPrim.geometricInfo.view.length, geomBuff = new ArrayBuffer(geomBuffSize), geomBuffView = new Uint8Array(geomBuff), srcView = new Uint8Array(this._data.buffer, prim.geometricInfo.view.offset, prim.geometricInfo.view.length), dstView = new Uint8Array(mesh._data.buffer, dstPrim.geometricInfo.view.offset, dstPrim.geometricInfo.view.length);
                    geomBuffView.set(srcView), geomBuffView.set(dstView, srcView.length), bufferBlob.setNextAlignment(4), 
                    primitives[_i6].geometricInfo = {
                        doubleSided: prim.geometricInfo.doubleSided,
                        view: {
                            offset: bufferBlob.getLength(),
                            length: geomBuffView.length,
                            count: prim.geometricInfo.view.count + dstPrim.geometricInfo.view.count,
                            stride: prim.geometricInfo.view.stride
                        }
                    }, bufferBlob.addBuffer(geomBuff);
                }
            }
            var meshStruct = {
                vertexBundles: vertexBundles,
                primitives: primitives,
                minPosition: this._struct.minPosition,
                maxPosition: this._struct.maxPosition
            };
            return meshStruct.minPosition && mesh._struct.minPosition && Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition), 
            meshStruct.maxPosition && mesh._struct.maxPosition && Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition), 
            this.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
            }), this.initialize(), !0;
        }
    }, {
        key: "validateMergingMesh",
        value: function validateMergingMesh(mesh) {
            if (!this._data && mesh._data) return !0;
            if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) return !1;
            for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                if (bundle.attributes.length !== dstBundle.attributes.length) return !1;
                for (var j = 0; j < bundle.attributes.length; ++j) if (bundle.attributes[j].format !== dstBundle.attributes[j].format) return !1;
            }
            if (this._struct.primitives.length !== mesh._struct.primitives.length) return !1;
            for (var _i8 = 0; _i8 < this._struct.primitives.length; ++_i8) {
                var prim = this._struct.primitives[_i8], dstPrim = mesh._struct.primitives[_i8];
                if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) return !1;
                for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) return !1;
                if (prim.primitiveMode !== dstPrim.primitiveMode) return !1;
                if (prim.indexView) {
                    if (void 0 === dstPrim.indexView) return !1;
                } else if (dstPrim.indexView) return !1;
            }
            return !0;
        }
    }, {
        key: "readAttribute",
        value: function readAttribute(primitiveIndex, attributeName) {
            var _this3 = this, result = null;
            return this._accessAttribute(primitiveIndex, attributeName, function(vertexBundle, iAttribute) {
                var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), formatInfo = GFXFormatInfos[format], storageConstructor = getStorageConstructor(format), reader = getReader(inputView, format);
                if (storageConstructor && reader) {
                    for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, storage = new storageConstructor(vertexCount * componentCount), inputStride = vertexBundle.view.stride, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                    result = storage;
                }
            }), result;
        }
    }, {
        key: "copyAttribute",
        value: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
            var _this4 = this, written = !1;
            return this._accessAttribute(primitiveIndex, attributeName, function(vertexBundle, iAttribute) {
                var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), outputView = new DataView(buffer, offset), formatInfo = GFXFormatInfos[format], reader = getReader(inputView, format), writer = function getWriter(dataView, format) {
                    var info = GFXFormatInfos[format], stride = info.size / info.count;
                    switch (info.type) {
                      case GFXFormatType.UNORM:
                        switch (stride) {
                          case 1:
                            return function(offset, value) {
                                return dataView.setUint8(offset, value);
                            };

                          case 2:
                            return function(offset, value) {
                                return dataView.setUint16(offset, value, isLittleEndian);
                            };

                          case 4:
                            return function(offset, value) {
                                return dataView.setUint32(offset, value, isLittleEndian);
                            };
                        }
                        break;

                      case GFXFormatType.SNORM:
                      case GFXFormatType.INT:
                        switch (stride) {
                          case 1:
                            return function(offset, value) {
                                return dataView.setInt8(offset, value);
                            };

                          case 2:
                            return function(offset, value) {
                                return dataView.setInt16(offset, value, isLittleEndian);
                            };

                          case 4:
                            return function(offset, value) {
                                return dataView.setInt32(offset, value, isLittleEndian);
                            };
                        }
                        break;

                      case GFXFormatType.UINT:
                        switch (stride) {
                          case 1:
                            return function(offset, value) {
                                return dataView.setUint8(offset, value);
                            };

                          case 2:
                            return function(offset, value) {
                                return dataView.setUint16(offset, value, isLittleEndian);
                            };

                          case 4:
                            return function(offset, value) {
                                return dataView.setUint32(offset, value, isLittleEndian);
                            };
                        }
                        break;

                      case GFXFormatType.FLOAT:
                        return function(offset, value) {
                            return dataView.setFloat32(offset, value, isLittleEndian);
                        };
                    }
                    return null;
                }(outputView, format);
                if (reader && writer) {
                    for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, inputStride = vertexBundle.view.stride, inputComponentByteLength = function getComponentByteLength(format) {
                        var info = GFXFormatInfos[format];
                        return info.size / info.count;
                    }(format), outputStride = stride, outputComponentByteLength = inputComponentByteLength, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                        writer(outputStride * iVertex + outputComponentByteLength * iComponent, reader(inputStride * iVertex + inputComponentByteLength * iComponent));
                    }
                    written = !0;
                }
            }), written;
        }
    }, {
        key: "readIndices",
        value: function readIndices(primitiveIndex) {
            if (!this._data || primitiveIndex >= this._struct.primitives.length) return null;
            var primitive = this._struct.primitives[primitiveIndex];
            if (!primitive.indexView) return null;
            for (var indexCount = primitive.indexView.count, indexFormat = indexCount < 256 ? GFXFormat.R8UI : indexCount < 65536 ? GFXFormat.R16UI : GFXFormat.R32UI, storage = new (getStorageConstructor(indexFormat))(indexCount), reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) storage[i] = reader(primitive.indexView.offset + storage.BYTES_PER_ELEMENT * i);
            return storage;
        }
    }, {
        key: "copyIndices",
        value: function copyIndices(primitiveIndex, outputArray) {
            if (!this._data || primitiveIndex >= this._struct.primitives.length) return !1;
            var primitive = this._struct.primitives[primitiveIndex];
            if (!primitive.indexView) return !1;
            for (var indexCount = primitive.indexView.count, indexFormat = 1 === primitive.indexView.stride ? GFXFormat.R8UI : 2 === primitive.indexView.stride ? GFXFormat.R16UI : GFXFormat.R32UI, reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) outputArray[i] = reader(primitive.indexView.offset + GFXFormatInfos[indexFormat].size * i);
            return !0;
        }
    }, {
        key: "_accessAttribute",
        value: function _accessAttribute(primitiveIndex, attributeName, accessor) {
            if (this._data && !(primitiveIndex >= this._struct.primitives.length)) {
                var _iterator7 = this._struct.primitives[primitiveIndex].vertexBundelIndices, _isArray7 = Array.isArray(_iterator7), _i9 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i9 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i9++];
                    } else {
                        if ((_i9 = _iterator7.next()).done) break;
                        _ref7 = _i9.value;
                    }
                    var vertexBundleIndex = _ref7, _vertexBundle2 = this._struct.vertexBundles[vertexBundleIndex], _iAttribute = _vertexBundle2.attributes.findIndex(function(a) {
                        return a.name === attributeName;
                    });
                    if (!(_iAttribute < 0)) {
                        accessor(_vertexBundle2, _iAttribute);
                        break;
                    }
                }
            }
        }
    }, {
        key: "_createVertexBuffers",
        value: function _createVertexBuffers(gfxDevice, data) {
            var _this5 = this;
            return this._struct.vertexBundles.map(function(vertexBundle) {
                var vertexBuffer = gfxDevice.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: vertexBundle.view.length,
                    stride: vertexBundle.view.stride
                }), view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                return _this5.loaded ? vertexBuffer.update(view) : _this5.once("load", function() {
                    vertexBuffer.update(view);
                }), vertexBuffer;
            });
        }
    }, {
        key: "renderingMesh",
        get: function get() {
            return this.initialize(), this._renderingMesh;
        }
    } ]), Mesh;
}()).prototype, "_struct", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return {
            vertexBundles: [],
            primitives: []
        };
    }
}), _descriptor2$c = _applyDecoratedDescriptor(_class2$m.prototype, "_dataLength", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$s = _class2$m)) || _class$s;

function getOffset(attributes, attributeIndex) {
    for (var result = 0, i = 0; i < attributeIndex; ++i) {
        var attribute = attributes[i];
        result += GFXFormatInfos[attribute.format].size;
    }
    return result;
}

function getStorageConstructor(format) {
    var info = GFXFormatInfos[format], stride = info.size / info.count;
    switch (info.type) {
      case GFXFormatType.UNORM:
      case GFXFormatType.UINT:
        switch (stride) {
          case 1:
            return Uint8Array;

          case 2:
            return Uint16Array;

          case 4:
            return Uint32Array;
        }
        break;

      case GFXFormatType.SNORM:
      case GFXFormatType.INT:
        switch (stride) {
          case 1:
            return Int8Array;

          case 2:
            return Int16Array;

          case 4:
            return Int32Array;
        }
        break;

      case GFXFormatType.FLOAT:
        return Float32Array;
    }
    return null;
}

cc.Mesh = Mesh;

var isLittleEndian = cc.sys.isLittleEndian;

function getReader(dataView, format) {
    var info = GFXFormatInfos[format], stride = info.size / info.count;
    switch (info.type) {
      case GFXFormatType.UNORM:
        switch (stride) {
          case 1:
            return function(offset) {
                return dataView.getUint8(offset);
            };

          case 2:
            return function(offset) {
                return dataView.getUint16(offset, isLittleEndian);
            };

          case 4:
            return function(offset) {
                return dataView.getUint32(offset, isLittleEndian);
            };
        }
        break;

      case GFXFormatType.SNORM:
      case GFXFormatType.INT:
        switch (stride) {
          case 1:
            return function(offset) {
                return dataView.getInt8(offset);
            };

          case 2:
            return function(offset) {
                return dataView.getInt16(offset, isLittleEndian);
            };

          case 4:
            return function(offset) {
                return dataView.getInt32(offset, isLittleEndian);
            };
        }
        break;

      case GFXFormatType.UINT:
        switch (stride) {
          case 1:
            return function(offset) {
                return dataView.getUint8(offset);
            };

          case 2:
            return function(offset) {
                return dataView.getUint16(offset, isLittleEndian);
            };

          case 4:
            return function(offset) {
                return dataView.getUint32(offset, isLittleEndian);
            };
        }
        break;

      case GFXFormatType.FLOAT:
        return function(offset) {
            return dataView.getFloat32(offset, isLittleEndian);
        };
    }
    return null;
}

var enums = {
    SHAPE_RAY: 1,
    SHAPE_LINE: 2,
    SHAPE_SPHERE: 4,
    SHAPE_AABB: 8,
    SHAPE_OBB: 16,
    SHAPE_PLANE: 32,
    SHAPE_TRIANGLE: 64,
    SHAPE_FRUSTUM: 128,
    SHAPE_FRUSTUM_ACCURATE: 256
}, X = new Vec3(), Y = new Vec3(), Z = new Vec3(), d = new Vec3(), min$1 = new Vec3(), max$1 = new Vec3(), u = new Array(3), e = new Array(3);

function point_plane(point, plane_) {
    return Vec3.dot(plane_.n, point) - plane_.d;
}

function pt_point_aabb(out, point, aabb_) {
    return Vec3.copy(out, point), Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents), 
    Vec3.add(max$1, aabb_.center, aabb_.halfExtents), out.x = out.x < min$1.x ? min$1.x : out.x, 
    out.y = out.y < min$1.x ? min$1.y : out.y, out.z = out.z < min$1.x ? min$1.z : out.z, 
    out.x = out.x > max$1.x ? max$1.x : out.x, out.y = out.y > max$1.x ? max$1.y : out.y, 
    out.z = out.z > max$1.x ? max$1.z : out.z, out;
}

function pt_point_obb(out, point, obb_) {
    Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02), Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05), 
    Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08), u[0] = X, 
    u[1] = Y, u[2] = Z, e[0] = obb_.halfExtents.x, e[1] = obb_.halfExtents.y, e[2] = obb_.halfExtents.z, 
    Vec3.subtract(d, point, obb_.center), Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
    for (var i = 0; i < 3; i++) {
        var dist = Vec3.dot(d, u[i]);
        dist > e[i] && (dist = e[i]), dist < -e[i] && (dist = -e[i]), out.x += dist * u[i].x, 
        out.y += dist * u[i].y, out.z += dist * u[i].z;
    }
    return out;
}

var pt, ab, aMin, aMax, bMin, bMax, distance = Object.freeze({
    point_plane: point_plane,
    pt_point_plane: function pt_point_plane(out, point, plane_) {
        var t = point_plane(point, plane_);
        return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
    },
    pt_point_aabb: pt_point_aabb,
    pt_point_obb: pt_point_obb
}), ray_plane = (pt = new Vec3(0, 0, 0), function(ray, plane) {
    var denom = Vec3.dot(ray.d, plane.n);
    if (Math.abs(denom) < Number.EPSILON) return 0;
    Vec3.multiplyScalar(pt, plane.n, plane.d);
    var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;
    return t < 0 ? 0 : t;
}), line_plane = (ab = new Vec3(0, 0, 0), function(line, plane) {
    Vec3.subtract(ab, line.e, line.s);
    var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);
    return t < 0 || t > 1 ? 0 : t;
}), ray_triangle = function() {
    var ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), pvec = new Vec3(0, 0, 0), tvec = new Vec3(0, 0, 0), qvec = new Vec3(0, 0, 0);
    return function(ray, triangle, doubleSided) {
        Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
        Vec3.cross(pvec, ray.d, ac);
        var det = Vec3.dot(ab, pvec);
        if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) return 0;
        var inv_det = 1 / det;
        Vec3.subtract(tvec, ray.o, triangle.a);
        var u = Vec3.dot(tvec, pvec) * inv_det;
        if (u < 0 || u > 1) return 0;
        Vec3.cross(qvec, tvec, ab);
        var v = Vec3.dot(ray.d, qvec) * inv_det;
        if (v < 0 || u + v > 1) return 0;
        var t = Vec3.dot(ac, qvec) * inv_det;
        return t < 0 ? 0 : t;
    };
}(), line_triangle = function() {
    var ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), qp = new Vec3(0, 0, 0), ap = new Vec3(0, 0, 0), n = new Vec3(0, 0, 0), e = new Vec3(0, 0, 0);
    return function(line, triangle, outPt) {
        Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
        Vec3.subtract(qp, line.s, line.e), Vec3.cross(n, ab, ac);
        var det = Vec3.dot(qp, n);
        if (det <= 0) return 0;
        Vec3.subtract(ap, line.s, triangle.a);
        var t = Vec3.dot(ap, n);
        if (t < 0 || t > det) return 0;
        Vec3.cross(e, qp, ap);
        var v = Vec3.dot(ac, e);
        if (v < 0 || v > det) return 0;
        var w = -Vec3.dot(ab, e);
        if (w < 0 || v + w > det) return 0;
        if (outPt) {
            var invDet = 1 / det, u = 1 - (v *= invDet) - (w *= invDet);
            Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
        }
        return 1;
    };
}(), line_quad = function() {
    var pq = new Vec3(0, 0, 0), pa = new Vec3(0, 0, 0), pb = new Vec3(0, 0, 0), pc = new Vec3(0, 0, 0), pd = new Vec3(0, 0, 0), m = new Vec3(0, 0, 0), tmp = new Vec3(0, 0, 0);
    return function(p, q, a, b, c, d, outPt) {
        Vec3.subtract(pq, q, p), Vec3.subtract(pa, a, p), Vec3.subtract(pb, b, p), Vec3.subtract(pc, c, p), 
        Vec3.cross(m, pc, pq);
        var v = Vec3.dot(pa, m);
        if (v >= 0) {
            var u = -Vec3.dot(pb, m);
            if (u < 0) return 0;
            var w = Vec3.dot(Vec3.cross(tmp, pq, pb), pa);
            if (w < 0) return 0;
            if (outPt) {
                var denom = 1 / (u + v + w);
                u *= denom, v *= denom, w *= denom, Vec3.set(outPt, a.x * u + b.x * v + c.x * w, a.y * u + b.y * v + c.y * w, a.z * u + b.z * v + c.z * w);
            }
        } else {
            Vec3.subtract(pd, d, p);
            var _u = Vec3.dot(pd, m);
            if (_u < 0) return 0;
            var _w = Vec3.dot(Vec3.cross(tmp, pq, pa), pd);
            if (_w < 0) return 0;
            if (outPt) {
                var _denom = 1 / (_u + (v = -v) + _w);
                _u *= _denom, v *= _denom, _w *= _denom, Vec3.set(outPt, a.x * _u + d.x * v + c.x * _w, a.y * _u + d.y * v + c.y * _w, a.z * _u + d.z * v + c.z * _w);
            }
        }
        return 1;
    };
}(), ray_sphere = function() {
    var e = new Vec3(0, 0, 0);
    return function(ray, sphere) {
        var r = sphere.radius, c = sphere.center, o = ray.o, d = ray.d, rSq = r * r;
        Vec3.subtract(e, c, o);
        var eSq = e.lengthSqr(), aLength = Vec3.dot(e, d), fSq = rSq - (eSq - aLength * aLength);
        if (fSq < 0) return 0;
        var f = Math.sqrt(fSq), t = eSq < rSq ? aLength + f : aLength - f;
        return t < 0 ? 0 : t;
    };
}(), ray_aabb = function() {
    var min = new Vec3(), max = new Vec3();
    return function(ray, aabb) {
        var o = ray.o, d = ray.d, ix = 1 / d.x, iy = 1 / d.y, iz = 1 / d.z;
        Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents);
        var t1 = (min.x - o.x) * ix, t2 = (max.x - o.x) * ix, t3 = (min.y - o.y) * iy, t4 = (max.y - o.y) * iy, t5 = (min.z - o.z) * iz, t6 = (max.z - o.z) * iz, tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6)), tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        return tmax < 0 || tmin > tmax ? 0 : tmin;
    };
}(), ray_obb = function() {
    var center = new Vec3(), o = new Vec3(), d = new Vec3(), X = new Vec3(), Y = new Vec3(), Z = new Vec3(), p = new Vec3(), size = new Array(3), f = new Array(3), e = new Array(3), t = new Array(6);
    return function(ray, obb) {
        size[0] = obb.halfExtents.x, size[1] = obb.halfExtents.y, size[2] = obb.halfExtents.z, 
        center = obb.center, o = ray.o, d = ray.d, Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
        Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), 
        Vec3.subtract(p, center, o), f[0] = Vec3.dot(X, d), f[1] = Vec3.dot(Y, d), f[2] = Vec3.dot(Z, d), 
        e[0] = Vec3.dot(X, p), e[1] = Vec3.dot(Y, p), e[2] = Vec3.dot(Z, p);
        for (var i = 0; i < 3; ++i) {
            if (0 === f[i]) {
                if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) return 0;
                f[i] = 1e-7;
            }
            t[2 * i + 0] = (e[i] + size[i]) / f[i], t[2 * i + 1] = (e[i] - size[i]) / f[i];
        }
        var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5])), tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
        return tmax < 0 || tmin > tmax || tmin < 0 ? 0 : tmin;
    };
}(), aabb_aabb = (aMin = new Vec3(), aMax = new Vec3(), bMin = new Vec3(), bMax = new Vec3(), 
function(aabb1, aabb2) {
    return Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents), Vec3.add(aMax, aabb1.center, aabb1.halfExtents), 
    Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents), Vec3.add(bMax, aabb2.center, aabb2.halfExtents), 
    aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
});

function getOBBVertices(c, e, a1, a2, a3, out) {
    Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z), 
    Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z), 
    Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z), 
    Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
}

function getInterval(vertices, axis) {
    for (var min = Vec3.dot(axis, vertices[0]), max = min, i = 1; i < 8; ++i) {
        var projection = Vec3.dot(axis, vertices[i]);
        min = projection < min ? projection : min, max = projection > max ? projection : max;
    }
    return [ min, max ];
}

var absDot, aabb_obb = function() {
    for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
    for (var vertices = new Array(8), vertices2 = new Array(8), _i = 0; _i < 8; _i++) vertices[_i] = new Vec3(0, 0, 0), 
    vertices2[_i] = new Vec3(0, 0, 0);
    var min = new Vec3(), max = new Vec3();
    return function(aabb, obb) {
        Vec3.set(test[0], 1, 0, 0), Vec3.set(test[1], 0, 1, 0), Vec3.set(test[2], 0, 0, 1), 
        Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
        Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), 
        Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
        for (var _i2 = 0; _i2 < 3; ++_i2) Vec3.cross(test[6 + 3 * _i2 + 0], test[_i2], test[0]), 
        Vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[1]), Vec3.cross(test[6 + 3 * _i2 + 1], test[_i2], test[2]);
        Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents), 
        function getAABBVertices(min, max, out) {
            Vec3.set(out[0], min.x, max.y, max.z), Vec3.set(out[1], min.x, max.y, min.z), Vec3.set(out[2], min.x, min.y, max.z), 
            Vec3.set(out[3], min.x, min.y, min.z), Vec3.set(out[4], max.x, max.y, max.z), Vec3.set(out[5], max.x, max.y, min.z), 
            Vec3.set(out[6], max.x, min.y, max.z), Vec3.set(out[7], max.x, min.y, min.z);
        }(min, max, vertices), getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
        for (var j = 0; j < 15; ++j) {
            var a = getInterval(vertices, test[j]), b = getInterval(vertices2, test[j]);
            if (b[0] > a[1] || a[0] > b[1]) return 0;
        }
        return 1;
    };
}(), aabb_plane = function aabb_plane(aabb, plane) {
    var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z), dot = Vec3.dot(plane.n, aabb.center);
    return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
}, aabb_frustum = function aabb_frustum(aabb, frustum) {
    for (var i = 0; i < frustum.planes.length; i++) if (-1 === aabb_plane(aabb, frustum.planes[i])) return 0;
    return 1;
}, aabb_frustum_accurate = function() {
    for (var tmp = new Array(8), out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
    return function(aabb, frustum) {
        for (var result = 0, intersects = !1, _i3 = 0; _i3 < frustum.planes.length; _i3++) {
            if (-1 === (result = aabb_plane(aabb, frustum.planes[_i3]))) return 0;
            1 === result && (intersects = !0);
        }
        if (!intersects) return 1;
        for (var _i4 = 0; _i4 < frustum.vertices.length; _i4++) Vec3.subtract(tmp[_i4], frustum.vertices[_i4], aabb.center);
        out1 = 0, out2 = 0;
        for (var _i5 = 0; _i5 < frustum.vertices.length; _i5++) tmp[_i5].x > aabb.halfExtents.x ? out1++ : tmp[_i5].x < -aabb.halfExtents.x && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i6 = 0; _i6 < frustum.vertices.length; _i6++) tmp[_i6].y > aabb.halfExtents.y ? out1++ : tmp[_i6].y < -aabb.halfExtents.y && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i7 = 0; _i7 < frustum.vertices.length; _i7++) tmp[_i7].z > aabb.halfExtents.z ? out1++ : tmp[_i7].z < -aabb.halfExtents.z && out2++;
        return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
    };
}(), obb_point = function() {
    var tmp = new Vec3(0, 0, 0), m3 = new Mat3();
    return function(obb, point) {
        return Vec3.subtract(tmp, point, obb.center), Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation)), 
        function lessThan(a, b) {
            return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
        }(tmp, obb.halfExtents);
    };
}(), obb_plane = (absDot = function absDot(n, x, y, z) {
    return Math.abs(n.x * x + n.y * y + n.z * z);
}, function(obb, plane) {
    var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), dot = Vec3.dot(plane.n, obb.center);
    return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
}), obb_frustum = function obb_frustum(obb, frustum) {
    for (var i = 0; i < frustum.planes.length; i++) if (-1 === obb_plane(obb, frustum.planes[i])) return 0;
    return 1;
}, obb_frustum_accurate = function() {
    for (var tmp = new Array(8), dist = 0, out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
    var dot = function dot(n, x, y, z) {
        return n.x * x + n.y * y + n.z * z;
    };
    return function(obb, frustum) {
        for (var result = 0, intersects = !1, _i8 = 0; _i8 < frustum.planes.length; _i8++) {
            if (-1 === (result = obb_plane(obb, frustum.planes[_i8]))) return 0;
            1 === result && (intersects = !0);
        }
        if (!intersects) return 1;
        for (var _i9 = 0; _i9 < frustum.vertices.length; _i9++) Vec3.subtract(tmp[_i9], frustum.vertices[_i9], obb.center);
        out1 = 0, out2 = 0;
        for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) (dist = dot(tmp[_i10], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02)) > obb.halfExtents.x ? out1++ : dist < -obb.halfExtents.x && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) (dist = dot(tmp[_i11], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05)) > obb.halfExtents.y ? out1++ : dist < -obb.halfExtents.y && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) (dist = dot(tmp[_i12], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08)) > obb.halfExtents.z ? out1++ : dist < -obb.halfExtents.z && out2++;
        return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
    };
}(), obb_obb = function() {
    for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
    for (var vertices = new Array(8), vertices2 = new Array(8), _i13 = 0; _i13 < 8; _i13++) vertices[_i13] = new Vec3(0, 0, 0), 
    vertices2[_i13] = new Vec3(0, 0, 0);
    return function(obb1, obb2) {
        Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02), 
        Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05), 
        Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08), 
        Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02), 
        Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05), 
        Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
        for (var _i14 = 0; _i14 < 3; ++_i14) Vec3.cross(test[6 + 3 * _i14 + 0], test[_i14], test[0]), 
        Vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[1]), Vec3.cross(test[6 + 3 * _i14 + 1], test[_i14], test[2]);
        getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices), 
        getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
        for (var _i15 = 0; _i15 < 15; ++_i15) {
            var a = getInterval(vertices, test[_i15]), b = getInterval(vertices2, test[_i15]);
            if (b[0] > a[1] || a[0] > b[1]) return 0;
        }
        return 1;
    };
}(), sphere_plane = function sphere_plane(sphere, plane) {
    var dot = Vec3.dot(plane.n, sphere.center), r = sphere.radius * plane.n.length();
    return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
}, sphere_frustum = function sphere_frustum(sphere, frustum) {
    for (var i = 0; i < frustum.planes.length; i++) if (-1 === sphere_plane(sphere, frustum.planes[i])) return 0;
    return 1;
}, sphere_frustum_accurate = function() {
    var pt = new Vec3(0, 0, 0), map = [ 1, -1, 1, -1, 1, -1 ];
    return function(sphere, frustum) {
        for (var i = 0; i < 6; i++) {
            var plane = frustum.planes[i], r = sphere.radius, c = sphere.center, n = plane.n, d = plane.d, dot = Vec3.dot(n, c);
            if (dot + r < d) return 0;
            if (!(dot - r > d)) {
                Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));
                for (var j = 0; j < 6; j++) if (j !== i && j !== i + map[i]) {
                    var test = frustum.planes[j];
                    if (Vec3.dot(test.n, pt) < test.d) return 0;
                }
            }
        }
        return 1;
    };
}(), sphere_sphere = function sphere_sphere(sphere0, sphere1) {
    var r = sphere0.radius + sphere1.radius;
    return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
}, sphere_aabb = function() {
    var pt = new Vec3();
    return function(sphere, aabb) {
        return pt_point_aabb(pt, sphere.center, aabb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
    };
}(), sphere_obb = function() {
    var pt = new Vec3();
    return function(sphere, obb) {
        return pt_point_obb(pt, sphere.center, obb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
    };
}(), intersect = {
    ray_sphere: ray_sphere,
    ray_aabb: ray_aabb,
    ray_obb: ray_obb,
    ray_plane: ray_plane,
    ray_triangle: ray_triangle,
    line_plane: line_plane,
    line_triangle: line_triangle,
    line_quad: line_quad,
    sphere_sphere: sphere_sphere,
    sphere_aabb: sphere_aabb,
    sphere_obb: sphere_obb,
    sphere_plane: sphere_plane,
    sphere_frustum: sphere_frustum,
    sphere_frustum_accurate: sphere_frustum_accurate,
    aabb_aabb: aabb_aabb,
    aabb_obb: aabb_obb,
    aabb_plane: aabb_plane,
    aabb_frustum: aabb_frustum,
    aabb_frustum_accurate: aabb_frustum_accurate,
    obb_obb: obb_obb,
    obb_plane: obb_plane,
    obb_frustum: obb_frustum,
    obb_frustum_accurate: obb_frustum_accurate,
    obb_point: obb_point,
    resolve: function resolve(g1, g2) {
        var outPt = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, type1 = g1._type, type2 = g2._type, resolver = this[type1 | type2];
        return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
    }
};

intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = ray_sphere, intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = ray_aabb, 
intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = ray_obb, intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = ray_plane, 
intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = ray_triangle, intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = line_plane, 
intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = line_triangle, intersect[enums.SHAPE_SPHERE] = sphere_sphere, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphere_aabb, intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphere_obb, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = sphere_plane, intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphere_frustum, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate, 
intersect[enums.SHAPE_AABB] = aabb_aabb, intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabb_obb, 
intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabb_plane, intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabb_frustum, 
intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate, 
intersect[enums.SHAPE_OBB] = obb_obb, intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obb_plane, 
intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obb_frustum, intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate;

var line = function() {
    function line() {
        var sx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, sy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, sz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, ex = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, ey = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, ez = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
        _classCallCheck(this, line), this.s = void 0, this.e = void 0, this._type = void 0, 
        this._type = enums.SHAPE_LINE, this.s = new Vec3(sx, sy, sz), this.e = new Vec3(ex, ey, ez);
    }
    return _createClass(line, null, [ {
        key: "create",
        value: function create(sx, sy, sz, ex, ey, ez) {
            return new line(sx, sy, sz, ex, ey, ez);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.s, a.s), Vec3.copy(out.e, a.e), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, start, end) {
            return Vec3.copy(out.s, start), Vec3.copy(out.e, end), out;
        }
    }, {
        key: "set",
        value: function set(out, sx, sy, sz, ex, ey, ez) {
            return out.s.x = sx, out.s.y = sy, out.s.z = sz, out.e.x = ex, out.e.y = ey, out.e.z = ez, 
            out;
        }
    }, {
        key: "len",
        value: function len(a) {
            return Vec3.distance(a.s, a.e);
        }
    } ]), _createClass(line, [ {
        key: "length",
        value: function length() {
            return Vec3.distance(this.s, this.e);
        }
    } ]), line;
}(), v1 = new Vec3(0, 0, 0), v2$1 = new Vec3(0, 0, 0), temp_mat = cc.mat4(), temp_vec4 = cc.v4(), plane = function() {
    function plane() {
        var nx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, ny = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, nz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        _classCallCheck(this, plane), this.n = void 0, this.d = void 0, this._type = void 0, 
        this._type = enums.SHAPE_PLANE, this.n = new Vec3(nx, ny, nz), this.d = d;
    }
    return _createClass(plane, null, [ {
        key: "create",
        value: function create(nx, ny, nz, d) {
            return new plane(nx, ny, nz, d);
        }
    }, {
        key: "clone",
        value: function clone(p) {
            return new plane(p.n.x, p.n.y, p.n.z, p.d);
        }
    }, {
        key: "copy",
        value: function copy(out, p) {
            return Vec3.copy(out.n, p.n), out.d = p.d, out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, a, b, c) {
            return Vec3.subtract(v1, b, a), Vec3.subtract(v2$1, c, a), Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1)), 
            out.d = Vec3.dot(out.n, a), out;
        }
    }, {
        key: "set",
        value: function set(out, nx, ny, nz, d) {
            return out.n.x = nx, out.n.y = ny, out.n.z = nz, out.d = d, out;
        }
    }, {
        key: "fromNormalAndPoint",
        value: function fromNormalAndPoint(out, normal, point) {
            return Vec3.copy(out.n, normal), out.d = Vec3.dot(normal, point), out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var len = a.n.length();
            return Vec3.normalize(out.n, a.n), len > 0 && (out.d = a.d / len), out;
        }
    } ]), _createClass(plane, [ {
        key: "transform",
        value: function transform(mat) {
            Mat4.invert(temp_mat, mat), Mat4.transpose(temp_mat, temp_mat), Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d), 
            Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat), Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z), 
            this.d = temp_vec4.w;
        }
    } ]), plane;
}(), ray = function() {
    function ray() {
        var ox = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, oy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, oz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, dx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, dy = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, dz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
        _classCallCheck(this, ray), this.o = void 0, this.d = void 0, this._type = void 0, 
        this._type = enums.SHAPE_RAY, this.o = new Vec3(ox, oy, oz), this.d = new Vec3(dx, dy, dz);
    }
    return _createClass(ray, null, [ {
        key: "create",
        value: function create() {
            var ox = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, oy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, oz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, dx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, dy = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, dz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
            return new ray(ox, oy, oz, dx, dy, dz);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.o, a.o), Vec3.copy(out.d, a.d), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, origin, target) {
            return Vec3.copy(out.o, origin), Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin)), 
            out;
        }
    }, {
        key: "set",
        value: function set(out, ox, oy, oz, dx, dy, dz) {
            return out.o.x = ox, out.o.y = oy, out.o.z = oz, out.d.x = dx, out.d.y = dy, out.d.z = dz, 
            out;
        }
    } ]), ray;
}(), triangle = function() {
    function triangle() {
        var ax = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, ay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, az = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, bx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, by = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, bz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, cx = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, cy = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 1, cz = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0;
        _classCallCheck(this, triangle), this.a = void 0, this.b = void 0, this.c = void 0, 
        this._type = void 0, this._type = enums.SHAPE_TRIANGLE, this.a = new Vec3(ax, ay, az), 
        this.b = new Vec3(bx, by, bz), this.c = new Vec3(cx, cy, cz);
    }
    return _createClass(triangle, null, [ {
        key: "create",
        value: function create() {
            var ax = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, ay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, az = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, bx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, by = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, bz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, cx = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, cy = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, cz = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
            return new triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
        }
    }, {
        key: "clone",
        value: function clone(t) {
            return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
        }
    }, {
        key: "copy",
        value: function copy(out, t) {
            return Vec3.copy(out.a, t.a), Vec3.copy(out.b, t.b), Vec3.copy(out.c, t.c), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, a, b, c) {
            return Vec3.copy(out.a, a), Vec3.copy(out.b, b), Vec3.copy(out.c, c), out;
        }
    }, {
        key: "set",
        value: function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
            return out.a.x = ax, out.a.y = ay, out.a.z = az, out.b.x = bx, out.b.y = by, out.b.z = bz, 
            out.c.x = cx, out.c.y = cy, out.c.z = cz, out;
        }
    } ]), triangle;
}(), _v3_tmp = new Vec3();

function maxComponent(v) {
    return Math.max(Math.max(v.x, v.y), v.z);
}

var sphere = function() {
    function sphere() {
        var cx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, cy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, cz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, sphere), this.center = void 0, this.radius = void 0, this._type = void 0, 
        this._type = enums.SHAPE_SPHERE, this.center = new Vec3(cx, cy, cz), this.radius = r;
    }
    return _createClass(sphere, null, [ {
        key: "create",
        value: function create(cx, cy, cz, r) {
            return new sphere(cx, cy, cz, r);
        }
    }, {
        key: "clone",
        value: function clone(p) {
            return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
        }
    }, {
        key: "copy",
        value: function copy(out, p) {
            return Vec3.copy(out.center, p.center), out.radius = p.radius, out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, minPos, maxPos) {
            return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), .5), out.radius = .5 * Vec3.subtract(_v3_tmp, maxPos, minPos).length(), 
            out;
        }
    }, {
        key: "set",
        value: function set(out, cx, cy, cz, r) {
            return out.center.x = cx, out.center.y = cy, out.center.z = cz, out.radius = r, 
            out;
        }
    } ]), _createClass(sphere, [ {
        key: "clone",
        value: function clone() {
            return sphere.clone(this);
        }
    }, {
        key: "copy",
        value: function copy(a) {
            return sphere.copy(this, a);
        }
    }, {
        key: "getBoundary",
        value: function getBoundary(minPos, maxPos) {
            Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius), 
            Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            Vec3.transformMat4(out.center, this.center, m), out.radius = this.radius * maxComponent(scale);
        }
    }, {
        key: "translateAndRotate",
        value: function translateAndRotate(m, rot, out) {
            Vec3.transformMat4(out.center, this.center, m);
        }
    }, {
        key: "setScale",
        value: function setScale(scale, out) {
            out.radius = this.radius * maxComponent(scale);
        }
    } ]), sphere;
}(), _v3_tmp$1 = new Vec3(), _v3_tmp2 = new Vec3(), _v3_tmp3 = new Vec3(), _v3_tmp4 = new Vec3(), _m3_tmp = new Mat3(), transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
    _m3_tmp.m00 = Math.abs(m4.m00), _m3_tmp.m01 = Math.abs(m4.m01), _m3_tmp.m02 = Math.abs(m4.m02), 
    _m3_tmp.m03 = Math.abs(m4.m04), _m3_tmp.m04 = Math.abs(m4.m05), _m3_tmp.m05 = Math.abs(m4.m06), 
    _m3_tmp.m06 = Math.abs(m4.m08), _m3_tmp.m07 = Math.abs(m4.m09), _m3_tmp.m08 = Math.abs(m4.m10), 
    Vec3.transformMat3(out, extent, _m3_tmp);
}, aabb = function() {
    function aabb() {
        var px = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, py = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, pz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, hw = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, hh = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, hl = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
        _classCallCheck(this, aabb), this.center = void 0, this.halfExtents = void 0, this._type = enums.SHAPE_AABB, 
        this.center = new Vec3(px, py, pz), this.halfExtents = new Vec3(hw, hh, hl);
    }
    return _createClass(aabb, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(px, py, pz, hw, hh, hl) {
            return new aabb(px, py, pz, hw, hh, hl);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
            out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, minPos, maxPos) {
            return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$1, minPos, maxPos), .5), 
            Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2, maxPos, minPos), .5), 
            out;
        }
    }, {
        key: "set",
        value: function set(out, px, py, pz, hw, hh, hl) {
            return Vec3.set(out.center, px, py, pz), Vec3.set(out.halfExtents, hw, hh, hl), 
            out;
        }
    }, {
        key: "merge",
        value: function merge(out, a, b) {
            return Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents), Vec3.subtract(_v3_tmp2, b.center, b.halfExtents), 
            Vec3.add(_v3_tmp3, a.center, a.halfExtents), Vec3.add(_v3_tmp4, b.center, b.halfExtents), 
            Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4), Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2), 
            aabb.fromPoints(out, _v3_tmp3, _v3_tmp4);
        }
    }, {
        key: "transform",
        value: function transform(out, a, matrix) {
            return Vec3.transformMat4(out.center, a.center, matrix), transform_extent_m4(out.halfExtents, a.halfExtents, matrix), 
            out;
        }
    } ]), _createClass(aabb, [ {
        key: "getBoundary",
        value: function getBoundary(minPos, maxPos) {
            Vec3.subtract(minPos, this.center, this.halfExtents), Vec3.add(maxPos, this.center, this.halfExtents);
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            Vec3.transformMat4(out.center, this.center, m), transform_extent_m4(out.halfExtents, this.halfExtents, m);
        }
    }, {
        key: "clone",
        value: function clone() {
            return aabb.clone(this);
        }
    }, {
        key: "copy",
        value: function copy(a) {
            return aabb.copy(this, a);
        }
    } ]), aabb;
}(), _v3_tmp$2 = new Vec3(), _v3_tmp2$1 = new Vec3(), _m3_tmp$1 = new Mat3(), obb = function() {
    function obb() {
        var cx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, cy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, cz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, hw = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, hh = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, hl = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, ox_1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, ox_2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, ox_3 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, oy_1 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, oy_2 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, oy_3 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, oz_1 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, oz_2 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, oz_3 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 1;
        _classCallCheck(this, obb), this.center = void 0, this.halfExtents = void 0, this.orientation = void 0, 
        this._type = void 0, this._type = enums.SHAPE_OBB, this.center = new Vec3(cx, cy, cz), 
        this.halfExtents = new Vec3(hw, hh, hl), this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
    }
    return _createClass(obb, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
            return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
            Mat3.copy(out.orientation, a.orientation), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, minPos, maxPos) {
            return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), .5), 
            Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), .5), 
            Mat3.identity(out.orientation), out;
        }
    }, {
        key: "set",
        value: function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
            return Vec3.set(out.center, cx, cy, cz), Vec3.set(out.halfExtents, hw, hh, hl), 
            Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3), 
            out;
        }
    } ]), _createClass(obb, [ {
        key: "getBoundary",
        value: function getBoundary(minPos, maxPos) {
            !function transform_extent_m3(out, extent, m3) {
                _m3_tmp$1.m00 = Math.abs(m3.m00), _m3_tmp$1.m01 = Math.abs(m3.m01), _m3_tmp$1.m02 = Math.abs(m3.m02), 
                _m3_tmp$1.m03 = Math.abs(m3.m03), _m3_tmp$1.m04 = Math.abs(m3.m04), _m3_tmp$1.m05 = Math.abs(m3.m05), 
                _m3_tmp$1.m06 = Math.abs(m3.m06), _m3_tmp$1.m07 = Math.abs(m3.m07), _m3_tmp$1.m08 = Math.abs(m3.m08), 
                Vec3.transformMat3(out, extent, _m3_tmp$1);
            }(_v3_tmp$2, this.halfExtents, this.orientation), Vec3.subtract(minPos, this.center, _v3_tmp$2), 
            Vec3.add(maxPos, this.center, _v3_tmp$2);
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot), 
            Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
    }, {
        key: "translateAndRotate",
        value: function translateAndRotate(m, rot, out) {
            Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot);
        }
    }, {
        key: "setScale",
        value: function setScale(scale, out) {
            Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
    } ]), obb;
}(), _v = new Array(8);

_v[0] = new Vec3(1, 1, 1), _v[1] = new Vec3(-1, 1, 1), _v[2] = new Vec3(-1, -1, 1), 
_v[3] = new Vec3(1, -1, 1), _v[4] = new Vec3(1, 1, -1), _v[5] = new Vec3(-1, 1, -1), 
_v[6] = new Vec3(-1, -1, -1), _v[7] = new Vec3(1, -1, -1);

var frustum = function() {
    function frustum() {
        _classCallCheck(this, frustum), this.planes = void 0, this.vertices = void 0, this._type = void 0, 
        this._type = enums.SHAPE_FRUSTUM, this.planes = new Array(6);
        for (var i = 0; i < 6; ++i) this.planes[i] = plane.create(0, 0, 0, 0);
        this.vertices = new Array(8);
        for (var _i2 = 0; _i2 < 8; ++_i2) this.vertices[_i2] = new Vec3();
    }
    return _createClass(frustum, [ {
        key: "accurate",
        set: function set(b) {
            this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
        }
    } ], [ {
        key: "create",
        value: function create() {
            return new frustum();
        }
    }, {
        key: "clone",
        value: function clone(f) {
            return frustum.copy(new frustum(), f);
        }
    }, {
        key: "copy",
        value: function copy(out, f) {
            out._type = f._type;
            for (var i = 0; i < 6; ++i) plane.copy(out.planes[i], f.planes[i]);
            for (var _i = 0; _i < 8; ++_i) Vec3.copy(out.vertices[_i], f.vertices[_i]);
            return out;
        }
    } ]), _createClass(frustum, [ {
        key: "update",
        value: function update(m, inv) {
            if (Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08), this.planes[0].d = -(m.m15 + m.m12), 
            Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08), this.planes[1].d = -(m.m15 - m.m12), 
            Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09), this.planes[2].d = -(m.m15 + m.m13), 
            Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09), this.planes[3].d = -(m.m15 - m.m13), 
            Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10), this.planes[4].d = -(m.m15 + m.m14), 
            Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10), this.planes[5].d = -(m.m15 - m.m14), 
            this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                for (var i = 0; i < 6; i++) {
                    var pl = this.planes[i], invDist = 1 / pl.n.length();
                    Vec3.multiplyScalar(pl.n, pl.n, invDist), pl.d *= invDist;
                }
                for (var _i3 = 0; _i3 < 8; _i3++) Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
            }
        }
    }, {
        key: "transform",
        value: function transform(mat) {
            if (this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                for (var i = 0; i < 8; i++) Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]), 
                plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]), 
                plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]), 
                plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]), 
                plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]), 
                plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
            }
        }
    } ]), frustum;
}();

frustum.createOrtho = function() {
    var _temp_v3 = new Vec3();
    return function(out, width, height, near, far, transform) {
        var halfWidth = width / 2, halfHeight = height / 2;
        Vec3.set(_temp_v3, halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[0], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[1], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[2], _temp_v3, transform), 
        Vec3.set(_temp_v3, halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[3], _temp_v3, transform), 
        Vec3.set(_temp_v3, halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[4], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[5], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[6], _temp_v3, transform), 
        Vec3.set(_temp_v3, halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[7], _temp_v3, transform), 
        plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]), 
        plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]), 
        plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]), 
        plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]), 
        plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]), 
        plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
    };
}();

for (var CircularPool = function() {
    function CircularPool(fn, size) {
        _classCallCheck(this, CircularPool), this._cursor = void 0, this._data = void 0, 
        this._cursor = 0, this._data = new Array(size);
        for (var i = 0; i < size; ++i) this._data[i] = fn();
    }
    return _createClass(CircularPool, [ {
        key: "request",
        value: function request() {
            var item = this._data[this._cursor];
            return this._cursor = (this._cursor + 1) % this._data.length, item;
        }
    } ]), CircularPool;
}(), FixedArray = function() {
    function FixedArray(size) {
        _classCallCheck(this, FixedArray), this._count = void 0, this._data = void 0, this._count = 0, 
        this._data = new Array(size);
    }
    return _createClass(FixedArray, [ {
        key: "_resize",
        value: function _resize(size) {
            if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = void 0;
        }
    }, {
        key: "reset",
        value: function reset() {
            for (var i = 0; i < this._count; ++i) this._data[i] = void 0;
            this._count = 0;
        }
    }, {
        key: "push",
        value: function push(val) {
            this._count >= this._data.length && this._resize(2 * this._data.length), this._data[this._count] = val, 
            ++this._count;
        }
    }, {
        key: "pop",
        value: function pop() {
            --this._count, this._count < 0 && (this._count = 0);
            var ret = this._data[this._count];
            return this._data[this._count] = void 0, ret;
        }
    }, {
        key: "fastRemove",
        value: function fastRemove(idx) {
            if (!(idx >= this._count || idx < 0)) {
                var last = this._count - 1;
                this._data[idx] = this._data[last], this._data[last] = void 0, this._count -= 1;
            }
        }
    }, {
        key: "indexOf",
        value: function indexOf(val) {
            return this._data.indexOf(val);
        }
    }, {
        key: "sort",
        value: function sort(cmp) {
            return _sort(this._data, 0, this._count, cmp);
        }
    }, {
        key: "length",
        get: function get() {
            return this._count;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    } ]), FixedArray;
}(), LinkedArray = function() {
    function LinkedArray(fn, size) {
        _classCallCheck(this, LinkedArray), this._fn = void 0, this._count = void 0, this._head = void 0, 
        this._tail = void 0, this._pool = void 0, this._fn = fn, this._count = 0, this._head = null, 
        this._tail = null, this._pool = new Pool$1(fn, size);
    }
    return _createClass(LinkedArray, [ {
        key: "add",
        value: function add() {
            var node = this._pool.alloc();
            return this._tail ? (this._tail._next = node, node._prev = this._tail) : this._head = node, 
            this._tail = node, this._count += 1, node;
        }
    }, {
        key: "remove",
        value: function remove(node) {
            node._prev ? node._prev._next = node._next : this._head = node._next, node._next ? node._next._prev = node._prev : this._tail = node._prev, 
            node._next = null, node._prev = null, this._pool.free(node), this._count -= 1;
        }
    }, {
        key: "forEach",
        value: function forEach(fn, binder) {
            var cursor = this._head;
            if (cursor) {
                binder && (fn = fn.bind(binder));
                for (var idx = 0, next = cursor; cursor; ) next = cursor._next, fn(cursor, idx, this), 
                cursor = next, ++idx;
            }
        }
    }, {
        key: "head",
        get: function get() {
            return this._head;
        }
    }, {
        key: "tail",
        get: function get() {
            return this._tail;
        }
    }, {
        key: "length",
        get: function get() {
            return this._count;
        }
    } ]), LinkedArray;
}(), _bufferPools = Array(8), i$1 = 0; i$1 < 8; ++i$1) _bufferPools[i$1] = [];

function _log2(v) {
    var r = (v > 65535) << 4, shift = ((v >>>= r) > 255) << 3;
    return r |= shift, r |= shift = ((v >>>= shift) > 15) << 2, (r |= shift = ((v >>>= shift) > 3) << 1) | (v >>>= shift) >> 1;
}

function _alloc(n) {
    var sz = function _nextPow16(v) {
        for (var _i = 16; _i <= 1 << 28; _i *= 16) if (v <= _i) return _i;
        return 0;
    }(n), bin = _bufferPools[_log2(sz) >> 2];
    return bin.length > 0 ? bin.pop() : new ArrayBuffer(sz);
}

var typedArrayPool = {
    alloc_int8: function alloc_int8(n) {
        var result = new Int8Array(_alloc(n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_uint8: function alloc_uint8(n) {
        var result = new Uint8Array(_alloc(n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_int16: function alloc_int16(n) {
        var result = new Int16Array(_alloc(2 * n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_uint16: function alloc_uint16(n) {
        var result = new Uint16Array(_alloc(2 * n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_int32: function alloc_int32(n) {
        var result = new Int32Array(_alloc(4 * n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_uint32: function alloc_uint32(n) {
        var result = new Uint32Array(_alloc(4 * n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_float32: function alloc_float32(n) {
        var result = new Float32Array(_alloc(4 * n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    alloc_float64: function alloc_float64(n) {
        var result = new Float64Array(_alloc(8 * n), 0, n);
        return result.length !== n ? result.subarray(0, n) : result;
    },
    free: function free(array) {
        !function _free(buf) {
            _bufferPools[_log2(buf.byteLength) >> 2].push(buf);
        }(array.buffer);
    },
    reset: function reset() {
        _bufferPools = Array(8);
        for (var _i2 = 0; _i2 < 8; ++_i2) _bufferPools[_i2] = [];
    }
}, mul = function mul(out, v, x, y, z) {
    return Vec3.set(out, v.x * x, v.y * y, v.z * z);
}, OctreeBlock = function() {
    function OctreeBlock(minPos, maxPos, capacity, depth, maxDepth, getBoundingShape) {
        _classCallCheck(this, OctreeBlock), this.minPos = void 0, this.maxPos = void 0, 
        this.boundingBox = void 0, this.capacity = void 0, this.depth = void 0, this.maxDepth = void 0, 
        this.blocks = void 0, this.entries = void 0, this._getBoundingShape = void 0, this.minPos = minPos, 
        this.maxPos = maxPos, this.boundingBox = aabb.fromPoints(aabb.create(), minPos, maxPos), 
        this.capacity = capacity, this.depth = depth, this.maxDepth = maxDepth, this._getBoundingShape = getBoundingShape, 
        this.blocks = null, this.entries = new FixedArray(this.capacity);
    }
    return _createClass(OctreeBlock, [ {
        key: "addEntry",
        value: function addEntry(entry) {
            if (this.blocks) {
                var _iterator = this.blocks, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.addEntry(entry);
                }
            } else {
                var shape = this._getBoundingShape(entry);
                if (!intersect.resolve(this.boundingBox, shape)) return;
                this.entries.push(entry), this.entries.length >= this.capacity && this.depth < this.maxDepth && (this.blocks = Octree.createBlocks(this.minPos, this.maxPos, this.entries, this.capacity, this.depth, this.maxDepth, this._getBoundingShape), 
                this.entries.reset());
            }
        }
    }, {
        key: "removeEntry",
        value: function removeEntry(entry) {
            if (this.blocks) {
                var _iterator2 = this.blocks, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.removeEntry(entry);
                }
            } else this.entries.fastRemove(this.entries.indexOf(entry));
        }
    }, {
        key: "select",
        value: function select(out, shape) {
            if (intersect.resolve(this.boundingBox, shape)) if (this.blocks) {
                var _iterator3 = this.blocks, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    _ref3.select(out, shape);
                }
            } else for (var i = 0; i < this.entries.length; i++) out.add(this.entries.data[i]);
        }
    }, {
        key: "frustumSelect",
        value: function frustumSelect(out, frustum) {
            if (intersect.aabb_frustum(this.boundingBox, frustum)) if (this.blocks) {
                var _iterator4 = this.blocks, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.frustumSelect(out, frustum);
                }
            } else for (var i = 0; i < this.entries.length; i++) out.add(this.entries.data[i]);
        }
    } ]), OctreeBlock;
}(), Octree = function() {
    function Octree() {
        var _this = this, blockCapacity = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32, maxDepth = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5;
        _classCallCheck(this, Octree), this.blockCapacity = void 0, this.maxDepth = void 0, 
        this.blocks = void 0, this.dynamics = void 0, this._selection = void 0, this._getBoundingShape = void 0, 
        this.blockCapacity = blockCapacity, this.maxDepth = maxDepth, this.blocks = [], 
        this.dynamics = [], this._selection = new Set(), this._getBoundingShape = function() {
            return _this._getBoundingShape;
        };
    }
    return _createClass(Octree, null, [ {
        key: "createBlocks",
        value: function createBlocks(worldMin, worldMax, entries, blockCapacity, curDepth, maxDepth, getBoundingShape) {
            var blocks = [], blockSize = new Vec3();
            Vec3.multiplyScalar(blockSize, Vec3.subtract(blockSize, worldMax, worldMin), .5);
            for (var x = 0; x < 2; x++) for (var y = 0; y < 2; y++) for (var z = 0; z < 2; z++) {
                var localMin = new Vec3(), localMax = new Vec3();
                Vec3.add(localMin, worldMin, mul(localMin, blockSize, x, y, z)), Vec3.add(localMax, worldMin, mul(localMax, blockSize, x + 1, y + 1, z + 1));
                for (var block = new OctreeBlock(localMin, localMax, blockCapacity, curDepth + 1, maxDepth, getBoundingShape), i = 0; i < entries.length; i++) {
                    var entry = (entries.data || entries)[i];
                    block.addEntry(entry);
                }
                blocks.push(block);
            }
            return blocks;
        }
    } ]), _createClass(Octree, [ {
        key: "build",
        value: function build(entries, getBoundingShape) {
            var worldMin = new Vec3(1 / 0, 1 / 0, 1 / 0), worldMax = new Vec3(-1 / 0, -1 / 0, -1 / 0), minPos = new Vec3(), maxPos = new Vec3(), staticEntries = [];
            this.dynamics = [];
            for (var i = 0; i < entries.length; i++) {
                var entry = (entries.data || entries)[i], shape = getBoundingShape(entry);
                shape ? (shape.getBoundary(minPos, maxPos), Vec3.min(worldMin, worldMin, minPos), 
                Vec3.max(worldMax, worldMax, maxPos), staticEntries.push(entry)) : this.dynamics.push(entry);
            }
            this.blocks = Octree.createBlocks(worldMin, worldMax, staticEntries, this.blockCapacity, 0, this.maxDepth, getBoundingShape), 
            this._getBoundingShape = getBoundingShape;
        }
    }, {
        key: "addEntry",
        value: function addEntry(entry) {
            if (this._getBoundingShape(entry).shape) {
                var _iterator5 = this.blocks, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    _ref5.addEntry(entry);
                }
            } else this.dynamics.push(entry);
        }
    }, {
        key: "removeEntry",
        value: function removeEntry(entry) {
            if (this._getBoundingShape(entry).shape) {
                var _iterator6 = this.blocks, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref6 = _i6.value;
                    }
                    _ref6.removeEntry(entry);
                }
            } else this.dynamics.splice(this.dynamics.indexOf(entry), 1);
        }
    }, {
        key: "select",
        value: function select(shape) {
            this._selection.clear();
            var _iterator7 = this.blocks, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                var _ref7;
                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    if ((_i7 = _iterator7.next()).done) break;
                    _ref7 = _i7.value;
                }
                _ref7.select(this._selection, shape);
            }
            var _iterator8 = this.dynamics, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                var _ref8;
                if (_isArray8) {
                    if (_i8 >= _iterator8.length) break;
                    _ref8 = _iterator8[_i8++];
                } else {
                    if ((_i8 = _iterator8.next()).done) break;
                    _ref8 = _i8.value;
                }
                var dynamic = _ref8;
                this._selection.add(dynamic);
            }
            return this._selection;
        }
    }, {
        key: "frustumSelect",
        value: function frustumSelect(frustum) {
            this._selection.clear();
            var _iterator9 = this.blocks, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                var _ref9;
                if (_isArray9) {
                    if (_i9 >= _iterator9.length) break;
                    _ref9 = _iterator9[_i9++];
                } else {
                    if ((_i9 = _iterator9.next()).done) break;
                    _ref9 = _i9.value;
                }
                _ref9.frustumSelect(this._selection, frustum);
            }
            var _iterator10 = this.dynamics, _isArray10 = Array.isArray(_iterator10), _i10 = 0;
            for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                var _ref10;
                if (_isArray10) {
                    if (_i10 >= _iterator10.length) break;
                    _ref10 = _iterator10[_i10++];
                } else {
                    if ((_i10 = _iterator10.next()).done) break;
                    _ref10 = _i10.value;
                }
                var dynamic = _ref10;
                this._selection.add(dynamic);
            }
            return this._selection;
        }
    } ]), Octree;
}(), WrapMode$1 = Enum({
    Default: 0,
    Once: 1,
    Loop: 2,
    PingPong: 3,
    ClampForever: 4
}), Keyframe = function Keyframe() {
    _classCallCheck(this, Keyframe), this.time = 0, this.value = 0, this.inTangent = 0, 
    this.outTangent = 0;
};

CCClass.fastDefine("cc.Keyframe", Keyframe, {
    time: 0,
    value: 0,
    inTangent: 0,
    outTangent: 0
});

var OptimizedKey = function() {
    function OptimizedKey() {
        _classCallCheck(this, OptimizedKey), this.index = void 0, this.time = void 0, this.endTime = void 0, 
        this.coefficient = void 0, this.index = -1, this.time = 0, this.endTime = 0, this.coefficient = new Float32Array(4);
    }
    return _createClass(OptimizedKey, [ {
        key: "evaluate",
        value: function evaluate(T) {
            return function evalOptCurve(t, coefs) {
                return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
            }(T - this.time, this.coefficient);
        }
    } ]), OptimizedKey;
}();

var AnimationCurve = function() {
    function AnimationCurve() {
        var keyFrames = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        _classCallCheck(this, AnimationCurve), this.keyFrames = void 0, this.preWrapMode = WrapMode$1.Loop, 
        this.postWrapMode = WrapMode$1.Loop, this.cachedKey = void 0, this.keyFrames = keyFrames || [].concat(AnimationCurve.defaultKF), 
        this.cachedKey = new OptimizedKey();
    }
    return _createClass(AnimationCurve, [ {
        key: "addKey",
        value: function addKey(keyFrame) {
            null == this.keyFrames && (this.keyFrames = []), this.keyFrames.push(keyFrame);
        }
    }, {
        key: "evaluate_slow",
        value: function evaluate_slow(time) {
            var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
            switch (wrapMode) {
              case WrapMode$1.Loop:
                wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode$1.PingPong:
                wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode$1.ClampForever:
                wrappedTime = clamp(time, startTime, endTime);
            }
            var preKFIndex = 0;
            if (wrappedTime > this.keyFrames[0].time) if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) preKFIndex = this.keyFrames.length - 2; else for (var i = 0; i < this.keyFrames.length - 1; i++) if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
                preKFIndex = i;
                break;
            }
            var keyframe0 = this.keyFrames[preKFIndex], keyframe1 = this.keyFrames[preKFIndex + 1], t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime), dt = keyframe1.time - keyframe0.time, m0 = keyframe0.outTangent * dt, m1 = keyframe1.inTangent * dt, t2 = t * t, t3 = t2 * t, b = t3 - 2 * t2 + t, c = t3 - t2, d = -2 * t3 + 3 * t2;
            return (2 * t3 - 3 * t2 + 1) * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
        }
    }, {
        key: "evaluate",
        value: function evaluate(time) {
            var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
            switch (wrapMode) {
              case WrapMode$1.Loop:
                wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode$1.PingPong:
                wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode$1.ClampForever:
                wrappedTime = clamp(time, startTime, endTime);
            }
            if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) return this.cachedKey.evaluate(wrappedTime);
            var leftIndex = this.findIndex(this.cachedKey, wrappedTime), rightIndex = leftIndex + 1;
            return rightIndex === this.keyFrames.length && (rightIndex -= 1), this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex), 
            this.cachedKey.evaluate(wrappedTime);
        }
    }, {
        key: "calcOptimizedKey",
        value: function calcOptimizedKey(optKey, leftIndex, rightIndex) {
            var lhs = this.keyFrames[leftIndex], rhs = this.keyFrames[rightIndex];
            optKey.index = leftIndex, optKey.time = lhs.time, optKey.endTime = rhs.time;
            var dx = rhs.time - lhs.time, dy = rhs.value - lhs.value, length = 1 / (dx * dx), d1 = lhs.outTangent * dx, d2 = rhs.inTangent * dx;
            optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx, optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length, 
            optKey.coefficient[2] = lhs.outTangent, optKey.coefficient[3] = lhs.value;
        }
    }, {
        key: "findIndex",
        value: function findIndex(optKey, t) {
            var cachedIndex = optKey.index;
            if (-1 !== cachedIndex) if (t > this.keyFrames[cachedIndex].time) for (var i = 0; i < 3; i++) {
                var currIndex = cachedIndex + i;
                if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) return currIndex;
            } else for (var _i = 0; _i < 3; _i++) {
                var _currIndex = cachedIndex - _i;
                if (_currIndex >= 0 && this.keyFrames[_currIndex - 1].time <= t) return _currIndex - 1;
            }
            for (var left = 0, right = this.keyFrames.length, mid = Math.floor((left + right) / 2); right - left > 1; ) this.keyFrames[mid].time >= t ? right = mid : left = mid + 1, 
            mid = Math.floor((left + right) / 2);
            return left;
        }
    } ]), AnimationCurve;
}();

AnimationCurve.defaultKF = [ {
    time: 0,
    value: 1,
    inTangent: 0,
    outTangent: 0
}, {
    time: 1,
    value: 1,
    inTangent: 0,
    outTangent: 0
} ], CCClass.fastDefine("cc.AnimationCurve", AnimationCurve, {
    preWrapMode: WrapMode$1.Default,
    postWrapMode: WrapMode$1.Default,
    keyFrames: []
}), replaceProperty(line.prototype, "line", [ {
    name: "mag",
    newName: "len"
}, {
    name: "magnitude",
    newName: "len"
} ]);

var _typeMap2, _keyMap, geometry = Object.freeze({
    distance: distance,
    enums: enums,
    intersect: intersect,
    line: line,
    plane: plane,
    ray: ray,
    triangle: triangle,
    sphere: sphere,
    aabb: aabb,
    obb: obb,
    frustum: frustum,
    Octree: Octree,
    Keyframe: Keyframe,
    AnimationCurve: AnimationCurve
});

!function(_keyMap) {
    _keyMap[_keyMap.positions = GFXAttributeName.ATTR_POSITION] = "positions", _keyMap[_keyMap.normals = GFXAttributeName.ATTR_NORMAL] = "normals", 
    _keyMap[_keyMap.uvs = GFXAttributeName.ATTR_TEX_COORD] = "uvs", _keyMap[_keyMap.colors = GFXAttributeName.ATTR_COLOR] = "colors";
}(_keyMap || (_keyMap = {}));

var _defAttrs = [ {
    name: GFXAttributeName.ATTR_POSITION,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_NORMAL,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD,
    format: GFXFormat.RG32F
}, {
    name: GFXAttributeName.ATTR_COLOR,
    format: GFXFormat.RGBA32F
} ], v3_1$4 = new Vec3();

function createMesh(geometry, out, options) {
    options = options || {};
    var attr, attributes = [], stride = 0, channels = [], vertCount = 0;
    if (geometry.positions.length > 0) {
        if (attr = null, geometry.attributes) {
            var _iterator = geometry.attributes, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var att = _ref;
                if (att.name === GFXAttributeName.ATTR_POSITION) {
                    attr = att;
                    break;
                }
            }
        }
        attr || (attr = _defAttrs[0]);
        var info = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.positions.length / info.count)), 
        channels.push({
            offset: stride,
            data: geometry.positions,
            attribute: attr
        }), stride += info.size;
    }
    if (geometry.normals && geometry.normals.length > 0) {
        if (attr = null, geometry.attributes) {
            var _iterator2 = geometry.attributes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var _att = _ref2;
                if (_att.name === GFXAttributeName.ATTR_NORMAL) {
                    attr = _att;
                    break;
                }
            }
        }
        attr || (attr = _defAttrs[1]);
        var _info = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count)), 
        channels.push({
            offset: stride,
            data: geometry.normals,
            attribute: attr
        }), stride += _info.size;
    }
    if (geometry.uvs && geometry.uvs.length > 0) {
        if (attr = null, geometry.attributes) {
            var _iterator3 = geometry.attributes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var _att2 = _ref3;
                if (_att2.name === GFXAttributeName.ATTR_TEX_COORD) {
                    attr = _att2;
                    break;
                }
            }
        }
        attr || (attr = _defAttrs[2]);
        var _info2 = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count)), 
        channels.push({
            offset: stride,
            data: geometry.uvs,
            attribute: attr
        }), stride += _info2.size;
    }
    if (geometry.colors && geometry.colors.length > 0) {
        if (attr = null, geometry.attributes) {
            var _iterator4 = geometry.attributes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                var _att3 = _ref4;
                if (_att3.name === GFXAttributeName.ATTR_COLOR) {
                    attr = _att3;
                    break;
                }
            }
        }
        attr || (attr = _defAttrs[3]);
        var _info3 = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info3.count)), 
        channels.push({
            offset: stride,
            data: geometry.colors,
            attribute: attr
        }), stride += _info3.size;
    }
    if (geometry.customAttributes) {
        var _iterator5 = geometry.customAttributes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
            var _ref5;
            if (_isArray5) {
                if (_i5 >= _iterator5.length) break;
                _ref5 = _iterator5[_i5++];
            } else {
                if ((_i5 = _iterator5.next()).done) break;
                _ref5 = _i5.value;
            }
            var ca = _ref5, _info4 = GFXFormatInfos[ca.attr.format];
            attributes.push(ca.attr), vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info4.count)), 
            channels.push({
                offset: stride,
                data: ca.values,
                attribute: ca.attr
            }), stride += _info4.size;
        }
    }
    for (var bufferBlob = new BufferBlob(), vertexBuffer = new ArrayBuffer(vertCount * stride), vertexBufferView = new DataView(vertexBuffer), _i6 = 0, _channels = channels; _i6 < _channels.length; _i6++) {
        var channel = _channels[_i6];
        writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
    }
    bufferBlob.setNextAlignment(0);
    var vertexBundle = {
        attributes: attributes,
        view: {
            offset: bufferBlob.getLength(),
            length: vertexBuffer.byteLength,
            count: vertCount,
            stride: stride
        }
    };
    bufferBlob.addBuffer(vertexBuffer);
    var indexBuffer = null, idxCount = 0;
    if (geometry.indices) {
        var indices = geometry.indices;
        idxCount = indices.length, indexBuffer = new ArrayBuffer(2 * idxCount), writeBuffer(new DataView(indexBuffer), indices, GFXFormat.R16UI);
    }
    var primitive = {
        primitiveMode: geometry.primitiveMode || GFXPrimitiveMode.TRIANGLE_LIST,
        vertexBundelIndices: [ 0 ]
    };
    if (primitive.primitiveMode >= GFXPrimitiveMode.TRIANGLE_LIST) {
        var geomInfo = Float32Array.from(geometry.positions);
        bufferBlob.setNextAlignment(4), primitive.geometricInfo = {
            doubleSided: geometry.doubleSided,
            view: {
                offset: bufferBlob.getLength(),
                length: geomInfo.byteLength,
                count: geometry.positions.length / 4,
                stride: 4
            }
        }, bufferBlob.addBuffer(geomInfo.buffer);
    }
    indexBuffer && (bufferBlob.setNextAlignment(2), primitive.indexView = {
        offset: bufferBlob.getLength(),
        length: indexBuffer.byteLength,
        count: idxCount,
        stride: 2
    }, bufferBlob.addBuffer(indexBuffer));
    var minPosition = geometry.minPos;
    if (!minPosition && options.calculateBounds) {
        minPosition = Vec3.set(new Vec3(), 1 / 0, 1 / 0, 1 / 0);
        for (var iVertex = 0; iVertex < vertCount; ++iVertex) Vec3.set(v3_1$4, geometry.positions[3 * iVertex + 0], geometry.positions[3 * iVertex + 1], geometry.positions[3 * iVertex + 2]), 
        Vec3.min(minPosition, minPosition, v3_1$4);
    }
    var maxPosition = geometry.maxPos;
    if (!maxPosition && options.calculateBounds) {
        maxPosition = Vec3.set(new Vec3(), -1 / 0, -1 / 0, -1 / 0);
        for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) Vec3.set(v3_1$4, geometry.positions[3 * _iVertex + 0], geometry.positions[3 * _iVertex + 1], geometry.positions[3 * _iVertex + 2]), 
        Vec3.max(maxPosition, maxPosition, v3_1$4);
    }
    var meshStruct = {
        vertexBundles: [ vertexBundle ],
        primitives: [ primitive ]
    };
    return minPosition && (meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z)), 
    maxPosition && (meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z)), 
    out || (out = new Mesh()), out.reset({
        struct: meshStruct,
        data: new Uint8Array(bufferBlob.getCombined())
    }), out;
}

var isLittleEndian$1 = cc.sys.isLittleEndian, _typeMap = (_defineProperty(_typeMap2 = {}, GFXFormatType.UNORM, "Uint"), 
_defineProperty(_typeMap2, GFXFormatType.SNORM, "Int"), _defineProperty(_typeMap2, GFXFormatType.UINT, "Uint"), 
_defineProperty(_typeMap2, GFXFormatType.INT, "Int"), _defineProperty(_typeMap2, GFXFormatType.UFLOAT, "Float"), 
_defineProperty(_typeMap2, GFXFormatType.FLOAT, "Float"), _defineProperty(_typeMap2, "default", "Uint"), 
_typeMap2);

function _getDataViewType(info) {
    return (_typeMap[info.type] || _typeMap.default) + info.size / info.count * 8;
}

function writeBuffer(target, data) {
    var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : GFXFormat.R32F, offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, stride = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, info = GFXFormatInfos[format];
    stride || (stride = info.size);
    for (var writer = "set" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(data.length / info.count), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
        var y = x + componentBytesLength * iComponent;
        target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian$1);
    }
}

function readBuffer(target) {
    var format = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : GFXFormat.R32F, offset = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, length = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : target.byteLength - offset, stride = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, out = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [], info = GFXFormatInfos[format];
    stride || (stride = info.size);
    for (var reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
        var y = x + componentBytesLength * iComponent;
        out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian$1);
    }
    return out;
}

function mapBuffer(target, callback) {
    var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : GFXFormat.R32F, offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, length = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : target.byteLength - offset, stride = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, out = arguments.length > 6 ? arguments[6] : void 0;
    out || (out = new DataView(new ArrayBuffer(target.byteLength)));
    var info = GFXFormatInfos[format];
    stride || (stride = info.size);
    for (var writer = "set" + _getDataViewType(info), reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
        var y = x + componentBytesLength * iComponent, _cur = target[reader](y, isLittleEndian$1);
        out[writer](y, callback(_cur, iComponent, target), isLittleEndian$1);
    }
    return out;
}

var _path = [], LCA = function LCA(a, b) {
    if (a === b) return a;
    var cur = b;
    for (_path.length = 0; cur; ) _path.push(cur), cur = cur.parent;
    for (cur = a; cur; ) {
        if (_path.find(function(n) {
            return n === cur;
        })) return cur;
        cur = cur.parent;
    }
    return null;
}, v3_2$2 = new Vec3();

function calculateBoneSpaceBounds(mesh, skeleton) {
    for (var result = new Array(skeleton.joints.length), i = 0; i < result.length; ++i) result[i] = {
        hasValue: !1,
        min: new Vec3(1 / 0, 1 / 0, 1 / 0),
        max: new Vec3(-1 / 0, -1 / 0, -1 / 0)
    };
    for (var iPrimitive = 0; iPrimitive < mesh.struct.primitives.length; ++iPrimitive) {
        var joints = mesh.readAttribute(iPrimitive, GFXAttributeName.ATTR_JOINTS);
        if (joints) {
            var weights = mesh.readAttribute(iPrimitive, GFXAttributeName.ATTR_WEIGHTS);
            if (weights) {
                var positions = mesh.readAttribute(iPrimitive, GFXAttributeName.ATTR_POSITION);
                if (positions) for (var vertexCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3), iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    Vec3.set(v3_1$4, positions[3 * iVertex + 0], positions[3 * iVertex + 1], positions[3 * iVertex + 2]);
                    for (var _i9 = 0; _i9 < 4; ++_i9) {
                        if (0 !== weights[4 * iVertex + _i9]) {
                            var refJointIndex = joints[4 * iVertex + _i9];
                            if (!(refJointIndex >= skeleton.joints.length)) {
                                skeleton.bindposes ? Vec3.transformMat4(v3_2$2, v3_1$4, skeleton.bindposes[refJointIndex]) : Vec3.copy(v3_2$2, v3_1$4);
                                var jointBounds = result[refJointIndex];
                                jointBounds.hasValue = !0, Vec3.min(jointBounds.min, jointBounds.min, v3_2$2), Vec3.max(jointBounds.max, jointBounds.max, v3_2$2);
                            }
                        }
                    }
                }
            }
        }
    }
    return result.map(function(bounds) {
        return bounds.hasValue ? aabb.fromPoints(new aabb(), bounds.min, bounds.max) : null;
    });
}

var boneSpaceBoundsManager = new (function() {
    function BoneSpaceBoundsManager() {
        _classCallCheck(this, BoneSpaceBoundsManager), this._cached = new Map();
    }
    return _createClass(BoneSpaceBoundsManager, [ {
        key: "use",
        value: function use(mesh, skeleton) {
            var bucket = this._cached.get(mesh);
            bucket || (bucket = new Map(), this._cached.set(mesh, bucket));
            var cached = bucket.get(skeleton);
            return cached || (cached = {
                bounds: calculateBoneSpaceBounds(mesh, skeleton),
                referenceCount: 0
            }, bucket.set(skeleton, cached)), ++cached.referenceCount, cached.bounds;
        }
    }, {
        key: "unuse",
        value: function unuse(mesh, skeleton) {
            var bucket = this._cached.get(mesh);
            if (bucket) {
                var cached = bucket.get(skeleton);
                cached && (--cached.referenceCount, 0 === cached.referenceCount && bucket.delete(skeleton)), 
                0 === bucket.size && this._cached.delete(mesh);
            }
        }
    } ]), BoneSpaceBoundsManager;
}())(), m4_1 = new Mat4(), m4_2 = new Mat4(), ab_1 = new aabb(), v3_3 = new Vec3(), v3_4 = new Vec3();

var utils = Object.freeze({
    toPPM: function toPPM(buffer, w, h) {
        return "P3 ".concat(w, " ").concat(h, " 255\n").concat(buffer.filter(function(e, i) {
            return i % 4 < 3;
        }).toString(), "\n");
    },
    createMesh: createMesh,
    readMesh: function readMesh(mesh) {
        var iPrimitive = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, out = {
            positions: []
        }, dataView = new DataView(mesh._nativeAsset), struct = mesh.struct, primitive = struct.primitives[iPrimitive], _iterator6 = primitive.vertexBundelIndices, _isArray6 = Array.isArray(_iterator6), _i7 = 0;
        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
            var _ref6;
            if (_isArray6) {
                if (_i7 >= _iterator6.length) break;
                _ref6 = _iterator6[_i7++];
            } else {
                if ((_i7 = _iterator6.next()).done) break;
                _ref6 = _i7.value;
            }
            var _idx = _ref6, bundle = struct.vertexBundles[_idx], offset = bundle.view.offset, _bundle$view = bundle.view, length = _bundle$view.length, stride = _bundle$view.stride, _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i8 = 0;
            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                var _ref7;
                if (_isArray7) {
                    if (_i8 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i8++];
                } else {
                    if ((_i8 = _iterator7.next()).done) break;
                    _ref7 = _i8.value;
                }
                var attr = _ref7, name = _keyMap[attr.name];
                name && (out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride))), 
                offset += GFXFormatInfos[attr.format].size;
            }
        }
        var view = primitive.indexView;
        return out.indices = readBuffer(dataView, GFXFormat["R".concat(8 * view.stride, "UI")], view.offset, view.length), 
        out;
    },
    writeBuffer: writeBuffer,
    readBuffer: readBuffer,
    mapBuffer: mapBuffer,
    LCA: LCA,
    calculateSkinnedBounds: function calculateSkinnedBounds(out, comp) {
        if (comp.model && comp.mesh) {
            var skeleton = comp.skeleton, root = comp.skinningRoot, clip = comp.model.uploadedAnim;
            if (!skeleton || !root || !clip) {
                if (!comp.model.worldBounds) return;
                return aabb.copy(out, comp.model.worldBounds), !0;
            }
            Vec3.set(v3_3, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), 
            Vec3.set(v3_4, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), 
            root.getWorldMatrix(m4_1);
            for (var boundList = boneSpaceBoundsManager.use(comp.mesh, skeleton), len = skeleton.joints.length, data = clip.convertedData, fid = comp.model.getFrameID(), i = 0; i < len; ++i) {
                var bounds = boundList[i], nodeData = data[skeleton.joints[i]];
                if (bounds && nodeData && nodeData.props) {
                    var matrix = nodeData.props.worldMatrix.values[fid];
                    Mat4.multiply(m4_2, m4_1, matrix), aabb.transform(ab_1, bounds, m4_2), ab_1.getBoundary(v3_1$4, v3_2$2), 
                    Vec3.min(v3_3, v3_3, v3_1$4), Vec3.max(v3_4, v3_4, v3_2$2);
                }
            }
            return aabb.fromPoints(out, v3_3, v3_4), !0;
        }
    },
    find: find
}), GFXInputAssembler = function(_GFXObject) {
    function GFXInputAssembler(device) {
        var _this;
        return _classCallCheck(this, GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXInputAssembler).call(this, GFXObjectType.INPUT_ASSEMBLER)))._device = void 0, 
        _this._attributes = [], _this._vertexBuffers = [], _this._indexBuffer = null, _this._vertexCount = 0, 
        _this._firstVertex = 0, _this._indexCount = 0, _this._firstIndex = 0, _this._vertexOffset = 0, 
        _this._instanceCount = 0, _this._firstInstance = 0, _this._isIndirect = !1, _this._indirectBuffer = null, 
        _this._device = device, _this;
    }
    return _inherits(GFXInputAssembler, GFXObject), _createClass(GFXInputAssembler, [ {
        key: "vertexBuffers",
        get: function get() {
            return this._vertexBuffers;
        }
    }, {
        key: "indexBuffer",
        get: function get() {
            return this._indexBuffer;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this._attributes;
        }
    }, {
        key: "vertexCount",
        get: function get() {
            return this._vertexCount;
        },
        set: function set(count) {
            this._vertexCount = count;
        }
    }, {
        key: "firstVertex",
        get: function get() {
            return this._firstVertex;
        },
        set: function set(first) {
            this._firstVertex = first;
        }
    }, {
        key: "indexCount",
        get: function get() {
            return this._indexCount;
        },
        set: function set(count) {
            this._indexCount = count;
        }
    }, {
        key: "firstIndex",
        get: function get() {
            return this._firstIndex;
        },
        set: function set(first) {
            this._firstIndex = first;
        }
    }, {
        key: "vertexOffset",
        get: function get() {
            return this._vertexOffset;
        },
        set: function set(offset) {
            this._vertexOffset = offset;
        }
    }, {
        key: "instanceCount",
        get: function get() {
            return this._instanceCount;
        },
        set: function set(count) {
            this._instanceCount = count;
        }
    }, {
        key: "firstInstance",
        get: function get() {
            return this._firstInstance;
        },
        set: function set(first) {
            this._firstInstance = first;
        }
    }, {
        key: "isIndirect",
        get: function get() {
            return this._isIndirect;
        }
    }, {
        key: "indirectBuffer",
        get: function get() {
            return this._indirectBuffer;
        }
    } ]), _createClass(GFXInputAssembler, [ {
        key: "getVertexBuffer",
        value: function getVertexBuffer() {
            var stream = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return stream < this._vertexBuffers.length ? this._vertexBuffers[stream] : null;
        }
    }, {
        key: "extractDrawInfo",
        value: function extractDrawInfo(drawInfo) {
            drawInfo.vertexCount = this._vertexCount, drawInfo.firstVertex = this._firstVertex, 
            drawInfo.indexCount = this._indexCount, drawInfo.firstIndex = this._firstIndex, 
            drawInfo.vertexOffset = this._vertexOffset, drawInfo.instanceCount = this._instanceCount, 
            drawInfo.firstInstance = this._firstInstance;
        }
    }, {
        key: "updateVertexAttr",
        value: function updateVertexAttr(vbuffer, attr, data) {
            var index = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, _final = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], offset = 0, format = GFXFormat.UNKNOWN, _iterator = this._attributes, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var a = _ref;
                if (a.name === attr) {
                    format = a.format;
                    break;
                }
                offset += GFXFormatInfos[a.format].size;
            }
            var vb = this._vertexBuffers[index];
            format && vb && (writeBuffer(new DataView(vbuffer), data, format, offset, vb.stride), 
            _final && vb.update(vbuffer, 0, vb.stride * vb.count));
        }
    }, {
        key: "updateIndexBuffer",
        value: function updateIndexBuffer(ibuffer, data) {
            var count = this._indexCount, ib = this._indexBuffer;
            count && ib && (writeBuffer(new DataView(ibuffer), data, GFXFormat["R".concat(8 * ib.stride, "UI")]), 
            ib.update(ibuffer, 0, ib.stride * ib.count), this._indexCount = data.length);
        }
    } ]), GFXInputAssembler;
}(), GFXPipelineLayout = function(_GFXObject) {
    function GFXPipelineLayout(device) {
        var _this;
        return _classCallCheck(this, GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineLayout).call(this, GFXObjectType.PIPELINE_LAYOUT)))._device = void 0, 
        _this._pushConstantsRanges = [], _this._layouts = [], _this._device = device, _this;
    }
    return _inherits(GFXPipelineLayout, GFXObject), _createClass(GFXPipelineLayout, [ {
        key: "layouts",
        get: function get() {
            return this._layouts;
        }
    } ]), GFXPipelineLayout;
}(), GFXRasterizerState = function() {
    function GFXRasterizerState() {
        _classCallCheck(this, GFXRasterizerState), this.isDiscard = !1, this.polygonMode = GFXPolygonMode.FILL, 
        this.shadeModel = GFXShadeModel.GOURAND, this.cullMode = GFXCullMode.BACK, this.isFrontFaceCCW = !0, 
        this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, this.isDepthClip = !0, 
        this.isMultisample = !1, this.lineWidth = 1;
    }
    return _createClass(GFXRasterizerState, [ {
        key: "compare",
        value: function compare(state) {
            return this.isDiscard === state.isDiscard && this.polygonMode === state.polygonMode && this.shadeModel === state.shadeModel && this.cullMode === state.cullMode && this.isFrontFaceCCW === state.isFrontFaceCCW && this.depthBias === state.depthBias && this.depthBiasClamp === state.depthBiasClamp && this.depthBiasSlop === state.depthBiasSlop && this.isDepthClip === state.isDepthClip && this.lineWidth === state.lineWidth && this.isMultisample === state.isMultisample;
        }
    } ]), GFXRasterizerState;
}(), GFXDepthStencilState = function() {
    function GFXDepthStencilState() {
        _classCallCheck(this, GFXDepthStencilState), this.depthTest = !0, this.depthWrite = !0, 
        this.depthFunc = GFXComparisonFunc.LESS, this.stencilTestFront = !1, this.stencilFuncFront = GFXComparisonFunc.ALWAYS, 
        this.stencilReadMaskFront = 4294967295, this.stencilWriteMaskFront = 4294967295, 
        this.stencilFailOpFront = GFXStencilOp.KEEP, this.stencilZFailOpFront = GFXStencilOp.KEEP, 
        this.stencilPassOpFront = GFXStencilOp.KEEP, this.stencilRefFront = 1, this.stencilTestBack = !1, 
        this.stencilFuncBack = GFXComparisonFunc.ALWAYS, this.stencilReadMaskBack = 4294967295, 
        this.stencilWriteMaskBack = 4294967295, this.stencilFailOpBack = GFXStencilOp.KEEP, 
        this.stencilZFailOpBack = GFXStencilOp.KEEP, this.stencilPassOpBack = GFXStencilOp.KEEP, 
        this.stencilRefBack = 1;
    }
    return _createClass(GFXDepthStencilState, [ {
        key: "compare",
        value: function compare(state) {
            return this.depthTest === state.depthTest && this.depthWrite === state.depthWrite && this.depthFunc === state.depthFunc && this.stencilTestFront === state.stencilTestFront && this.stencilFuncFront === state.stencilFuncFront && this.stencilReadMaskFront === state.stencilReadMaskFront && this.stencilWriteMaskFront === state.stencilWriteMaskFront && this.stencilFailOpFront === state.stencilFailOpFront && this.stencilZFailOpFront === state.stencilZFailOpFront && this.stencilPassOpFront === state.stencilPassOpFront && this.stencilRefFront === state.stencilRefFront && this.stencilTestBack === state.stencilTestBack && this.stencilFuncBack === state.stencilFuncBack && this.stencilReadMaskBack === state.stencilReadMaskBack && this.stencilWriteMaskBack === state.stencilWriteMaskBack && this.stencilFailOpBack === state.stencilFailOpBack && this.stencilZFailOpBack === state.stencilZFailOpBack && this.stencilPassOpBack === state.stencilPassOpBack && this.stencilRefBack === state.stencilRefBack;
        }
    } ]), GFXDepthStencilState;
}(), GFXBlendTarget = function() {
    function GFXBlendTarget() {
        _classCallCheck(this, GFXBlendTarget), this.blend = !1, this.blendSrc = GFXBlendFactor.ONE, 
        this.blendDst = GFXBlendFactor.ZERO, this.blendEq = GFXBlendOp.ADD, this.blendSrcAlpha = GFXBlendFactor.ONE, 
        this.blendDstAlpha = GFXBlendFactor.ZERO, this.blendAlphaEq = GFXBlendOp.ADD, this.blendColorMask = GFXColorMask.ALL;
    }
    return _createClass(GFXBlendTarget, [ {
        key: "compare",
        value: function compare(target) {
            return this.blend === target.blend && this.blendSrc === target.blendSrc && this.blendDst === target.blendDst && this.blendEq === target.blendEq && this.blendSrcAlpha === target.blendSrcAlpha && this.blendDstAlpha === target.blendDstAlpha && this.blendAlphaEq === target.blendAlphaEq && this.blendColorMask === target.blendColorMask;
        }
    } ]), GFXBlendTarget;
}(), GFXBlendState = function GFXBlendState() {
    _classCallCheck(this, GFXBlendState), this.isA2C = !1, this.isIndepend = !1, this.blendColor = [ 0, 0, 0, 0 ], 
    this.targets = [ new GFXBlendTarget() ];
}, GFXInputState = function GFXInputState() {
    _classCallCheck(this, GFXInputState), this.attributes = [];
}, GFXPipelineState = function(_GFXObject) {
    function GFXPipelineState(device) {
        var _this;
        return _classCallCheck(this, GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineState).call(this, GFXObjectType.PIPELINE_STATE)))._device = void 0, 
        _this._shader = null, _this._primitive = GFXPrimitiveMode.TRIANGLE_LIST, _this._is = null, 
        _this._rs = null, _this._dss = null, _this._bs = null, _this._dynamicStates = [], 
        _this._layout = null, _this._renderPass = null, _this._device = device, _this;
    }
    return _inherits(GFXPipelineState, GFXObject), _createClass(GFXPipelineState, [ {
        key: "shader",
        get: function get() {
            return this._shader;
        }
    }, {
        key: "primitive",
        get: function get() {
            return this._primitive;
        }
    }, {
        key: "rasterizerState",
        get: function get() {
            return this._rs;
        }
    }, {
        key: "depthStencilState",
        get: function get() {
            return this._dss;
        }
    }, {
        key: "blendState",
        get: function get() {
            return this._bs;
        }
    }, {
        key: "dynamicStates",
        get: function get() {
            return this._dynamicStates;
        }
    }, {
        key: "pipelineLayout",
        get: function get() {
            return this._layout;
        }
    }, {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    } ]), GFXPipelineState;
}(), GFXQueue = function(_GFXObject) {
    function GFXQueue(device) {
        var _this;
        return _classCallCheck(this, GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXQueue).call(this, GFXObjectType.QUEUE)))._device = void 0, 
        _this._type = GFXQueueType.GRAPHICS, _this._device = device, _this;
    }
    return _inherits(GFXQueue, GFXObject), _createClass(GFXQueue, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ]), GFXQueue;
}(), GFXRenderPass = function(_GFXObject) {
    function GFXRenderPass(device) {
        var _this;
        return _classCallCheck(this, GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXRenderPass).call(this, GFXObjectType.RENDER_PASS)))._device = void 0, 
        _this._colorInfos = [], _this._depthStencilInfo = null, _this._device = device, 
        _this;
    }
    return _inherits(GFXRenderPass, GFXObject), GFXRenderPass;
}(), GFXSamplerState = function() {
    function GFXSamplerState() {
        _classCallCheck(this, GFXSamplerState), this.name = "", this.minFilter = GFXFilter.LINEAR, 
        this.magFilter = GFXFilter.LINEAR, this.mipFilter = GFXFilter.NONE, this.addressU = GFXAddress.WRAP, 
        this.addressV = GFXAddress.WRAP, this.addressW = GFXAddress.WRAP, this.maxAnisotropy = 16, 
        this.cmpFunc = GFXComparisonFunc.NEVER, this.borderColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }, this.minLOD = 0, this.maxLOD = 0, this.mipLODBias = 0;
    }
    return _createClass(GFXSamplerState, [ {
        key: "compare",
        value: function compare(state) {
            return this.minFilter === state.minFilter && this.magFilter === state.magFilter && this.mipFilter === state.mipFilter && this.addressU === state.addressU && this.addressV === state.addressV && this.addressW === state.addressW && this.maxAnisotropy === state.maxAnisotropy && this.cmpFunc === state.cmpFunc && this.borderColor.r === state.borderColor.r && this.borderColor.g === state.borderColor.g && this.borderColor.b === state.borderColor.b && this.borderColor.a === state.borderColor.a && this.minLOD === state.minLOD && this.maxLOD === state.maxLOD && this.mipLODBias === state.mipLODBias;
        }
    } ]), GFXSamplerState;
}(), GFXSampler = function(_GFXObject) {
    function GFXSampler(device) {
        var _this;
        return _classCallCheck(this, GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXSampler).call(this, GFXObjectType.SAMPLER)))._device = void 0, 
        _this._state = new GFXSamplerState(), _this._device = device, _this;
    }
    return _inherits(GFXSampler, GFXObject), _createClass(GFXSampler, [ {
        key: "state",
        get: function get() {
            return this._state;
        }
    } ]), GFXSampler;
}(), GFXShader = function(_GFXObject) {
    function GFXShader(device) {
        var _this;
        return _classCallCheck(this, GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXShader).call(this, GFXObjectType.SHADER)))._device = void 0, 
        _this._id = void 0, _this._name = "", _this._stages = [], _this._blocks = [], _this._samplers = [], 
        _this._device = device, _this._id = device.genShaderId(), _this;
    }
    return _inherits(GFXShader, GFXObject), _createClass(GFXShader, [ {
        key: "id",
        get: function get() {
            return this._id;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    } ]), GFXShader;
}(), GFXTexture = function(_GFXObject) {
    function GFXTexture(device) {
        var _this;
        return _classCallCheck(this, GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTexture).call(this, GFXObjectType.TEXTURE)))._device = void 0, 
        _this._type = GFXTextureType.TEX2D, _this._usage = GFXTextureUsageBit.NONE, _this._format = GFXFormat.UNKNOWN, 
        _this._width = 0, _this._height = 0, _this._depth = 1, _this._arrayLayer = 1, _this._mipLevel = 1, 
        _this._samples = GFXSampleCount.X1, _this._flags = GFXTextureFlagBit.NONE, _this._isPowerOf2 = !1, 
        _this._size = 0, _this._buffer = null, _this._device = device, _this;
    }
    return _inherits(GFXTexture, GFXObject), _createClass(GFXTexture, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "usage",
        get: function get() {
            return this._usage;
        }
    }, {
        key: "format",
        get: function get() {
            return this._format;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "depth",
        get: function get() {
            return this._depth;
        }
    }, {
        key: "arrayLayer",
        get: function get() {
            return this._arrayLayer;
        }
    }, {
        key: "mipLevel",
        get: function get() {
            return this._mipLevel;
        }
    }, {
        key: "samples",
        get: function get() {
            return this._samples;
        }
    }, {
        key: "flags",
        get: function get() {
            return this._flags;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        }
    }, {
        key: "buffer",
        get: function get() {
            return this._buffer;
        }
    } ]), GFXTexture;
}();

cc.GFXDevice = GFXDevice, cc.GFXBuffer = GFXBuffer, cc.GFXTexture = GFXTexture, 
cc.GFXTextureView = GFXTextureView, cc.GFXSampler = GFXSampler, cc.GFXShader = GFXShader, 
cc.GFXInputAssembler = GFXInputAssembler, cc.GFXRenderPass = GFXRenderPass, cc.GFXFramebuffer = GFXFramebuffer, 
cc.GFXPipelineLayout = GFXPipelineLayout, cc.GFXPipelineState = GFXPipelineState, 
cc.GFXCommandBuffer = GFXCommandBuffer, cc.GFXQueue = GFXQueue, Object.assign(cc, GFXDefines);

var _jointsFormat2, JointsMediumType, TextureBufferPool = function() {
    function TextureBufferPool(device) {
        _classCallCheck(this, TextureBufferPool), this._device = void 0, this._format = GFXFormat.UNKNOWN, 
        this._formatSize = 0, this._chunks = [], this._chunkCount = 0, this._handles = [], 
        this._region0 = new GFXBufferTextureCopy(), this._region1 = new GFXBufferTextureCopy(), 
        this._region2 = new GFXBufferTextureCopy(), this._roundUpFn = null, this._inOrderFree = !1, 
        this._device = device;
    }
    return _createClass(TextureBufferPool, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._format = info.format, this._formatSize = GFXFormatInfos[this._format].size, 
            this._chunks = new Array(info.maxChunks), this._roundUpFn = info.roundUpFn || null, 
            this._inOrderFree = info.inOrderFree || !1, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            for (var i = 0; i < this._chunkCount; ++i) {
                var chunk = this._chunks[i];
                chunk.texView.destroy(), chunk.texture.destroy();
            }
            this._chunks.splice(0), this._handles.splice(0);
        }
    }, {
        key: "alloc",
        value: function alloc(size) {
            var _this = this;
            if (0 === size) return null;
            for (var _loop = function _loop(i) {
                var chunk = _this._chunks[i], isFound = !1, start = chunk.start;
                if (start + size <= chunk.end) isFound = !0; else if (_this._inOrderFree) start > chunk.end ? start + size <= chunk.size ? isFound = !0 : size <= chunk.end && (chunk.start = start = 0, 
                isFound = !0) : start === chunk.end && (chunk.start = start = 0, chunk.end = chunk.size, 
                size <= chunk.end && (isFound = !0)); else {
                    start = 0;
                    for (var handles = _this._handles.filter(function(h) {
                        return h.chunkIdx === i;
                    }).sort(function(a, b) {
                        return a.start - b.start;
                    }), j = 0; j < handles.length; j++) {
                        var handle = handles[j];
                        if (start + size <= handle.start) {
                            isFound = !0;
                            break;
                        }
                        start = handle.end;
                    }
                    !isFound && start + size <= chunk.size && (isFound = !0);
                }
                if (isFound) {
                    chunk.start += size;
                    var _handle = {
                        chunkIdx: i,
                        start: start,
                        end: start + size,
                        texture: chunk.texture,
                        texView: chunk.texView
                    };
                    return _this._handles.push(_handle), {
                        v: _handle
                    };
                }
            }, i = 0; i < this._chunkCount; ++i) {
                var _ret = _loop(i);
                if ("object" === _typeof(_ret)) return _ret.v;
            }
            if (this._chunkCount >= this._chunks.length) return console.error("TextureBufferPool: Reach max chunk count."), 
            null;
            var targetSize = Math.sqrt(size / this._formatSize), texWidth = this._roundUpFn && this._roundUpFn(targetSize) || Math.max(1024, function nearestPO2(num) {
                return --num, num |= num >> 16, num |= num >> 8, num |= num >> 4, num |= num >> 2, 
                num |= num >> 1, ++num;
            }(targetSize)), texSize = texWidth * texWidth * this._formatSize;
            console.info("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize);
            var texture = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.SAMPLED,
                format: this._format,
                width: texWidth,
                height: texWidth,
                mipLevel: 1
            }), texView = this._device.createTextureView({
                texture: texture,
                type: GFXTextureViewType.TV2D,
                format: this._format
            }), texHandle = {
                chunkIdx: this._chunkCount,
                start: 0,
                end: size,
                texture: texture,
                texView: texView
            };
            return this._handles.push(texHandle), this._chunks[this._chunkCount++] = {
                texture: texture,
                texView: texView,
                size: texSize,
                start: size,
                end: texSize
            }, texHandle;
        }
    }, {
        key: "free",
        value: function free(handle) {
            for (var i = 0; i < this._handles.length; ++i) if (this._handles[i] === handle) return this._chunks[handle.chunkIdx].end = handle.end, 
            void this._handles.splice(i, 1);
        }
    }, {
        key: "update",
        value: function update(handle, buffer) {
            var buffers = [], regions = [], start = handle.start / this._formatSize, remainSize = buffer.byteLength / this._formatSize, offsetX = start % handle.texture.width, offsetY = Math.floor(start / handle.texture.width), copySize = Math.min(handle.texture.width - offsetX, remainSize), begin = 0;
            offsetX > 0 && (this._region0.texOffset.x = offsetX, this._region0.texOffset.y = offsetY, 
            this._region0.texExtent.width = copySize, this._region0.texExtent.height = 1, buffers.push(buffer.slice(begin * this._formatSize, (begin + copySize) * this._formatSize)), 
            regions.push(this._region0), offsetX = 0, offsetY += 1, remainSize -= copySize, 
            begin += copySize), remainSize > 0 && (this._region1.texOffset.x = offsetX, this._region1.texOffset.y = offsetY, 
            remainSize > handle.texture.width ? (this._region1.texExtent.width = handle.texture.width, 
            this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width), 
            copySize = this._region1.texExtent.width * this._region1.texExtent.height) : (copySize = remainSize, 
            this._region1.texExtent.width = copySize, this._region1.texExtent.height = 1), buffers.push(buffer.slice(begin * this._formatSize, (begin + copySize) * this._formatSize)), 
            regions.push(this._region1), offsetX = 0, offsetY += this._region1.texExtent.height, 
            remainSize -= copySize, begin += copySize), remainSize > 0 && (this._region2.texOffset.x = offsetX, 
            this._region2.texOffset.y = offsetY, this._region2.texExtent.width = remainSize, 
            this._region2.texExtent.height = 1, buffers.push(buffer.slice(begin * this._formatSize, (begin + remainSize) * this._formatSize)), 
            regions.push(this._region2)), this._device.copyBuffersToTexture(buffers, handle.texture, regions);
        }
    } ]), TextureBufferPool;
}(), uploadJointData = function uploadJointDataDQS(out, base, mat, firstBone) {
    Mat4.toRTS(mat, qt_1$2, v3_1$5, v3_2$3), firstBone ? Quat.copy(dq_0, qt_1$2) : Quat.dot(dq_0, qt_1$2) < 0 && Quat.multiplyScalar(qt_1$2, qt_1$2, -1);
    Quat.set(dq_1, v3_1$5.x, v3_1$5.y, v3_1$5.z, 0), Quat.multiplyScalar(dq_1, Quat.multiply(dq_1, dq_1, qt_1$2), .5), 
    out[base + 0] = qt_1$2.x, out[base + 1] = qt_1$2.y, out[base + 2] = qt_1$2.z, out[base + 3] = qt_1$2.w, 
    out[base + 4] = dq_1.x, out[base + 5] = dq_1.y, out[base + 6] = dq_1.z, out[base + 7] = dq_1.w, 
    out[base + 8] = v3_2$3.x, out[base + 9] = v3_2$3.y, out[base + 10] = v3_2$3.z;
};

function selectJointsMediumType(device) {
    return device.hasFeature(GFXFeature.TEXTURE_FLOAT) ? JointsMediumType.RGBA32F : JointsMediumType.RGBA8;
}

!function(JointsMediumType) {
    JointsMediumType[JointsMediumType.NONE = 0] = "NONE", JointsMediumType[JointsMediumType.RGBA8 = 1] = "RGBA8", 
    JointsMediumType[JointsMediumType.RGBA32F = 2] = "RGBA32F";
}(JointsMediumType || (JointsMediumType = {}));

var id_m4 = Object.freeze(new Mat4()), m4_1$1 = new Mat4(), dq_0 = new Quat(), dq_1 = new Quat(), v3_1$5 = new Vec3(), qt_1$2 = new Quat(), v3_2$3 = new Vec3();

function roundUpTextureSize(targetLength) {
    return Math.max(180, 12 * Math.ceil(targetLength / 12));
}

var _jointsFormat = (_defineProperty(_jointsFormat2 = {}, JointsMediumType.RGBA8, GFXFormat.RGBA8), 
_defineProperty(_jointsFormat2, JointsMediumType.RGBA32F, GFXFormat.RGBA32F), _jointsFormat2), JointsTexturePool = function() {
    function JointsTexturePool(device) {
        _classCallCheck(this, JointsTexturePool), this._device = void 0, this._pool = void 0, 
        this._textureBuffers = new Map(), this._formatSize = 0, this._device = device, this._pool = new TextureBufferPool(device);
    }
    return _createClass(JointsTexturePool, [ {
        key: "initialize",
        value: function initialize() {
            var maxChunks = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8, format = _jointsFormat[selectJointsMediumType(this._device)];
            this._formatSize = GFXFormatInfos[format].size;
            var scale = 16 / this._formatSize;
            this._pool.initialize({
                format: format,
                maxChunks: maxChunks * scale,
                roundUpFn: roundUpTextureSize
            });
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._pool.destroy();
        }
    }, {
        key: "getDefaultJointsTexture",
        value: function getDefaultJointsTexture(skeleton) {
            var len = skeleton && skeleton.joints.length || 1, texture = this._textureBuffers.get(len) || null;
            if (texture) return texture.refCount++, texture;
            var handle = this._pool.alloc(12 * len * Float32Array.BYTES_PER_ELEMENT);
            if (!handle) return null;
            texture = {
                pixelOffset: handle.start / this._formatSize,
                refCount: 1,
                hash: len,
                handle: handle
            };
            for (var textureBuffer = new Float32Array(12 * len), i = 0; i < len; i++) uploadJointData(textureBuffer, 12 * i, id_m4, 0 === i);
            return this._pool.update(handle, textureBuffer.buffer), this._textureBuffers.set(len, texture), 
            texture;
        }
    }, {
        key: "getJointsTextureWithAnimation",
        value: function getJointsTextureWithAnimation(skeleton, clip) {
            var hash = skeleton.hash ^ clip.hash, texture = this._textureBuffers.get(hash) || null;
            if (texture) return texture.refCount++, texture;
            var frames = clip.keys[0].length, bufSize = 12 * skeleton.joints.length * frames, handle = this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);
            if (!handle) return null;
            texture = {
                pixelOffset: handle.start / this._formatSize,
                refCount: 1,
                hash: hash,
                handle: handle
            };
            for (var textureBuffer = new Float32Array(bufSize), data = clip.convertedData, i = 0; i < skeleton.joints.length; i++) {
                var nodeData = data[skeleton.joints[i]];
                if (nodeData && nodeData.props) for (var bindpose = skeleton.bindposes[i], matrix = nodeData.props.worldMatrix.values, frame = 0; frame < frames; frame++) {
                    var m = matrix[frame];
                    Mat4.multiply(m4_1$1, m, bindpose), uploadJointData(textureBuffer, 12 * (frames * i + frame), m4_1$1, 0 === i);
                }
            }
            return this._pool.update(handle, textureBuffer.buffer), this._textureBuffers.set(hash, texture), 
            texture;
        }
    }, {
        key: "releaseTexture",
        value: function releaseTexture(texture) {
            0 == --texture.refCount && (this._pool.free(texture.handle), this._textureBuffers.delete(texture.hash));
        }
    } ]), JointsTexturePool;
}(), jointsTextureSamplerHash = genSamplerHash([ GFXFilter.POINT, GFXFilter.POINT, GFXFilter.NONE, GFXAddress.CLAMP, GFXAddress.CLAMP, GFXAddress.CLAMP ]), jointsTextureSampler = null;

function getJointsTextureSampler(device) {
    return jointsTextureSampler || (jointsTextureSampler = samplerLib.getSampler(device, jointsTextureSamplerHash));
}

var phases, phaseNum, _type2fn2, _type2default2, effects$1 = [ {
    _name: "builtin-screen-quad",
    techniques: [ {
        passes: [ {
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            program: "builtin-screen-quad|screen-quad-vs:vert|screen-quad-fs:frag",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                offset: {
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-screen-quad|screen-quad-vs:vert|screen-quad-fs:frag",
        hash: 1022306579,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nin vec3 a_position;\n\nvoid CCDecode (out vec3 position) {\n  position = a_position;\n}\n\nin vec2 a_texCoord;\nout vec2 v_uv;\n\nuniform Constants {\n  vec4 offset;\n};\n\nvec4 vert () {\n  vec3 position;\n  CCDecode(position);\n\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n\n  v_uv = a_texCoord;\n  return vec4(position, 1.0);\n}\n\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\n\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform vec4 cc_screenSize;\n\nattribute vec3 a_position;\n\nvoid CCDecode (out vec3 position) {\n  position = a_position;\n}\n\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\n\nuniform vec4 offset;\n\nvec4 vert () {\n  vec3 position;\n  CCDecode(position);\n\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n\n  v_uv = a_texCoord;\n  return vec4(position, 1.0);\n}\n\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\n\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n\n}\n\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n\n}\n\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\n\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "offset",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-billboard",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-billboard|vert:vs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    inspector: {
                        type: "color"
                    },
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-billboard|vert:vs_main|tinted-fs:add",
        hash: 3746923305,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if 1 || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if 1\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nuniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = (a_texCoord.xy - 0.5) * cc_size_rotation.xy;\n  rotateCorner(vertOffset, cc_size_rotation.z);\n  computeVertPos(pos, vertOffset, vec3(1,1,1), cc_matView);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if 1 || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if 1\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = (a_texCoord.xy - 0.5) * cc_size_rotation.xy;\n  rotateCorner(vertOffset, cc_size_rotation.z);\n  computeVertPos(pos, vertOffset, vec3(1,1,1), cc_matView);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_STRETCHED_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HORIZONTAL_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_VERTICAL_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_MESH",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "builtin",
            defines: [],
            binding: 1,
            members: [ {
                name: "cc_size_rotation",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 2,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-particle-trail",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                frameTile_velLenScale: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    inspector: {
                        type: "color"
                    },
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
        hash: 1137903321,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec4 a_color;\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform vec4 scale;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec4 a_color;\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_STRETCHED_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HORIZONTAL_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_VERTICAL_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_MESH",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_WORLD_SPACE",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 1,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-particle",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                frameTile_velLenScale: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    inspector: {
                        type: "color"
                    },
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
        hash: 1382661351,
        glsl3: {
            vert: "\nprecision highp float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec2 a_texCoord1;\nin vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\n  in vec3 a_color1;\n#endif\n#if CC_USE_MESH\n  in vec3 a_texCoord2;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n",
            frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }\n"
        },
        glsl1: {
            vert: "\nprecision highp float;\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos(inout vec4 pos, vec2 vertOffset, vec3 scale\n#if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n  , mat4 view\n#endif\n#if CC_USE_STRETCHED_BILLBOARD\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float size\n  , float xIndex\n#endif\n) {\n#if CC_USE_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = normalize(vec3(view[0][1], view[1][1], view[2][1]));\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_STRETCHED_BILLBOARD\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz));\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * size;\n  pos.xyz += ((camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex) * scale;\n#elif CC_USE_HORIZONTAL_BILLBOARD\n  vec3 camRight = vec3(1, 0, 0);\n  vec3 camUp = vec3(0, 0, -1);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#elif CC_USE_VERTICAL_BILLBOARD\n  vec3 camRight = normalize(vec3(view[0][0], view[1][0], view[2][0]));\n  vec3 camUp = vec3(0, 1, 0);\n  pos.xyz += ((camRight * vertOffset.x) + (camUp * vertOffset.y)) * scale;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV(float frameIndex, vec2 vertIndex, vec2 frameTile) {\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if !CC_USE_MESH\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nvoid rotateCorner(inout vec2 corner, float angle) {\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvec4 quaternionFromAxisAngle(float angle, vec3 axis){\n  angle /= 2.;\n  float s = sin(angle);\n  vec4 res;\n  res.xyz = s * axis;\n  res.w = cos(angle);\n  return res;\n}\nmat4 matrixFromRT(vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nvoid scaleMatrix(inout mat4 m, float s){\n  m[0].xyz *= s;\n  m[1].xyz *= s;\n  m[2].xyz *= s;\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec2 a_texCoord1;\nattribute vec4 a_color;\n#if CC_USE_STRETCHED_BILLBOARD\n  attribute vec3 a_color1;\n#endif\n#if CC_USE_MESH\n  attribute vec3 a_texCoord2;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main() {\n  #if CC_USE_MESH\n    vec4 pos = vec4(a_texCoord2, 1);\n    mat4 xformNoScale = matrixFromRT(quaternionFromAxisAngle(a_texCoord1.y, vec3(0, 0, -1)), a_position);\n    mat4 xform = mat4(xformNoScale);\n    scaleMatrix(xform, a_texCoord1.x);\n    pos = xform * pos;\n    vec4 normal = xformNoScale * vec4(a_normal,0);\n  #else\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_STRETCHED_BILLBOARD\n      vec4 velocity = vec4(a_color1.xyz, 0);\n    #endif\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_USE_STRETCHED_BILLBOARD\n    velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if !CC_USE_MESH\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5) * a_texCoord1.x);\n    #if !CC_USE_STRETCHED_BILLBOARD\n      rotateCorner(cornerOffset, a_texCoord1.y);\n    #endif\n    computeVertPos(pos, cornerOffset, vec3(scale)\n    #if CC_USE_BILLBOARD || CC_USE_VERTICAL_BILLBOARD\n      , cc_matView\n    #endif\n    #if CC_USE_STRETCHED_BILLBOARD\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord1.x\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }\n",
            frag: "\nprecision highp float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvec4 multiply () {\n  vec4 col;\n  vec4 texColor = texture2D(mainTexture, uv);\n  col.rgb = tintColor.rgb * texColor.rgb * color.rgb * vec3(2.0);\n  col.a = (1.0 - texColor.a) * (tintColor.a * color.a * 2.0);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_STRETCHED_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HORIZONTAL_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_VERTICAL_BILLBOARD",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_MESH",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_WORLD_SPACE",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 1,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-sprite",
    techniques: [ {
        passes: [ {
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            rasterizerState: {
                cullMode: 0
            },
            program: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
            priority: 244,
            depthStencilState: {
                depthTest: !1,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "white",
                    type: 28
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
        hash: 3858821905,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#if USE_LOCAL\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n#endif\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: [ "USE_LOCAL" ]
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "USE_LOCAL",
            type: "boolean",
            defines: []
        }, {
            name: "USE_TEXTURE",
            type: "boolean",
            defines: []
        } ],
        blocks: [],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [ "USE_TEXTURE" ],
            binding: 30
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-standard",
    techniques: [ {
        name: "opaque",
        passes: [ {
            program: "builtin-standard|standard-vs:vert|standard-fs:frag",
            properties: {
                tilingOffset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                albedo: {
                    value: [ 1, 1, 1, 1 ],
                    inspector: {
                        type: "color"
                    },
                    type: 16
                },
                albedoScale: {
                    value: [ 1, 1, 1, 0 ],
                    type: 16
                },
                pbrParams: {
                    value: [ .8, .6, 1, 1 ],
                    type: 16
                },
                pbrScale: {
                    value: [ 1, 1, 1, 1 ],
                    type: 16
                },
                emissive: {
                    value: [ 0, 0, 0, 1 ],
                    inspector: {
                        type: "color"
                    },
                    type: 16
                },
                emissiveScale: {
                    value: [ 1, 1, 1, 1 ],
                    type: 16
                },
                albedoMap: {
                    value: "grey",
                    type: 28
                },
                normalMap: {
                    value: "normal",
                    type: 28
                },
                pbrMap: {
                    value: "grey",
                    type: 28
                },
                metallicRoughnessMap: {
                    value: "grey",
                    type: 28
                },
                occlusionMap: {
                    value: "white",
                    type: 28
                },
                emissiveMap: {
                    value: "grey",
                    type: 28
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-standard|standard-vs:vert|standard-fs:frag",
        hash: 2154331631,
        glsl3: {
            vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\nvoid CCDecode (out StandardAttributes attr) {\n  attr.position = vec4(a_position, 1.0);\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nvoid CCAttrToInput (in StandardAttributes attr, out StandardVertInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCVertInput (out StandardVertInput In) {\n  StandardAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n  vec4 pbrParams;\n  vec4 pbrScale;\n  vec4 emissive;\n  vec4 emissiveScale;\n};\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 pos = cc_matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((cc_matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((cc_matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_tangent, v_normal) * In.tangent.w;\n  #endif\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  highp vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\n#endif\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float factor2 = factor * factor;\n  float factor3 = factor2 * factor2;\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec3 albedo;\n  float alpha;\n  vec3 position;\n  vec3 normal;\n  float roughness;\n  float metallic;\n  float occlusion;\n  vec3 emissive;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec3 env = SRGBToLinear(texture(cc_environment, R).rgb) * cc_ambientSky.w;\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.alpha);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScale;\n  vec4 pbrParams;\n  vec4 pbrScale;\n  vec4 emissive;\n  vec4 emissiveScale;\n};\nin vec3 v_position;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  in vec2 v_uv;\n#endif\nin vec3 v_normal;\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor.rgb * albedoScale.xyz;\n  s.alpha = baseColor.a;\n  #if USE_ALPHA_TEST\n    if(s.alpha < albedoScale.w)\n      discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrScale.w) * normalize(v_tangent) +\n      (nmmp.y * pbrScale.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    pbr = texture(pbrMap, v_uv);\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, v_uv);\n    pbr.METALLIC_CHANNEL = metallicRoughness.METALLIC_CHANNEL;\n    pbr.ROUGHNESS_CHANNEL = metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.OCCLUSION_CHANNEL = texture(occlusionMap, v_uv).OCCLUSION_CHANNEL;\n  #endif\n  pbr *= pbrScale;\n  s.roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  s.metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  s.occlusion = pbr.OCCLUSION_CHANNEL;\n  s.emissive = emissive.rgb * emissiveScale.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, v_uv).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nuniform mat4 cc_matWorldIT;\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\nvoid CCDecode (out StandardAttributes attr) {\n  attr.position = vec4(a_position, 1.0);\n  attr.normal = a_normal;\n  attr.tangent = a_tangent;\n}\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nvoid CCAttrToInput (in StandardAttributes attr, out StandardVertInput In) {\n  In.position = attr.position;\n  In.normal = attr.normal;\n  In.tangent = attr.tangent;\n}\nvoid CCVertInput (out StandardVertInput In) {\n  StandardAttributes attr;\n  CCDecode(attr);\n  #if CC_USE_SKINNING\n    CCSkin(attr);\n  #endif\n  CCAttrToInput(attr, In);\n}\nuniform vec4 tilingOffset;\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  vec4 pos = cc_matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((cc_matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((cc_matWorldIT * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_tangent, v_normal) * In.tangent.w;\n  #endif\n  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  return cc_matViewProj * pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform vec4 cc_cameraPos;\nuniform vec4 cc_exposure;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_mainLitColor;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\n#endif\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nfloat SmoothDistAtt2(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float factor2 = factor * factor;\n  float factor3 = factor2 * factor2;\n  float smoothFactor = clamp(1.0 - factor3 * factor3, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat SmoothDistAtt(float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt(float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt(vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile(float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular(float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox(vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting(vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL+V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL+V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec3 albedo;\n  float alpha;\n  vec3 position;\n  vec3 normal;\n  float roughness;\n  float metallic;\n  float occlusion;\n  vec3 emissive;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec3 env = SRGBToLinear(textureCube(cc_environment, R).rgb) * cc_ambientSky.w;\n    finalColor += env * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.alpha);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScale;\nuniform vec4 pbrParams;\nuniform vec4 pbrScale;\nuniform vec4 emissive;\nuniform vec4 emissiveScale;\nvarying vec3 v_position;\n#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP || USE_METALLIC_ROUGHNESS_MAP || USE_OCCLUSION_MAP\n  varying vec2 v_uv;\n#endif\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, v_uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor.rgb * albedoScale.xyz;\n  s.alpha = baseColor.a;\n  #if USE_ALPHA_TEST\n    if(s.alpha < albedoScale.w)\n      discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, v_uv).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrScale.w) * normalize(v_tangent) +\n      (nmmp.y * pbrScale.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    pbr = texture2D(pbrMap, v_uv);\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, v_uv);\n    pbr.METALLIC_CHANNEL = metallicRoughness.METALLIC_CHANNEL;\n    pbr.ROUGHNESS_CHANNEL = metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.OCCLUSION_CHANNEL = texture2D(occlusionMap, v_uv).OCCLUSION_CHANNEL;\n  #endif\n  pbr *= pbrScale;\n  s.roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);\n  s.metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);\n  s.occlusion = pbr.OCCLUSION_CHANNEL;\n  s.emissive = emissive.rgb * emissiveScale.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, v_uv).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: [ {
                    name: "cc_environment",
                    defines: [ "CC_USE_IBL" ]
                } ]
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                }, {
                    name: "CCSkinningTexture",
                    defines: [ "CC_USE_SKINNING" ]
                }, {
                    name: "CCForwardLight",
                    defines: []
                } ],
                samplers: [ {
                    name: "cc_jointsTexture",
                    defines: [ "CC_USE_SKINNING" ]
                } ]
            }
        },
        defines: [ {
            name: "CC_USE_SKINNING",
            type: "number",
            defines: [],
            range: [ 0, 2 ]
        }, {
            name: "USE_NORMAL_MAP",
            type: "boolean",
            defines: []
        }, {
            name: "USE_ALBEDO_MAP",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_IBL",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        }, {
            name: "USE_PBR_MAP",
            type: "boolean",
            defines: []
        }, {
            name: "USE_METALLIC_ROUGHNESS_MAP",
            type: "boolean",
            defines: []
        }, {
            name: "USE_OCCLUSION_MAP",
            type: "boolean",
            defines: []
        }, {
            name: "USE_EMISSIVE_MAP",
            type: "boolean",
            defines: []
        }, {
            name: "ROUGHNESS_CHANNEL",
            type: "string",
            defines: [],
            options: [ "r", "g", "b", "a" ]
        }, {
            name: "METALLIC_CHANNEL",
            type: "string",
            defines: [],
            options: [ "g", "r", "b", "a" ]
        }, {
            name: "OCCLUSION_CHANNEL",
            type: "string",
            defines: [],
            options: [ "b", "r", "g", "a" ]
        }, {
            name: "USE_ALPHA_TEST",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "tilingOffset",
                type: 16,
                count: 1
            }, {
                name: "albedo",
                type: 16,
                count: 1
            }, {
                name: "albedoScale",
                type: 16,
                count: 1
            }, {
                name: "pbrParams",
                type: 16,
                count: 1
            }, {
                name: "pbrScale",
                type: 16,
                count: 1
            }, {
                name: "emissive",
                type: 16,
                count: 1
            }, {
                name: "emissiveScale",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "albedoMap",
            type: 28,
            count: 1,
            defines: [ "USE_ALBEDO_MAP" ],
            binding: 30
        }, {
            name: "normalMap",
            type: 28,
            count: 1,
            defines: [ "USE_NORMAL_MAP" ],
            binding: 31
        }, {
            name: "pbrMap",
            type: 28,
            count: 1,
            defines: [ "USE_PBR_MAP" ],
            binding: 32
        }, {
            name: "metallicRoughnessMap",
            type: 28,
            count: 1,
            defines: [ "USE_METALLIC_ROUGHNESS_MAP" ],
            binding: 33
        }, {
            name: "occlusionMap",
            type: 28,
            count: 1,
            defines: [ "USE_OCCLUSION_MAP" ],
            binding: 34
        }, {
            name: "emissiveMap",
            type: 28,
            count: 1,
            defines: [ "USE_EMISSIVE_MAP" ],
            binding: 35
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-terrain",
    techniques: [ {
        name: "opaque",
        passes: [ {
            program: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
            properties: {
                UVScale: {
                    value: [ 1, 1, 1, 1 ],
                    type: 16
                },
                weightMap: {
                    value: "black",
                    type: 28
                },
                detailMap0: {
                    value: "grey",
                    type: 28
                },
                detailMap1: {
                    value: "grey",
                    type: 28
                },
                detailMap2: {
                    value: "grey",
                    type: 28
                },
                detailMap3: {
                    value: "grey",
                    type: 28
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
        hash: 3405213441,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 uvw;\nout vec2 uv0;\nout vec2 uv1;\nout vec2 uv2;\nout vec2 uv3;\nout vec3 diffuse;\nuniform TexCoords {\n  vec4 UVScale;\n};\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  pos = cc_matViewProj * pos;\n  uvw = a_texCoord;\n  uv0 = a_position.xz * UVScale.x;\n  uv1 = a_position.xz * UVScale.y;\n  uv2 = a_position.xz * UVScale.z;\n  uv3 = a_position.xz * UVScale.w;\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 N = a_normal;\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  diffuse = ambDiff + vec3(dot(N, L));\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  color.rgb *= diffuse;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_mainLitDir;\nuniform vec4 cc_ambientSky;\nuniform vec4 cc_ambientGround;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 uvw;\nvarying vec2 uv0;\nvarying vec2 uv1;\nvarying vec2 uv2;\nvarying vec2 uv3;\nvarying vec3 diffuse;\nuniform vec4 UVScale;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  pos = cc_matViewProj * pos;\n  uvw = a_texCoord;\n  uv0 = a_position.xz * UVScale.x;\n  uv1 = a_position.xz * UVScale.y;\n  uv2 = a_position.xz * UVScale.z;\n  uv3 = a_position.xz * UVScale.w;\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 N = a_normal;\n  float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  diffuse = ambDiff + vec3(dot(N, L));\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  color.rgb *= diffuse;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        }, {
            name: "LAYERS",
            type: "number",
            defines: [],
            range: [ 0, 3 ]
        } ],
        blocks: [ {
            name: "TexCoords",
            defines: [],
            binding: 0,
            members: [ {
                name: "UVScale",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "weightMap",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        }, {
            name: "detailMap0",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        }, {
            name: "detailMap1",
            type: 28,
            count: 1,
            defines: [],
            binding: 32
        }, {
            name: "detailMap2",
            type: 28,
            count: 1,
            defines: [],
            binding: 33
        }, {
            name: "detailMap3",
            type: 28,
            count: 1,
            defines: [],
            binding: 34
        } ],
        dependencies: {}
    } ]
}, {
    name: "builtin-unlit",
    techniques: [ {
        name: "opaque",
        passes: [ {
            program: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
            properties: {
                color: {
                    value: [ 1, 1, 1, 1 ],
                    inspector: {
                        type: "color"
                    },
                    type: 16
                },
                tilingOffset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                mainTexture: {
                    value: "grey",
                    type: 28
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
        hash: 4040740523,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\n#if USE_TEXTURE\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n  uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nhighp vec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  highp vec4 pos = cc_matViewProj * cc_matWorld * position;\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform Constant {\n    vec4 color;\n  };\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nhighp vec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  highp vec4 pos = cc_matViewProj * cc_matWorld * position;\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\n#if USE_COLOR\n  uniform vec4 color;\n#endif\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_COLOR\n    o *= color;\n  #endif\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                }, {
                    name: "CCSkinningTexture",
                    defines: [ "CC_USE_SKINNING" ]
                } ],
                samplers: [ {
                    name: "cc_jointsTexture",
                    defines: [ "CC_USE_SKINNING" ]
                } ]
            }
        },
        defines: [ {
            name: "CC_USE_SKINNING",
            type: "number",
            defines: [],
            range: [ 0, 2 ]
        }, {
            name: "USE_VERTEX_COLOR",
            type: "boolean",
            defines: []
        }, {
            name: "USE_TEXTURE",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        }, {
            name: "USE_COLOR",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "TexCoords",
            defines: [ "USE_TEXTURE" ],
            binding: 0,
            members: [ {
                name: "tilingOffset",
                type: 16,
                count: 1
            } ]
        }, {
            name: "Constant",
            defines: [ "USE_COLOR" ],
            binding: 1,
            members: [ {
                name: "color",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [ "USE_TEXTURE" ],
            binding: 30
        } ],
        dependencies: {}
    } ]
}, {
    name: "editor/terrain-circle-brush",
    techniques: [ {
        name: "transparent",
        passes: [ {
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            program: "editor/terrain-circle-brush|terrain-brush-vs:vert|terrain-brush-fs:frag",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                BrushPos: {
                    value: [ 0, 0, 0, 1 ],
                    type: 16
                },
                BrushParams: {
                    value: [ 2.5, 2.5, 0, 0 ],
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "editor/terrain-circle-brush|terrain-brush-vs:vert|terrain-brush-fs:frag",
        hash: 502409078,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nout vec4 wposition;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  wposition = cc_matWorld * pos;\n  wposition.y += 0.01;\n  pos = cc_matViewProj * wposition;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec4 wposition;\nuniform TexCoords {\n  vec4 BrushPos;\n  vec4 BrushParams;\n};\nvec4 frag () {\n  float Radius = BrushParams.x;\n  float Falloff = BrushParams.y;\n  float Distance = length(wposition.xz - BrushPos.xz);\n  float k = 0.0;\n  #if LINEAR\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n  #elif SMOOTH\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Distance - Radius) / Falloff;\n      k = sqrt(1.0 - y * y);\n    }\n  #elif SPHERICAL\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n    k = k*k*(3 - 2 * k);\n  #elif TIP\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Falloff + Radius - Distance) / Falloff;\n      k = 1.0 - sqrt(1.0 - y * y);\n    }\n  #endif\n  vec4 color = vec4(0, 0, 0, 0);\n  color.rgb = vec3(100, 100, 135) / 255.0;\n  color.a = 0.85 * k;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nvarying vec4 wposition;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  wposition = cc_matWorld * pos;\n  wposition.y += 0.01;\n  pos = cc_matViewProj * wposition;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec4 wposition;\nuniform vec4 BrushPos;\nuniform vec4 BrushParams;\nvec4 frag () {\n  float Radius = BrushParams.x;\n  float Falloff = BrushParams.y;\n  float Distance = length(wposition.xz - BrushPos.xz);\n  float k = 0.0;\n  #if LINEAR\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n  #elif SMOOTH\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Distance - Radius) / Falloff;\n      k = sqrt(1.0 - y * y);\n    }\n  #elif SPHERICAL\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      k = max(0.0, 1.0 - (Distance - Radius) / Falloff);\n    }\n    k = k*k*(3 - 2 * k);\n  #elif TIP\n    if (Distance <= Radius) {\n      k = 1.0;\n    }\n    else if (Distance > Radius + Falloff) {\n      k = 0.0;\n    }\n    else {\n      float y = (Falloff + Radius - Distance) / Falloff;\n      k = 1.0 - sqrt(1.0 - y * y);\n    }\n  #endif\n  vec4 color = vec4(0, 0, 0, 0);\n  color.rgb = vec3(100, 100, 135) / 255.0;\n  color.a = 0.85 * k;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        }, {
            name: "LINEAR",
            type: "boolean",
            defines: []
        }, {
            name: "SMOOTH",
            type: "boolean",
            defines: []
        }, {
            name: "SPHERICAL",
            type: "boolean",
            defines: []
        }, {
            name: "TIP",
            type: "boolean",
            defines: []
        } ],
        blocks: [ {
            name: "TexCoords",
            defines: [],
            binding: 0,
            members: [ {
                name: "BrushPos",
                type: 16,
                count: 1
            }, {
                name: "BrushParams",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [],
        dependencies: {}
    } ]
}, {
    name: "pipeline/planar-shadow",
    techniques: [ {
        passes: [ {
            phase: "planarShadow",
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            program: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1,
                stencilTestFront: !0,
                stencilFuncFront: 5,
                stencilPassOpFront: 2,
                stencilWriteMaskBack: 128,
                stencilWriteMaskFront: 128,
                stencilReadMaskBack: 128,
                stencilReadMaskFront: 128,
                stencilRefBack: 128,
                stencilRefFront: 128
            }
        } ]
    } ],
    shaders: [ {
        name: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
        hash: 3455522760,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CCShadow {\n  mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec4 a_weights;\nin vec4 a_joints;\nuniform CCSkinningTexture {\n  highp vec4 cc_jointsTextureInfo;\n};\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  vec4 pos = cc_matWorld * position;\n  pos = cc_matViewProj * cc_matLightPlaneProj * pos;\n  pos.z -= 0.0001;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform CCShadow {\n  mat4 cc_matLightPlaneProj;\n  vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nuniform mat4 cc_matLightPlaneProj;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\n#if CC_USE_SKINNING\nstruct StandardAttributes {\n  vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform highp vec4 cc_jointsTextureInfo;\nuniform sampler2D cc_jointsTexture;\n#if CC_USE_SKINNING == 1\n  highp float decode32(highp vec4 rgba) {\n    rgba = rgba * 255.0;\n    highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n    highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n    highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n    return Sign * exp2(Exponent - 23.0) * Mantissa;\n  }\n#endif\n#if CC_USE_SKINNING == 1\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 12.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 3.5) * invSize, y)))\n    );\n    Qt = vec4(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 4.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 5.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 6.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 7.5) * invSize, y)))\n    );\n    S = vec3(\n      decode32(texture2D(cc_jointsTexture, vec2((x + 8.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 9.5) * invSize, y))),\n      decode32(texture2D(cc_jointsTexture, vec2((x + 10.5) * invSize, y)))\n    );\n  }\n#elif CC_USE_SKINNING == 2\n  void getJointDQ(float i, out vec4 Qr, out vec4 Qt, out vec3 S) {\n    highp float j = 3.0 * (cc_jointsTextureInfo.z * i + cc_jointsTextureInfo.w) + cc_jointsTextureInfo.y;\n    highp float invSize = 1.0 / cc_jointsTextureInfo.x;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointsTextureInfo.x;\n    y = (y + 0.5) * invSize;\n    Qr = texture2D(cc_jointsTexture, vec2((x + 0.5) * invSize, y));\n    Qt = texture2D(cc_jointsTexture, vec2((x + 1.5) * invSize, y));\n    S = texture2D(cc_jointsTexture, vec2((x + 2.5) * invSize, y)).xyz;\n  }\n#endif\nvoid skinRTS(out vec4 R, out vec3 T, out vec3 S) {\n  vec4 r, t, Qt = vec4(0.0); vec3 s;\n  R = vec4(0.0); S = vec3(0.0);\n  for (int i = 0; i < 4; i++) {\n    float w = a_weights[i];\n    getJointDQ(a_joints[i], r, t, s);\n    S += s * w; R += r * w; Qt += t * w;\n  }\n  float invNorm = 1.0 / length(R); R *= invNorm; Qt *= invNorm;\n  T = 2.0 * (R.w * Qt.xyz - Qt.w * R.xyz + cross(R.xyz, Qt.xyz));\n}\nvec3 VectorTransformQuat(vec3 v, vec4 Q) {\n\treturn v + 2.0 * cross(Q.xyz, cross(Q.xyz, v) + Q.w * v);\n}\nvoid CCSkin(inout vec4 position) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  position.xyz = VectorTransformQuat(position.xyz * S, R) + T;\n}\nvoid CCSkin(inout StandardAttributes attr) {\n  vec4 R; vec3 T, S;\n  skinRTS(R, T, S);\n  attr.position.xyz = VectorTransformQuat(attr.position.xyz * S, R) + T;\n  attr.normal = VectorTransformQuat(attr.normal, R);\n  attr.tangent.xyz = VectorTransformQuat(attr.tangent.xyz, R);\n}\n#endif\nvoid CCVertInput (out highp vec4 position) {\n  CCDecode(position);\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  vec4 pos = cc_matWorld * position;\n  pos = cc_matViewProj * cc_matLightPlaneProj * pos;\n  pos.z -= 0.0001;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform vec4 cc_shadowColor;\nuniform vec4 cc_exposure;\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                }, {
                    name: "CCShadow",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                }, {
                    name: "CCSkinningTexture",
                    defines: [ "CC_USE_SKINNING" ]
                } ],
                samplers: [ {
                    name: "cc_jointsTexture",
                    defines: [ "CC_USE_SKINNING" ]
                } ]
            }
        },
        defines: [ {
            name: "CC_USE_SKINNING",
            type: "number",
            defines: [],
            range: [ 0, 2 ]
        }, {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        } ],
        blocks: [],
        samplers: [],
        dependencies: {}
    } ]
}, {
    name: "pipeline/skybox",
    techniques: [ {
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            program: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
            priority: 245,
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            }
        } ]
    } ],
    shaders: [ {
        name: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
        hash: 3895563201,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\nout vec4 viewDir;\nvec4 vert () {\n  CCDecode(viewDir);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  highp vec4 pos = cc_matProj * matViewRotOnly * viewDir;\n  pos.z = pos.w * 0.99999;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform samplerCube cc_environment;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nin vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n    c = LinearToSRGB(c / (1.0 + c));\n    vec4 o = vec4(c, 1.0);\n  #else\n    vec4 o = texture(cc_environment, viewDir.xyz);\n  #endif\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matProj;\nattribute vec3 a_position;\nvoid CCDecode (out vec4 position) {\n  position = vec4(a_position, 1.0);\n}\nvarying vec4 viewDir;\nvec4 vert () {\n  CCDecode(viewDir);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  highp vec4 pos = cc_matProj * matViewRotOnly * viewDir;\n  pos.z = pos.w * 0.99999;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision mediump float;\nuniform samplerCube cc_environment;\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackRGBE(vec4 rgbe) {\n    return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nuniform vec4 cc_exposure;\nvec4 CCFragOutput(vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n\t#endif\n\treturn color;\n}\nvarying vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n    c = LinearToSRGB(c / (1.0 + c));\n    vec4 o = vec4(c, 1.0);\n  #else\n    vec4 o = textureCube(cc_environment, viewDir.xyz);\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: [ {
                    name: "cc_environment",
                    defines: []
                } ]
            },
            locals: {
                blocks: [],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        }, {
            name: "USE_RGBE_CUBEMAP",
            type: "boolean",
            defines: []
        } ],
        blocks: [],
        samplers: [],
        dependencies: {}
    } ]
}, {
    name: "pipeline/smaa",
    techniques: [ {
        name: "smaa",
        passes: [ {
            program: "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
            depthStencilState: {
                depthTest: !1,
                depthWrite: !1
            },
            properties: {
                u_texSampler: {
                    type: 28,
                    samplerHash: 66186
                }
            }
        }, {
            program: "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
            depthStencilState: {
                depthTest: !1,
                depthWrite: !1
            },
            properties: {
                u_edgeTexSampler: {
                    type: 28,
                    samplerHash: 66186
                },
                u_areaTexSampler: {
                    type: 28,
                    samplerHash: 66186
                },
                u_searchTexSampler: {
                    type: 28,
                    samplerHash: 66181
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "pipeline/smaa|smaa-edge-vs:vert|smaa-edge-fs:frag",
        hash: 734353496,
        glsl3: {
            vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision highp float;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-1.0, 0.0, 0.0, 1.0);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4( 1.0, 0.0, 0.0, -1.0);\n  v_offsets[2] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-2.0, 0.0, 0.0, 2.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform vec4 cc_exposure;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nuniform sampler2D u_texSampler;\nvec3 ToLDR(vec3 color) {\n#if CC_USE_HDR\n  color *= cc_exposure.x * 1024.0;\n  color = ACESToneMap(color);\n  color = LinearToSRGB(color);\n#endif\n  return color;\n}\nvec4 frag () {\n  vec2 threshold = vec2(0.1, 0.1);\n  vec4 delta;\n  vec3 C = ToLDR(texture2D(u_texSampler, v_uv).rgb);\n  vec3 Cleft = ToLDR(texture2D(u_texSampler, v_offsets[0].xy).rgb);\n  vec3 t = abs(C - Cleft);\n  delta.x = max(max(t.r, t.g), t.b);\n  vec3 Ctop = ToLDR(texture2D(u_texSampler, v_offsets[0].zw).rgb);\n  t = abs(C - Ctop);\n  delta.y = max(max(t.r, t.g), t.b);\n  vec2 edges = step(threshold, delta.xy);\n  if (dot(edges, vec2(1.0, 1.0)) == 0.0)\n    discard;\n  vec3 Cright = ToLDR(texture2D(u_texSampler, v_offsets[1].xy).rgb);\n  t = abs(C - Cright);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Cbottom = ToLDR(texture2D(u_texSampler, v_offsets[1].zw).rgb);\n  t = abs(C - Cbottom);\n  delta.w = max(max(t.r, t.g), t.b);\n  float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\n  vec3 Cleftleft = ToLDR(texture2D(u_texSampler, v_offsets[2].xy).rgb);\n  t = abs(C - Cleftleft);\n  delta.z = max(max(t.r, t.g), t.b);\n  vec3 Ctoptop = ToLDR(texture2D(u_texSampler, v_offsets[2].zw).rgb);\n  t = abs(C - Ctoptop);\n  delta.w = max(max(t.r, t.g), t.b);\n  maxDelta = max(max(maxDelta, delta.z), delta.w);\n  edges.xy *= step(0.5 * maxDelta, delta.xy);\n  vec4 o = vec4(edges, 0.0, 0.0);\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        } ],
        blocks: [],
        samplers: [ {
            name: "u_texSampler",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        } ],
        dependencies: {}
    }, {
        name: "pipeline/smaa|smaa-blend-vs:vert|smaa-blend-fs:frag",
        hash: 1697076750,
        glsl3: {
            vert: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offsets[3];\nout vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 v_uv;\nin vec4 v_offsets[3];\nin vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision highp float;\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0.0, 1.0);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_pixCoord = v_uv * cc_nativeSize.xy;\n  v_offsets[0] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.25, 0.125, 1.25, 0.125);\n  v_offsets[1] = v_uv.xyxy + cc_nativeSize.zwzw * vec4(-0.125, 0.25, -0.125, -1.25);\n  v_offsets[2] = vec4(v_offsets[0].xz, v_offsets[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * cc_nativeSize.zzww * float(8);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform vec4 cc_nativeSize;\nvarying vec2 v_uv;\nvarying vec4 v_offsets[3];\nvarying vec2 v_pixCoord;\nuniform sampler2D u_edgeTexSampler;\nuniform sampler2D u_areaTexSampler;\nuniform sampler2D u_searchTexSampler;\nfloat SMAASearchLength(vec2 e, float bias, float scale) {\n  e.r = bias + e.r * scale;\n  return 255.0 * texture2D(u_searchTexSampler, e).r;\n}\nfloat SMAASearchXLeft(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord -= vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x > end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x += 0.25 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z;\n  texcoord.x += 2.0 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z * SMAASearchLength(e, 0.0, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchXRight(vec2 texcoord, float end) {\n  vec2 e = vec2(0.0, 1.0);\n  for (int i = 0; i < 8; ++i) {\n      e = texture2D(u_edgeTexSampler, texcoord).rg;\n      texcoord += vec2( 2.0, 0.0 ) * cc_nativeSize.zw;\n      if (!(texcoord.x < end && e.g > 0.8281 && e.r == 0.0))\n        break;\n  }\n  texcoord.x -= 0.25 * cc_nativeSize.z;\n  texcoord.x -= cc_nativeSize.z;\n  texcoord.x -= 2.0 * cc_nativeSize.z;\n  texcoord.x += cc_nativeSize.z * SMAASearchLength(e, 0.5, 0.5);\n  return texcoord.x;\n}\nfloat SMAASearchYUp(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord += vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y > end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y -= 0.25 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w;\n    texcoord.y -= 2.0 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w * SMAASearchLength(e.gr, 0.0, 0.5);\n    return texcoord.y;\n}\nfloat SMAASearchYDown(vec2 texcoord, float end) {\n    vec2 e = vec2(1.0, 0.0);\n    for (int i = 0; i < 8; ++i) {\n        e = texture2D(u_edgeTexSampler, texcoord).rg;\n        texcoord -= vec2( 0.0, 2.0 ) * cc_nativeSize.zw;\n        if (!(texcoord.y < end && e.r > 0.8281 && e.g == 0.0))\n          break;\n    }\n    texcoord.y += 0.25 * cc_nativeSize.w;\n    texcoord.y += cc_nativeSize.w;\n    texcoord.y += 2.0 * cc_nativeSize.w;\n    texcoord.y -= cc_nativeSize.w * SMAASearchLength(e.gr, 0.5, 0.5);\n    return texcoord.y;\n}\nvec2 Round(vec2 x) {\n  return sign(x) * floor(abs(x) + 0.5);\n}\nvec2 SMAAArea(vec2 dist, float e1, float e2) {\n    vec2 texcoord = float(16) * Round(4.0 * vec2(e1, e2)) + dist;\n    texcoord = (1.0 / vec2(160.0, 560.0)) * texcoord + 0.5 * (1.0 / vec2(160.0, 560.0));\n    return texture2D(u_areaTexSampler, texcoord).rg;\n}\nvec4 frag () {\n  vec4 weights = vec4(0.0);\n  vec2 e = texture2D(u_edgeTexSampler, v_uv).rg;\n  vec2 d;\n  vec2 coords;\n  if ( e.g > 0.0 ) {\n      coords.x = SMAASearchXLeft(v_offsets[0].xy, v_offsets[2].x);\n      coords.y = v_offsets[1].y;\n      d.x = coords.x;\n      float e1 = texture2D(u_edgeTexSampler, coords).r;\n      coords.x = SMAASearchXRight(v_offsets[0].zw, v_offsets[2].y);\n      d.y = coords.x;\n      d = d / cc_nativeSize.z - v_pixCoord.x;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(cc_nativeSize.z, 0.0)).r;\n      weights.rg = SMAAArea(sqrt_d, e1, e2);\n  }\n  if ( e.r > 0.0 ) {\n      coords.y = SMAASearchYUp(v_offsets[1].xy, v_offsets[2].z);\n      coords.x = v_offsets[0].x;\n      d.x = coords.y;\n      float e1 = texture2D(u_edgeTexSampler, coords).g;\n      coords.y = SMAASearchYDown(v_offsets[1].zw, v_offsets[2].w);\n      d.y = coords.y;\n      d = d / cc_nativeSize.w - v_pixCoord.y;\n      vec2 sqrt_d = sqrt(abs(d));\n      coords.y -= 1.0 * cc_nativeSize.w;\n      float e2 = texture2D(u_edgeTexSampler, coords + vec2(0.0, cc_nativeSize.w)).g;\n      weights.ba = SMAAArea(sqrt_d, e1, e2);\n  }\n  return weights;\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [],
                samplers: []
            }
        },
        defines: [],
        blocks: [],
        samplers: [ {
            name: "u_edgeTexSampler",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        }, {
            name: "u_areaTexSampler",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        }, {
            name: "u_searchTexSampler",
            type: 28,
            count: 1,
            defines: [],
            binding: 32
        } ],
        dependencies: {}
    } ]
}, {
    name: "pipeline/tonemap",
    techniques: [ {
        name: "tonemap",
        passes: [ {
            program: "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
            depthStencilState: {
                depthTest: !1,
                depthWrite: !1
            },
            properties: {
                u_texSampler: {
                    type: 28,
                    samplerHash: 66186
                },
                u_blendTexSampler: {
                    type: 28,
                    samplerHash: 66186
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "pipeline/tonemap|tonemap-vs:vert|tonemap-fs:frag",
        hash: 433933566,
        glsl3: {
            vert: "\nprecision highp float;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n  vec4 cc_screenSize;\n  vec4 cc_screenScale;\n  vec4 cc_nativeSize;\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_exposure;\n  vec4 cc_mainLitDir;\n  vec4 cc_mainLitColor;\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nin vec2 v_uv;\nin vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n  #if CC_USE_HDR\n    color *= cc_exposure.x * 1024.0;\n    color = ACESToneMap(color);\n    color = LinearToSRGB(color);\n  #endif\n  return color;\n}\nvec4 frag () {\n  #if CC_USE_SMAA\n    vec4 a;\n    a.rb = texture(u_blendTexSampler, v_uv).rb;\n    a.g = texture(u_blendTexSampler, v_offset.zw).g;\n    a.a = texture(u_blendTexSampler, v_offset.xy).a;\n    if (dot(a, vec4(1.0)) < 1e-5) {\n      vec4 o = texture(u_texSampler, v_uv);\n      o.rgb = ToLDR(o.rgb);\n      return o;\n    } else {\n      vec2 offset;\n      offset.x = a.a > a.b ? a.a : -a.b;\n      offset.y = a.g > a.r ? -a.g : a.r;\n      if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n      } else {\n        offset.x = 0.0;\n      }\n      vec4 C = texture(u_texSampler, v_uv);\n      C.rgb = ToLDR(C.rgb);\n      vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n      vec4 Cop = texture(u_texSampler, uv);\n      Cop.rgb = ToLDR(Cop.rgb);\n      float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n      C.rgb = pow(C.rgb, vec3(2.2));\n      Cop.rgb = pow(Cop.rgb, vec3(2.2));\n      vec4 mixed = mix(C, Cop, s);\n      mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n      return mixed;\n    }\n  #else\n    vec4 o = texture(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  #endif\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }\n"
        },
        glsl1: {
            vert: "\nprecision highp float;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform vec4 cc_screenScale;\nuniform vec4 cc_nativeSize;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord * cc_screenScale.xy;\n  v_offset = v_uv.xyxy + cc_nativeSize.zwzw * vec4(1.0, 0.0, 0.0, -1.0);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }\n",
            frag: "\nprecision highp float;\nuniform vec4 cc_nativeSize;\nuniform vec4 cc_exposure;\n#define saturate(a) clamp( a, 0.0, 1.0 )\nvec3 SRGBToLinear(vec3 gamma)\n{\n\treturn pow(gamma, vec3(2.2));\n}\nvec3 LinearToSRGB(vec3 linear)\n{\n\treturn pow(linear, vec3(0.454545));\n}\nvec3 ACESToneMap(vec3 color) {\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvarying vec2 v_uv;\nvarying vec4 v_offset;\nuniform sampler2D u_texSampler;\nuniform sampler2D u_blendTexSampler;\nvec3 ToLDR(vec3 color) {\n  #if CC_USE_HDR\n    color *= cc_exposure.x * 1024.0;\n    color = ACESToneMap(color);\n    color = LinearToSRGB(color);\n  #endif\n  return color;\n}\nvec4 frag () {\n  #if CC_USE_SMAA\n    vec4 a;\n    a.rb = texture2D(u_blendTexSampler, v_uv).rb;\n    a.g = texture2D(u_blendTexSampler, v_offset.zw).g;\n    a.a = texture2D(u_blendTexSampler, v_offset.xy).a;\n    if (dot(a, vec4(1.0)) < 1e-5) {\n      vec4 o = texture2D(u_texSampler, v_uv);\n      o.rgb = ToLDR(o.rgb);\n      return o;\n    } else {\n      vec2 offset;\n      offset.x = a.a > a.b ? a.a : -a.b;\n      offset.y = a.g > a.r ? -a.g : a.r;\n      if (abs(offset.x) > abs(offset.y)) {\n        offset.y = 0.0;\n      } else {\n        offset.x = 0.0;\n      }\n      vec4 C = texture2D(u_texSampler, v_uv);\n      C.rgb = ToLDR(C.rgb);\n      vec2 uv = v_uv + sign(offset) * cc_nativeSize.zw;\n      vec4 Cop = texture2D(u_texSampler, uv);\n      Cop.rgb = ToLDR(Cop.rgb);\n      float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\n      C.rgb = pow(C.rgb, vec3(2.2));\n      Cop.rgb = pow(Cop.rgb, vec3(2.2));\n      vec4 mixed = mix(C, Cop, s);\n      mixed.rgb = pow(mixed.rgb, vec3(1.0 / 2.2));\n      return mixed;\n    }\n  #else\n    vec4 o = texture2D(u_texSampler, v_uv);\n    o.rgb = ToLDR(o.rgb);\n    return o;\n  #endif\n}\nvoid main() { gl_FragColor = frag(); }\n"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean",
            defines: []
        }, {
            name: "CC_USE_SMAA",
            type: "boolean",
            defines: []
        } ],
        blocks: [],
        samplers: [ {
            name: "u_texSampler",
            type: 28,
            count: 1,
            defines: [],
            binding: 30
        }, {
            name: "u_blendTexSampler",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        } ],
        dependencies: {}
    } ]
} ], BuiltinResMgr = function() {
    function BuiltinResMgr() {
        _classCallCheck(this, BuiltinResMgr), this._device = null, this._resources = {};
    }
    return _createClass(BuiltinResMgr, [ {
        key: "initBuiltinRes",
        value: function initBuiltinRes(device) {
            this._device = device;
            var resources = this._resources, canvas = document.createElement("canvas"), context = canvas.getContext("2d"), imgAsset = new ImageAsset(canvas), l = canvas.width = canvas.height = 2;
            context.fillStyle = "#000", context.fillRect(0, 0, l, l);
            var blackTexture = new Texture2D();
            blackTexture._uuid = "black-texture", blackTexture.image = imgAsset, resources[blackTexture._uuid] = blackTexture;
            var blackCubeTexture = new TextureCube();
            blackCubeTexture._uuid = "black-cube-texture", blackCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
            blackCubeTexture.image = {
                front: new ImageAsset(canvas),
                back: new ImageAsset(canvas),
                left: new ImageAsset(canvas),
                right: new ImageAsset(canvas),
                top: new ImageAsset(canvas),
                bottom: new ImageAsset(canvas)
            }, blackCubeTexture.onLoaded(), resources[blackCubeTexture._uuid] = blackCubeTexture, 
            context.fillStyle = "#777", context.fillRect(0, 0, l, l);
            var greyTexture = new Texture2D();
            greyTexture._uuid = "grey-texture", greyTexture.image = imgAsset, greyTexture.onLoaded(), 
            resources[greyTexture._uuid] = greyTexture, context.fillStyle = "#fff", context.fillRect(0, 0, l, l);
            var whiteTexture = new Texture2D();
            whiteTexture._uuid = "white-texture", whiteTexture.image = imgAsset, whiteTexture.onLoaded(), 
            resources[whiteTexture._uuid] = whiteTexture;
            var whiteCubeTexture = new TextureCube();
            whiteCubeTexture._uuid = "white-cube-texture", whiteCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
            whiteCubeTexture.image = {
                front: new ImageAsset(canvas),
                back: new ImageAsset(canvas),
                left: new ImageAsset(canvas),
                right: new ImageAsset(canvas),
                top: new ImageAsset(canvas),
                bottom: new ImageAsset(canvas)
            }, whiteCubeTexture.onLoaded(), resources[whiteCubeTexture._uuid] = whiteCubeTexture, 
            context.fillStyle = "#7f7fff", context.fillRect(0, 0, l, l);
            var normalTexture = new Texture2D();
            normalTexture._uuid = "normal-texture", normalTexture.image = imgAsset, resources[normalTexture._uuid] = normalTexture, 
            canvas.width = canvas.height = 16, context.fillStyle = "#ddd", context.fillRect(0, 0, 16, 16), 
            context.fillStyle = "#555", context.fillRect(0, 0, 8, 8), context.fillStyle = "#555", 
            context.fillRect(8, 8, 8, 8);
            var defaultTexture = new Texture2D();
            defaultTexture._uuid = "default-texture", defaultTexture.image = imgAsset, defaultTexture.onLoaded(), 
            resources[defaultTexture._uuid] = defaultTexture;
            var defaultCubeTexture = new TextureCube();
            defaultCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), defaultCubeTexture._uuid = "default-cube-texture", 
            defaultCubeTexture.image = {
                front: new ImageAsset(canvas),
                back: new ImageAsset(canvas),
                left: new ImageAsset(canvas),
                right: new ImageAsset(canvas),
                top: new ImageAsset(canvas),
                bottom: new ImageAsset(canvas)
            }, defaultCubeTexture.onLoaded(), resources[defaultCubeTexture._uuid] = defaultCubeTexture;
            var spriteFrame = new SpriteFrame();
            spriteFrame.texture.image = imgAsset, spriteFrame._uuid = "default-spriteframe", 
            resources[spriteFrame._uuid] = spriteFrame, effects$1.forEach(function(e) {
                Object.assign(new cc.EffectAsset(), e).onLoaded();
            });
            var standardMtl = new cc.Material();
            standardMtl._uuid = "standard-material", standardMtl.initialize({
                effectName: "builtin-standard"
            }), standardMtl.onLoaded(), resources[standardMtl._uuid] = standardMtl;
            var missingMtl = new cc.Material();
            missingMtl._uuid = "missing-material", missingMtl.initialize({
                effectName: "builtin-unlit",
                defines: {
                    USE_COLOR: !0
                }
            }), missingMtl.setProperty("color", cc.color("#ff00ff")), missingMtl.onLoaded(), 
            resources[missingMtl._uuid] = missingMtl;
            var missingSkinningMtl = new cc.Material();
            missingSkinningMtl._uuid = "missing-skinning-material";
            var type = selectJointsMediumType(device);
            missingSkinningMtl.initialize({
                effectName: "builtin-unlit",
                defines: {
                    USE_COLOR: !0,
                    CC_USE_SKINNING: type
                }
            }), missingSkinningMtl.setProperty("color", cc.color("#ff00ff")), missingSkinningMtl.onLoaded(), 
            resources[missingSkinningMtl._uuid] = missingSkinningMtl;
            var missingEfxMtl = new cc.Material();
            missingEfxMtl._uuid = "missing-effect-material", missingEfxMtl.initialize({
                effectName: "builtin-unlit",
                defines: {
                    USE_COLOR: !0
                }
            }), missingEfxMtl.setProperty("color", cc.color("#ffff00")), missingEfxMtl.onLoaded(), 
            resources[missingEfxMtl._uuid] = missingEfxMtl;
            var spriteMtl = new cc.Material();
            spriteMtl._uuid = "ui-base-material", spriteMtl.initialize({
                defines: {
                    USE_TEXTURE: !1
                },
                effectName: "builtin-sprite"
            }), spriteMtl.onLoaded(), resources[spriteMtl._uuid] = spriteMtl;
            var spriteColorMtl = new cc.Material();
            spriteColorMtl._uuid = "ui-sprite-material", spriteColorMtl.initialize({
                defines: {
                    USE_TEXTURE: !0
                },
                effectName: "builtin-sprite"
            }), spriteColorMtl.onLoaded(), resources[spriteColorMtl._uuid] = spriteColorMtl;
            var defaultParticleMtl = new cc.Material();
            defaultParticleMtl._uuid = "default-particle-material", defaultParticleMtl.initialize({
                effectName: "builtin-particle"
            }), defaultParticleMtl.onLoaded(), resources[defaultParticleMtl._uuid] = defaultParticleMtl;
            var defaultTrailMtl = new cc.Material();
            defaultTrailMtl._uuid = "default-trail-material", defaultTrailMtl.initialize({
                effectName: "builtin-particle-trail"
            }), defaultTrailMtl.onLoaded(), resources[defaultTrailMtl._uuid] = defaultTrailMtl;
            var defaultBillboardMtl = new cc.Material();
            defaultBillboardMtl._uuid = "default-billboard-material", defaultBillboardMtl.initialize({
                effectName: "builtin-billboard"
            }), defaultBillboardMtl.onLoaded(), resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
        }
    }, {
        key: "get",
        value: function get(uuid) {
            return this._resources[uuid];
        }
    } ]), BuiltinResMgr;
}(), builtinResMgr = cc.builtinResMgr = new BuiltinResMgr(), getPhaseID = (phases = new Map(), 
phaseNum = 0, function(phaseName) {
    return phases.has(phaseName) || (phases.set(phaseName, 1 << phaseNum), phaseNum++), 
    phases.get(phaseName);
}), _type2fn = (_defineProperty(_type2fn2 = {}, GFXType.INT, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return a[idx] = v;
}), _defineProperty(_type2fn2, GFXType.INT2, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec2.array(a, v, 2 * idx);
}), _defineProperty(_type2fn2, GFXType.INT3, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec3.array(a, v, 3 * idx);
}), _defineProperty(_type2fn2, GFXType.INT4, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec4.array(a, v, 4 * idx);
}), _defineProperty(_type2fn2, GFXType.FLOAT, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return a[idx] = v;
}), _defineProperty(_type2fn2, GFXType.FLOAT2, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec2.array(a, v, 2 * idx);
}), _defineProperty(_type2fn2, GFXType.FLOAT3, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec3.array(a, v, 3 * idx);
}), _defineProperty(_type2fn2, GFXType.FLOAT4, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec4.array(a, v, 4 * idx);
}), _defineProperty(_type2fn2, GFXType.MAT3, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Mat3.array(a, v, 9 * idx);
}), _defineProperty(_type2fn2, GFXType.MAT4, function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Mat4.array(a, v, 16 * idx);
}), _type2fn2), _type2default = (_defineProperty(_type2default2 = {}, GFXType.INT, [ 0 ]), 
_defineProperty(_type2default2, GFXType.INT2, [ 0, 0 ]), _defineProperty(_type2default2, GFXType.INT3, [ 0, 0, 0 ]), 
_defineProperty(_type2default2, GFXType.INT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default2, GFXType.FLOAT, [ 0 ]), 
_defineProperty(_type2default2, GFXType.FLOAT2, [ 0, 0 ]), _defineProperty(_type2default2, GFXType.FLOAT3, [ 0, 0, 0 ]), 
_defineProperty(_type2default2, GFXType.FLOAT4, [ 0, 0, 0, 0 ]), _defineProperty(_type2default2, GFXType.MAT3, [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 
_defineProperty(_type2default2, GFXType.MAT4, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]), 
_defineProperty(_type2default2, GFXType.SAMPLER2D, "default-texture"), _defineProperty(_type2default2, GFXType.SAMPLER_CUBE, "default-cube-texture"), 
_type2default2), genHandle = function genHandle(bt, binding, type) {
    var index = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    return bt << 28 & 4026531840 | type << 22 & 264241152 | binding << 11 & 4192256 | 2047 & index;
}, isBuiltin = function isBuiltin(binding) {
    return binding >= UniformBinding.CUSTUM_UBO_BINDING_END_POINT;
}, Pass = function() {
    function Pass(device) {
        _classCallCheck(this, Pass), this._buffers = {}, this._samplers = {}, this._textureViews = {}, 
        this._resources = [], this._phase = 0, this._idxInTech = 0, this._programName = "", 
        this._priority = RenderPriority.DEFAULT, this._primitive = GFXPrimitiveMode.TRIANGLE_LIST, 
        this._stage = RenderPassStage.DEFAULT, this._bindings = [], this._bs = new GFXBlendState(), 
        this._dss = new GFXDepthStencilState(), this._rs = new GFXRasterizerState(), this._dynamicStates = [], 
        this._dynamics = {}, this._customizations = [], this._handleMap = {}, this._blocks = [], 
        this._shaderInfo = null, this._defines = {}, this._properties = {}, this._device = void 0, 
        this._renderPass = null, this._shader = null, this._device = device;
    }
    return _createClass(Pass, null, [ {
        key: "createPasses",
        value: function createPasses(effect, info) {
            if (!effect.techniques) return [];
            for (var techIdx = info.techIdx, defines = info.defines, states = info.states, tech = effect.techniques[techIdx || 0], passNum = tech.passes.length, passes = [], k = 0; k < passNum; ++k) {
                var passInfo = tech.passes[k], defs = passInfo.curDefs = defines.length > k ? defines[k] : {};
                if (!passInfo.switch || defs[passInfo.switch]) {
                    passInfo.states = states.length > k ? states[k] : {}, passInfo.idxInTech = k;
                    var pass = new Pass(cc.game._gfxDevice);
                    pass.initialize(passInfo), passes.push(pass);
                }
            }
            return passes;
        }
    } ]), _createClass(Pass, [ {
        key: "initialize",
        value: function initialize(info) {
            var _this = this;
            this._idxInTech = info.idxInTech, this._programName = info.program, this._defines = info.curDefs, 
            this._shaderInfo = programLib.getTemplate(info.program), this._properties = info.properties || this._properties;
            var device = this._device;
            this._fillinPipelineInfo(info), this._fillinPipelineInfo(info.states);
            var _loop2 = function _loop2() {
                if (_isArray) {
                    if (_i >= _iterator.length) return "break";
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) return "break";
                    _ref = _i.value;
                }
                var u = _ref;
                if (isBuiltin(u.binding)) return "continue";
                var blockSize = u.members.reduce(function(s, m) {
                    return s + GFXGetTypeSize(m.type) * m.count;
                }, 0);
                _this._buffers[u.binding] = device.createBuffer({
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: 16 * Math.ceil(blockSize / 16),
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST
                });
                var block = _this._blocks[u.binding] = {
                    buffer: new ArrayBuffer(blockSize),
                    dirty: !1,
                    views: []
                };
                u.members.reduce(function(acc, cur, idx) {
                    var size = GFXGetTypeSize(cur.type) * cur.count, view = new Float32Array(block.buffer, acc, size / Float32Array.BYTES_PER_ELEMENT);
                    return block.views.push(view), _this._handleMap[cur.name] = genHandle(GFXBindingType.UNIFORM_BUFFER, u.binding, cur.type, idx), 
                    acc + size;
                }, 0);
            };
            var _iterator = this._shaderInfo.blocks, _isArray = Array.isArray(_iterator), _i = 0;
            _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                switch (_loop2()) {
                  case "break":
                    break _loop;

                  case "continue":
                    continue;
                }
            }
            var _iterator2 = this._shaderInfo.samplers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var u = _ref2;
                this._handleMap[u.name] = genHandle(GFXBindingType.SAMPLER, u.binding, u.type);
            }
            this.resetUBOs(), this.resetTextures(), this.tryCompile();
        }
    }, {
        key: "getHandle",
        value: function getHandle(name) {
            return this._handleMap[name];
        }
    }, {
        key: "getBinding",
        value: function getBinding(name) {
            var handle = this.getHandle(name);
            if (void 0 !== handle) return Pass.getBindingFromHandle(handle);
        }
    }, {
        key: "setUniform",
        value: function setUniform(handle, value) {
            var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), idx = Pass.getIndexFromHandle(handle), block = this._blocks[binding];
            _type2fn[type](block.views[idx], value), block.dirty = !0;
        }
    }, {
        key: "setUniformArray",
        value: function setUniformArray(handle, value) {
            for (var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), idx = Pass.getIndexFromHandle(handle), block = this._blocks[binding], i = 0; i < value.length; i++) null !== value[i] && _type2fn[type](block.views[idx], value[i], i);
            block.dirty = !0;
        }
    }, {
        key: "bindBuffer",
        value: function bindBuffer(binding, value) {
            this._buffers[binding] = value;
            var _iterator3 = this._resources, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                _ref3.bindingLayout.bindBuffer(binding, value);
            }
        }
    }, {
        key: "bindTextureView",
        value: function bindTextureView(binding, value) {
            this._textureViews[binding] = value;
            var _iterator4 = this._resources, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                _ref4.bindingLayout.bindTextureView(binding, value);
            }
        }
    }, {
        key: "bindSampler",
        value: function bindSampler(binding, value) {
            this._samplers[binding] = value;
            var _iterator5 = this._resources, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                _ref5.bindingLayout.bindSampler(binding, value);
            }
        }
    }, {
        key: "setDynamicState",
        value: function setDynamicState(state, value) {
            var ds = this._dynamics[state];
            ds && ds.value === value || (ds.value = value, ds.dirty = !0);
        }
    }, {
        key: "overridePipelineStates",
        value: function overridePipelineStates(original, overrides) {
            this._bs = new GFXBlendState(), this._dss = new GFXDepthStencilState(), this._rs = new GFXRasterizerState(), 
            this._fillinPipelineInfo(original), this._fillinPipelineInfo(overrides);
        }
    }, {
        key: "update",
        value: function update() {
            for (var len = this._blocks.length, i = 0; i < len; i++) {
                var block = this._blocks[i];
                block.dirty && (this._buffers[i].update(block.buffer), block.dirty = !1);
            }
            var source = cc.director.root.pipeline.globalBindings, _iterator6 = this._shaderInfo.builtins.globals.samplers, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    if ((_i6 = _iterator6.next()).done) break;
                    _ref6 = _i6.value;
                }
                var s = _ref6, info = source.get(s.name);
                info.sampler && this.bindSampler(info.samplerInfo.binding, info.sampler), this.bindTextureView(info.samplerInfo.binding, info.textureView);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var _iterator7 = this._shaderInfo.blocks, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                var _ref7;
                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    if ((_i7 = _iterator7.next()).done) break;
                    _ref7 = _i7.value;
                }
                var u = _ref7;
                isBuiltin(u.binding) || this._buffers[u.binding].destroy();
            }
            this._buffers = {}, this._samplers = {}, this._textureViews = {};
        }
    }, {
        key: "resetUBOs",
        value: function resetUBOs() {
            var _iterator8 = this._shaderInfo.blocks, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                var _ref8;
                if (_isArray8) {
                    if (_i8 >= _iterator8.length) break;
                    _ref8 = _iterator8[_i8++];
                } else {
                    if ((_i8 = _iterator8.next()).done) break;
                    _ref8 = _i8.value;
                }
                var u = _ref8;
                if (!isBuiltin(u.binding)) {
                    for (var block = this._blocks[u.binding], i = 0; i < u.members.length; i++) for (var cur = u.members[i], view = block.views[i], inf = this._properties[cur.name], givenDefault = inf && inf.value, value = givenDefault || _type2default[cur.type], j = 0; j < cur.count; j++) view.set(value, j * value.length);
                    block.dirty = !0;
                }
            }
        }
    }, {
        key: "resetTextures",
        value: function resetTextures() {
            var device = this._device, _iterator9 = this._shaderInfo.samplers, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                var _ref9;
                if (_isArray9) {
                    if (_i9 >= _iterator9.length) break;
                    _ref9 = _iterator9[_i9++];
                } else {
                    if ((_i9 = _iterator9.next()).done) break;
                    _ref9 = _i9.value;
                }
                var u = _ref9, inf = this._properties[u.name];
                inf && void 0 !== inf.samplerHash && (this._samplers[u.binding] = samplerLib.getSampler(device, inf.samplerHash));
                var texName = inf && inf.value ? inf.value + "-texture" : _type2default[u.type], texture = builtinResMgr.get(texName);
                if (texture) {
                    this._textureViews[u.binding] = texture.getGFXTextureView();
                    var samplerHash = texture.getSamplerHash();
                    (!this._samplers[u.binding] || samplerHash > 0) && (this._samplers[u.binding] = samplerLib.getSampler(device, samplerHash));
                } else console.warn("illegal texture default value " + texName);
            }
        }
    }, {
        key: "tryCompile",
        value: function tryCompile(defineOverrides) {
            var _this2 = this;
            defineOverrides && Object.assign(this._defines, defineOverrides);
            var pipeline = cc.director.root.pipeline;
            return !!pipeline && (this._renderPass = pipeline.getRenderPass(this._stage), this._renderPass ? (this._shader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline), 
            this._shader ? (this._bindings = this._shaderInfo.blocks.reduce(function(acc, cur) {
                return cur.defines.every(function(d) {
                    return _this2._defines[d];
                }) && acc.push({
                    name: cur.name,
                    binding: cur.binding,
                    type: GFXBindingType.UNIFORM_BUFFER
                }), acc;
            }, []).concat(this._shaderInfo.samplers.reduce(function(acc, cur) {
                return cur.defines.every(function(d) {
                    return _this2._defines[d];
                }) && acc.push({
                    name: cur.name,
                    binding: cur.binding,
                    type: GFXBindingType.SAMPLER
                }), acc;
            }, [])), !0) : (console.warn("create shader ".concat(this._programName, " failed")), 
            !1)) : (console.warn("illegal pass stage."), !1));
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState() {
            if (!(this._renderPass && this._shader && this._bindings.length || this.tryCompile())) return console.warn("pass resources not complete, create PSO failed"), 
            null;
            for (var bindingLayout = this._device.createBindingLayout({
                bindings: this._bindings
            }), _i10 = 0, _Object$keys = Object.keys(this._buffers); _i10 < _Object$keys.length; _i10++) {
                var b = _Object$keys[_i10];
                bindingLayout.bindBuffer(parseInt(b), this._buffers[b]);
            }
            for (var _i11 = 0, _Object$keys2 = Object.keys(this._samplers); _i11 < _Object$keys2.length; _i11++) {
                var s = _Object$keys2[_i11];
                bindingLayout.bindSampler(parseInt(s), this._samplers[s]);
            }
            for (var _i12 = 0, _Object$keys3 = Object.keys(this._textureViews); _i12 < _Object$keys3.length; _i12++) {
                var t = _Object$keys3[_i12];
                bindingLayout.bindTextureView(parseInt(t), this._textureViews[t]);
            }
            var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, _iterator10 = target.blocks, _isArray10 = Array.isArray(_iterator10), _i13 = 0;
            for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                var _ref10;
                if (_isArray10) {
                    if (_i13 >= _iterator10.length) break;
                    _ref10 = _iterator10[_i13++];
                } else {
                    if ((_i13 = _iterator10.next()).done) break;
                    _ref10 = _i13.value;
                }
                var _b = _ref10, info = source.get(_b.name);
                info && info.type === GFXBindingType.UNIFORM_BUFFER ? bindingLayout.bindBuffer(info.blockInfo.binding, info.buffer) : console.warn("builtin UBO '".concat(_b.name, "' not available!"));
            }
            var _iterator11 = target.samplers, _isArray11 = Array.isArray(_iterator11), _i14 = 0;
            for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                var _ref11;
                if (_isArray11) {
                    if (_i14 >= _iterator11.length) break;
                    _ref11 = _iterator11[_i14++];
                } else {
                    if ((_i14 = _iterator11.next()).done) break;
                    _ref11 = _i14.value;
                }
                var _s = _ref11, _info = source.get(_s.name);
                _info && _info.type === GFXBindingType.SAMPLER ? (_info.sampler && bindingLayout.bindSampler(_info.samplerInfo.binding, _info.sampler), 
                bindingLayout.bindTextureView(_info.samplerInfo.binding, _info.textureView)) : console.warn("builtin texture '".concat(_s.name, "' not available!"));
            }
            var pipelineLayout = this._device.createPipelineLayout({
                layouts: [ bindingLayout ]
            }), pipelineState = this._device.createPipelineState({
                bs: this._bs,
                dss: this._dss,
                dynamicStates: this._dynamicStates,
                is: new GFXInputState(),
                layout: pipelineLayout,
                primitive: this._primitive,
                renderPass: this._renderPass,
                rs: this._rs,
                shader: this._shader
            });
            return this._resources.push({
                bindingLayout: bindingLayout,
                pipelineLayout: pipelineLayout,
                pipelineState: pipelineState
            }), pipelineState;
        }
    }, {
        key: "destroyPipelineState",
        value: function destroyPipelineState(pipelineStates) {
            var idx = this._resources.findIndex(function(res) {
                return res.pipelineState === pipelineStates;
            });
            if (idx >= 0) {
                var _this$_resources$idx = this._resources[idx], bl = _this$_resources$idx.bindingLayout, pl = _this$_resources$idx.pipelineLayout, ps = _this$_resources$idx.pipelineState;
                bl.destroy(), pl.destroy(), ps.destroy(), this._resources.splice(idx, 1);
            }
        }
    }, {
        key: "serializePipelineStates",
        value: function serializePipelineStates() {
            var shaderKey = programLib.getKey(this._programName, this._defines), res = "".concat(shaderKey, ",").concat(this._stage, ",").concat(this._primitive);
            return res += serializeBlendState(this._bs), res += serializeDepthStencilState(this._dss), 
            res += serializeRasterizerState(this._rs);
        }
    }, {
        key: "_fillinPipelineInfo",
        value: function _fillinPipelineInfo(info) {
            if (void 0 !== info.priority && (this._priority = info.priority), void 0 !== info.primitive && (this._primitive = info.primitive), 
            void 0 !== info.stage && (this._stage = info.stage), void 0 !== info.dynamics && (this._dynamicStates = info.dynamics), 
            info.customizations && (this._customizations = info.customizations), 0 === this._phase) {
                var phaseName = info.phase || "default";
                this._phase = getPhaseID(phaseName);
            }
            var bs = this._bs;
            if (info.blendState) {
                var bsInfo = Object.assign({}, info.blendState);
                bsInfo.targets && bsInfo.targets.forEach(function(t, i) {
                    return Object.assign(bs.targets[i] || (bs.targets[i] = new GFXBlendTarget()), t);
                }), delete bsInfo.targets, Object.assign(bs, bsInfo);
            }
            Object.assign(this._rs, info.rasterizerState), Object.assign(this._dss, info.depthStencilState);
        }
    }, {
        key: "idxInTech",
        get: function get() {
            return this._idxInTech;
        }
    }, {
        key: "programName",
        get: function get() {
            return this._programName;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        }
    }, {
        key: "primitive",
        get: function get() {
            return this._primitive;
        }
    }, {
        key: "stage",
        get: function get() {
            return this._stage;
        }
    }, {
        key: "phase",
        get: function get() {
            return this._phase;
        }
    }, {
        key: "bindings",
        get: function get() {
            return this._bindings;
        }
    }, {
        key: "blendState",
        get: function get() {
            return this._bs;
        }
    }, {
        key: "depthStencilState",
        get: function get() {
            return this._dss;
        }
    }, {
        key: "rasterizerState",
        get: function get() {
            return this._rs;
        }
    }, {
        key: "dynamics",
        get: function get() {
            return this._dynamics;
        }
    }, {
        key: "customizations",
        get: function get() {
            return this._customizations;
        }
    }, {
        key: "shader",
        get: function get() {
            return this._shader;
        }
    } ]), Pass;
}();

Pass.getBindingTypeFromHandle = function getBindingTypeFromHandle(handle) {
    return (4026531840 & handle) >>> 28;
}, Pass.getTypeFromHandle = function getTypeFromHandle(handle) {
    return (264241152 & handle) >>> 22;
}, Pass.getBindingFromHandle = function getBindingFromHandle(handle) {
    return (4192256 & handle) >>> 11;
}, Pass.getIndexFromHandle = function getIndexFromHandle(handle) {
    return 2047 & handle;
};

var _dec$t, _dec2$a, _class$t, _class2$n, _descriptor$l, _descriptor2$d, _descriptor3$8, _descriptor4$6, _descriptor5$5, _dec$u, _dec2$b, _dec3$3, _class$u, _class2$o, _descriptor$m, _descriptor2$e, serializeBlendState = function serializeBlendState(bs) {
    var res = ",bs,".concat(bs.isA2C, ",").concat(bs.blendColor), _iterator12 = bs.targets, _isArray12 = Array.isArray(_iterator12), _i15 = 0;
    for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
        var _ref12;
        if (_isArray12) {
            if (_i15 >= _iterator12.length) break;
            _ref12 = _iterator12[_i15++];
        } else {
            if ((_i15 = _iterator12.next()).done) break;
            _ref12 = _i15.value;
        }
        var t = _ref12;
        res += ",bt,".concat(t.blend, ",").concat(t.blendEq, ",").concat(t.blendAlphaEq, ",").concat(t.blendColorMask), 
        res += ",".concat(t.blendSrc, ",").concat(t.blendDst, ",").concat(t.blendSrcAlpha, ",").concat(t.blendDstAlpha);
    }
    return res;
}, serializeRasterizerState = function serializeRasterizerState(rs) {
    return ",rs,".concat(rs.cullMode, ",").concat(rs.depthBias, ",").concat(rs.isFrontFaceCCW);
}, serializeDepthStencilState = function serializeDepthStencilState(dss) {
    var res = ",dss,".concat(dss.depthTest, ",").concat(dss.depthWrite, ",").concat(dss.depthFunc);
    return res += ",".concat(dss.stencilTestFront, ",").concat(dss.stencilFuncFront, ",").concat(dss.stencilRefFront, ",").concat(dss.stencilReadMaskFront), 
    res += ",".concat(dss.stencilFailOpFront, ",").concat(dss.stencilZFailOpFront, ",").concat(dss.stencilPassOpFront, ",").concat(dss.stencilWriteMaskFront), 
    res += ",".concat(dss.stencilTestBack, ",").concat(dss.stencilFuncBack, ",").concat(dss.stencilRefBack, ",").concat(dss.stencilReadMaskBack), 
    res += ",".concat(dss.stencilFailOpBack, ",").concat(dss.stencilZFailOpBack, ",").concat(dss.stencilPassOpBack, ",").concat(dss.stencilWriteMaskBack);
}, Material = (_dec$t = ccclass("cc.Material"), _dec2$a = property(EffectAsset), 
_dec$t((_descriptor$l = _applyDecoratedDescriptor((_class2$n = function(_Asset) {
    function Material() {
        var _this;
        return _classCallCheck(this, Material), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)), "_effectAsset", _descriptor$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_techIdx", _descriptor2$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_defines", _descriptor3$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_states", _descriptor4$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_props", _descriptor5$5, _assertThisInitialized(_this)), 
        _this._passes = [], _this._owner = null, _this._hash = 0, _this.loaded = !1, _this;
    }
    return _inherits(Material, Asset), _createClass(Material, [ {
        key: "effectAsset",
        get: function get() {
            return this._effectAsset;
        }
    }, {
        key: "effectName",
        get: function get() {
            return this._effectAsset ? this._effectAsset.name : "";
        }
    }, {
        key: "technique",
        get: function get() {
            return this._techIdx;
        }
    }, {
        key: "passes",
        get: function get() {
            return this._passes;
        }
    }, {
        key: "hash",
        get: function get() {
            return this._hash;
        }
    } ], [ {
        key: "getInstantiatedMaterial",
        value: function getInstantiatedMaterial(mat, rndCom, inEditor) {
            if (mat._owner === rndCom) return mat;
            var instance = new Material();
            return instance.copy(mat), instance._native = mat._native + " (Instance)", instance._owner = rndCom, 
            inEditor && (instance._uuid = mat._uuid), instance;
        }
    } ]), _createClass(Material, [ {
        key: "initialize",
        value: function initialize(info) {
            this._defines || (this._defines = []), this._states || (this._states = []), this._props || (this._props = []), 
            void 0 !== info.technique && (this._techIdx = info.technique), info.effectAsset ? this._effectAsset = info.effectAsset : info.effectName && (this._effectAsset = EffectAsset.get(info.effectName)), 
            info.defines && this._prepareInfo(info.defines, this._defines), info.states && this._prepareInfo(info.states, this._states), 
            this._update();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (this._passes && this._passes.length) {
                var _iterator = this._passes, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.destroy();
                }
            }
            return this._passes = [], this._effectAsset = null, this._props = [], this._defines = [], 
            this._states = [], _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
        }
    }, {
        key: "resetUniforms",
        value: function resetUniforms() {
            var clearPasses = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            if (this._props.length = this._passes.length, this._props.fill({}), clearPasses) {
                var _iterator2 = this._passes, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var pass = _ref2;
                    pass.resetUBOs(), pass.resetTextures();
                }
            }
        }
    }, {
        key: "recompileShaders",
        value: function recompileShaders(overrides, passIdx) {
            if (this._passes && this._effectAsset) {
                if (void 0 === passIdx) {
                    var _iterator3 = this._passes, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        _ref3.tryCompile(overrides);
                    }
                } else this._passes[passIdx].tryCompile(overrides);
                this._onPassesChange();
            }
        }
    }, {
        key: "overridePipelineStates",
        value: function overridePipelineStates(overrides, passIdx) {
            if (this._passes && this._effectAsset) {
                var passInfos = this._effectAsset.techniques[this._techIdx].passes;
                if (void 0 === passIdx) {
                    var _iterator4 = this._passes, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref4 = _i4.value;
                        }
                        var pass = _ref4;
                        pass.overridePipelineStates(passInfos[pass.idxInTech], overrides);
                    }
                } else this._passes[passIdx].overridePipelineStates(passInfos[passIdx], overrides);
                this._onPassesChange();
            }
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this._update(), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "setProperty",
        value: function setProperty(name, val, passIdx) {
            var success = !1;
            if (void 0 === passIdx) for (var passes = this._passes, len = passes.length, i = 0; i < len; i++) {
                var pass = passes[i];
                this._uploadProperty(pass, name, val) && (this._props[i][name] = val, success = !0);
            } else {
                if (passIdx >= this._passes.length) return void console.warn("illegal pass index: ".concat(passIdx, "."));
                var _pass = this._passes[passIdx];
                this._uploadProperty(_pass, name, val) && (this._props[passIdx][name] = val, success = !0);
            }
            success || console.warn("illegal property name: ".concat(name, "."));
        }
    }, {
        key: "getProperty",
        value: function getProperty(name, passIdx) {
            if (void 0 === passIdx) for (var propsArray = this._props, len = propsArray.length, i = 0; i < len; i++) for (var props = propsArray[i], _i5 = 0, _Object$keys = Object.keys(props); _i5 < _Object$keys.length; _i5++) {
                var p = _Object$keys[_i5];
                if (p === name) return props[p];
            } else {
                if (passIdx >= this._props.length) return console.warn("illegal pass index: ".concat(passIdx, ".")), 
                null;
                for (var _props = this._props[passIdx], _i6 = 0, _Object$keys2 = Object.keys(_props); _i6 < _Object$keys2.length; _i6++) {
                    var _p = _Object$keys2[_i6];
                    if (_p === name) return _props[_p];
                }
            }
            return null;
        }
    }, {
        key: "copy",
        value: function copy(mat) {
            this._techIdx = mat._techIdx, this._props.length = mat._props.length, this._props.fill({});
            for (var i = 0; i < mat._props.length; i++) Object.assign(this._props[i], mat._props[i]);
            this._defines.length = mat._defines.length, this._defines.fill({});
            for (var _i7 = 0; _i7 < mat._defines.length; _i7++) Object.assign(this._defines[_i7], mat._defines[_i7]);
            Object.assign(this._states, mat._states), this._effectAsset = mat._effectAsset, 
            this._update();
        }
    }, {
        key: "_prepareInfo",
        value: function _prepareInfo(patch, cur) {
            if (!Array.isArray(patch)) {
                var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                patch = Array(len).fill(patch);
            }
            for (var i = 0; i < patch.length; i++) Object.assign(cur[i] || (cur[i] = {}), patch[i]);
        }
    }, {
        key: "_update",
        value: function _update() {
            var _this2 = this, keepProps = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            if (this._effectAsset) {
                if (this._passes && this._passes.length) {
                    var _iterator5 = this._passes, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i8 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i8++];
                        } else {
                            if ((_i8 = _iterator5.next()).done) break;
                            _ref5 = _i8.value;
                        }
                        var pass = _ref5;
                        pass.destroy();
                    }
                }
                this._passes = Pass.createPasses(this._effectAsset, {
                    techIdx: this._techIdx,
                    defines: this._defines,
                    states: this._states
                });
                var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                this._props.length = totalPasses, keepProps ? this._passes.forEach(function(pass, i) {
                    var props = _this2._props[pass.idxInTech];
                    props || (props = _this2._props[i] = {});
                    for (var _i9 = 0, _Object$keys3 = Object.keys(props); _i9 < _Object$keys3.length; _i9++) {
                        var p = _Object$keys3[_i9];
                        props[p] && _this2._uploadProperty(pass, p, props[p]);
                    }
                }) : this._props.fill({});
            } else this._passes = builtinResMgr.get("missing-effect-material")._passes.slice();
            this._onPassesChange();
        }
    }, {
        key: "_uploadProperty",
        value: function _uploadProperty(pass, name, val) {
            var handle = pass.getHandle(name);
            if (void 0 === handle) return !1;
            var bindingType = Pass.getBindingTypeFromHandle(handle);
            if (bindingType === GFXBindingType.UNIFORM_BUFFER) Array.isArray(val) ? pass.setUniformArray(handle, val) : pass.setUniform(handle, val); else if (bindingType === GFXBindingType.SAMPLER) {
                var binding = Pass.getBindingFromHandle(handle);
                if (val instanceof GFXTextureView) pass.bindTextureView(binding, val); else if (val instanceof TextureBase) {
                    var textureView = val.getGFXTextureView();
                    if (!textureView || !textureView.texture.width || !textureView.texture.height) return !1;
                    pass.bindTextureView(binding, textureView), pass.bindSampler(binding, samplerLib.getSampler(cc.game._gfxDevice, val.getSamplerHash()));
                }
            }
            return !0;
        }
    }, {
        key: "_onPassesChange",
        value: function _onPassesChange() {
            var _this3 = this, str = "", _iterator6 = this._passes, _isArray6 = Array.isArray(_iterator6), _i10 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i10 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i10++];
                } else {
                    if ((_i10 = _iterator6.next()).done) break;
                    _ref6 = _i10.value;
                }
                str += _ref6.serializePipelineStates();
            }
            if (this._hash = murmurhash2_32_gc(str, 666), this._owner) {
                var comp = this._owner, index = comp.sharedMaterials.findIndex(function(m) {
                    return m === _this3;
                });
                index >= 0 && comp._onRebuildPSO(index, this);
            }
        }
    } ]), Material;
}()).prototype, "_effectAsset", [ _dec2$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$d = _applyDecoratedDescriptor(_class2$n.prototype, "_techIdx", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$8 = _applyDecoratedDescriptor(_class2$n.prototype, "_defines", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor4$6 = _applyDecoratedDescriptor(_class2$n.prototype, "_states", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class2$n.prototype, "_props", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$t = _class2$n)) || _class$t);

cc.Material = Material;

var _class$v, _class2$p, _descriptor$n, _descriptor2$f, Skeleton = (_dec$u = ccclass("cc.Skeleton"), 
_dec2$b = property([ CCString ]), _dec3$3 = property([ Mat4 ]), _dec$u((_descriptor$m = _applyDecoratedDescriptor((_class2$o = function(_Asset) {
    function Skeleton() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Skeleton);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Skeleton)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_joints", _descriptor$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_bindposes", _descriptor2$e, _assertThisInitialized(_this)), 
        _this._bindTRS = [], _this._hash = 0, _this;
    }
    return _inherits(Skeleton, Asset), _createClass(Skeleton, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.bindposes = this._bindposes;
        }
    }, {
        key: "bindposes",
        get: function get() {
            return this._bindposes;
        },
        set: function set(value) {
            this._bindposes = value, this._bindTRS = value.map(function(m) {
                var position = new Vec3(), rotation = new Quat(), scale = new Vec3();
                return Mat4.toRTS(m, rotation, position, scale), {
                    position: position,
                    rotation: rotation,
                    scale: scale
                };
            }), this._hash = murmurhash2_32_gc(this.bindposes.reduce(function(acc, cur) {
                return acc + cur.m00.toPrecision(2) + " " + cur.m01.toPrecision(2) + " " + cur.m02.toPrecision(2) + " " + cur.m03.toPrecision(2) + " " + cur.m04.toPrecision(2) + " " + cur.m05.toPrecision(2) + " " + cur.m06.toPrecision(2) + " " + cur.m07.toPrecision(2) + " " + cur.m08.toPrecision(2) + " " + cur.m09.toPrecision(2) + " " + cur.m10.toPrecision(2) + " " + cur.m11.toPrecision(2) + " " + cur.m12.toPrecision(2) + " " + cur.m13.toPrecision(2) + " " + cur.m14.toPrecision(2) + " " + cur.m15.toPrecision(2) + "\n";
            }, ""), 666);
        }
    }, {
        key: "bindTRS",
        get: function get() {
            return this._bindTRS;
        }
    }, {
        key: "joints",
        get: function get() {
            return this._joints;
        },
        set: function set(value) {
            this._joints = value;
        }
    }, {
        key: "hash",
        get: function get() {
            return this._hash;
        }
    } ]), Skeleton;
}()).prototype, "_joints", [ _dec2$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$e = _applyDecoratedDescriptor(_class2$o.prototype, "_bindposes", [ _dec3$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$u = _class2$o)) || _class$u);

cc.Skeleton = Skeleton;

var _dec$w, _dec2$c, _dec3$4, _class$w, _class2$q, _descriptor$o, _descriptor2$g, PhysicsMaterial = ccclass("cc.PhysicsMaterial")((_descriptor$n = _applyDecoratedDescriptor((_class2$p = function(_Asset) {
    function PhysicsMaterial() {
        var _this;
        return _classCallCheck(this, PhysicsMaterial), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsMaterial).call(this)), "_friction", _descriptor$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_restitution", _descriptor2$f, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(PhysicsMaterial, Asset), _createClass(PhysicsMaterial, [ {
        key: "friction",
        get: function get() {
            return this._friction;
        },
        set: function set(value) {
            this._friction = value;
        }
    }, {
        key: "restitution",
        get: function get() {
            return this._restitution;
        },
        set: function set(value) {
            this._restitution = value;
        }
    } ]), PhysicsMaterial;
}()).prototype, "_friction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor2$f = _applyDecoratedDescriptor(_class2$p.prototype, "_restitution", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _class$v = _class2$p)) || _class$v;

cc.PhysicsMaterial = PhysicsMaterial;

var _dec$x, _dec2$d, _class$x, _class2$r, _descriptor$p, _descriptor2$h, _descriptor3$9, _descriptor4$7, _descriptor5$6, _dec$y, _dec2$e, _class$y, _class2$s, _descriptor$q, _dec3$5, _dec4$2, _dec5$2, _dec6$2, _class4$1, _class5$1, _descriptor2$i, _descriptor3$a, property$1 = property, RenderableComponent = (_dec$w = ccclass("cc.RenderableComponent"), 
_dec2$c = property$1({
    type: [ Material ]
}), _dec3$4 = property$1({
    type: Material,
    displayName: "Materials"
}), _dec$w((_descriptor$o = _applyDecoratedDescriptor((_class2$q = function(_Component) {
    function RenderableComponent() {
        var _this;
        return _classCallCheck(this, RenderableComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RenderableComponent).call(this)), "_materials", _descriptor$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_viewID", _descriptor2$g, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(RenderableComponent, Component), _createClass(RenderableComponent, [ {
        key: "getMaterial",
        value: function getMaterial(idx) {
            var inEditor = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], autoUpdate = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], mat = this._materials[idx];
            if (!mat) return null;
            var instantiated = Material.getInstantiatedMaterial(mat, this, inEditor);
            return instantiated !== this._materials[idx] && this.setMaterial(instantiated, idx, autoUpdate || !inEditor), 
            this._materials[idx];
        }
    }, {
        key: "getSharedMaterial",
        value: function getSharedMaterial(idx) {
            return idx < 0 || idx >= this._materials.length ? null : this._materials[idx];
        }
    }, {
        key: "setMaterial",
        value: function setMaterial(material, index) {
            var notify = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            this._materials[index] = material, notify && this._onMaterialModified(index, material);
        }
    }, {
        key: "_getModel",
        value: function _getModel() {
            return null;
        }
    }, {
        key: "recreateModel",
        value: function recreateModel() {}
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(index, material) {}
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(index, material) {}
    }, {
        key: "_clearMaterials",
        value: function _clearMaterials() {}
    }, {
        key: "_onVisiblityChange",
        value: function _onVisiblityChange(val) {}
    }, {
        key: "sharedMaterials",
        get: function get() {
            return this._materials.slice();
        },
        set: function set(val) {
            for (var i = 0; i < val.length; i++) val[i] !== this._materials[i] && this.setMaterial(val[i], i);
            if (val.length < this._materials.length) {
                for (var _i = val.length; _i < this._materials.length; _i++) this.setMaterial(null, _i);
                this._materials.splice(val.length);
            }
        }
    }, {
        key: "materials",
        get: function get() {
            for (var i = 0; i < this._materials.length; i++) this._materials[i] = this.getMaterial(i);
            return this._materials;
        },
        set: function set(val) {
            var dLen = val.length - this._materials.length;
            if (dLen > 0) this._materials = this._materials.concat(new Array(dLen).fill(null)); else if (dLen < 0) {
                for (var i = -dLen; i < this._materials.length; ++i) this.setMaterial(null, i);
                this._materials = this._materials.splice(-dLen);
            }
        }
    }, {
        key: "material",
        get: function get() {
            return this.getMaterial(0);
        },
        set: function set(val) {
            1 === this._materials.length && this._materials[0] === val || this.setMaterial(val, 0);
        }
    }, {
        key: "sharedMaterial",
        get: function get() {
            return this.getSharedMaterial(0);
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._viewID;
        },
        set: function set(val) {
            this._viewID = val, this._onVisiblityChange(val);
        }
    } ]), RenderableComponent;
}()).prototype, "_materials", [ _dec2$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$g = _applyDecoratedDescriptor(_class2$q.prototype, "_viewID", [ property$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$q.prototype, "sharedMaterials", [ _dec3$4 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "sharedMaterials"), _class2$q.prototype), 
_applyDecoratedDescriptor(_class2$q.prototype, "visibility", [ property$1 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "visibility"), _class2$q.prototype), 
_class$w = _class2$q)) || _class$w), EventHandler = (_dec$x = ccclass("cc.ClickEvent"), 
_dec2$d = property(cc.Node), _dec$x((_applyDecoratedDescriptor((_class2$r = function() {
    function EventHandler() {
        _classCallCheck(this, EventHandler), _initializerDefineProperty(this, "target", _descriptor$p, this), 
        _initializerDefineProperty(this, "component", _descriptor2$h, this), _initializerDefineProperty(this, "_componentId", _descriptor3$9, this), 
        _initializerDefineProperty(this, "handler", _descriptor4$7, this), _initializerDefineProperty(this, "customEventData", _descriptor5$6, this);
    }
    return _createClass(EventHandler, [ {
        key: "emit",
        value: function emit(params) {
            var target = this.target;
            if (cc.isValid(target)) {
                this._genCompIdIfNeeded();
                var compType = cc.js._getClassById(this._componentId), comp = target.getComponent(compType);
                if (cc.isValid(comp)) {
                    var handler = comp[this.handler];
                    "function" == typeof handler && (null != this.customEventData && "" !== this.customEventData && (params = params.slice()).push(this.customEventData), 
                    handler.apply(comp, params));
                }
            }
        }
    }, {
        key: "_compName2Id",
        value: function _compName2Id(compName) {
            var comp = cc.js.getClassByName(compName);
            return cc.js._getClassId(comp);
        }
    }, {
        key: "_compId2Name",
        value: function _compId2Name(compId) {
            var comp = cc.js._getClassById(compId);
            return cc.js.getClassName(comp);
        }
    }, {
        key: "_genCompIdIfNeeded",
        value: function _genCompIdIfNeeded() {
            this._componentId || (this._componentName = this.component, this.component = "");
        }
    }, {
        key: "_componentName",
        get: function get() {
            return this._genCompIdIfNeeded(), this._compId2Name(this._componentId);
        },
        set: function set(value) {
            this._componentId = this._compName2Id(value);
        }
    } ], [ {
        key: "emitEvents",
        value: function emitEvents(events) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
            for (var i = 0, l = events.length; i < l; i++) {
                var event = events[i];
                event instanceof EventHandler && event.emit(args);
            }
        }
    } ]), EventHandler;
}()).prototype, "_componentName", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "_componentName"), _class2$r.prototype), 
_descriptor$p = _applyDecoratedDescriptor(_class2$r.prototype, "target", [ _dec2$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$h = _applyDecoratedDescriptor(_class2$r.prototype, "component", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor3$9 = _applyDecoratedDescriptor(_class2$r.prototype, "_componentId", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor4$7 = _applyDecoratedDescriptor(_class2$r.prototype, "handler", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor5$6 = _applyDecoratedDescriptor(_class2$r.prototype, "customEventData", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$x = _class2$r)) || _class$x);

cc.Component.EventHandler = EventHandler;

var _class$z, MissingClass$1 = (_dec$y = ccclass("cc.MissingClass"), _dec2$e = property({
    visible: !1,
    editorOnly: !0
}), _dec$y((_descriptor$q = _applyDecoratedDescriptor((_class2$s = function MissingClass() {
    _classCallCheck(this, MissingClass), _initializerDefineProperty(this, "_$erialized", _descriptor$q, this);
}).prototype, "_$erialized", [ _dec2$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$y = _class2$s)) || _class$y), MissingScript = (_dec3$5 = ccclass("cc.MissingScript"), 
_dec4$2 = inspector("packages://inspector/inspectors/comps/missing-script.js"), 
_dec5$2 = property({
    serializable: !1
}), _dec6$2 = property({
    visible: !1,
    editorOnly: !0
}), _dec3$5(_class4$1 = _dec4$2((_descriptor2$i = _applyDecoratedDescriptor((_class5$1 = function(_Component) {
    function MissingScript() {
        var _this;
        return _classCallCheck(this, MissingScript), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MissingScript).call(this)), "compiled", _descriptor2$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_$erialized", _descriptor3$a, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(MissingScript, Component), _createClass(MissingScript, null, [ {
        key: "safeFindClass",
        value: function safeFindClass(id, data) {
            var cls = _getClassById(id);
            return cls || (id ? (cc.deserialize.reportMissingClass(id), MissingScript.getMissingWrapper(id, data)) : null);
        }
    }, {
        key: "getMissingWrapper",
        value: function getMissingWrapper(id, data) {
            return data.node && (/^[0-9a-zA-Z+\/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass$1;
        }
    } ]), _createClass(MissingScript, [ {
        key: "onLoad",
        value: function onLoad() {
            cc.warnID(4600, this.node.name);
        }
    } ]), MissingScript;
}()).prototype, "compiled", [ _dec5$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$a = _applyDecoratedDescriptor(_class5$1.prototype, "_$erialized", [ _dec6$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class4$1 = _class5$1)) || _class4$1) || _class4$1);

cc._MissingScript = MissingScript;

var BlockEvents = [ SystemEventType.TOUCH_START, SystemEventType.TOUCH_END, SystemEventType.TOUCH_MOVE, SystemEventType.MOUSE_DOWN, SystemEventType.MOUSE_MOVE, SystemEventType.MOUSE_UP, SystemEventType.MOUSE_ENTER, SystemEventType.MOUSE_LEAVE, SystemEventType.MOUSE_WHEEL ];

function stopPropagation(event) {
    event.propagationStopped = !0;
}

var _dec$A, _dec2$g, _dec3$6, _dec4$3, _dec5$3, _class$A, _class2$t, _descriptor$r, _descriptor2$j, _class3$c, _temp$v, BlockInputEventsComponent = ccclass("cc.BlockInputEventsComponent")(_class$z = menu("Components/BlockInputEventsComponent")(_class$z = function(_Component) {
    function BlockInputEventsComponent() {
        return _classCallCheck(this, BlockInputEventsComponent), _possibleConstructorReturn(this, _getPrototypeOf(BlockInputEventsComponent).apply(this, arguments));
    }
    return _inherits(BlockInputEventsComponent, Component), _createClass(BlockInputEventsComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
        }
    } ]), BlockInputEventsComponent;
}()) || _class$z) || _class$z;

cc.BlockInputEventsComponent = BlockInputEventsComponent;

var _dec$B, _dec2$h, _dec3$7, _dec4$4, _dec5$4, _dec6$3, _class$B, _class2$u, _descriptor$s, _descriptor2$k, _vec2a = new Vec2(), _vec2b = new Vec2(), _mat4_temp = new Mat4(), _matrix = new Mat4(), _worldMatrix = new Mat4(), UITransformComponent = (_dec$A = ccclass("cc.UITransformComponent"), 
_dec2$g = executionOrder(110), _dec3$6 = menu("UI/UITransform"), _dec4$3 = property({
    displayOrder: 0
}), _dec5$3 = property({
    displayOrder: 1
}), _dec$A(_class$A = _dec2$g(_class$A = _dec3$6(_class$A = executeInEditMode((_temp$v = _class3$c = function(_Component) {
    function UITransformComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UITransformComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UITransformComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_contentSize", _descriptor$r, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_anchorPoint", _descriptor2$j, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(UITransformComponent, Component), _createClass(UITransformComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.node.uiTransfromComp = this, this.node.layer = cc.Layers.UI;
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.node.uiTransfromComp = null;
        }
    }, {
        key: "setContentSize",
        value: function setContentSize(size, height) {
            var locContentSize = this._contentSize;
            if (void 0 === height) {
                if ((size = size).width === locContentSize.width && size.height === locContentSize.height) return;
                0, locContentSize.width = size.width, locContentSize.height = size.height;
            } else {
                if (size === locContentSize.width && height === locContentSize.height) return;
                0, locContentSize.width = size, locContentSize.height = height;
            }
            this.node.emit(SystemEventType.SIZE_CHANGED);
        }
    }, {
        key: "setAnchorPoint",
        value: function setAnchorPoint(point, y) {
            var locAnchorPoint = this._anchorPoint;
            if (void 0 === y) {
                if ((point = point).x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
                locAnchorPoint.x = point.x, locAnchorPoint.y = point.y;
            } else {
                if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
                locAnchorPoint.x = point, locAnchorPoint.y = y;
            }
            this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
        }
    }, {
        key: "isHit",
        value: function isHit(point, listener) {
            var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _vec2a, testPt = _vec2b, visibility = -1, renderComp = this.node.getComponent(cc.UIRenderComponent);
            visibility = renderComp ? renderComp.visibility : this._getVisibility();
            var canvas = cc.director.root.ui.getScreen(visibility);
            if (canvas) {
                canvas.node.getWorldRT(_mat4_temp);
                var m12 = _mat4_temp.m12, m13 = _mat4_temp.m13, center = cc.visibleRect.center;
                if (_mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13), _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13), 
                Mat4.invert(_mat4_temp, _mat4_temp), Vec2.transformMat4(cameraPt, point, _mat4_temp), 
                this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), Vec2.transformMat4(testPt, cameraPt, _mat4_temp), 
                testPt.x += this._anchorPoint.x * w, testPt.y += this._anchorPoint.y * h, testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    if (listener && listener.mask) {
                        for (var mask = listener.mask, parent = this.node, i = 0; parent && i < mask.index; ++i, 
                        parent = parent.parent) ;
                        if (parent === mask.node) {
                            var comp = parent.getComponent(cc.MaskComponent);
                            return !comp || !comp.enabledInHierarchy || comp.isHit(cameraPt);
                        }
                        return listener.mask = null, !0;
                    }
                    return !0;
                }
                return !1;
            }
        }
    }, {
        key: "convertToNodeSpaceAR",
        value: function convertToNodeSpaceAR(worldPoint, out) {
            return this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), 
            out || (out = new Vec3()), Vec3.transformMat4(out, worldPoint, _mat4_temp);
        }
    }, {
        key: "convertToWorldSpaceAR",
        value: function convertToWorldSpaceAR(nodePoint, out) {
            return this.node.getWorldMatrix(_worldMatrix), out || (out = new Vec3()), Vec3.transformMat4(out, nodePoint, _worldMatrix);
        }
    }, {
        key: "getBoundingBox",
        value: function getBoundingBox() {
            Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
            var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
            return rect.transformMat4(_matrix), rect;
        }
    }, {
        key: "getBoundingBoxToWorld",
        value: function getBoundingBoxToWorld() {
            return this.node.parent ? (this.node.parent.getWorldMatrix(_worldMatrix), this.getBoundingBoxTo(_worldMatrix)) : this.getBoundingBox();
        }
    }, {
        key: "getBoundingBoxTo",
        value: function getBoundingBoxTo(parentMat) {
            Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
            var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
            if (Mat4.multiply(_worldMatrix, parentMat, _matrix), rect.transformMat4(_worldMatrix), 
            !this.node.children) return rect;
            var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var child = _ref;
                if (child && child.active) {
                    var uiTransform = child.getComponent(UITransformComponent);
                    if (uiTransform) {
                        var childRect = uiTransform.getBoundingBoxTo(parentMat);
                        childRect && Rect.union(rect, rect, childRect);
                    }
                }
            }
            return rect;
        }
    }, {
        key: "getComputeAABB",
        value: function getComputeAABB(out) {
            var rectWorld = this.getBoundingBoxToWorld(), px = rectWorld.center.x, py = rectWorld.center.y, pz = this.node.worldPosition.z, w = rectWorld.width / 2, h = rectWorld.height / 2;
            if (null == out) return new aabb(px, py, pz, w, h, .01);
            aabb.set(out, px, py, pz, w, h, .01);
        }
    }, {
        key: "_getVisibility",
        value: function _getVisibility() {
            for (var visibility = -1, parent = this.node; parent; ) {
                if (parent) {
                    var canvasComp = parent.getComponent("cc.CanvasComponent");
                    if (canvasComp) {
                        visibility = canvasComp.visibility;
                        break;
                    }
                }
                parent = parent.parent;
            }
            return visibility;
        }
    }, {
        key: "contentSize",
        get: function get() {
            return this._contentSize;
        },
        set: function set(value) {
            this._contentSize.equals(value) || (this._contentSize.set(value), this.node.emit(SystemEventType.SIZE_CHANGED));
        }
    }, {
        key: "width",
        get: function get() {
            return this._contentSize.width;
        },
        set: function set(value) {
            this._contentSize.width !== value && (this._contentSize.width = value, this.node.emit(SystemEventType.SIZE_CHANGED));
        }
    }, {
        key: "height",
        get: function get() {
            return this._contentSize.height;
        },
        set: function set(value) {
            this.contentSize.height !== value && (this._contentSize.height = value, this.node.emit(SystemEventType.SIZE_CHANGED));
        }
    }, {
        key: "anchorPoint",
        get: function get() {
            return this._anchorPoint;
        },
        set: function set(value) {
            this._anchorPoint.equals(value) || (this._anchorPoint.set(value), this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
        }
    }, {
        key: "anchorX",
        get: function get() {
            return this._anchorPoint.x;
        },
        set: function set(value) {
            this._anchorPoint.x !== value && (this._anchorPoint.x = value, this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
        }
    }, {
        key: "anchorY",
        get: function get() {
            return this._anchorPoint.y;
        },
        set: function set(value) {
            this._anchorPoint.y !== value && (this._anchorPoint.y = value, this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
        }
    } ]), UITransformComponent;
}(), _class3$c.EventType = SystemEventType, _applyDecoratedDescriptor((_class2$t = _temp$v).prototype, "contentSize", [ _dec4$3 ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "contentSize"), _class2$t.prototype), 
_applyDecoratedDescriptor(_class2$t.prototype, "anchorPoint", [ _dec5$3 ], Object.getOwnPropertyDescriptor(_class2$t.prototype, "anchorPoint"), _class2$t.prototype), 
_descriptor$r = _applyDecoratedDescriptor(_class2$t.prototype, "_contentSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Size(100, 100);
    }
}), _descriptor2$j = _applyDecoratedDescriptor(_class2$t.prototype, "_anchorPoint", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(.5, .5);
    }
}), _class$A = _class2$t)) || _class$A) || _class$A) || _class$A) || _class$A);

cc.UITransformComponent = UITransformComponent;

var _class$C, _class2$v, _descriptor$t, _worldPos = new Vec3(), CanvasComponent = (_dec$B = ccclass("cc.CanvasComponent"), 
_dec2$h = executionOrder(100), _dec3$7 = requireComponent(UITransformComponent), 
_dec4$4 = menu("UI/Canvas"), _dec5$4 = property(), _dec6$3 = property({
    type: RenderTexture
}), _dec$B(_class$B = _dec2$h(_class$B = _dec3$7(_class$B = _dec4$4(_class$B = executeInEditMode(_class$B = disallowMultiple((_applyDecoratedDescriptor((_class2$u = function(_Component) {
    function CanvasComponent() {
        var _this;
        return _classCallCheck(this, CanvasComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasComponent).call(this)), "_priority", _descriptor$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_targetTexture", _descriptor2$k, _assertThisInitialized(_this)), 
        _this._thisOnResized = void 0, _this._camera = null, _this._pos = new Vec3(), _this._thisOnResized = _this.alignWithScreen.bind(_assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(CanvasComponent, Component), _createClass(CanvasComponent, [ {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(val) {
            this._priority = val, this._camera && (this._camera.priority = val);
        }
    }, {
        key: "targetTexture",
        get: function get() {
            return this._targetTexture;
        },
        set: function set(value) {
            if (this._camera) if (this._targetTexture && this._targetTexture.removeCamera(this._camera), 
            value) {
                var window = value.getGFXWindow();
                this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height), 
                value.addCamera(this._camera);
            } else this._camera.changeTargetWindow();
            this._targetTexture = value;
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._camera ? this._camera.view.visibility : -1;
        }
    }, {
        key: "camera",
        get: function get() {
            return this._camera;
        }
    } ]), _createClass(CanvasComponent, [ {
        key: "__preload",
        value: function __preload() {
            var cameraNode = new Node$1("UICamera_" + this.node.name);
            cameraNode.setPosition(0, 0, 999), this._camera = cc.director.root.ui.renderScene.createCamera({
                name: "ui_" + this.node.name,
                node: cameraNode,
                projection: cc.CameraComponent.ProjectionType.ORTHO,
                priority: this._priority,
                isUI: !0,
                flows: [ "UIFlow" ]
            }), this._camera.fov = 45, this._camera.clearFlag = GFXClearFlag.COLOR | GFXClearFlag.DEPTH | GFXClearFlag.STENCIL;
            var device = cc.director.root.device;
            if (this._camera.resize(device.width, device.height), this._targetTexture) {
                var window = this._targetTexture.getGFXWindow();
                this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height), 
                this._targetTexture.addCamera(this._camera);
            }
            cc.view.on("design-resolution-changed", this._thisOnResized), this.alignWithScreen(), 
            cc.director.root.ui.addScreen(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._camera && (cc.director.root.ui.renderScene.destroyCamera(this._camera), this._targetTexture && this._targetTexture.removeCamera(this._camera)), 
            cc.view.off("design-resolution-changed", this._thisOnResized), cc.director.root.ui.removeScreen(this);
        }
    }, {
        key: "alignWithScreen",
        value: function alignWithScreen() {
            var nodeSize, designSize;
            this.node.getPosition(this._pos);
            var canvasSize = cc.visibleRect;
            nodeSize = canvasSize, designSize = cc.view.getDesignResolutionSize();
            var offsetX = 0, offsetY = 0;
            if (cc.view.getResolutionPolicy() === cc.ResolutionPolicy.NO_BORDER && (offsetX = .5 * (designSize.width - canvasSize.width), 
            offsetY = .5 * (designSize.height - canvasSize.height)), Vec3.set(_worldPos, .5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY, 0), 
            this._pos.equals(_worldPos) || this.node.setPosition(_worldPos), this.node.width !== nodeSize.width && (this.node.width = nodeSize.width), 
            this.node.height !== nodeSize.height && (this.node.height = nodeSize.height), this.node.getWorldPosition(_worldPos), 
            this._camera) {
                var size = cc.view.getVisibleSize();
                this._camera.resize(size.width, size.height), this._camera.orthoHeight = this._camera.height / 2, 
                this._camera.node.setPosition(_worldPos.x, _worldPos.y, 999), this._camera.update();
            }
        }
    } ]), CanvasComponent;
}()).prototype, "priority", [ _dec5$4 ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "priority"), _class2$u.prototype), 
_applyDecoratedDescriptor(_class2$u.prototype, "targetTexture", [ _dec6$3 ], Object.getOwnPropertyDescriptor(_class2$u.prototype, "targetTexture"), _class2$u.prototype), 
_descriptor$s = _applyDecoratedDescriptor(_class2$u.prototype, "_priority", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$k = _applyDecoratedDescriptor(_class2$u.prototype, "_targetTexture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$B = _class2$u)) || _class$B) || _class$B) || _class$B) || _class$B) || _class$B) || _class$B);

cc.CanvasComponent = CanvasComponent;

var _dec$D, _dec2$j, _dec3$8, _dec4$5, _dec5$5, _dec6$4, _dec7$2, _class$D, _class2$w, _descriptor$u, _descriptor2$l, _descriptor3$b, _descriptor4$8, _class3$d, _temp$y, InstanceMaterialType, UIComponent = ccclass("cc.UIComponent")(_class$C = executionOrder(110)(_class$C = disallowMultiple(_class$C = executeInEditMode((_applyDecoratedDescriptor((_class2$v = function(_Component) {
    function UIComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_priority", _descriptor$t, _assertThisInitialized(_this)), 
        _this._visibility = -1, _this._lastParent = null, _this;
    }
    return _inherits(UIComponent, Component), _createClass(UIComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this._lastParent = this.node.parent, this._updateVisibility(), this._lastParent && this.node.on(SystemEventType.CHILD_REMOVED, this._parentChanged, this), 
            this.node._uiComp = this, this._sortSiblings();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._cancelEventFromParent(), this.node._uiComp === this && (this.node._uiComp = null);
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {}
    }, {
        key: "postUpdateAssembler",
        value: function postUpdateAssembler(render) {}
    }, {
        key: "setVisibility",
        value: function setVisibility(value) {
            this._visibility = value;
        }
    }, {
        key: "_parentChanged",
        value: function _parentChanged(node) {
            return node === this.node && (this._updateVisibility(), this._cancelEventFromParent(), 
            this._lastParent = this.node.parent, this._sortSiblings(), !0);
        }
    }, {
        key: "_sortSiblings",
        value: function _sortSiblings() {
            var siblings = this.node.parent && this.node.parent.children;
            siblings && siblings.sort(function(a, b) {
                var aComp = a._uiComp, bComp = b._uiComp;
                return (aComp ? aComp.priority : 0) - (bComp ? bComp.priority : 0);
            });
        }
    }, {
        key: "_updateVisibility",
        value: function _updateVisibility() {
            for (var parent = this.node; parent; ) {
                if (parent) {
                    var canvasComp = parent.getComponent(CanvasComponent);
                    if (canvasComp) {
                        this._visibility = canvasComp.visibility;
                        break;
                    }
                }
                parent = parent.parent;
            }
        }
    }, {
        key: "_cancelEventFromParent",
        value: function _cancelEventFromParent() {
            this._lastParent && (this._lastParent.off(SystemEventType.CHILD_REMOVED, this._parentChanged, this), 
            this._lastParent = null), this._visibility = -1;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(value) {
            this._priority !== value && (this._priority = value, this._sortSiblings());
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._visibility;
        }
    } ]), UIComponent;
}()).prototype, "priority", [ property ], Object.getOwnPropertyDescriptor(_class2$v.prototype, "priority"), _class2$v.prototype), 
_descriptor$t = _applyDecoratedDescriptor(_class2$v.prototype, "_priority", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$C = _class2$v)) || _class$C) || _class$C) || _class$C) || _class$C;

ccenum(GFXBlendFactor), function(InstanceMaterialType) {
    InstanceMaterialType[InstanceMaterialType.ADDCOLOR = 0] = "ADDCOLOR", InstanceMaterialType[InstanceMaterialType.ADDCOLORANDTEXTURE = 1] = "ADDCOLORANDTEXTURE";
}(InstanceMaterialType || (InstanceMaterialType = {}));

var _dec$E, _dec2$k, _dec3$9, _dec4$6, _dec5$6, _dec6$5, _dec7$3, _dec8$1, _class$E, _class2$x, _descriptor$v, _descriptor2$m, _descriptor3$c, _descriptor4$9, _descriptor5$7, _descriptor6$2, _descriptor7$2, _descriptor8$2, _descriptor9$2, _descriptor10$2, _descriptor11$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15, _descriptor16, _descriptor17, _class3$e, _temp$z, AlignMode, AlignFlags, UIRenderComponent = (_dec$D = ccclass("cc.UIRenderComponent"), 
_dec2$j = executionOrder(110), _dec3$8 = requireComponent(UITransformComponent), 
_dec4$5 = property({
    type: GFXBlendFactor,
    displayOrder: 0
}), _dec5$5 = property({
    type: GFXBlendFactor,
    displayOrder: 1
}), _dec6$4 = property({
    displayOrder: 2
}), _dec7$2 = property({
    type: Material,
    displayOrder: 3
}), _dec$D(_class$D = _dec2$j(_class$D = _dec3$8(_class$D = executeInEditMode((_temp$y = _class3$d = function(_UIComponent) {
    function UIRenderComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIRenderComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIRenderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_srcBlendFactor", _descriptor$u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor2$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor3$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sharedMaterial", _descriptor4$8, _assertThisInitialized(_this)), 
        _this._assembler = null, _this._postAssembler = null, _this._renderData = null, 
        _this._renderDataFlag = !0, _this._renderFlag = !0, _this._material = null, _this._instanceMaterialType = InstanceMaterialType.ADDCOLORANDTEXTURE, 
        _this._blendTemplate = {
            blendState: {
                targets: [ {
                    blendSrc: GFXBlendFactor.SRC_ALPHA,
                    blendDst: GFXBlendFactor.ONE_MINUS_SRC_ALPHA
                } ]
            },
            depthStencilState: {},
            rasterizerState: {}
        }, _this;
    }
    return _inherits(UIRenderComponent, UIComponent), _createClass(UIRenderComponent, [ {
        key: "__preload",
        value: function __preload() {
            this._instanceMaterial(), this._flushAssembler && this._flushAssembler(), this._updateColor();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "onEnable", this).call(this), 
            this.node.on(SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.on(SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
            this._renderFlag = this._canRender();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "onDisable", this).call(this), 
            this.node.off(SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.off(SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
            this._renderFlag = !1;
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.destroyRenderData(), this._material && (this._material.destroy(), cc.director.root.ui._removeUIMaterial(this._material.hash)), 
            this._updateMaterial(null), this._renderData = null;
        }
    }, {
        key: "markForUpdateRenderData",
        value: function markForUpdateRenderData() {
            var enable = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            if (this._renderFlag = this._canRender(), enable && this._renderFlag) {
                var renderData = this._renderData;
                renderData && (renderData.vertDirty = !0), this._renderDataFlag = enable;
            } else enable || (this._renderDataFlag = enable);
        }
    }, {
        key: "requestRenderData",
        value: function requestRenderData() {
            var data = RenderData.add();
            return this._renderData = data, data;
        }
    }, {
        key: "destroyRenderData",
        value: function destroyRenderData() {
            this._renderData && (RenderData.remove(this._renderData), this._renderData = null);
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "updateAssembler", this).call(this, render), 
            this._renderFlag && (this._checkAndUpdateRenderData(), this._render(render));
        }
    }, {
        key: "postUpdateAssembler",
        value: function postUpdateAssembler(render) {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "postUpdateAssembler", this).call(this, render), 
            this._renderFlag && this._postRender(render);
        }
    }, {
        key: "_render",
        value: function _render(render) {}
    }, {
        key: "_postRender",
        value: function _postRender(render) {}
    }, {
        key: "_checkAndUpdateRenderData",
        value: function _checkAndUpdateRenderData() {
            this._renderDataFlag && (this._assembler.updateRenderData(this), this._renderDataFlag = !1);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            return null !== this.material && this.enabled && this.enabledInHierarchy;
        }
    }, {
        key: "_postCanRender",
        value: function _postCanRender() {}
    }, {
        key: "_updateColor",
        value: function _updateColor() {
            this._assembler && this._assembler.updateColor && this._assembler.updateColor(this);
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial(material) {
            this._material = material, this._updateBlendFunc();
        }
    }, {
        key: "_updateBlendFunc",
        value: function _updateBlendFunc() {
            if (this._material) {
                var target = this._blendTemplate.blendState.targets[0];
                target.blendDst === this._dstBlendFactor && target.blendSrc === this._srcBlendFactor || (target.blendDst = this._dstBlendFactor, 
                target.blendSrc = this._srcBlendFactor, this._blendTemplate.depthStencilState = this._material.passes[0].depthStencilState, 
                this._blendTemplate.rasterizerState = this._material.passes[0].rasterizerState, 
                this._material.overridePipelineStates(this._blendTemplate, 0));
            }
        }
    }, {
        key: "_nodeStateChange",
        value: function _nodeStateChange(type) {
            this._renderData && this.markForUpdateRenderData();
            var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var renderComp = _ref.getComponent(UIRenderComponent);
                renderComp && renderComp.markForUpdateRenderData();
            }
        }
    }, {
        key: "_instanceMaterial",
        value: function _instanceMaterial() {
            var mat = null;
            if (this._sharedMaterial) mat = Material.getInstantiatedMaterial(this._sharedMaterial, new RenderableComponent(), !1); else switch (this._instanceMaterialType) {
              case InstanceMaterialType.ADDCOLOR:
                mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-base-material"), new RenderableComponent(), !1);
                break;

              case InstanceMaterialType.ADDCOLORANDTEXTURE:
                mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-sprite-material"), new RenderableComponent(), !1);
            }
            this._updateMaterial(mat);
        }
    }, {
        key: "srcBlendFactor",
        get: function get() {
            return this._srcBlendFactor;
        },
        set: function set(value) {
            this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "dstBlendFactor",
        get: function get() {
            return this._dstBlendFactor;
        },
        set: function set(value) {
            this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
        }
    }, {
        key: "sharedMaterial",
        get: function get() {
            return this._sharedMaterial;
        },
        set: function set(value) {
            this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
        }
    }, {
        key: "material",
        get: function get() {
            return this._material || this._instanceMaterial && this._instanceMaterial(), this._material;
        }
    }, {
        key: "renderData",
        get: function get() {
            return this._renderData;
        }
    } ]), UIRenderComponent;
}(), _class3$d.BlendState = GFXBlendFactor, _class3$d.Assembler = null, _class3$d.PostAssembler = null, 
_applyDecoratedDescriptor((_class2$w = _temp$y).prototype, "srcBlendFactor", [ _dec4$5 ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "srcBlendFactor"), _class2$w.prototype), 
_applyDecoratedDescriptor(_class2$w.prototype, "dstBlendFactor", [ _dec5$5 ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "dstBlendFactor"), _class2$w.prototype), 
_applyDecoratedDescriptor(_class2$w.prototype, "color", [ _dec6$4 ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "color"), _class2$w.prototype), 
_applyDecoratedDescriptor(_class2$w.prototype, "sharedMaterial", [ _dec7$2 ], Object.getOwnPropertyDescriptor(_class2$w.prototype, "sharedMaterial"), _class2$w.prototype), 
_descriptor$u = _applyDecoratedDescriptor(_class2$w.prototype, "_srcBlendFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return GFXBlendFactor.SRC_ALPHA;
    }
}), _descriptor2$l = _applyDecoratedDescriptor(_class2$w.prototype, "_dstBlendFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return GFXBlendFactor.ONE_MINUS_SRC_ALPHA;
    }
}), _descriptor3$b = _applyDecoratedDescriptor(_class2$w.prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor4$8 = _applyDecoratedDescriptor(_class2$w.prototype, "_sharedMaterial", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$D = _class2$w)) || _class$D) || _class$D) || _class$D) || _class$D);

cc.UIRenderComponent = UIRenderComponent, function(AlignMode) {
    AlignMode[AlignMode.ONCE = 0] = "ONCE", AlignMode[AlignMode.ALWAYS = 1] = "ALWAYS";
}(AlignMode || (AlignMode = {})), ccenum(AlignMode), function(AlignFlags) {
    AlignFlags[AlignFlags.TOP = 1] = "TOP", AlignFlags[AlignFlags.MID = 2] = "MID", 
    AlignFlags[AlignFlags.BOT = 4] = "BOT", AlignFlags[AlignFlags.LEFT = 8] = "LEFT", 
    AlignFlags[AlignFlags.CENTER = 16] = "CENTER", AlignFlags[AlignFlags.RIGHT = 32] = "RIGHT", 
    AlignFlags[AlignFlags.HORIZONTAL = 56] = "HORIZONTAL", AlignFlags[AlignFlags.VERTICAL = 7] = "VERTICAL";
}(AlignFlags || (AlignFlags = {}));

var TOP_BOT = AlignFlags.TOP | AlignFlags.BOT, LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT, WidgetComponent = (_dec$E = ccclass("cc.WidgetComponent"), 
_dec2$k = executionOrder(110), _dec3$9 = menu("UI/Widget"), _dec4$6 = requireComponent(UITransformComponent), 
_dec5$6 = property({
    type: cc.Node
}), _dec6$5 = property({
    visible: !1
}), _dec7$3 = property({
    visible: !1
}), _dec8$1 = property({
    type: AlignMode
}), _dec$E(_class$E = _dec2$k(_class$E = _dec3$9(_class$E = _dec4$6(_class$E = executeInEditMode((_temp$z = _class3$e = function(_Component) {
    function WidgetComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WidgetComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WidgetComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastPos = new Vec3(), 
        _this._lastSize = new Size(), _this._dirty = !0, _initializerDefineProperty(_this, "_alignFlags", _descriptor$v, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_target", _descriptor2$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_left", _descriptor3$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_right", _descriptor4$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_top", _descriptor5$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_bottom", _descriptor6$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_originalWidth", _descriptor15, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_originalHeight", _descriptor16, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_alignMode", _descriptor17, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(WidgetComponent, Component), _createClass(WidgetComponent, [ {
        key: "updateAlignment",
        value: function updateAlignment() {
            cc._widgetManager.updateAlignment(this.node);
        }
    }, {
        key: "_validateTargetInDEV",
        value: function _validateTargetInDEV() {
        }
    }, {
        key: "setDirty",
        value: function setDirty() {
            this._recursiveDirty();
        }
    }, {
        key: "onLoad",
        value: function onLoad() {}
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.node.getPosition(this._lastPos), this.node.getContentSize(this._lastSize), 
            cc._widgetManager.add(this), this._registerTargetEvents();
        }
    }, {
        key: "update",
        value: function update() {
            this._dirty || this.node.hasChangedFlags && this._recursiveDirty();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            cc._widgetManager.remove(this), this._unregisterTargetEvents();
        }
    }, {
        key: "_aotuChangedValue",
        value: function _aotuChangedValue(flag, isAbs) {
            if ((this._alignFlags & flag) > 0 && this.node.parent && this.node.parent.uiTransfromComp) {
                var size = this.node.parent.getContentSize();
                this.isAlignLeft && flag === AlignFlags.LEFT ? this._left = isAbs ? this._left * size.width : this._left / size.width : this.isAlignRight && flag === AlignFlags.RIGHT ? this._right = isAbs ? this._right * size.width : this._right / size.width : this.isAlignHorizontalCenter && flag === AlignFlags.CENTER ? this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width : this.isAlignTop && flag === AlignFlags.TOP ? this._top = isAbs ? this._top * size.height : this._top / size.height : this.isAlignBottom && flag === AlignFlags.BOT ? this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height : this.isAbsoluteVerticalCenter && flag === AlignFlags.MID && (this._verticalCenter = isAbs ? this._verticalCenter * size.height : this._verticalCenter / size.height), 
                this._recursiveDirty();
            }
        }
    }, {
        key: "_registerTargetEvents",
        value: function _registerTargetEvents() {
            var target = this._target || this.node.parent;
            target && (target.on(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
            target.on(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
        }
    }, {
        key: "_unregisterTargetEvents",
        value: function _unregisterTargetEvents() {
            var target = this._target || this.node.parent;
            target && (target.off(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
            target.off(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
        }
    }, {
        key: "_targetChangedOperation",
        value: function _targetChangedOperation() {
            this._recursiveDirty();
        }
    }, {
        key: "_setAlign",
        value: function _setAlign(flag, isAlign) {
            if (isAlign !== (this._alignFlags & flag) > 0) {
                var isHorizontal = (flag & LEFT_RIGHT) > 0;
                isAlign ? (this._alignFlags |= flag, isHorizontal ? (this.isAlignHorizontalCenter = !1, 
                this.isStretchWidth && (this._originalWidth = this.node.width)) : (this.isAlignVerticalCenter = !1, 
                this.isStretchHeight && (this._originalHeight = this.node.height))) : (isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight), 
                this._alignFlags &= ~flag);
            }
        }
    }, {
        key: "_recursiveDirty",
        value: function _recursiveDirty() {
            this._dirty || this.node.getComponentsInChildren(WidgetComponent).forEach(function(widget) {
                widget._dirty = !0;
            });
        }
    }, {
        key: "target",
        get: function get() {
            return this._target;
        },
        set: function set(value) {
            this._target !== value && (this._unregisterTargetEvents(), this._target = value, 
            this._registerTargetEvents(), this._validateTargetInDEV(), this._recursiveDirty());
        }
    }, {
        key: "isAlignTop",
        get: function get() {
            return (this._alignFlags & AlignFlags.TOP) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.TOP, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignBottom",
        get: function get() {
            return (this._alignFlags & AlignFlags.BOT) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.BOT, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignLeft",
        get: function get() {
            return (this._alignFlags & AlignFlags.LEFT) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.LEFT, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignRight",
        get: function get() {
            return (this._alignFlags & AlignFlags.RIGHT) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.RIGHT, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignVerticalCenter",
        get: function get() {
            return (this._alignFlags & AlignFlags.MID) > 0;
        },
        set: function set(value) {
            value ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= AlignFlags.MID) : this._alignFlags &= ~AlignFlags.MID, 
            this._recursiveDirty();
        }
    }, {
        key: "isAlignHorizontalCenter",
        get: function get() {
            return (this._alignFlags & AlignFlags.CENTER) > 0;
        },
        set: function set(value) {
            value ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= AlignFlags.CENTER) : this._alignFlags &= ~AlignFlags.CENTER, 
            this._recursiveDirty();
        }
    }, {
        key: "isStretchWidth",
        get: function get() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
        }
    }, {
        key: "isStretchHeight",
        get: function get() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
        }
    }, {
        key: "top",
        get: function get() {
            return this._top;
        },
        set: function set(value) {
            this._top = value, this._recursiveDirty();
        }
    }, {
        key: "bottom",
        get: function get() {
            return this._bottom;
        },
        set: function set(value) {
            this._bottom = value, this._recursiveDirty();
        }
    }, {
        key: "left",
        get: function get() {
            return this._left;
        },
        set: function set(value) {
            this._left = value, this._recursiveDirty();
        }
    }, {
        key: "right",
        get: function get() {
            return this._right;
        },
        set: function set(value) {
            this._right = value, this._recursiveDirty();
        }
    }, {
        key: "horizontalCenter",
        get: function get() {
            return this._horizontalCenter;
        },
        set: function set(value) {
            this._horizontalCenter = value, this._recursiveDirty();
        }
    }, {
        key: "verticalCenter",
        get: function get() {
            return this._verticalCenter;
        },
        set: function set(value) {
            this._verticalCenter = value, this._recursiveDirty();
        }
    }, {
        key: "isAbsoluteTop",
        get: function get() {
            return this._isAbsTop;
        },
        set: function set(value) {
            this._isAbsTop !== value && (this._isAbsTop = value, this._aotuChangedValue(AlignFlags.TOP, this._isAbsTop));
        }
    }, {
        key: "isAbsoluteBottom",
        get: function get() {
            return this._isAbsBottom;
        },
        set: function set(value) {
            this._isAbsBottom !== value && (this._isAbsBottom = value, this._aotuChangedValue(AlignFlags.BOT, this._isAbsBottom));
        }
    }, {
        key: "isAbsoluteLeft",
        get: function get() {
            return this._isAbsLeft;
        },
        set: function set(value) {
            this._isAbsLeft !== value && (this._isAbsLeft = value, this._aotuChangedValue(AlignFlags.LEFT, this._isAbsLeft));
        }
    }, {
        key: "isAbsoluteRight",
        get: function get() {
            return this._isAbsRight;
        },
        set: function set(value) {
            this._isAbsRight !== value && (this._isAbsRight = value, this._aotuChangedValue(AlignFlags.RIGHT, this._isAbsRight));
        }
    }, {
        key: "alignMode",
        get: function get() {
            return this._alignMode;
        },
        set: function set(value) {
            this._alignMode = value, this._recursiveDirty();
        }
    }, {
        key: "isAbsoluteHorizontalCenter",
        get: function get() {
            return this._isAbsHorizontalCenter;
        },
        set: function set(value) {
            this._isAbsHorizontalCenter !== value && (this._isAbsHorizontalCenter = value, this._aotuChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter));
        }
    }, {
        key: "isAbsoluteVerticalCenter",
        get: function get() {
            return this._isAbsVerticalCenter;
        },
        set: function set(value) {
            this._isAbsVerticalCenter !== value && (this._isAbsVerticalCenter = value, this._aotuChangedValue(AlignFlags.MID, this._isAbsVerticalCenter));
        }
    }, {
        key: "alignFlags",
        get: function get() {
            return this._alignFlags;
        },
        set: function set(value) {
            this._alignFlags !== value && (this._alignFlags = value, this._recursiveDirty());
        }
    } ]), WidgetComponent;
}(), _class3$e.AlignMode = AlignMode, _applyDecoratedDescriptor((_class2$x = _temp$z).prototype, "target", [ _dec5$6 ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "target"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAlignTop", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAlignTop"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAlignBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAlignBottom"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAlignLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAlignLeft"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAlignRight", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAlignRight"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAlignVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAlignVerticalCenter"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAlignHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAlignHorizontalCenter"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isStretchWidth", [ _dec6$5 ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isStretchWidth"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isStretchHeight", [ _dec7$3 ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isStretchHeight"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "top", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "top"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "bottom", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "bottom"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "left", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "left"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "right", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "right"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "horizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "horizontalCenter"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "verticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "verticalCenter"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAbsoluteTop", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAbsoluteTop"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAbsoluteBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAbsoluteBottom"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAbsoluteLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAbsoluteLeft"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAbsoluteRight", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAbsoluteRight"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "alignMode", [ _dec8$1 ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "alignMode"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAbsoluteHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAbsoluteHorizontalCenter"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "isAbsoluteVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "isAbsoluteVerticalCenter"), _class2$x.prototype), 
_applyDecoratedDescriptor(_class2$x.prototype, "alignFlags", [ property ], Object.getOwnPropertyDescriptor(_class2$x.prototype, "alignFlags"), _class2$x.prototype), 
_descriptor$v = _applyDecoratedDescriptor(_class2$x.prototype, "_alignFlags", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$m = _applyDecoratedDescriptor(_class2$x.prototype, "_target", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$c = _applyDecoratedDescriptor(_class2$x.prototype, "_left", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor4$9 = _applyDecoratedDescriptor(_class2$x.prototype, "_right", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor5$7 = _applyDecoratedDescriptor(_class2$x.prototype, "_top", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$2 = _applyDecoratedDescriptor(_class2$x.prototype, "_bottom", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$2 = _applyDecoratedDescriptor(_class2$x.prototype, "_horizontalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$2 = _applyDecoratedDescriptor(_class2$x.prototype, "_verticalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class2$x.prototype, "_isAbsLeft", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class2$x.prototype, "_isAbsRight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class2$x.prototype, "_isAbsTop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor12$1 = _applyDecoratedDescriptor(_class2$x.prototype, "_isAbsBottom", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class2$x.prototype, "_isAbsHorizontalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor14$1 = _applyDecoratedDescriptor(_class2$x.prototype, "_isAbsVerticalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor15 = _applyDecoratedDescriptor(_class2$x.prototype, "_originalWidth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor16 = _applyDecoratedDescriptor(_class2$x.prototype, "_originalHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor17 = _applyDecoratedDescriptor(_class2$x.prototype, "_alignMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return AlignMode.ALWAYS;
    }
}), _class$E = _class2$x)) || _class$E) || _class$E) || _class$E) || _class$E) || _class$E);

cc.WidgetComponent = WidgetComponent;

var _tempPos = new Vec3(), _zeroVec3 = new Vec3(), _defaultAnchor = new Vec2();

function getReadonlyNodeSize(parent) {
    return parent instanceof cc.Scene ? cc.visibleRect : parent.getContentSize();
}

function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
    for (var scale = widgetNode.parent ? widgetNode.parent.getScale() : _zeroVec3, scaleX = scale.x, scaleY = scale.y, translateX = 0, translateY = 0, node = widgetNode.parent; ;) {
        if (!node) return out_inverseTranslate.x = out_inverseTranslate.y = 0, void (out_inverseScale.x = out_inverseScale.y = 1);
        var pos = node.getPosition();
        if (translateX += pos.x, translateY += pos.y, (node = node.parent) === target) break;
        var sx = (scale = node ? node.getScale() : _zeroVec3).x, sy = scale.y;
        translateX *= sx, translateY *= sy, scaleX *= sx, scaleY *= sy;
    }
    out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1, out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1, 
    out_inverseTranslate.x = -translateX, out_inverseTranslate.y = -translateY;
}

var tInverseTranslate = new Vec3(), tInverseScale = new Vec3(1, 1, 1);

function align(node, widget) {
    var target, hasTarget = widget.target, inverseTranslate = tInverseTranslate, inverseScale = tInverseScale;
    hasTarget ? computeInverseTransForTarget(node, target = hasTarget, inverseTranslate, inverseScale) : target = node.parent;
    var targetSize = getReadonlyNodeSize(target), isScene = target instanceof cc.Scene, targetAnchor = isScene ? _defaultAnchor : target.getAnchorPoint(), isRoot = isScene;
    node.getPosition(_tempPos);
    var x = _tempPos.x, y = _tempPos.y, anchor = node.getAnchorPoint(), scale = node.getScale();
    if (widget.alignFlags & AlignFlags.HORIZONTAL) {
        var localLeft = 0, localRight = 0, targetWidth = targetSize.width;
        isRoot ? (localLeft = cc.visibleRect.left.x, localRight = cc.visibleRect.right.x) : localRight = (localLeft = -targetAnchor.x * targetWidth) + targetWidth, 
        localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth, localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth, 
        hasTarget && (localLeft += inverseTranslate.x, localLeft *= inverseScale.x, localRight += inverseTranslate.x, 
        localRight *= inverseScale.x);
        var width = 0, anchorX = anchor.x, scaleX = scale.x;
        if (scaleX < 0 && (anchorX = 1 - anchorX, scaleX = -scaleX), widget.isStretchWidth) width = localRight - localLeft, 
        0 !== scaleX && (node.width = width / scaleX), x = localLeft + anchorX * width; else if (width = node.width * scaleX, 
        widget.isAlignHorizontalCenter) {
            var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth, targetCenter = (.5 - targetAnchor.x) * targetSize.width;
            hasTarget && (localHorizontalCenter *= inverseScale.x, targetCenter += inverseTranslate.x, 
            targetCenter *= inverseScale.x), x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
        } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        widget._lastSize.width = width;
    }
    if (widget.alignFlags & AlignFlags.VERTICAL) {
        var localTop = 0, localBottom = 0, targetHeight = targetSize.height;
        isRoot ? (localBottom = cc.visibleRect.bottom.y, localTop = cc.visibleRect.top.y) : localTop = (localBottom = -targetAnchor.y * targetHeight) + targetHeight, 
        localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight, 
        localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight, hasTarget && (localBottom += inverseTranslate.y, 
        localBottom *= inverseScale.y, localTop += inverseTranslate.y, localTop *= inverseScale.y);
        var height = 0, anchorY = anchor.y, scaleY = scale.y;
        if (scaleY < 0 && (anchorY = 1 - anchorY, scaleY = -scaleY), widget.isStretchHeight) height = localTop - localBottom, 
        0 !== scaleY && (node.height = height / scaleY), y = localBottom + anchorY * height; else if (height = node.height * scaleY, 
        widget.isAlignVerticalCenter) {
            var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight, targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
            hasTarget && (localVerticalCenter *= inverseScale.y, targetMiddle += inverseTranslate.y, 
            targetMiddle *= inverseScale.y), y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
        } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        widget._lastSize.height = height;
    }
    node.setPosition(x, y, _tempPos.z), Vec3.set(widget._lastPos, x, y, _tempPos.z);
}

function refreshScene() {
    var scene = cc.director.getScene();
    if (scene) {
        if (widgetManager.isAligning = !0, widgetManager._nodesOrderDirty) activeWidgets.length = 0, 
        function visitNode$1(node) {
            var widget = node.getComponent(WidgetComponent);
            widget && (align(node, widget), widget.alignMode !== AlignMode.ALWAYS ? widget.enabled = !1 : activeWidgets.push(widget));
            var _iterator = node.children, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var child = _ref;
                child.active && visitNode$1(child);
            }
        }(scene), widgetManager._nodesOrderDirty = !1; else {
            var widget = null, iterator = widgetManager._activeWidgetsIterator;
            for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) (widget = activeWidgets[iterator.i])._dirty && (align(widget.node, widget), 
            widget._dirty = !1);
        }
        widgetManager.isAligning = !1;
    }
}

function adjustWidgetToAllowMovingInEditor(eventType) {
    if (eventType === SystemEventType.POSITION_PART && !widgetManager.isAligning) {
        var newPos = this.node.getPosition(), oldPos = this._lastPos, delta = new Vec3(newPos);
        delta.subtract(oldPos);
        var target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
        this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3(), inverseScale));
        var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3();
        0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z), 
        this.isAlignTop && (this.top -= (this.isAbsoluteTop ? delta.y : deltaInPercent.y) * inverseScale.y), 
        this.isAlignBottom && (this.bottom += (this.isAbsoluteBottom ? delta.y : deltaInPercent.y) * inverseScale.y), 
        this.isAlignLeft && (this.left += (this.isAbsoluteLeft ? delta.x : deltaInPercent.x) * inverseScale.x), 
        this.isAlignRight && (this.right -= (this.isAbsoluteRight ? delta.x : deltaInPercent.x) * inverseScale.x), 
        this.isAlignHorizontalCenter && (this.horizontalCenter += (this.isAbsoluteHorizontalCenter ? delta.x : deltaInPercent.x) * inverseScale.x), 
        this.isAlignVerticalCenter && (this.verticalCenter += (this.isAbsoluteVerticalCenter ? delta.y : deltaInPercent.y) * inverseScale.y);
    }
}

function adjustWidgetToAllowResizingInEditor() {
    if (!widgetManager.isAligning) {
        this.setDirty();
        var newSize = this.node.getContentSize(), oldSize = this._lastSize, delta = new Vec3(newSize.width - oldSize.width, newSize.height - oldSize.height, 0), target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
        this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3(), inverseScale));
        var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3();
        0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z);
        var anchor = this.node.getAnchorPoint();
        this.isAlignTop && (this.top -= (this.isAbsoluteTop ? delta.y : deltaInPercent.y) * (1 - anchor.y) * inverseScale.y), 
        this.isAlignBottom && (this.bottom -= (this.isAbsoluteBottom ? delta.y : deltaInPercent.y) * anchor.y * inverseScale.y), 
        this.isAlignLeft && (this.left -= (this.isAbsoluteLeft ? delta.x : deltaInPercent.x) * anchor.x * inverseScale.x), 
        this.isAlignRight && (this.right -= (this.isAbsoluteRight ? delta.x : deltaInPercent.x) * (1 - anchor.x) * inverseScale.x);
    }
}

function adjustWidgetToAnchorChanged() {
    this.setDirty();
}

var activeWidgets = [];

var LightType, canvasList = [], widgetManager = cc._widgetManager = {
    isAligning: !1,
    _nodesOrderDirty: !1,
    _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
    animationState: null,
    init: function init(director) {
        director.on(cc.Director.EVENT_AFTER_UPDATE, refreshScene), cc.sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : cc.view.on("design-resolution-changed", this.onResized, this);
    },
    add: function add(widget) {
        this._nodesOrderDirty = !0;
        var renderComp = widget.node.getComponent(UIRenderComponent);
        if (renderComp) {
            var canvasComp = cc.director.root.ui.getScreen(renderComp.visibility);
            canvasComp && -1 === canvasList.indexOf(canvasComp) && (canvasList.push(canvasComp), 
            canvasComp.node.on("design-resolution-changed", this.onResized, this));
        }
        widget.node.on(SystemEventType.TRANSFORM_CHANGED, adjustWidgetToAllowMovingInEditor, widget), 
        widget.node.on(SystemEventType.SIZE_CHANGED, adjustWidgetToAllowResizingInEditor, widget), 
        widget.node.on(SystemEventType.ANCHOR_CHANGED, adjustWidgetToAnchorChanged, widget);
    },
    remove: function remove(widget) {
        this._activeWidgetsIterator.remove(widget), widget.node.off(SystemEventType.TRANSFORM_CHANGED, adjustWidgetToAllowMovingInEditor, widget), 
        widget.node.off(SystemEventType.SIZE_CHANGED, adjustWidgetToAllowResizingInEditor, widget), 
        widget.node.off(SystemEventType.ANCHOR_CHANGED, adjustWidgetToAnchorChanged, widget);
    },
    onResized: function onResized() {
        var scene = cc.director.getScene();
        scene && this.refreshWidgetOnResized(scene);
    },
    refreshWidgetOnResized: function refreshWidgetOnResized(node) {
        if (cc.Node.isNode(node)) {
            var widget = node.getComponent(WidgetComponent);
            if (widget && widget.alignFlags === AlignMode.ALWAYS) return;
        }
        var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
            var _ref2;
            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                if ((_i2 = _iterator2.next()).done) break;
                _ref2 = _i2.value;
            }
            var child = _ref2;
            this.refreshWidgetOnResized(child);
        }
    },
    updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
        function i(t, c) {
            return Math.abs(t - c) > 1e-10 ? c : t;
        }
        var widgetNode = widget.node, widgetParent = widgetNode.parent;
        if (widgetParent) {
            var zero = new Vec3(), one = new Vec3(1, 1, 1);
            if (widget.target && computeInverseTransForTarget(widgetNode, widgetParent = widget.target, zero, one), 
            !e) return;
            var parentAP = widgetParent.getAnchorPoint(), matchSize = getReadonlyNodeSize(widgetParent), myAP = widgetNode.getAnchorPoint(), pos = widgetNode.getPosition(), alignFlags = AlignFlags, widgetNodeScale = widgetNode.getScale(), temp = 0;
            if (e & alignFlags.LEFT) {
                var l = -parentAP.x * matchSize.width;
                l += zero.x, l *= one.x, temp = pos.x - myAP.x * widgetNode.width * widgetNodeScale.x - l, 
                widget.isAbsoluteLeft || (temp /= matchSize.width), temp /= one.x, widget.left = i(widget.left, temp);
            }
            if (e & alignFlags.RIGHT) {
                var r = (1 - parentAP.x) * matchSize.width;
                r += zero.x, temp = (r *= one.x) - (pos.x + (1 - myAP.x) * widgetNode.width * widgetNodeScale.x), 
                widget.isAbsoluteRight || (temp /= matchSize.width), temp /= one.x, widget.right = i(widget.right, temp);
            }
            if (e & alignFlags.TOP) {
                var t = (1 - parentAP.y) * matchSize.height;
                t += zero.y, temp = (t *= one.y) - (pos.y + (1 - myAP.y) * widgetNode.height * widgetNodeScale.y), 
                widget.isAbsoluteTop || (temp /= matchSize.height), temp /= one.y, widget.top = i(widget.top, temp);
            }
            if (e & alignFlags.BOT) {
                var b = -parentAP.y * matchSize.height;
                b += zero.y, b *= one.y, temp = pos.y - myAP.y * widgetNode.height * widgetNodeScale.y - b, 
                widget.isAbsoluteBottom || (temp /= matchSize.height), temp /= one.y, widget.bottom = i(widget.bottom, temp);
            }
        }
    },
    updateAlignment: function updateAlignment(node) {
        var parent = node.parent;
        parent && cc.Node.isNode(parent) && updateAlignment(parent);
        var widget = node.getComponent(WidgetComponent);
        widget && parent && align(node, widget);
    },
    AlignMode: AlignMode,
    AlignFlags: AlignFlags
};

!function(LightType) {
    LightType[LightType.DIRECTIONAL = 0] = "DIRECTIONAL", LightType[LightType.SPHERE = 1] = "SPHERE", 
    LightType[LightType.SPOT = 2] = "SPOT", LightType[LightType.UNKNOWN = 3] = "UNKNOWN";
}(LightType || (LightType = {}));

var nt2lm = function nt2lm(size) {
    return 4 * Math.PI * Math.PI * size * size;
}, Light = function() {
    function Light(scene, name, node) {
        _classCallCheck(this, Light), this._enabled = !0, this._color = new Vec3(1, 1, 1), 
        this._useColorTemp = !1, this._colorTemp = 6550, this._colorTempRGB = new Vec3(1, 1, 1), 
        this._scene = void 0, this._node = void 0, this._type = void 0, this._name = void 0, 
        this._scene = scene, this._name = name, this._type = LightType.UNKNOWN, this._node = node;
    }
    return _createClass(Light, [ {
        key: "enabled",
        set: function set(val) {
            this._enabled = val;
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "color",
        set: function set(color) {
            this._color.set(color);
        },
        get: function get() {
            return this._color;
        }
    }, {
        key: "useColorTemperature",
        set: function set(enable) {
            this._useColorTemp = enable;
        },
        get: function get() {
            return this._useColorTemp;
        }
    }, {
        key: "colorTemperature",
        set: function set(val) {
            this._colorTemp = val, function ColorTemperatureToRGB(rgb, kelvin) {
                kelvin < 1e3 ? kelvin = 1e3 : kelvin > 15e3 && (kelvin = 15e3);
                var kSqr = kelvin * kelvin, u = (.860117757 + .000154118254 * kelvin + 1.28641212e-7 * kSqr) / (1 + .000842420235 * kelvin + 7.08145163e-7 * kSqr), v = (.317398726 + 422806245e-13 * kelvin + 4.20481691e-8 * kSqr) / (1 - 289741816e-13 * kelvin + 1.61456053e-7 * kSqr), d = 2 * u - 8 * v + 4, x = 3 * u / d, y = 2 * v / d, X = 1 / y * x, Z = 1 / y * (1 - x - y);
                rgb.x = 3.2404542 * X - 1.5371385 + -.4985314 * Z, rgb.y = -.969266 * X + 1.8760108 + .041556 * Z, 
                rgb.z = .0556434 * X - .2040259 + 1.0572252 * Z;
            }(this._colorTempRGB, this._colorTemp);
        },
        get: function get() {
            return this._colorTemp;
        }
    }, {
        key: "colorTemperatureRGB",
        get: function get() {
            return this._colorTempRGB;
        }
    }, {
        key: "node",
        set: function set(n) {
            this._node = n;
        },
        get: function get() {
            return this._node;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    } ]), _createClass(Light, [ {
        key: "update",
        value: function update() {}
    } ]), Light;
}();

function cullSphereLight(light, model) {
    return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb));
}

function cullSpotLight(light, model) {
    return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb) && intersect.aabb_frustum(model.worldBounds, light.frustum));
}

(lightFrustum = new frustum()).accurate = !0;

var lightFrustum, calcDirectionalLightCullFrustum = function() {
    var lightPos = cc.v3(), lightViewCenter = cc.v3(), lightRot = cc.quat(), camFrustum = new frustum();
    camFrustum.accurate = !0;
    var lightViewMat = cc.mat4(), lightVeiwMatInv = cc.mat4(), minBoxCorner = cc.v3(), maxBoxCorner = cc.v3();
    return function(out, sceneCamera, light, near, far, nearBias) {
        Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), sceneCamera.node.getWorldPosition(lightPos)), 
        Mat4.invert(lightVeiwMatInv, lightViewMat), sceneCamera.getSplitFrustum(camFrustum, near, far), 
        camFrustum.transform(lightVeiwMatInv), Vec3.set(minBoxCorner, camFrustum.vertices[0].x, camFrustum.vertices[0].y, camFrustum.vertices[0].z), 
        Vec3.copy(maxBoxCorner, minBoxCorner);
        for (var i = 1; i < camFrustum.vertices.length; i++) minBoxCorner.x = Math.min(minBoxCorner.x, camFrustum.vertices[i].x), 
        minBoxCorner.y = Math.min(minBoxCorner.y, camFrustum.vertices[i].y), minBoxCorner.z = Math.min(minBoxCorner.z, camFrustum.vertices[i].z), 
        maxBoxCorner.x = Math.max(maxBoxCorner.x, camFrustum.vertices[i].x), maxBoxCorner.y = Math.max(maxBoxCorner.y, camFrustum.vertices[i].y), 
        maxBoxCorner.z = Math.max(maxBoxCorner.z, camFrustum.vertices[i].z);
        Vec3.set(lightViewCenter, (minBoxCorner.x + maxBoxCorner.x) / 2, (minBoxCorner.y + maxBoxCorner.y) / 2, maxBoxCorner.z), 
        lightViewCenter.z += nearBias, Vec3.transformMat4(lightPos, lightViewCenter, lightViewMat), 
        Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), lightPos), frustum.createOrtho(out, maxBoxCorner.x - minBoxCorner.x, maxBoxCorner.y - minBoxCorner.y, 0, minBoxCorner.z - nearBias - maxBoxCorner.z, lightViewMat);
    };
}(), RenderFlow = function() {
    function RenderFlow(pipeline) {
        _classCallCheck(this, RenderFlow), this._device = void 0, this._pipeline = void 0, 
        this._name = "", this._priority = 0, this._stages = [], this._material = new Material(), 
        this._device = pipeline.device, this._pipeline = pipeline;
    }
    return _createClass(RenderFlow, [ {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "pipeline",
        get: function get() {
            return this._pipeline;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        }
    }, {
        key: "stages",
        get: function get() {
            return this._stages;
        }
    }, {
        key: "material",
        get: function get() {
            return this._material;
        }
    } ]), _createClass(RenderFlow, [ {
        key: "resize",
        value: function resize(width, height) {
            var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.resize(width, height);
            }
        }
    }, {
        key: "render",
        value: function render(view) {
            var _iterator2 = this._stages, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                _ref2.render(view);
            }
        }
    }, {
        key: "createStage",
        value: function createStage(clazz, info) {
            var stage = new clazz(this);
            return stage.initialize(info) ? (this._stages.push(stage), this._stages.sort(function(a, b) {
                return a.priority - b.priority;
            }), stage) : null;
        }
    }, {
        key: "destroyStages",
        value: function destroyStages() {
            var _iterator3 = this._stages, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                _ref3.destroy();
            }
            this._stages = [];
        }
    } ]), RenderFlow;
}(), RenderStage = function() {
    function RenderStage(flow) {
        if (_classCallCheck(this, RenderStage), this._flow = void 0, this._pipeline = void 0, 
        this._device = void 0, this._name = "", this._priority = 0, this._framebuffer = null, 
        this._cmdBuff = null, this._clearColors = void 0, this._clearDepth = 1, this._clearStencil = 0, 
        this._renderArea = void 0, this._pass = null, this._pso = null, this._flow = flow, 
        this._pipeline = flow.pipeline, this._device = flow.device, !this._flow.pipeline.root.device) throw new Error("");
        this._device = this._flow.pipeline.root.device, this._clearColors = [ {
            r: .3,
            g: .6,
            b: .9,
            a: 1
        } ], this._renderArea = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
    }
    return _createClass(RenderStage, [ {
        key: "flow",
        get: function get() {
            return this._flow;
        }
    }, {
        key: "pipeline",
        get: function get() {
            return this._pipeline;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        }
    }, {
        key: "framebuffer",
        get: function get() {
            return this._framebuffer;
        }
    } ]), _createClass(RenderStage, [ {
        key: "setClearColor",
        value: function setClearColor(color) {
            this._clearColors.length > 0 ? this._clearColors[0] = color : this._clearColors.push(color);
        }
    }, {
        key: "setClearColors",
        value: function setClearColors(colors) {
            this._clearColors = colors;
        }
    }, {
        key: "setClearDepth",
        value: function setClearDepth(depth) {
            this._clearDepth = depth;
        }
    }, {
        key: "setClearStencil",
        value: function setClearStencil(stencil) {
            this._clearStencil = stencil;
        }
    }, {
        key: "setRenderArea",
        value: function setRenderArea(width, height) {
            this._renderArea.width = width, this._renderArea.height = height;
        }
    } ]), RenderStage;
}(), ToneMapStage = function(_RenderStage) {
    function ToneMapStage(flow) {
        var _this;
        return _classCallCheck(this, ToneMapStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ToneMapStage).call(this, flow)))._hTexSampler = 0, 
        _this._hBlendTexSampler = 0, _this._bindingLayout = null, _this;
    }
    return _inherits(ToneMapStage, RenderStage), _createClass(ToneMapStage, [ {
        key: "initialize",
        value: function initialize(info) {
            return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                allocator: this._device.commandAllocator,
                type: GFXCommandBufferType.PRIMARY
            }), this.rebuild(), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {}
    }, {
        key: "rebuild",
        value: function rebuild() {
            this._pass = this._flow.material.passes[0], this._hTexSampler = this._pass.getBinding("u_texSampler");
            var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
            this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
            this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hTexSampler, this._pipeline.curShadingTexView), 
            this._pipeline.useSMAA && (this._hBlendTexSampler = this._pass.getBinding("u_blendTexSampler"), 
            this._pass.bindTextureView(this._hBlendTexSampler, this._pipeline.smaaBlendTexView)), 
            this._pass.update(), this._bindingLayout.update();
        }
    }, {
        key: "render",
        value: function render(view) {
            var camera = view.camera;
            if (this._cmdBuff) {
                this._renderArea.width = camera.width, this._renderArea.height = camera.height;
                var framebuffer = view.window.framebuffer;
                this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(framebuffer, this._renderArea, GFXClearFlag.ALL, [ {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._pso.pipelineLayout.layouts[0]), 
                this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                this._cmdBuff.endRenderPass(), this._cmdBuff.end();
            }
            this._device.queue.submit([ this._cmdBuff ]);
        }
    } ]), ToneMapStage;
}(), ToneMapFlow = function(_RenderFlow) {
    function ToneMapFlow(pipeline) {
        return _classCallCheck(this, ToneMapFlow), _possibleConstructorReturn(this, _getPrototypeOf(ToneMapFlow).call(this, pipeline));
    }
    return _inherits(ToneMapFlow, RenderFlow), _createClass(ToneMapFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            this._material.initialize({
                effectName: "pipeline/tonemap",
                defines: {
                    CC_USE_SMAA: this._pipeline.useSMAA
                }
            });
            var framebuffer = this._pipeline.root.mainWindow.framebuffer;
            return this.createStage(ToneMapStage, {
                name: "ToneMapStage",
                priority: 0,
                framebuffer: framebuffer
            }), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._material && this._material.destroy(), this.destroyStages();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            this._material && (this._material.destroy(), this._material.initialize({
                effectName: "pipeline/tonemap",
                defines: {
                    CC_USE_SMAA: this._pipeline.useSMAA
                }
            }));
            var _iterator = this._stages, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.rebuild();
            }
        }
    } ]), ToneMapFlow;
}(), _vec4Array = new Float32Array(4), _outMat = new Mat4(), _v3tmp = new Vec3(), _v4Zero = new Vec4(0, 0, 0, 0), RenderPipeline = function() {
    function RenderPipeline(root) {
        _classCallCheck(this, RenderPipeline), this._root = void 0, this._device = void 0, 
        this._name = "BasePipeline", this._renderObjects = [], this._renderPasses = new Map(), 
        this._flows = [], this._isHDRSupported = !1, this._isHDR = !1, this._lightMeterScale = 1e4, 
        this._shadingPass = null, this._fboCount = 0, this._msaaShadingTex = null, this._msaaShadingTexView = null, 
        this._msaaDepthStencilTex = null, this._msaaDepthStencilTexView = null, this._msaaShadingFBO = null, 
        this._colorFmt = GFXFormat.UNKNOWN, this._depthStencilFmt = GFXFormat.UNKNOWN, this._shadingTextures = [], 
        this._shadingTexViews = [], this._depthStencilTex = null, this._depthStencilTexView = null, 
        this._shadingFBOs = [], this._shadingWidth = 0, this._shadingHeight = 0, this._shadingScale = 1, 
        this._curIdx = 0, this._prevIdx = 1, this._usePostProcess = !1, this._useMSAA = !1, 
        this._useSMAA = !1, this._smaaPass = null, this._smaaEdgeFBO = null, this._smaaEdgeTex = null, 
        this._smaaEdgeTexView = null, this._smaaBlendFBO = null, this._smaaBlendTex = null, 
        this._smaaBlendTexView = null, this._quadVB = null, this._quadIB = null, this._quadIA = null, 
        this._uboGlobal = new UBOGlobal(), this._globalBindings = new Map(), this._defaultTex = null, 
        this._defaultTexView = null, this._fpScale = 1 / 1024, this._fpScaleInv = 1024, 
        this._macros = {}, this._root = root, this._device = root.device;
    }
    return _createClass(RenderPipeline, [ {
        key: "root",
        get: function get() {
            return this._root;
        }
    }, {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "renderObjects",
        get: function get() {
            return this._renderObjects;
        }
    }, {
        key: "flows",
        get: function get() {
            return this._flows;
        }
    }, {
        key: "usePostProcess",
        get: function get() {
            return this._usePostProcess;
        }
    }, {
        key: "isHDRSupported",
        get: function get() {
            return this._isHDRSupported;
        }
    }, {
        key: "isHDR",
        get: function get() {
            return this._isHDR;
        }
    }, {
        key: "shadingScale",
        get: function get() {
            return this._shadingScale;
        }
    }, {
        key: "lightMeterScale",
        set: function set(scale) {
            this._lightMeterScale = scale;
        },
        get: function get() {
            return this._lightMeterScale;
        }
    }, {
        key: "depthStencilTexView",
        get: function get() {
            return this._depthStencilTexView;
        }
    }, {
        key: "curShadingTexView",
        get: function get() {
            return this._shadingTexViews[this._curIdx];
        }
    }, {
        key: "prevShadingTexView",
        get: function get() {
            return this._shadingTexViews[this._prevIdx];
        }
    }, {
        key: "curShadingFBO",
        get: function get() {
            return this._shadingFBOs[this._curIdx];
        }
    }, {
        key: "prevShadingFBO",
        get: function get() {
            return this._shadingFBOs[this._prevIdx];
        }
    }, {
        key: "msaaShadingFBO",
        get: function get() {
            return this._msaaShadingFBO;
        }
    }, {
        key: "useMSAA",
        get: function get() {
            return this._useMSAA;
        }
    }, {
        key: "useSMAA",
        get: function get() {
            return this._useSMAA;
        }
    }, {
        key: "smaaEdgeTexView",
        get: function get() {
            return this._smaaEdgeTexView;
        }
    }, {
        key: "smaaEdgeFBO",
        get: function get() {
            return this._smaaEdgeFBO;
        }
    }, {
        key: "smaaBlendTexView",
        get: function get() {
            return this._smaaBlendTexView;
        }
    }, {
        key: "smaaBlendFBO",
        get: function get() {
            return this._smaaBlendFBO;
        }
    }, {
        key: "quadIA",
        get: function get() {
            return this._quadIA;
        }
    }, {
        key: "globalBindings",
        get: function get() {
            return this._globalBindings;
        }
    }, {
        key: "defaultTexture",
        get: function get() {
            return this._defaultTex;
        }
    }, {
        key: "fpScale",
        get: function get() {
            return this._fpScale;
        }
    }, {
        key: "fpScaleInv",
        get: function get() {
            return this._fpScaleInv;
        }
    }, {
        key: "macros",
        get: function get() {
            return this._macros;
        }
    }, {
        key: "defaultGlobalUBOData",
        get: function get() {
            return this._uboGlobal.view;
        }
    } ]), _createClass(RenderPipeline, [ {
        key: "render",
        value: function render(view) {
            view.camera.update(), this.sceneCulling(view), this.updateUBOs(view);
            var _iterator = view.flows, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.render(view);
            }
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            this.updateMacros();
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            var w = Math.floor(width * this._shadingScale), h = Math.floor(height * this._shadingScale);
            (w > this._shadingWidth || h > this._shadingHeight) && this.resizeFBOs(w, h);
            var _iterator2 = this._flows, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                _ref2.resize(width, height);
            }
        }
    }, {
        key: "swapFBOs",
        value: function swapFBOs() {
            var temp = this._curIdx;
            this._curIdx = this._prevIdx, this._prevIdx = temp;
        }
    }, {
        key: "addRenderPass",
        value: function addRenderPass(stage, renderPass) {
            renderPass && this._renderPasses.set(stage, renderPass);
        }
    }, {
        key: "getRenderPass",
        value: function getRenderPass(stage) {
            var renderPass = this._renderPasses.get(stage);
            return renderPass || null;
        }
    }, {
        key: "removeRenderPass",
        value: function removeRenderPass(stage) {
            this._renderPasses.delete(stage);
        }
    }, {
        key: "clearRenderPasses",
        value: function clearRenderPasses() {
            this._renderPasses.clear();
        }
    }, {
        key: "createFlow",
        value: function createFlow(clazz, info) {
            var flow = new clazz(this);
            return flow.initialize(info) ? (this._flows.push(flow), this._flows.sort(function(a, b) {
                return a.priority - b.priority;
            }), flow) : null;
        }
    }, {
        key: "destroyFlows",
        value: function destroyFlows() {
            var _iterator3 = this._flows, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                _ref3.destroy();
            }
            this._flows = [];
        }
    }, {
        key: "getFlow",
        value: function getFlow(name) {
            var _iterator4 = this._flows, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                var flow = _ref4;
                if (flow.name === name) return flow;
            }
            return null;
        }
    }, {
        key: "updateMacros",
        value: function updateMacros() {
            programLib.destroyShaderByDefines(this._macros), this._macros.CC_USE_HDR = this._isHDR;
            var _iterator5 = this._root.scenes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                _ref5.onPipelineChange();
            }
        }
    }, {
        key: "_initialize",
        value: function _initialize(info) {
            if (void 0 !== info.enablePostProcess ? this._usePostProcess = info.enablePostProcess : this._usePostProcess = !1, 
            this._usePostProcess && ((this._device.hasFeature(GFXFeature.FORMAT_R11G11B10F) || this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT) || this._device.hasFeature(GFXFeature.TEXTURE_FLOAT)) && (this._isHDRSupported = !0), 
            this._fboCount = 1, this._shadingTextures = new Array(this._fboCount), this._shadingTexViews = new Array(this._fboCount), 
            this._shadingFBOs = new Array(this._fboCount), this._isHDR = void 0 === info.enableHDR || info.enableHDR, 
            this._useSMAA = void 0 !== info.enableSMAA && info.enableSMAA, this._useMSAA = void 0 !== info.enableMSAA && info.enableMSAA, 
            this._useMSAA && (this._useMSAA = this.device.hasFeature(GFXFeature.MSAA))), this._isHDR && this._isHDRSupported && (this._device.hasFeature(GFXFeature.COLOR_HALF_FLOAT) && this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT_LINEAR) ? this._device.hasFeature(GFXFeature.FORMAT_R11G11B10F) ? (this._colorFmt = GFXFormat.R11G11B10F, 
            this._isHDR = !0) : this._device.hasFeature(GFXFeature.TEXTURE_HALF_FLOAT) && (this._colorFmt = GFXFormat.RGBA16F, 
            this._isHDR = !0) : this._device.hasFeature(GFXFeature.COLOR_FLOAT) && this._device.hasFeature(GFXFeature.TEXTURE_FLOAT_LINEAR) && this._device.hasFeature(GFXFeature.TEXTURE_FLOAT) && (this._colorFmt = GFXFormat.RGBA32F, 
            this._isHDR = !0), this._isHDR = !1), this._isHDR || (this._colorFmt = GFXFormat.RGBA8), 
            24 === this._device.depthBits ? 8 === this._device.stencilBits ? this._depthStencilFmt = GFXFormat.D24S8 : this._depthStencilFmt = GFXFormat.D24 : this._depthStencilFmt = GFXFormat.D16, 
            this.updateMacros(), this._shadingScale = 1, this._shadingWidth = Math.floor(this._device.nativeWidth), 
            this._shadingHeight = Math.floor(this._device.nativeHeight), console.info("USE_POST_PROCESS: " + this._usePostProcess), 
            this._usePostProcess && (console.info("USE_MSAA: " + this._useMSAA), console.info("USE_SMAA: " + this._useSMAA), 
            console.info("USE_HDR: " + this._isHDR)), console.info("SHADING_SIZE: " + this._shadingWidth + " x " + this._shadingHeight), 
            console.info("SHADING_SCALE: " + this._shadingScale.toFixed(4)), console.info("SHADING_COLOR_FORMAT: " + GFXFormatInfos[this._colorFmt].name), 
            console.info("SHADING_DEPTH_FORMAT: " + GFXFormatInfos[this._depthStencilFmt].name), 
            this._shadingPass = this._device.createRenderPass({
                colorAttachments: [ {
                    format: this._colorFmt,
                    loadOp: GFXLoadOp.CLEAR,
                    storeOp: GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                    endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                } ],
                depthStencilAttachment: {
                    format: this._depthStencilFmt,
                    depthLoadOp: GFXLoadOp.CLEAR,
                    depthStoreOp: GFXStoreOp.STORE,
                    stencilLoadOp: GFXLoadOp.CLEAR,
                    stencilStoreOp: GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                    endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                }
            }), this._useMSAA && (this._msaaShadingTex = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                format: this._colorFmt,
                width: this._shadingWidth,
                height: this._shadingHeight
            }), this._msaaShadingTexView = this._device.createTextureView({
                texture: this._msaaShadingTex,
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt
            }), this._msaaDepthStencilTex = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                format: this._depthStencilFmt,
                width: this._shadingWidth,
                height: this._shadingHeight
            }), this._msaaDepthStencilTexView = this._device.createTextureView({
                texture: this._msaaDepthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt
            }), this._msaaShadingFBO = this._device.createFramebuffer({
                renderPass: this._shadingPass,
                colorViews: [ this._msaaShadingTexView ],
                depthStencilView: this._msaaDepthStencilTexView
            })), this._fboCount > 0) {
                this._depthStencilTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._depthStencilFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._depthStencilTexView = this._device.createTextureView({
                    texture: this._depthStencilTex,
                    type: GFXTextureViewType.TV2D,
                    format: this._depthStencilFmt
                });
                for (var i = 0; i < this._fboCount; ++i) this._shadingTextures[i] = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: this._colorFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._shadingTexViews[i] = this._device.createTextureView({
                    texture: this._shadingTextures[i],
                    type: GFXTextureViewType.TV2D,
                    format: this._colorFmt
                }), this._shadingFBOs[i] = this._device.createFramebuffer({
                    renderPass: this._shadingPass,
                    colorViews: [ this._shadingTexViews[i] ],
                    depthStencilView: this._depthStencilTexView
                });
            }
            if (this._useSMAA) {
                var smaaColorFmt = GFXFormat.RGBA8;
                this._smaaPass = this._device.createRenderPass({
                    colorAttachments: [ {
                        format: smaaColorFmt,
                        loadOp: GFXLoadOp.CLEAR,
                        storeOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                        endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                    } ]
                }), this._smaaEdgeTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: smaaColorFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._smaaEdgeTexView = this._device.createTextureView({
                    texture: this._smaaEdgeTex,
                    type: GFXTextureViewType.TV2D,
                    format: smaaColorFmt
                }), this._smaaEdgeFBO = this._device.createFramebuffer({
                    renderPass: this._smaaPass,
                    colorViews: [ this._smaaEdgeTexView ],
                    depthStencilView: null
                }), this._smaaBlendTex = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                    format: smaaColorFmt,
                    width: this._shadingWidth,
                    height: this._shadingHeight
                }), this._smaaBlendTexView = this._device.createTextureView({
                    texture: this._smaaBlendTex,
                    type: GFXTextureViewType.TV2D,
                    format: smaaColorFmt
                }), this._smaaBlendFBO = this._device.createFramebuffer({
                    renderPass: this._smaaPass,
                    colorViews: [ this._smaaBlendTexView ],
                    depthStencilView: null
                });
            }
            return !!this.createQuadInputAssembler() && !!this.createUBOs();
        }
    }, {
        key: "_destroy",
        value: function _destroy() {
            this.destroyFlows(), this.clearRenderPasses(), this.destroyQuadInputAssembler(), 
            this.destroyUBOs(), this._smaaEdgeTexView && (this._smaaEdgeTexView.destroy(), this._smaaEdgeTexView = null), 
            this._smaaEdgeTex && (this._smaaEdgeTex.destroy(), this._smaaEdgeTex = null), this._smaaEdgeFBO && (this._smaaEdgeFBO.destroy(), 
            this._smaaEdgeFBO = null), this._smaaBlendTexView && (this._smaaBlendTexView.destroy(), 
            this._smaaBlendTexView = null), this._smaaBlendTex && (this._smaaBlendTex.destroy(), 
            this._smaaBlendTex = null), this._smaaBlendFBO && (this._smaaBlendFBO.destroy(), 
            this._smaaBlendFBO = null), this._msaaShadingTexView && (this._msaaShadingTexView.destroy(), 
            this._msaaShadingTexView = null), this._msaaShadingTex && (this._msaaShadingTex.destroy(), 
            this._msaaShadingTex = null), this._msaaDepthStencilTexView && (this._msaaDepthStencilTexView.destroy(), 
            this._msaaDepthStencilTexView = null), this._msaaDepthStencilTex && (this._msaaDepthStencilTex.destroy(), 
            this._msaaDepthStencilTex = null), this._msaaShadingFBO && (this._msaaShadingFBO.destroy(), 
            this._msaaShadingFBO = null);
            for (var i = 0; i < this._shadingTexViews.length; ++i) this._shadingTexViews[i] && this._shadingTexViews[i].destroy(), 
            this._shadingTextures[i] && this._shadingTextures[i].destroy(), this._shadingFBOs[i] && this._shadingFBOs[i].destroy();
            this._shadingTexViews.splice(0), this._shadingTextures.splice(0), this._shadingFBOs.splice(0), 
            this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
            this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
            this._shadingPass && (this._shadingPass.destroy(), this._shadingPass = null);
        }
    }, {
        key: "resizeFBOs",
        value: function resizeFBOs(width, height) {
            this._shadingWidth = width, this._shadingHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
            this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                texture: this._depthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt
            }));
            for (var i = 0; i < this._fboCount; ++i) this._shadingTextures[i].resize(width, height), 
            this._shadingTexViews[i].destroy(), this._shadingTexViews[i].initialize({
                texture: this._shadingTextures[i],
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt
            }), this._shadingFBOs[i].destroy(), this._shadingFBOs[i].initialize({
                renderPass: this._shadingPass,
                colorViews: [ this._shadingTexViews[i] ],
                depthStencilView: this._depthStencilTexView
            });
            if (this._useMSAA && (this._msaaShadingTex.resize(width, height), this._msaaShadingTexView.destroy(), 
            this._msaaShadingTexView.initialize({
                texture: this._msaaShadingTex,
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt
            }), this._msaaDepthStencilTex.resize(width, height), this._msaaDepthStencilTexView.destroy(), 
            this._msaaDepthStencilTexView.initialize({
                texture: this._msaaDepthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt
            }), this._msaaShadingFBO.destroy(), this._msaaShadingFBO.initialize({
                renderPass: this._shadingPass,
                colorViews: [ this._msaaShadingTexView ],
                depthStencilView: this._msaaDepthStencilTexView
            })), this._useSMAA) {
                var smaaColorFmt = this._smaaEdgeTex.format;
                this._smaaEdgeTex.resize(width, height), this._smaaEdgeTexView.destroy(), this._smaaEdgeTexView.initialize({
                    texture: this._smaaEdgeTex,
                    type: GFXTextureViewType.TV2D,
                    format: smaaColorFmt
                }), this._smaaEdgeFBO.destroy(), this._smaaEdgeFBO.initialize({
                    renderPass: this._smaaPass,
                    colorViews: [ this._smaaEdgeTexView ],
                    depthStencilView: null
                }), this._smaaBlendTex.resize(width, height), this._smaaBlendTexView.destroy(), 
                this._smaaBlendTexView.initialize({
                    texture: this._smaaBlendTex,
                    type: GFXTextureViewType.TV2D,
                    format: smaaColorFmt
                }), this._smaaBlendFBO.destroy(), this._smaaBlendFBO.initialize({
                    renderPass: this._smaaPass,
                    colorViews: [ this._smaaBlendTexView ],
                    depthStencilView: null
                });
            }
            console.info("Resizing shading fbos: " + this._shadingWidth + "x" + this._shadingHeight);
        }
    }, {
        key: "createQuadInputAssembler",
        value: function createQuadInputAssembler() {
            var vbStride = 4 * Float32Array.BYTES_PER_ELEMENT, vbSize = 4 * vbStride;
            if (this._quadVB = this._device.createBuffer({
                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: vbSize,
                stride: vbStride
            }), !this._quadVB) return !1;
            var verts = new Float32Array(16), n = 0;
            verts[n++] = -1, verts[n++] = -1, verts[n++] = 0, verts[n++] = 0, verts[n++] = 1, 
            verts[n++] = -1, verts[n++] = 1, verts[n++] = 0, verts[n++] = -1, verts[n++] = 1, 
            verts[n++] = 0, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, 
            verts[n++] = 1, this._quadVB.update(verts);
            var ibStride = Uint8Array.BYTES_PER_ELEMENT, ibSize = 6 * ibStride;
            if (this._quadIB = this._device.createBuffer({
                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: ibSize,
                stride: ibStride
            }), !this._quadIB) return !1;
            var indices = new Uint8Array(6);
            indices[0] = 0, indices[1] = 1, indices[2] = 2, indices[3] = 1, indices[4] = 3, 
            indices[5] = 2, this._quadIB.update(indices);
            var attributes = [ {
                name: "a_position",
                format: GFXFormat.RG32F
            }, {
                name: "a_texCoord",
                format: GFXFormat.RG32F
            } ];
            return this._quadIA = this._device.createInputAssembler({
                attributes: attributes,
                vertexBuffers: [ this._quadVB ],
                indexBuffer: this._quadIB
            }), !0;
        }
    }, {
        key: "destroyQuadInputAssembler",
        value: function destroyQuadInputAssembler() {
            this._quadVB && (this._quadVB.destroy(), this._quadVB = null), this._quadIB && (this._quadIB.destroy(), 
            this._quadIB = null), this._quadIA && (this._quadIA.destroy(), this._quadIA = null);
        }
    }, {
        key: "createUBOs",
        value: function createUBOs() {
            if (!this._globalBindings.get(UBOGlobal.BLOCK.name)) {
                var globalUBO = this._root.device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOGlobal.SIZE
                });
                this._globalBindings.set(UBOGlobal.BLOCK.name, {
                    type: GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOGlobal.BLOCK,
                    buffer: globalUBO
                });
            }
            if (!this._globalBindings.get(UBOShadow.BLOCK.name)) {
                var shadowUBO = this._root.device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOShadow.SIZE
                });
                this._globalBindings.set(UBOShadow.BLOCK.name, {
                    type: GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOShadow.BLOCK,
                    buffer: shadowUBO
                });
            }
            return this._globalBindings.get(UNIFORM_ENVIRONMENT.name) || this._globalBindings.set(UNIFORM_ENVIRONMENT.name, {
                type: GFXBindingType.SAMPLER,
                samplerInfo: UNIFORM_ENVIRONMENT
            }), !0;
        }
    }, {
        key: "destroyUBOs",
        value: function destroyUBOs() {
            var globalUBO = this._globalBindings.get(UBOGlobal.BLOCK.name);
            globalUBO && (globalUBO.buffer.destroy(), this._globalBindings.delete(UBOGlobal.BLOCK.name));
            var shadowUBO = this._globalBindings.get(UBOShadow.BLOCK.name);
            shadowUBO && (shadowUBO.buffer.destroy(), this._globalBindings.delete(UBOShadow.BLOCK.name));
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(view) {
            var camera = view.camera, scene = camera.scene, device = this._root.device, mainLight = scene.mainLight, ambient = scene.ambient, fv = this._uboGlobal.view;
            fv[UBOGlobal.TIME_OFFSET] = this._root.cumulativeTime, fv[UBOGlobal.SCREEN_SIZE_OFFSET] = device.width, 
            fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = device.height, fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET], 
            fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1], 
            fv[UBOGlobal.SCREEN_SCALE_OFFSET] = camera.width / this._shadingWidth * this._shadingScale, 
            fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1] = camera.height / this._shadingHeight * this._shadingScale, 
            fv[UBOGlobal.SCREEN_SCALE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET], fv[UBOGlobal.SCREEN_SCALE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1], 
            fv[UBOGlobal.NATIVE_SIZE_OFFSET] = this._shadingWidth, fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = this._shadingHeight, 
            fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET], fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1], 
            Mat4.array(fv, camera.matView, UBOGlobal.MAT_VIEW_OFFSET), Mat4.invert(_outMat, camera.matView), 
            Mat4.array(fv, _outMat, UBOGlobal.MAT_VIEW_INV_OFFSET), Mat4.array(fv, camera.matProj, UBOGlobal.MAT_PROJ_OFFSET), 
            Mat4.invert(_outMat, camera.matProj), Mat4.array(fv, _outMat, UBOGlobal.MAT_PROJ_INV_OFFSET), 
            Mat4.array(fv, camera.matViewProj, UBOGlobal.MAT_VIEW_PROJ_OFFSET), Mat4.array(fv, camera.matViewProjInv, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET), 
            Vec3.array(fv, camera.position, UBOGlobal.CAMERA_POS_OFFSET);
            var exposure = camera.exposure;
            if (fv[UBOGlobal.EXPOSURE_OFFSET] = exposure, fv[UBOGlobal.EXPOSURE_OFFSET + 1] = 1 / exposure, 
            fv[UBOGlobal.EXPOSURE_OFFSET + 2] = this._isHDR ? 1 : 0, fv[UBOGlobal.EXPOSURE_OFFSET + 3] = this._fpScale / exposure, 
            Vec3.array(fv, mainLight.direction, UBOGlobal.MAIN_LIT_DIR_OFFSET), mainLight.enabled) {
                if (Vec3.array(fv, mainLight.color, UBOGlobal.MAIN_LIT_COLOR_OFFSET), mainLight.useColorTemperature) {
                    var colorTempRGB = mainLight.colorTemperatureRGB;
                    fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET] *= colorTempRGB.x, fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 1] *= colorTempRGB.y, 
                    fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 2] *= colorTempRGB.z;
                }
                this._isHDR ? fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * this._fpScale : fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
            } else Vec4.array(fv, _v4Zero, UBOGlobal.MAIN_LIT_COLOR_OFFSET);
            _vec4Array.set(ambient.skyColor), this._isHDR ? _vec4Array[3] = ambient.skyIllum * this._fpScale : _vec4Array[3] = ambient.skyIllum * exposure, 
            this._uboGlobal.view.set(_vec4Array, UBOGlobal.AMBIENT_SKY_OFFSET), this._uboGlobal.view.set(ambient.groundAlbedo, UBOGlobal.AMBIENT_GROUND_OFFSET), 
            this._globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this._uboGlobal.view.buffer);
        }
    }, {
        key: "sceneCulling",
        value: function sceneCulling(view) {
            var camera = view.camera, scene = camera.scene;
            this._renderObjects.splice(0);
            var mainLight = scene.mainLight;
            mainLight && mainLight.enabled && mainLight.update();
            var planarShadows = scene.planarShadows;
            planarShadows.enabled && mainLight.node.hasChangedFlags && planarShadows.updateDirLight(mainLight), 
            scene.skybox.enabled && this.addVisibleModel(scene.skybox, camera);
            var _iterator6 = scene.models, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    if ((_i6 = _iterator6.next()).done) break;
                    _ref6 = _i6.value;
                }
                var model = _ref6;
                if (model._resetUBOUpdateFlag(), model.enabled && (model.viewID & view.visibility || 0 === view.visibility && model.viewID <= 0)) {
                    if (model.updateTransform(), model.worldBounds && !intersect.aabb_frustum(model.worldBounds, camera.frustum)) continue;
                    model.updateUBOs(), this.addVisibleModel(model, camera);
                }
            }
            planarShadows.enabled && planarShadows.updateCommandBuffers();
        }
    }, {
        key: "addVisibleModel",
        value: function addVisibleModel(model, camera) {
            var depth = 0;
            model.node && (model.node.getWorldPosition(_v3tmp), Vec3.subtract(_v3tmp, _v3tmp, camera.position), 
            depth = Vec3.dot(_v3tmp, camera.forward)), this._renderObjects.push({
                model: model,
                depth: depth
            });
        }
    } ]), RenderPipeline;
}(), CachedArray = function() {
    function CachedArray(length, compareFn) {
        _classCallCheck(this, CachedArray), this.array = void 0, this.length = 0, this.cache = void 0, 
        this._compareFn = void 0, this.array = new Array(length), this.cache = this.array, 
        this.length = 0, this._compareFn = void 0 !== compareFn ? compareFn : function(a, b) {
            return a - b;
        };
    }
    return _createClass(CachedArray, [ {
        key: "push",
        value: function push(item) {
            this.array[this.length++] = item;
        }
    }, {
        key: "pop",
        value: function pop() {
            return this.array[this.length--];
        }
    }, {
        key: "get",
        value: function get(idx) {
            return this.array[idx];
        }
    }, {
        key: "clear",
        value: function clear() {
            this.cache.fill(null), this.length = 0;
        }
    }, {
        key: "sort",
        value: function sort() {
            this.array.length = this.length, this.array.sort(this._compareFn);
        }
    }, {
        key: "concat",
        value: function concat(array) {
            for (var i = 0; i < array.length; ++i) this.array[this.length++] = array.array[i];
        }
    }, {
        key: "append",
        value: function append(array) {
            var _iterator = array, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var item = _ref;
                this.array[this.length++] = item;
            }
        }
    } ]), CachedArray;
}();

function opaqueCompareFn(a, b) {
    return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : a.depth - b.depth : a.hash - b.hash;
}

function transparentCompareFn(a, b) {
    return a.hash === b.hash ? a.depth === b.depth ? a.shaderId - b.shaderId : b.depth - a.depth : a.hash - b.hash;
}

var RenderQueue = function() {
    function RenderQueue(desc) {
        _classCallCheck(this, RenderQueue), this.queue = void 0, this.cmdBuffs = void 0, 
        this.cmdBuffCount = 0, this._passDesc = void 0, this._passDesc = desc, this.cmdBuffs = new CachedArray(64), 
        this.queue = new CachedArray(64, this._passDesc.sortFunc);
    }
    return _createClass(RenderQueue, [ {
        key: "clear",
        value: function clear() {
            this.queue.clear(), this.cmdBuffCount = 0;
        }
    }, {
        key: "insertRenderPass",
        value: function insertRenderPass(renderObj, modelIdx, passIdx) {
            var subModel = renderObj.model.getSubModel(modelIdx), pass = subModel.passes[passIdx], pso = subModel.psos[passIdx];
            if (pso.blendState.targets[0].blend !== this._passDesc.isTransparent || !(pass.phase & this._passDesc.phases)) return !1;
            var hash = 0 | pass.priority << 16 | subModel.priority << 8 | passIdx;
            return this.queue.push({
                hash: hash,
                depth: renderObj.depth,
                shaderId: pso.shader.id,
                subModel: subModel,
                cmdBuff: subModel.commandBuffers[passIdx]
            }), !0;
        }
    }, {
        key: "sort",
        value: function sort() {
            this.queue.sort(), this.cmdBuffCount = this.queue.length;
            for (var i = 0; i < this.queue.length; ++i) this.cmdBuffs.array[i] = this.queue.array[i].cmdBuff;
        }
    } ]), RenderQueue;
}(), bufs = [], UIStage = function(_RenderStage) {
    function UIStage(flow) {
        var _this;
        return _classCallCheck(this, UIStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIStage).call(this, flow)))._uiQueue = void 0, 
        _this._uiQueue = new RenderQueue({
            isTransparent: !0,
            phases: getPhaseID("default"),
            sortFunc: transparentCompareFn
        }), _this;
    }
    return _inherits(UIStage, RenderStage), _createClass(UIStage, [ {
        key: "initialize",
        value: function initialize(info) {
            return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            void 0 !== info.framebuffer && (this._framebuffer = info.framebuffer), this._cmdBuff = this._device.createCommandBuffer({
                allocator: this._device.commandAllocator,
                type: GFXCommandBufferType.PRIMARY
            }), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {}
    }, {
        key: "rebuild",
        value: function rebuild() {}
    }, {
        key: "render",
        value: function render(view) {
            this._uiQueue.clear();
            var _iterator = this._pipeline.renderObjects, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                for (var ro = _ref, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._uiQueue.insertRenderPass(ro, i, j);
            }
            this._uiQueue.sort();
            var framebuffer = view.window.framebuffer, cmdBuff = this._cmdBuff, camera = view.camera;
            this._renderArea.width = this.flow.pipeline.root.device.width, this._renderArea.height = this.flow.pipeline.root.device.height, 
            cmdBuff.begin(), cmdBuff.beginRenderPass(framebuffer, this._renderArea, GFXClearFlag.DEPTH_STENCIL, [], camera.clearDepth, camera.clearStencil), 
            cmdBuff.execute(this._uiQueue.cmdBuffs.array, this._uiQueue.cmdBuffCount), cmdBuff.endRenderPass(), 
            cmdBuff.end(), bufs[0] = cmdBuff, this._device.queue.submit(bufs);
        }
    } ]), UIStage;
}(), UIFlow = function(_RenderFlow) {
    function UIFlow(pipeline) {
        return _classCallCheck(this, UIFlow), _possibleConstructorReturn(this, _getPrototypeOf(UIFlow).call(this, pipeline));
    }
    return _inherits(UIFlow, RenderFlow), _createClass(UIFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.name && (this._name = info.name), this._priority = info.priority;
            var mainWindow = this._pipeline.root.mainWindow;
            return !(!mainWindow || !mainWindow.framebuffer) && (this.createStage(UIStage, {
                name: "UIStage",
                priority: 0,
                framebuffer: mainWindow.framebuffer
            }), !0);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyStages();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {}
    }, {
        key: "render",
        value: function render(view) {
            var isHDR = this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2];
            this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = 0, this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer), 
            _get(_getPrototypeOf(UIFlow.prototype), "render", this).call(this, view), this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = isHDR, 
            this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData.buffer);
        }
    } ]), UIFlow;
}();

var ForwardStagePriority, colors = [], bufs$1 = [], ForwardStage = function(_RenderStage) {
    function ForwardStage(flow) {
        var _this;
        return _classCallCheck(this, ForwardStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardStage).call(this, flow)))._opaqueQueue = void 0, 
        _this._transparentQueue = void 0, _this._opaqueQueue = new RenderQueue({
            isTransparent: !1,
            phases: getPhaseID("default"),
            sortFunc: opaqueCompareFn
        }), _this._transparentQueue = new RenderQueue({
            isTransparent: !0,
            phases: getPhaseID("default") | getPhaseID("planarShadow"),
            sortFunc: transparentCompareFn
        }), _this;
    }
    return _inherits(ForwardStage, RenderStage), _createClass(ForwardStage, [ {
        key: "initialize",
        value: function initialize(info) {
            return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            this._cmdBuff = this._device.createCommandBuffer({
                allocator: this._device.commandAllocator,
                type: GFXCommandBufferType.PRIMARY
            }), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {}
    }, {
        key: "rebuild",
        value: function rebuild() {}
    }, {
        key: "render",
        value: function render(view) {
            this._opaqueQueue.clear(), this._transparentQueue.clear();
            var _iterator = this._pipeline.renderObjects, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                for (var ro = _ref, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._opaqueQueue.insertRenderPass(ro, i, j), 
                this._transparentQueue.insertRenderPass(ro, i, j);
            }
            this._opaqueQueue.sort(), this._transparentQueue.sort();
            var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
            if (this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
            this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
            camera.clearFlag & GFXClearFlag.COLOR) {
                if (colors[0] = camera.clearColor, this._pipeline.isHDR) {
                    colors[0] = function SRGBToLinear(gamma) {
                        return {
                            r: Math.pow(gamma.r, 2.2),
                            g: Math.pow(gamma.g, 2.2),
                            b: Math.pow(gamma.b, 2.2),
                            a: 1
                        };
                    }(colors[0]);
                    var scale = this._pipeline.fpScale / camera.exposure;
                    colors[0].r *= scale, colors[0].g *= scale, colors[0].b *= scale;
                }
                colors.length = 1;
            }
            this._pipeline.usePostProcess ? this._pipeline.useMSAA ? this._framebuffer = this._pipeline.msaaShadingFBO : this._framebuffer = this._pipeline.curShadingFBO : this._framebuffer = view.window.framebuffer;
            var planarShadow = camera.scene.planarShadows;
            cmdBuff.begin(), cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, colors, camera.clearDepth, camera.clearStencil), 
            cmdBuff.execute(this._opaqueQueue.cmdBuffs.array, this._opaqueQueue.cmdBuffCount), 
            cmdBuff.execute(planarShadow.cmdBuffs.array, planarShadow.cmdBuffCount), cmdBuff.execute(this._transparentQueue.cmdBuffs.array, this._transparentQueue.cmdBuffCount), 
            cmdBuff.endRenderPass(), cmdBuff.end(), bufs$1[0] = cmdBuff, this._device.queue.submit(bufs$1), 
            this._pipeline.useMSAA && this._device.blitFramebuffer(this._framebuffer, this._pipeline.curShadingFBO, this._renderArea, this._renderArea, GFXFilter.POINT);
        }
    } ]), ForwardStage;
}();

!function(ForwardStagePriority) {
    ForwardStagePriority[ForwardStagePriority.FORWARD = 0] = "FORWARD";
}(ForwardStagePriority || (ForwardStagePriority = {}));

var ForwardFlowPriority, ForwardFlow = function(_RenderFlow) {
    function ForwardFlow(pipeline) {
        return _classCallCheck(this, ForwardFlow), _possibleConstructorReturn(this, _getPrototypeOf(ForwardFlow).call(this, pipeline));
    }
    return _inherits(ForwardFlow, RenderFlow), _createClass(ForwardFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            this.createStage(ForwardStage, {
                name: "ForwardStage",
                priority: ForwardStagePriority.FORWARD
            }), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyStages();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {}
    } ]), ForwardFlow;
}();

!function(ForwardFlowPriority) {
    ForwardFlowPriority[ForwardFlowPriority.FORWARD = 0] = "FORWARD", ForwardFlowPriority[ForwardFlowPriority.UI = 10] = "UI";
}(ForwardFlowPriority || (ForwardFlowPriority = {}));

var RenderViewPriority, _vec4Array$1 = new Float32Array(4), _sphere = sphere.create(0, 0, 0, 1), _tempLightIndex = [], _tempLightDist = [], _tempVec3 = new Vec3(), ForwardPipeline = function(_RenderPipeline) {
    function ForwardPipeline(root) {
        var _this;
        return _classCallCheck(this, ForwardPipeline), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardPipeline).call(this, root)))._uboLights = new UBOForwardLight(), 
        _this._lightsUBO = null, _this._validLights = void 0, _this._lightIndexOffset = void 0, 
        _this._lightIndices = void 0, _this._validLights = [], _this._lightIndexOffset = [], 
        _this._lightIndices = [], _this;
    }
    return _inherits(ForwardPipeline, RenderPipeline), _createClass(ForwardPipeline, [ {
        key: "lightsUBO",
        get: function get() {
            return this._lightsUBO;
        }
    } ]), _createClass(ForwardPipeline, [ {
        key: "initialize",
        value: function initialize(info) {
            if (!this._initialize(info)) return !1;
            if (this._name = "ForwardPipeline", !this._globalBindings.get(UBOForwardLight.BLOCK.name)) {
                var lightsUBO = this._root.device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOForwardLight.SIZE
                });
                if (!lightsUBO) return !1;
                this._globalBindings.set(UBOForwardLight.BLOCK.name, {
                    type: GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOForwardLight.BLOCK,
                    buffer: lightsUBO
                });
            }
            var mainWindow = this._root.mainWindow, windowPass = null;
            return mainWindow && (windowPass = mainWindow.renderPass), windowPass ? (this.addRenderPass(RenderPassStage.DEFAULT, windowPass), 
            this.createFlow(ForwardFlow, {
                name: "ForwardFlow",
                priority: ForwardFlowPriority.FORWARD
            }), this._usePostProcess && (this._useSMAA, this.createFlow(ToneMapFlow, {
                name: "ToneMapFlow",
                priority: 0
            })), this.createFlow(UIFlow, {
                name: "UIFlow",
                priority: ForwardFlowPriority.UI
            }), !0) : (console.error("RenderPass of main window is null."), !1);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var lightsUBO = this._globalBindings.get(UBOForwardLight.BLOCK.name);
            lightsUBO && (lightsUBO.buffer.destroy(), this._globalBindings.delete(UBOForwardLight.BLOCK.name)), 
            this._destroy();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "rebuild", this).call(this);
            var _iterator = this._flows, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.rebuild();
            }
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(view) {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "updateUBOs", this).call(this, view);
            for (var exposure = view.camera.exposure, i = 0; i < this._renderObjects.length; i++) {
                this._uboLights.view.fill(0);
                var nextLightIndex = i + 1 < this._renderObjects.length ? this._lightIndexOffset[i + 1] : this._lightIndices.length;
                if (this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name)) {
                    for (var sphereNum = 0, spotNum = 0, l = this._lightIndexOffset[i]; l < nextLightIndex; l++) {
                        var light = this._validLights[this._lightIndices[l]];
                        if (light && light.enabled) switch (light.type) {
                          case LightType.SPHERE:
                            if (sphereNum >= UBOForwardLight.MAX_SPHERE_LIGHTS) continue;
                            var sphereLit = light;
                            if (Vec3.array(_vec4Array$1, sphereLit.position), this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_POS_OFFSET + 4 * sphereNum), 
                            _vec4Array$1[0] = sphereLit.size, _vec4Array$1[1] = sphereLit.range, _vec4Array$1[2] = 0, 
                            this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET + 4 * sphereNum), 
                            Vec3.array(_vec4Array$1, light.color), light.useColorTemperature) {
                                var tempRGB = light.colorTemperatureRGB;
                                _vec4Array$1[0] *= tempRGB.x, _vec4Array$1[1] *= tempRGB.y, _vec4Array$1[2] *= tempRGB.z;
                            }
                            _vec4Array$1[3] = sphereLit.luminance * this._lightMeterScale, this._isHDR ? _vec4Array$1[3] = sphereLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array$1[3] = sphereLit.luminance * exposure * this._lightMeterScale, 
                            this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET + 4 * sphereNum), 
                            sphereNum++;
                            break;

                          case LightType.SPOT:
                            if (spotNum >= UBOForwardLight.MAX_SPOT_LIGHTS) continue;
                            var spotLit = light;
                            if (Vec3.array(_vec4Array$1, spotLit.position), _vec4Array$1[3] = spotLit.size, 
                            this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_POS_OFFSET + 4 * spotNum), 
                            _vec4Array$1[0] = spotLit.size, _vec4Array$1[1] = spotLit.range, _vec4Array$1[2] = spotLit.spotAngle, 
                            this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * spotNum), 
                            Vec3.array(_vec4Array$1, spotLit.direction), this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_DIR_OFFSET + 4 * spotNum), 
                            Vec3.array(_vec4Array$1, light.color), light.useColorTemperature) {
                                var _tempRGB = light.colorTemperatureRGB;
                                _vec4Array$1[0] *= _tempRGB.x, _vec4Array$1[1] *= _tempRGB.y, _vec4Array$1[2] *= _tempRGB.z;
                            }
                            this._isHDR ? _vec4Array$1[3] = spotLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array$1[3] = spotLit.luminance * exposure * this._lightMeterScale, 
                            this._uboLights.view.set(_vec4Array$1, UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET + 4 * spotNum), 
                            spotNum++;
                        }
                    }
                    this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name).buffer.update(this._uboLights.view);
                }
            }
        }
    }, {
        key: "sceneCulling",
        value: function sceneCulling(view) {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "sceneCulling", this).call(this, view), 
            this._validLights.splice(0);
            var _iterator2 = view.camera.scene.sphereLights, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var light = _ref2;
                light.enabled && (light.update(), sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range), 
                intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(light));
            }
            var _iterator3 = view.camera.scene.spotLights, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var _light = _ref3;
                _light.enabled && (_light.update(), sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range), 
                intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(_light));
            }
            this._lightIndexOffset.splice(0), this._lightIndices.splice(0);
            for (var i = 0; i < this._renderObjects.length; i++) this._lightIndexOffset[i] = this._lightIndices.length, 
            this._renderObjects[i].model.localBindings.get(UBOForwardLight.BLOCK.name) && this.cullLightPerModel(this._renderObjects[i].model);
        }
    }, {
        key: "cullLightPerModel",
        value: function cullLightPerModel(model) {
            var _this$_lightIndices;
            _tempLightIndex.splice(0);
            for (var i = 0; i < this._validLights.length; i++) {
                var isCulled = !1;
                switch (this._validLights[i].type) {
                  case LightType.DIRECTIONAL:
                    this._validLights[i], isCulled = !1;
                    break;

                  case LightType.SPHERE:
                    isCulled = cullSphereLight(this._validLights[i], model);
                    break;

                  case LightType.SPOT:
                    isCulled = cullSpotLight(this._validLights[i], model);
                }
                isCulled || (_tempLightIndex.push(i), this._validLights[i].type === LightType.DIRECTIONAL ? _tempLightDist[i] = 0 : _tempLightDist[i] = Vec3.distance(this._validLights[i].position, model.node.getWorldPosition(_tempVec3)));
            }
            _tempLightIndex.sort(this.sortLight), (_this$_lightIndices = this._lightIndices).push.apply(_this$_lightIndices, _tempLightIndex);
        }
    }, {
        key: "sortLight",
        value: function sortLight(a, b) {
            return _tempLightDist[a] - _tempLightDist[b];
        }
    } ]), ForwardPipeline;
}();

!function(RenderViewPriority) {
    RenderViewPriority[RenderViewPriority.GENERAL = 100] = "GENERAL";
}(RenderViewPriority || (RenderViewPriority = {}));

var CameraProjection, CameraAperture, CameraISO, CameraShutter, RenderView = function() {
    function RenderView(root, camera) {
        _classCallCheck(this, RenderView), this._root = void 0, this._name = "", this._window = null, 
        this._priority = 0, this._visibility = 0, this._camera = void 0, this._isEnable = !0, 
        this._isUI = !1, this._flows = [], this._root = root, this._camera = camera;
    }
    return _createClass(RenderView, [ {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "window",
        get: function get() {
            return this._window;
        },
        set: function set(val) {
            this._window = val;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(val) {
            this._priority = val, this.isUI && (this._priority |= 1 << 30);
        }
    }, {
        key: "visibility",
        set: function set(vis) {
            this._visibility = vis;
        },
        get: function get() {
            return this._visibility;
        }
    }, {
        key: "camera",
        get: function get() {
            return this._camera;
        }
    }, {
        key: "isEnable",
        get: function get() {
            return this._isEnable;
        }
    }, {
        key: "isUI",
        get: function get() {
            return this._isUI;
        }
    }, {
        key: "flows",
        get: function get() {
            return this._flows;
        }
    } ], [ {
        key: "registerCreateFunc",
        value: function registerCreateFunc(root) {
            root._createViewFun = function(_root, _camera) {
                return new RenderView(_root, _camera);
            };
        }
    } ]), _createClass(RenderView, [ {
        key: "initialize",
        value: function initialize(info) {
            this._name = info.name, this._isUI = info.isUI, this.priority = info.priority, info.flows || (info.flows = [ "ForwardFlow", "ToneMapFlow", "SMAAFlow" ]);
            var _iterator = cc.director.root.pipeline.flows, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var f = _ref;
                -1 !== info.flows.indexOf(f.name) && this.flows.push(f);
            }
            return !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._window = null, this._priority = 0;
        }
    }, {
        key: "enable",
        value: function enable(isEnable) {
            this._isEnable = isEnable;
        }
    } ]), RenderView;
}();

!function(CameraProjection) {
    CameraProjection[CameraProjection.ORTHO = 0] = "ORTHO", CameraProjection[CameraProjection.PERSPECTIVE = 1] = "PERSPECTIVE";
}(CameraProjection || (CameraProjection = {})), function(CameraAperture) {
    CameraAperture[CameraAperture.F1_8 = 0] = "F1_8", CameraAperture[CameraAperture.F2_0 = 1] = "F2_0", 
    CameraAperture[CameraAperture.F2_2 = 2] = "F2_2", CameraAperture[CameraAperture.F2_5 = 3] = "F2_5", 
    CameraAperture[CameraAperture.F2_8 = 4] = "F2_8", CameraAperture[CameraAperture.F3_2 = 5] = "F3_2", 
    CameraAperture[CameraAperture.F3_5 = 6] = "F3_5", CameraAperture[CameraAperture.F4_0 = 7] = "F4_0", 
    CameraAperture[CameraAperture.F4_5 = 8] = "F4_5", CameraAperture[CameraAperture.F5_0 = 9] = "F5_0", 
    CameraAperture[CameraAperture.F5_6 = 10] = "F5_6", CameraAperture[CameraAperture.F6_3 = 11] = "F6_3", 
    CameraAperture[CameraAperture.F7_1 = 12] = "F7_1", CameraAperture[CameraAperture.F8_0 = 13] = "F8_0", 
    CameraAperture[CameraAperture.F9_0 = 14] = "F9_0", CameraAperture[CameraAperture.F10_0 = 15] = "F10_0", 
    CameraAperture[CameraAperture.F11_0 = 16] = "F11_0", CameraAperture[CameraAperture.F13_0 = 17] = "F13_0", 
    CameraAperture[CameraAperture.F14_0 = 18] = "F14_0", CameraAperture[CameraAperture.F16_0 = 19] = "F16_0", 
    CameraAperture[CameraAperture.F18_0 = 20] = "F18_0", CameraAperture[CameraAperture.F20_0 = 21] = "F20_0", 
    CameraAperture[CameraAperture.F22_0 = 22] = "F22_0";
}(CameraAperture || (CameraAperture = {})), function(CameraISO) {
    CameraISO[CameraISO.ISO100 = 0] = "ISO100", CameraISO[CameraISO.ISO200 = 1] = "ISO200", 
    CameraISO[CameraISO.ISO400 = 2] = "ISO400", CameraISO[CameraISO.ISO800 = 3] = "ISO800";
}(CameraISO || (CameraISO = {})), function(CameraShutter) {
    CameraShutter[CameraShutter.D1 = 0] = "D1", CameraShutter[CameraShutter.D2 = 1] = "D2", 
    CameraShutter[CameraShutter.D4 = 2] = "D4", CameraShutter[CameraShutter.D8 = 3] = "D8", 
    CameraShutter[CameraShutter.D15 = 4] = "D15", CameraShutter[CameraShutter.D30 = 5] = "D30", 
    CameraShutter[CameraShutter.D60 = 6] = "D60", CameraShutter[CameraShutter.D125 = 7] = "D125", 
    CameraShutter[CameraShutter.D250 = 8] = "D250", CameraShutter[CameraShutter.D500 = 9] = "D500", 
    CameraShutter[CameraShutter.D1000 = 10] = "D1000", CameraShutter[CameraShutter.D2000 = 11] = "D2000", 
    CameraShutter[CameraShutter.D4000 = 12] = "D4000";
}(CameraShutter || (CameraShutter = {}));

var FSTOPS = [ 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22 ], SHUTERS = [ 1, .5, .25, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 25e-5 ], ISOS = [ 100, 200, 400, 800 ], v_a = cc.v3(), v_b = cc.v3(), _tempMat1 = cc.mat4(), _tempMat2 = cc.mat4(), Camera = function() {
    function Camera(scene, info) {
        _classCallCheck(this, Camera), this._scene = void 0, this._name = void 0, this._enabled = !1, 
        this._proj = void 0, this._isWindowSize = !0, this._width = void 0, this._height = void 0, 
        this._screenScale = void 0, this._aspect = void 0, this._orthoHeight = 10, this._fov = toRadian(45), 
        this._nearClip = 1, this._farClip = 1e3, this._clearStencil = 0, this._clearDepth = 1, 
        this._clearFlag = GFXClearFlag.NONE, this._clearColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }, this._viewport = new Rect(0, 0, 1, 1), this._isProjDirty = !0, this._matView = new Mat4(), 
        this._matProj = new Mat4(), this._matViewProj = new Mat4(), this._matViewProjInv = new Mat4(), 
        this._frustum = new frustum(), this._forward = new Vec3(), this._position = new Vec3(), 
        this._node = null, this._view = void 0, this._visibility = 0, this._priority = 0, 
        this._aperture = CameraAperture.F16_0, this._apertureValue = void 0, this._shutter = CameraShutter.D125, 
        this._shutterValue = 0, this._iso = CameraISO.ISO100, this._isoValue = 0, this._ec = 0, 
        this._exposure = 0, this._scene = scene, this._name = info.name, this._node = info.node, 
        this._proj = info.projection, this._priority = info.priority || 0, this._apertureValue = FSTOPS[this._aperture], 
        this._shutterValue = SHUTERS[this._shutter], this._isoValue = ISOS[this._iso], this.updateExposure(), 
        this._aspect = this._width = this._height = this._screenScale = 1;
        var isUI = void 0 !== info.isUI && info.isUI;
        this._view = this._scene.root.createView({
            camera: this,
            name: this._name,
            priority: this._priority,
            isUI: isUI,
            flows: info.flows
        }), this.changeTargetWindow(info.window), console.log("Create Camera: " + this._name + " " + this._width + " x " + this._height);
    }
    return _createClass(Camera, [ {
        key: "destroy",
        value: function destroy() {
            this._scene.root.destroyView(this._view);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width = width, this._height = height, this._aspect = this._width / this._height, 
            this._isProjDirty = !0;
        }
    }, {
        key: "setFixedSize",
        value: function setFixedSize(width, height) {
            this._width = width, this._height = height, this._aspect = this._width / this._height, 
            this._isWindowSize = !1;
        }
    }, {
        key: "update",
        value: function update() {
            var forceUpdate = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (this._node) {
                if ((this._node.hasChangedFlags || forceUpdate) && (Mat4.invert(this._matView, this.node.worldMatrix), 
                this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, 
                this._node.getWorldPosition(this._position)), this._isProjDirty) if (this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip); else {
                    var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                    Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip);
                }
                (this._node.hasChangedFlags || this._isProjDirty || forceUpdate) && (Mat4.multiply(this._matViewProj, this._matProj, this._matView), 
                Mat4.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv)), 
                this._isProjDirty = !1;
            }
        }
    }, {
        key: "getSplitFrustum",
        value: function getSplitFrustum(out, nearClip, farClip) {
            if (this._node) {
                if (nearClip = Math.max(nearClip, this._nearClip), farClip = Math.min(farClip, this._farClip), 
                Mat4.invert(this._matView, this.node.worldMatrix), this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(_tempMat1, this._fov, this._aspect, nearClip, farClip); else {
                    var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                    Mat4.ortho(_tempMat1, -x, x, -y, y, nearClip, farClip);
                }
                Mat4.multiply(_tempMat2, _tempMat1, this._matView), Mat4.invert(_tempMat1, _tempMat2), 
                out.update(_tempMat2, _tempMat1);
            }
        }
    }, {
        key: "changeTargetWindow",
        value: function changeTargetWindow() {
            var window = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, scene = this._scene, win = window || scene.root.mainWindow;
            win && (this._width = win.width, this._height = win.height, this._view.window = win), 
            this._aspect = this._width / this._height;
        }
    }, {
        key: "screenPointToRay",
        value: function screenPointToRay(out, x, y) {
            var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
            return Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1), Vec3.transformMat4(v_a, v_a, this._matViewProjInv), 
            this._proj === CameraProjection.PERSPECTIVE ? this._node && this._node.getWorldPosition(v_b) : (Vec3.set(v_b, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1), 
            Vec3.transformMat4(v_b, v_b, this._matViewProjInv)), ray.fromPoints(out, v_b, v_a);
        }
    }, {
        key: "screenToWorld",
        value: function screenToWorld(out, screenPos) {
            var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
            return this._proj === CameraProjection.PERSPECTIVE ? (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1), 
            Vec3.transformMat4(out, out, this._matViewProjInv), this._node && this._node.getWorldPosition(v_a), 
            Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z))) : (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 2 * screenPos.z - 1), 
            Vec3.transformMat4(out, out, this.matViewProjInv)), out;
        }
    }, {
        key: "worldToScreen",
        value: function worldToScreen(out, worldPos) {
            var cx = this._viewport.x * this._width, cy = this._viewport.y * this._height, cw = this._viewport.width * this._width, ch = this._viewport.height * this._height;
            return Vec3.transformMat4(out, worldPos, this.matViewProj), out.x = cx + .5 * (out.x + 1) * cw, 
            out.y = cy + .5 * (out.y + 1) * ch, out.z = .5 * out.z + .5, out;
        }
    }, {
        key: "updateExposure",
        value: function updateExposure() {
            var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
            this._exposure = .833333 / Math.pow(2, ev100);
        }
    }, {
        key: "screenScale",
        set: function set(val) {
            this._screenScale = val;
        },
        get: function get() {
            return this._screenScale;
        }
    }, {
        key: "enabled",
        set: function set(val) {
            this._enabled = val, this._view.enable(val);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "view",
        get: function get() {
            return this._view;
        }
    }, {
        key: "node",
        set: function set(val) {
            this._node = val;
        },
        get: function get() {
            return this._node;
        }
    }, {
        key: "isWindowSize",
        get: function get() {
            return this._isWindowSize;
        }
    }, {
        key: "orthoHeight",
        set: function set(val) {
            this._orthoHeight = val, this._isProjDirty = !0;
        },
        get: function get() {
            return this._orthoHeight;
        }
    }, {
        key: "projectionType",
        set: function set(val) {
            this._proj = val, this._isProjDirty = !0;
        },
        get: function get() {
            return this._proj;
        }
    }, {
        key: "viewport",
        set: function set(v) {
            this._viewport = v;
        },
        get: function get() {
            return this._viewport;
        }
    }, {
        key: "fov",
        set: function set(fov) {
            this._fov = fov, this._isProjDirty = !0;
        },
        get: function get() {
            return this._fov;
        }
    }, {
        key: "nearClip",
        set: function set(nearClip) {
            this._nearClip = nearClip, this._isProjDirty = !0;
        },
        get: function get() {
            return this._nearClip;
        }
    }, {
        key: "farClip",
        set: function set(farClip) {
            this._farClip = farClip, this._isProjDirty = !0;
        },
        get: function get() {
            return this._farClip;
        }
    }, {
        key: "clearColor",
        set: function set(val) {
            this._clearColor.r = val.r, this._clearColor.g = val.g, this._clearColor.b = val.b, 
            this._clearColor.a = val.a;
        },
        get: function get() {
            return this._clearColor;
        }
    }, {
        key: "clearDepth",
        set: function set(val) {
            this._clearDepth = val;
        },
        get: function get() {
            return this._clearDepth;
        }
    }, {
        key: "clearStencil",
        set: function set(val) {
            this._clearStencil = val;
        },
        get: function get() {
            return this._clearStencil;
        }
    }, {
        key: "clearFlag",
        set: function set(val) {
            this._clearFlag = val;
        },
        get: function get() {
            return this._clearFlag;
        }
    }, {
        key: "scene",
        get: function get() {
            return this._scene;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "aspect",
        get: function get() {
            return this._aspect;
        }
    }, {
        key: "matView",
        get: function get() {
            return this._matView;
        }
    }, {
        key: "matProj",
        get: function get() {
            return this._matProj;
        }
    }, {
        key: "matViewProj",
        get: function get() {
            return this._matViewProj;
        }
    }, {
        key: "matViewProjInv",
        get: function get() {
            return this._matViewProjInv;
        }
    }, {
        key: "frustum",
        get: function get() {
            return this._frustum;
        }
    }, {
        key: "forward",
        get: function get() {
            return this._forward;
        }
    }, {
        key: "position",
        get: function get() {
            return this._position;
        }
    }, {
        key: "visibility",
        set: function set(vis) {
            this._visibility = vis, this._view.visibility = vis;
        },
        get: function get() {
            return this._visibility;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._view.priority;
        },
        set: function set(val) {
            this._priority = val, this._view.priority = this._priority;
        }
    }, {
        key: "aperture",
        set: function set(val) {
            this._aperture = val, this._apertureValue = FSTOPS[this._aperture], this.updateExposure();
        },
        get: function get() {
            return this._aperture;
        }
    }, {
        key: "apertureValue",
        get: function get() {
            return this._apertureValue;
        }
    }, {
        key: "shutter",
        set: function set(val) {
            this._shutter = val, this._shutterValue = SHUTERS[this._shutter], this.updateExposure();
        },
        get: function get() {
            return this._shutter;
        }
    }, {
        key: "shutterValue",
        get: function get() {
            return this._shutterValue;
        }
    }, {
        key: "iso",
        set: function set(val) {
            this._iso = val, this._isoValue = ISOS[this._iso], this.updateExposure();
        },
        get: function get() {
            return this._iso;
        }
    }, {
        key: "isoValue",
        get: function get() {
            return this._isoValue;
        }
    }, {
        key: "ec",
        set: function set(val) {
            this._ec = val;
        },
        get: function get() {
            return this._ec;
        }
    }, {
        key: "exposure",
        get: function get() {
            return this._exposure;
        }
    } ]), Camera;
}(), _forward = new Vec3(0, 0, -1), _v3$1 = new Vec3(), _qt$1 = new Quat(), DirectionalLight = function(_Light) {
    function DirectionalLight(scene, name, node) {
        var _this;
        return _classCallCheck(this, DirectionalLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).call(this, scene, name, node)))._dir = new Vec3(1, -1, -1), 
        _this._illum = 65e3, _this._type = LightType.DIRECTIONAL, _this;
    }
    return _inherits(DirectionalLight, Light), _createClass(DirectionalLight, [ {
        key: "direction",
        set: function set(dir) {
            this._dir = dir, Vec3.normalize(this._dir, this._dir);
        },
        get: function get() {
            return this._dir;
        }
    }, {
        key: "illuminance",
        set: function set(illum) {
            this._illum = illum;
        },
        get: function get() {
            return this._illum;
        }
    } ]), _createClass(DirectionalLight, [ {
        key: "update",
        value: function update() {
            this._node && (this._dir = Vec3.transformQuat(_v3$1, _forward, this._node.getWorldRotation(_qt$1)), 
            Vec3.normalize(this._dir, this._dir));
        }
    } ]), DirectionalLight;
}(), Customization = function() {
    function Customization(info) {
        _classCallCheck(this, Customization), this._onAttach = void 0, this._onDetach = void 0, 
        this._models = {}, this._onAttach = info.onAttach, this._onDetach = info.onDetach;
    }
    return _createClass(Customization, [ {
        key: "attach",
        value: function attach(model) {
            var models = this._models, id = model.id;
            models[id] ? models[id]++ : (this._onAttach && this._onAttach(model), models[id] = 1);
        }
    }, {
        key: "detach",
        value: function detach(model) {
            var models = this._models, id = model.id;
            !models[id] || --models[id] > 0 || this._onDetach && this._onDetach(model);
        }
    } ]), Customization;
}(), customizationManager = new (function() {
    function CustomizationManager() {
        _classCallCheck(this, CustomizationManager), this._customs = {};
    }
    return _createClass(CustomizationManager, [ {
        key: "register",
        value: function register(name, info) {
            this._customs[name] = new Customization(info);
        }
    }, {
        key: "attach",
        value: function attach(name, model) {
            var cus = this._customs[name];
            cus ? cus.attach(model) : console.warn("no customization named '".concat(name, "'"));
        }
    }, {
        key: "detach",
        value: function detach(name, model) {
            var cus = this._customs[name];
            cus ? cus.detach(model) : console.warn("no customization named '".concat(name, "'"));
        }
    } ]), CustomizationManager;
}())();

cc.customizationManager = customizationManager;

var SubModel = function() {
    function SubModel() {
        _classCallCheck(this, SubModel), this._subMeshObject = void 0, this._inputAssembler = void 0, 
        this._material = void 0, this._cmdBuffers = void 0, this._psos = void 0, this._priority = void 0, 
        this._subMeshObject = null, this._material = null, this._cmdBuffers = new Array(), 
        this._psos = null, this._inputAssembler = null, this._priority = RenderPriority.DEFAULT;
    }
    return _createClass(SubModel, [ {
        key: "initialize",
        value: function initialize(subMesh, mat, psos) {
            this._psos = psos, this.subMeshData = subMesh, this.material = mat;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._inputAssembler && this._inputAssembler.destroy();
            for (var i = 0; i < this.passes.length; i++) this.passes[i].destroyPipelineState(this._psos[i]);
            var _iterator = this._cmdBuffers, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.destroy();
            }
            this._cmdBuffers.splice(0), this._material = null;
        }
    }, {
        key: "updateCommandBuffer",
        value: function updateCommandBuffer() {
            if (this._material) {
                for (var i = 0; i < this._material.passes.length; i++) this._subMeshObject && this._material.passes[i].primitive !== this._subMeshObject.primitiveMode && console.warn("mesh primitive type doesn't match with pass settings"), 
                this.recordCommandBuffer(i);
                for (var _i2 = this._cmdBuffers.length - 1; _i2 >= this._material.passes.length; _i2--) {
                    var cmdBuff = this._cmdBuffers.pop();
                    cmdBuff && cmdBuff.destroy();
                }
            }
        }
    }, {
        key: "recordCommandBuffer",
        value: function recordCommandBuffer(index) {
            var device = cc.director.root.device, pso = this._psos[index];
            if (null == this._cmdBuffers[index]) {
                var cmdBufferInfo = {
                    allocator: device.commandAllocator,
                    type: GFXCommandBufferType.SECONDARY
                };
                this._cmdBuffers[index] = device.createCommandBuffer(cmdBufferInfo);
            } else this._cmdBuffers[index].status === GFXStatus.UNREADY && this._cmdBuffers[index].initialize({
                allocator: device.commandAllocator,
                type: GFXCommandBufferType.SECONDARY
            });
            var inputAssembler = this._inputAssembler, cmdBuff = this._cmdBuffers[index];
            cmdBuff.begin(), cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
            cmdBuff.bindInputAssembler(inputAssembler), cmdBuff.draw(inputAssembler), cmdBuff.end();
        }
    }, {
        key: "priority",
        set: function set(val) {
            this._priority = val;
        },
        get: function get() {
            return this._priority;
        }
    }, {
        key: "subMeshData",
        set: function set(sm) {
            this._inputAssembler && this._inputAssembler.destroy(), this._subMeshObject = sm;
            var iaInfo = {};
            iaInfo.attributes = this._subMeshObject.attributes, iaInfo.vertexBuffers = this._subMeshObject.vertexBuffers, 
            this._subMeshObject.indexBuffer && (iaInfo.indexBuffer = this._subMeshObject.indexBuffer), 
            this._subMeshObject.indirectBuffer && (iaInfo.indirectBuffer = this._subMeshObject.indirectBuffer), 
            this._inputAssembler ? this._inputAssembler.initialize(iaInfo) : this._inputAssembler = cc.director.root.device.createInputAssembler(iaInfo);
        },
        get: function get() {
            return this._subMeshObject;
        }
    }, {
        key: "psos",
        get: function get() {
            return this._psos;
        },
        set: function set(val) {
            this._psos = val;
        }
    }, {
        key: "material",
        set: function set(material) {
            this._material = material, null != material && this.updateCommandBuffer();
        },
        get: function get() {
            return this._material;
        }
    }, {
        key: "inputAssembler",
        get: function get() {
            return this._inputAssembler;
        }
    }, {
        key: "passes",
        get: function get() {
            return this._material.passes;
        }
    }, {
        key: "commandBuffers",
        get: function get() {
            return this._cmdBuffers;
        }
    } ]), SubModel;
}(), m4_1$2 = new Mat4(), _subMeshPool = new Pool$1(function() {
    return new SubModel();
}, 32);

function getUniformBlockSize(block) {
    var size = 0, _iterator = block.members, _isArray = Array.isArray(_iterator), _i = 0;
    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
        var _ref;
        if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
        } else {
            if ((_i = _iterator.next()).done) break;
            _ref = _i.value;
        }
        var mem = _ref;
        size += GFXGetTypeSize(mem.type) * mem.count;
    }
    return size;
}

var Model = function() {
    function Model(scene, node) {
        _classCallCheck(this, Model), this._type = "default", this._device = void 0, this._scene = void 0, 
        this._node = void 0, this._transform = void 0, this._id = void 0, this._enabled = !1, 
        this._viewID = 1, this._cameraID = -1, this._userKey = -1, this._worldBounds = null, 
        this._modelBounds = null, this._subModels = [], this._matPSORecord = void 0, this._matRefCount = void 0, 
        this._uboLocal = void 0, this._localUBO = null, this._localBindings = new Map(), 
        this._inited = !1, this._uboUpdated = !1, this._castShadow = !1, this._transformUpdated = !1, 
        this._device = cc.director.root.device, this._scene = scene, this._id = this._scene.generateModelId(), 
        this._transform = this._node = node, this._matPSORecord = new Map(), this._matRefCount = new Map(), 
        this._uboLocal = new UBOLocal();
    }
    return _createClass(Model, [ {
        key: "scene",
        set: function set(scene) {
            this._scene = scene, this._id = this._scene.generateModelId();
        },
        get: function get() {
            return this._scene;
        }
    }, {
        key: "id",
        get: function get() {
            return this._id;
        }
    }, {
        key: "subModelNum",
        get: function get() {
            return this._subModels.length;
        }
    }, {
        key: "inited",
        get: function get() {
            return this._inited;
        }
    }, {
        key: "enabled",
        set: function set(val) {
            this._enabled = val;
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "node",
        get: function get() {
            return this._node;
        },
        set: function set(node) {
            this._node = node;
        }
    }, {
        key: "transform",
        get: function get() {
            return this._transform;
        },
        set: function set(transform) {
            this._transform = transform;
        }
    }, {
        key: "worldBounds",
        get: function get() {
            return this._worldBounds;
        }
    }, {
        key: "modelBounds",
        get: function get() {
            return this._modelBounds;
        }
    }, {
        key: "viewID",
        get: function get() {
            return this._viewID;
        },
        set: function set(id) {
            this._viewID = id;
        }
    }, {
        key: "userKey",
        set: function set(key) {
            this._userKey = key;
        }
    }, {
        key: "uboLocal",
        get: function get() {
            return this._uboLocal;
        }
    }, {
        key: "localUBO",
        get: function get() {
            return this._localUBO;
        }
    }, {
        key: "localBindings",
        get: function get() {
            return this._localBindings;
        }
    }, {
        key: "castShadow",
        get: function get() {
            return this._castShadow;
        },
        set: function set(val) {
            this._castShadow = val;
        }
    }, {
        key: "UBOUpdated",
        get: function get() {
            return this._uboUpdated;
        }
    } ]), _createClass(Model, [ {
        key: "destroy",
        value: function destroy() {
            var _iterator2 = this._subModels, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var subModel = _ref2;
                subModel.destroy(), _subMeshPool.free(subModel);
            }
            for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                var localBinding = lbResult.value;
                localBinding.buffer && (localBinding.buffer.destroy(), localBinding.buffer = void 0), 
                lbResult = lbIter.next();
            }
            this._localBindings.has(UBOForwardLight.BLOCK.name) && this._localBindings.delete(UBOForwardLight.BLOCK.name), 
            this._worldBounds = null, this._modelBounds = null, this._subModels.splice(0), this._matPSORecord.clear(), 
            this._matRefCount.clear(), this._inited = !1;
        }
    }, {
        key: "getSubModel",
        value: function getSubModel(idx) {
            return this._subModels[idx];
        }
    }, {
        key: "updateTransform",
        value: function updateTransform() {
            var node = this._transform;
            (node._hasChangedFlags || node._dirtyFlags) && (node.updateWorldTransform(), this._transformUpdated = !0, 
            this._modelBounds && this._worldBounds && this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds));
        }
    }, {
        key: "_resetUBOUpdateFlag",
        value: function _resetUBOUpdateFlag() {
            this._uboUpdated = !1;
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs() {
            if (this._uboUpdated) return !1;
            if (this._uboUpdated = !0, this._transformUpdated) {
                var worldMatrix = this._transform._mat;
                Mat4.array(this._uboLocal.view, worldMatrix, UBOLocal.MAT_WORLD_OFFSET), Mat4.inverseTranspose(m4_1$2, worldMatrix), 
                Mat4.array(this._uboLocal.view, m4_1$2, UBOLocal.MAT_WORLD_IT_OFFSET);
                var commonLocal = this._localBindings.get(UBOLocal.BLOCK.name);
                commonLocal && commonLocal.buffer && commonLocal.buffer.update(this._uboLocal.view), 
                this._transformUpdated = !1;
            }
            return this._matPSORecord.forEach(this._updatePass, this), !0;
        }
    }, {
        key: "createBoundingShape",
        value: function createBoundingShape(minPos, maxPos) {
            minPos && maxPos && (this._modelBounds = aabb.fromPoints(aabb.create(), minPos, maxPos), 
            this._worldBounds = aabb.clone(this._modelBounds), this._transform.updateWorldTransform(), 
            this._modelBounds.transform(this._transform._mat, this._transform._pos, this._transform._rot, this._transform._scale, this._worldBounds));
        }
    }, {
        key: "initSubModel",
        value: function initSubModel(idx, subMeshData, mat) {
            if (this.initLocalBindings(mat), null == this._subModels[idx]) this._subModels[idx] = _subMeshPool.alloc(); else {
                var oldMat = this._subModels[idx].material;
                this._subModels[idx].destroy(), this.releasePSO(oldMat);
            }
            this.allocatePSO(mat), this._subModels[idx].initialize(subMeshData, mat, this._matPSORecord.get(mat)), 
            this._inited = !0;
        }
    }, {
        key: "setSubModelMesh",
        value: function setSubModelMesh(idx, subMeshData) {
            null == this._subModels[idx] && (this._subModels[idx] = _subMeshPool.alloc()), this._subModels[idx].subMeshData = subMeshData;
        }
    }, {
        key: "setSubModelMaterial",
        value: function setSubModelMaterial(idx, mat) {
            null != this._subModels[idx] && (this.initLocalBindings(mat), this._subModels[idx].material === mat ? mat && (this.destroyPipelineState(mat, this._matPSORecord.get(mat)), 
            this._matPSORecord.set(mat, this.createPipelineState(mat))) : (this._subModels[idx].material && this.releasePSO(this._subModels[idx].material), 
            mat && this.allocatePSO(mat)), this._subModels[idx].psos = mat && this._matPSORecord.get(mat) || null, 
            this._subModels[idx].material = mat);
        }
    }, {
        key: "onPipelineChange",
        value: function onPipelineChange() {
            var _iterator3 = this._subModels, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                for (var m = _ref3, mat = m.material, psos = this._matPSORecord.get(mat), i = 0; i < mat.passes.length; i++) {
                    var pass = mat.passes[i];
                    pass.tryCompile(), pass.destroyPipelineState(psos[i]), psos[i] = this._doCreatePSO(pass), 
                    psos[i].pipelineLayout.layouts[0].update();
                }
                m.updateCommandBuffer();
            }
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(mat) {
            for (var ret = new Array(mat.passes.length), i = 0; i < ret.length; i++) {
                var pass = mat.passes[i], _iterator4 = pass.customizations, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var cus = _ref4;
                    customizationManager.attach(cus, this);
                }
                ret[i] = this._doCreatePSO(pass);
            }
            return ret;
        }
    }, {
        key: "destroyPipelineState",
        value: function destroyPipelineState(mat, pso) {
            for (var i = 0; i < mat.passes.length; i++) {
                var pass = mat.passes[i];
                pass.destroyPipelineState(pso[i]);
                var _iterator5 = pass.customizations, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i5 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i5++];
                    } else {
                        if ((_i5 = _iterator5.next()).done) break;
                        _ref5 = _i5.value;
                    }
                    var cus = _ref5;
                    customizationManager.detach(cus, this);
                }
            }
        }
    }, {
        key: "_doCreatePSO",
        value: function _doCreatePSO(pass) {
            var pso = pass.createPipelineState();
            return pso.pipelineLayout.layouts[0].bindBuffer(UBOLocal.BLOCK.binding, this._localBindings.get(UBOLocal.BLOCK.name).buffer), 
            this._localBindings.has(UBOForwardLight.BLOCK.name) && pso.pipelineLayout.layouts[0].bindBuffer(UBOForwardLight.BLOCK.binding, this._localBindings.get(UBOForwardLight.BLOCK.name).buffer), 
            pso;
        }
    }, {
        key: "onSetLocalBindings",
        value: function onSetLocalBindings(mat) {
            this._localBindings.has(UBOLocal.BLOCK.name) || this._localBindings.set(UBOLocal.BLOCK.name, {
                type: GFXBindingType.UNIFORM_BUFFER,
                blockInfo: UBOLocal.BLOCK
            });
            var hasForwardLight = !1, _iterator6 = mat.passes, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    if ((_i6 = _iterator6.next()).done) break;
                    _ref6 = _i6.value;
                }
                if (_ref6.bindings.find(function(b) {
                    return b.name === UBOForwardLight.BLOCK.name;
                })) {
                    hasForwardLight = !0;
                    break;
                }
            }
            hasForwardLight && "ForwardPipeline" === cc.director.root.pipeline.name && (this._localBindings.has(UBOForwardLight.BLOCK.name) || this._localBindings.set(UBOForwardLight.BLOCK.name, {
                type: GFXBindingType.UNIFORM_BUFFER,
                blockInfo: UBOForwardLight.BLOCK
            }));
        }
    }, {
        key: "initLocalBindings",
        value: function initLocalBindings(mat) {
            if (mat) {
                this.onSetLocalBindings(mat);
                for (var lbIter = this._localBindings.values(), lbResult = lbIter.next(); !lbResult.done; ) {
                    var localBinding = lbResult.value;
                    localBinding.buffer || (localBinding.buffer = this._device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: getUniformBlockSize(localBinding.blockInfo)
                    })), lbResult = lbIter.next();
                }
            }
        }
    }, {
        key: "_updatePass",
        value: function _updatePass(psos, mat) {
            for (var i = 0; i < mat.passes.length; i++) mat.passes[i].update();
            for (var _i7 = 0; _i7 < psos.length; _i7++) psos[_i7].pipelineLayout.layouts[0].update();
        }
    }, {
        key: "allocatePSO",
        value: function allocatePSO(mat) {
            null == this._matRefCount.get(mat) ? (this._matRefCount.set(mat, 1), this._matPSORecord.set(mat, this.createPipelineState(mat))) : this._matRefCount.set(mat, this._matRefCount.get(mat) + 1);
        }
    }, {
        key: "releasePSO",
        value: function releasePSO(mat) {
            this._matRefCount.set(mat, this._matRefCount.get(mat) - 1), 0 === this._matRefCount.get(mat) && (this.destroyPipelineState(mat, this._matPSORecord.get(mat)), 
            this._matPSORecord.delete(mat), this._matRefCount.delete(mat));
        }
    } ]), Model;
}(), SkinningModel = function(_Model) {
    function SkinningModel(scene, node) {
        var _this;
        _classCallCheck(this, SkinningModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModel).call(this, scene, node))).uploadedAnim = null, 
        _this._jointsMedium = void 0, _this._skeleton = null, _this._type = "skinning";
        var jointsTextureInfo = new Float32Array(4), texture = _this._scene.texturePool.getDefaultJointsTexture();
        return _this._jointsMedium = {
            buffer: null,
            jointsTextureInfo: jointsTextureInfo,
            texture: texture
        }, _this;
    }
    return _inherits(SkinningModel, Model), _createClass(SkinningModel, [ {
        key: "worldBounds",
        get: function get() {
            return this.uploadedAnim ? null : this._worldBounds;
        }
    } ]), _createClass(SkinningModel, [ {
        key: "destroy",
        value: function destroy() {
            _get(_getPrototypeOf(SkinningModel.prototype), "destroy", this).call(this), this._jointsMedium.buffer && (this._jointsMedium.buffer.destroy(), 
            this._jointsMedium.buffer = null);
        }
    }, {
        key: "bindSkeleton",
        value: function bindSkeleton(skeleton, skinningRoot) {
            if (this._skeleton = skeleton, skeleton && skinningRoot) {
                this._transform = skinningRoot, this._jointsMedium.buffer || (this._jointsMedium.buffer = this._device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOSkinningTexture.SIZE,
                    stride: UBOSkinningTexture.SIZE
                }));
                var texture = this.uploadedAnim ? this._scene.texturePool.getJointsTextureWithAnimation(skeleton, this.uploadedAnim) : this._scene.texturePool.getDefaultJointsTexture(skeleton);
                this._applyJointsTexture(texture);
            }
        }
    }, {
        key: "uploadAnimation",
        value: function uploadAnimation(anim) {
            this._skeleton && (this.uploadedAnim = anim, this._applyJointsTexture(this._scene.texturePool.getJointsTextureWithAnimation(this._skeleton, anim)));
        }
    }, {
        key: "setFrameID",
        value: function setFrameID(val) {
            var _this$_jointsMedium = this._jointsMedium, buffer = _this$_jointsMedium.buffer, jointsTextureInfo = _this$_jointsMedium.jointsTextureInfo;
            jointsTextureInfo[3] = val, buffer.update(jointsTextureInfo);
        }
    }, {
        key: "getFrameID",
        value: function getFrameID() {
            return this._jointsMedium.jointsTextureInfo[3];
        }
    }, {
        key: "_applyJointsTexture",
        value: function _applyJointsTexture(texture) {
            if (texture) {
                this._jointsMedium.texture = texture;
                var _this$_jointsMedium2 = this._jointsMedium, buffer = _this$_jointsMedium2.buffer, jointsTextureInfo = _this$_jointsMedium2.jointsTextureInfo;
                jointsTextureInfo[0] = texture.handle.texture.width, jointsTextureInfo[1] = texture.pixelOffset + .1, 
                jointsTextureInfo[2] = this.uploadedAnim ? this.uploadedAnim.keys[0].length : 1, 
                jointsTextureInfo[3] = 0, buffer && buffer.update(jointsTextureInfo);
                var sampler = getJointsTextureSampler(this._device), _iterator = this._subModels, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var submodel = _ref;
                    if (submodel.psos) {
                        var _iterator2 = submodel.psos, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref2 = _i2.value;
                            }
                            var pso = _ref2;
                            pso.pipelineLayout.layouts[0].bindTextureView(UNIFORM_JOINTS_TEXTURE.binding, texture.handle.texView), 
                            pso.pipelineLayout.layouts[0].bindSampler(UNIFORM_JOINTS_TEXTURE.binding, sampler);
                        }
                    }
                }
            }
        }
    }, {
        key: "_doCreatePSO",
        value: function _doCreatePSO(pass) {
            var pso = _get(_getPrototypeOf(SkinningModel.prototype), "_doCreatePSO", this).call(this, pass), _this$_jointsMedium3 = this._jointsMedium, buffer = _this$_jointsMedium3.buffer, texture = _this$_jointsMedium3.texture;
            pso.pipelineLayout.layouts[0].bindBuffer(UBOSkinningTexture.BLOCK.binding, buffer);
            var sampler = getJointsTextureSampler(this._device);
            return texture && (pso.pipelineLayout.layouts[0].bindTextureView(UNIFORM_JOINTS_TEXTURE.binding, texture.handle.texView), 
            pso.pipelineLayout.layouts[0].bindSampler(UNIFORM_JOINTS_TEXTURE.binding, sampler)), 
            pso;
        }
    } ]), SkinningModel;
}(), _forward$1 = new Vec3(0, 0, -1), _v3$2 = new Vec3(), _qt$2 = new Quat(), PlanarShadows = function() {
    function PlanarShadows(scene) {
        _classCallCheck(this, PlanarShadows), this._scene = void 0, this._enabled = !1, 
        this._normal = new Vec3(0, 1, 0), this._distance = 0, this._matLight = new Mat4(), 
        this._data = Float32Array.from([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, .3 ]), 
        this._globalBindings = void 0, this._cmdBuffs = void 0, this._cmdBuffCount = 0, 
        this._psoRecord = new Map(), this._cbRecord = new Map(), this._passNormal = void 0, 
        this._passSkinning = void 0, this._scene = scene, this._globalBindings = scene.root.pipeline.globalBindings.get(UBOShadow.BLOCK.name), 
        this._cmdBuffs = new CachedArray(64);
        var effectAsset = EffectAsset.get("pipeline/planar-shadow"), defines = {
            CC_USE_SKINNING: selectJointsMediumType(scene.root.device)
        };
        this._passNormal = Pass.createPasses(effectAsset, {
            techIdx: 0,
            defines: [],
            states: []
        })[0], this._passSkinning = Pass.createPasses(effectAsset, {
            techIdx: 0,
            defines: [ defines ],
            states: []
        })[0];
    }
    return _createClass(PlanarShadows, [ {
        key: "enabled",
        set: function set(enable) {
            this._enabled = enable, this.updateDirLight(), this._cmdBuffs.clear();
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "normal",
        set: function set(val) {
            Vec3.copy(this._normal, val), this.updateDirLight();
        },
        get: function get() {
            return this._normal;
        }
    }, {
        key: "distance",
        set: function set(val) {
            this._distance = val, this.updateDirLight();
        },
        get: function get() {
            return this._distance;
        }
    }, {
        key: "shadowColor",
        set: function set(color) {
            Color.array(this._data, color, UBOShadow.SHADOW_COLOR_OFFSET), this._globalBindings.buffer.update(this.data);
        }
    }, {
        key: "matLight",
        get: function get() {
            return this._matLight;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    }, {
        key: "cmdBuffs",
        get: function get() {
            return this._cmdBuffs;
        }
    }, {
        key: "cmdBuffCount",
        get: function get() {
            return this._cmdBuffs.length;
        }
    } ]), _createClass(PlanarShadows, [ {
        key: "updateSphereLight",
        value: function updateSphereLight(light) {
            light.node.getWorldPosition(_v3$2);
            var n = this._normal, d = this._distance, NdL = Vec3.dot(n, _v3$2), lx = _v3$2.x, ly = _v3$2.y, lz = _v3$2.z, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
            m.m00 = NdL - d - lx * nx, m.m01 = -ly * nx, m.m02 = -lz * nx, m.m03 = -nx, m.m04 = -lx * ny, 
            m.m05 = NdL - d - ly * ny, m.m06 = -lz * ny, m.m07 = -ny, m.m08 = -lx * nz, m.m09 = -ly * nz, 
            m.m10 = NdL - d - lz * nz, m.m11 = -nz, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
            m.m15 = NdL, Mat4.array(this.data, this._matLight), this._globalBindings.buffer.update(this.data);
        }
    }, {
        key: "updateDirLight",
        value: function updateDirLight() {
            var light = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._scene.mainLight;
            light.node.getWorldRotation(_qt$2), Vec3.transformQuat(_v3$2, _forward$1, _qt$2);
            var n = this._normal, d = this._distance, NdL = Vec3.dot(n, _v3$2), scale = 1 / NdL, lx = _v3$2.x * scale, ly = _v3$2.y * scale, lz = _v3$2.z * scale, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
            m.m00 = 1 - nx * lx, m.m01 = -nx * ly, m.m02 = -nx * lz, m.m03 = 0, m.m04 = -ny * lx, 
            m.m05 = 1 - ny * ly, m.m06 = -ny * lz, m.m07 = 0, m.m08 = -nz * lx, m.m09 = -nz * ly, 
            m.m10 = 1 - nz * lz, m.m11 = 0, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
            m.m15 = 1, Mat4.array(this.data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET), 
            this._globalBindings.buffer.update(this.data);
        }
    }, {
        key: "updateCommandBuffers",
        value: function updateCommandBuffers() {
            if (this._cmdBuffs.clear(), this._scene.mainLight.enabled) {
                var _iterator = this._scene.models, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var model = _ref;
                    if (model.enabled && model.node && model.castShadow) {
                        var pso = this._psoRecord.get(model);
                        pso || (pso = this._createPSO(model), this._psoRecord.set(model, pso)), model.UBOUpdated || model.updateUBOs();
                        for (var i = 0; i < model.subModelNum; i++) {
                            var ia = model.getSubModel(i).inputAssembler;
                            if (ia) {
                                var cb = this._cbRecord.get(ia);
                                cb || ((cb = this._createCommandBuffer()).begin(), cb.bindPipelineState(pso), cb.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                                cb.bindInputAssembler(ia), cb.draw(ia), cb.end(), this._cbRecord.set(ia, cb)), this.cmdBuffs.push(cb);
                            }
                        }
                    }
                }
            }
        }
    }, {
        key: "onPipelineChange",
        value: function onPipelineChange() {
            for (var cbs = this._cbRecord.values(), cbRes = cbs.next(); !cbRes.done; ) cbRes.value.destroy(), 
            cbRes = cbs.next();
            this._cbRecord.clear();
            for (var models = this._psoRecord.keys(), modelRes = models.next(); !modelRes.done; ) {
                (modelRes.value instanceof SkinningModel ? this._passSkinning : this._passNormal).destroyPipelineState(this._psoRecord.get(modelRes.value)), 
                modelRes = models.next();
            }
            this._psoRecord.clear();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.onPipelineChange(), this._passNormal.destroy(), this._passSkinning.destroy();
        }
    }, {
        key: "_createPSO",
        value: function _createPSO(model) {
            var pass = model instanceof SkinningModel ? this._passSkinning : this._passNormal, pso = model._doCreatePSO(pass);
            return pso.pipelineLayout.layouts[0].update(), pso;
        }
    }, {
        key: "_createCommandBuffer",
        value: function _createCommandBuffer() {
            var device = this._scene.root.device;
            return device.createCommandBuffer({
                allocator: device.commandAllocator,
                type: GFXCommandBufferType.SECONDARY
            });
        }
    } ]), PlanarShadows;
}();

function applyDefaultGeometryOptions(options) {
    return void 0 === (options = options || {}).includeNormal && (options.includeNormal = !0), 
    void 0 === options.includeUV && (options.includeUV = !0), options;
}

function box(options) {
    var ws = (options = options || {}).widthSegments || 1, hs = options.heightSegments || 1, ls = options.lengthSegments || 1, hw = (options.width || 1) / 2, hh = (options.height || 1) / 2, hl = (options.length || 1) / 2, corners = [ Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl) ], faceAxes = [ [ 2, 3, 1 ], [ 4, 5, 7 ], [ 7, 6, 2 ], [ 1, 0, 4 ], [ 1, 4, 2 ], [ 5, 0, 6 ] ], faceNormals = [ [ 0, 0, 1 ], [ 0, 0, -1 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 1, 0, 0 ], [ -1, 0, 0 ] ], positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-hw, -hh, -hl), maxPos = new Vec3(hw, hh, hl), boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
    function _buildPlane(side, uSegments, vSegments) {
        var u, v, ix, iy, offset = positions.length / 3, faceAxe = faceAxes[side], faceNormal = faceNormals[side];
        for (iy = 0; iy <= vSegments; iy++) for (ix = 0; ix <= uSegments; ix++) if (u = ix / uSegments, 
        v = iy / vSegments, Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u), 
        Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v), Vec3.subtract(temp3, temp2, corners[faceAxe[0]]), 
        Vec3.add(r, temp1, temp3), positions.push(r.x, r.y, r.z), normals.push(faceNormal[0], faceNormal[1], faceNormal[2]), 
        uvs.push(u, v), ix < uSegments && iy < vSegments) {
            var useg1 = uSegments + 1, a = ix + iy * useg1, b = ix + (iy + 1) * useg1, c = ix + 1 + (iy + 1) * useg1, d = ix + 1 + iy * useg1;
            indices.push(offset + a, offset + d, offset + b), indices.push(offset + b, offset + d, offset + c);
        }
    }
    return _buildPlane(0, ws, hs), _buildPlane(4, ls, hs), _buildPlane(1, ws, hs), _buildPlane(5, ls, hs), 
    _buildPlane(3, ws, ls), _buildPlane(2, ws, ls), {
        positions: positions,
        normals: normals,
        uvs: uvs,
        indices: indices,
        minPos: minPos,
        maxPos: maxPos,
        boundingRadius: boundingRadius
    };
}

var temp1 = new Vec3(), temp2 = new Vec3(), temp3 = new Vec3(), r = new Vec3(), c0 = new Vec3(), c1 = new Vec3(), c2 = new Vec3(), c3 = new Vec3(), c4 = new Vec3(), c5 = new Vec3(), c6 = new Vec3(), c7 = new Vec3(), temp1$1 = new Vec3(0, 0, 0), temp2$1 = new Vec3(0, 0, 0);

function cylinder() {
    var radiusTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, height = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, halfHeight = .5 * height, radialSegments = opts.radialSegments || 32, heightSegments = opts.heightSegments || 1, capped = void 0 === opts.capped || opts.capped, arc = opts.arc || 2 * Math.PI, cntCap = 0;
    capped || (radiusTop > 0 && cntCap++, radiusBottom > 0 && cntCap++);
    var vertCount = (radialSegments + 1) * (heightSegments + 1);
    capped && (vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap);
    var indexCount = radialSegments * heightSegments * 2 * 3;
    capped && (indexCount += radialSegments * cntCap * 3);
    var indices = new Array(indexCount), positions = new Array(3 * vertCount), normals = new Array(3 * vertCount), uvs = new Array(2 * vertCount), maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius), maxPos = new Vec3(maxRadius, halfHeight, maxRadius), boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight), index = 0, indexOffset = 0;
    return function generateTorso() {
        for (var indexArray = [], r = radiusTop - radiusBottom, slope = r * r / height * Math.sign(r), y = 0; y <= heightSegments; y++) {
            for (var indexRow = [], v = y / heightSegments, radius = v * r + radiusBottom, x = 0; x <= radialSegments; ++x) {
                var u = x / radialSegments, theta = u * arc, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = v * height - halfHeight, 
                positions[3 * index + 2] = radius * cosTheta, Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta)), 
                normals[3 * index] = temp1$1.x, normals[3 * index + 1] = temp1$1.y, normals[3 * index + 2] = temp1$1.z, 
                uvs[2 * index] = 2 * (1 - u) % 1, uvs[2 * index + 1] = v, indexRow.push(index), 
                ++index;
            }
            indexArray.push(indexRow);
        }
        for (var _y = 0; _y < heightSegments; ++_y) for (var _x = 0; _x < radialSegments; ++_x) {
            var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
            indices[indexOffset] = i1, indices[++indexOffset] = i4, indices[++indexOffset] = i2, 
            indices[++indexOffset] = i4, indices[++indexOffset] = i3, indices[++indexOffset] = i2, 
            ++indexOffset;
        }
    }(), capped && (radiusBottom > 0 && generateCap(!1), radiusTop > 0 && generateCap(!0)), 
    {
        positions: positions,
        normals: normals,
        uvs: uvs,
        indices: indices,
        minPos: minPos,
        maxPos: maxPos,
        boundingRadius: boundingRadius
    };
    function generateCap(top) {
        for (var radius = top ? radiusTop : radiusBottom, sign = top ? 1 : -1, centerIndexStart = index, x = 1; x <= radialSegments; ++x) positions[3 * index] = 0, 
        positions[3 * index + 1] = halfHeight * sign, positions[3 * index + 2] = 0, normals[3 * index] = 0, 
        normals[3 * index + 1] = sign, normals[3 * index + 2] = 0, uvs[2 * index] = .5, 
        uvs[2 * index + 1] = .5, ++index;
        for (var centerIndexEnd = index, _x2 = 0; _x2 <= radialSegments; ++_x2) {
            var theta = _x2 / radialSegments * arc, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = halfHeight * sign, 
            positions[3 * index + 2] = radius * cosTheta, normals[3 * index] = 0, normals[3 * index + 1] = sign, 
            normals[3 * index + 2] = 0, uvs[2 * index] = .5 - .5 * sinTheta * sign, uvs[2 * index + 1] = .5 + .5 * cosTheta, 
            ++index;
        }
        for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
            var c = centerIndexStart + _x3, i = centerIndexEnd + _x3;
            top ? (indices[indexOffset] = i + 1, indices[++indexOffset] = c, indices[++indexOffset] = i, 
            ++indexOffset) : (indices[indexOffset] = c, indices[++indexOffset] = i + 1, indices[++indexOffset] = i, 
            ++indexOffset);
        }
    }
}

var temp1$2 = new Vec3(0, 0, 0), temp2$2 = new Vec3(0, 0, 0), temp3$1 = new Vec3(0, 0, 0), r$1 = new Vec3(0, 0, 0), c00 = new Vec3(0, 0, 0), c10 = new Vec3(0, 0, 0), c01 = new Vec3(0, 0, 0);

var temp1$3 = new Vec3(0, 0, 0), temp2$3 = new Vec3(0, 0, 0);

var _dec$F, _dec2$l, _dec3$a, _dec4$7, _dec5$7, _dec6$6, _dec7$4, _dec8$2, _dec9$1, _class$F, _class2$y, _descriptor$w, _descriptor2$n, _descriptor3$d, _descriptor4$a, _descriptor5$8, _descriptor6$3, _descriptor7$3, _descriptor8$3, _descriptor9$3, _class3$f, _temp$A, SpriteType, FillType, SizeMode, primitives = Object.freeze({
    box: box,
    cone: function cone() {
        return cylinder(0, arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {});
    },
    cylinder: cylinder,
    plane: function plane$1(options) {
        var normalizedOptions = function applyDefaultPlaneOptions(options) {
            return (options = applyDefaultGeometryOptions(options)).width = options.width || 10, 
            options.length = options.length || 10, options.widthSegments = options.widthSegments || 10, 
            options.lengthSegments = options.lengthSegments || 10, options;
        }(options), width = normalizedOptions.width, length = normalizedOptions.length, uSegments = normalizedOptions.widthSegments, vSegments = normalizedOptions.lengthSegments, hw = .5 * width, hl = .5 * length, positions = [], uvs = [], indices = [], minPos = new Vec3(-hw, 0, -hl), maxPos = new Vec3(hw, 0, hl), boundingRadius = Math.sqrt(width * width + length * length);
        Vec3.set(c00, -hw, 0, hl), Vec3.set(c10, hw, 0, hl), Vec3.set(c01, -hw, 0, -hl);
        for (var y = 0; y <= vSegments; y++) for (var x = 0; x <= uSegments; x++) {
            var u = x / uSegments, v = y / vSegments;
            if (Vec3.lerp(temp1$2, c00, c10, u), Vec3.lerp(temp2$2, c00, c01, v), Vec3.subtract(temp3$1, temp2$2, c00), 
            Vec3.add(r$1, temp1$2, temp3$1), positions.push(r$1.x, r$1.y, r$1.z), normalizedOptions.includeUV && uvs.push(u, v), 
            x < uSegments && y < vSegments) {
                var useg1 = uSegments + 1, a = x + y * useg1, b = x + (y + 1) * useg1, c = x + 1 + (y + 1) * useg1, d = x + 1 + y * useg1;
                indices.push(a, d, b), indices.push(d, c, b);
            }
        }
        var result = {
            positions: positions,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
        if (normalizedOptions.includeNormal) {
            var nVertex = (vSegments + 1) * (uSegments + 1), normals = new Array(3 * nVertex);
            result.normals = normals;
            for (var i = 0; i < nVertex; ++i) normals[3 * i + 0] = 0, normals[3 * i + 1] = 1, 
            normals[3 * i + 2] = 0;
        }
        return normalizedOptions.includeUV && (result.uvs = uvs), result;
    },
    quad: function quad(options) {
        var normalizedOptions = applyDefaultGeometryOptions(options), result = {
            positions: [ -.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0 ],
            indices: [ 0, 3, 1, 3, 2, 1 ],
            minPos: {
                x: -.5,
                y: -.5,
                z: 0
            },
            maxPos: {
                x: .5,
                y: .5,
                z: 0
            },
            boundingRadius: Math.sqrt(.5)
        };
        return !1 !== normalizedOptions.includeNormal && (result.normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]), 
        !1 !== normalizedOptions.includeUV && (result.uvs = [ 0, 0, 0, 1, 1, 1, 1, 0 ]), 
        result;
    },
    sphere: function sphere$1() {
        for (var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, segments = void 0 !== opts.segments ? opts.segments : 32, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius, -radius, -radius), maxPos = new Vec3(radius, radius, radius), boundingRadius = radius, lat = 0; lat <= segments; ++lat) for (var theta = lat * Math.PI / segments, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= segments; ++lon) {
            var phi = 2 * lon * Math.PI / segments - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / segments, v = lat / segments;
            if (positions.push(x * radius, y * radius, z * radius), normals.push(x, y, z), uvs.push(u, v), 
            lat < segments && lon < segments) {
                var seg1 = segments + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                indices.push(a, d, b), indices.push(d, c, b);
            }
        }
        return {
            positions: positions,
            indices: indices,
            normals: normals,
            uvs: uvs,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    },
    torus: function torus() {
        for (var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .4, tube = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1, opts = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, radialSegments = opts.radialSegments || 32, tubularSegments = opts.tubularSegments || 32, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius - tube, -tube, -radius - tube), maxPos = new Vec3(radius + tube, tube, radius + tube), boundingRadius = radius + tube, j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments, v = j / radialSegments, u1 = u * arc, v1 = v * Math.PI * 2, x = (radius + tube * Math.cos(v1)) * Math.sin(u1), y = tube * Math.sin(v1), z = (radius + tube * Math.cos(v1)) * Math.cos(u1), nx = Math.sin(u1) * Math.cos(v1), ny = Math.sin(v1), nz = Math.cos(u1) * Math.cos(v1);
            if (positions.push(x, y, z), normals.push(nx, ny, nz), uvs.push(u, v), i < tubularSegments && j < radialSegments) {
                var seg1 = tubularSegments + 1, a = seg1 * j + i, b = seg1 * (j + 1) + i, c = seg1 * (j + 1) + i + 1, d = seg1 * j + i + 1;
                indices.push(a, d, b), indices.push(d, c, b);
            }
        }
        return {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    },
    capsule: function capsule() {
        var radiusTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, height = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, torsoHeight = height - radiusTop - radiusBottom, sides = opts.sides || 32, heightSegments = opts.heightSegments || 32, bottomProp = radiusBottom / height, torProp = torsoHeight / height, topProp = radiusTop / height, bottomSegments = Math.floor(heightSegments * bottomProp), topSegments = Math.floor(heightSegments * topProp), torSegments = Math.floor(heightSegments * torProp), topOffset = torsoHeight + radiusBottom - height / 2, torOffset = radiusBottom - height / 2, bottomOffset = radiusBottom - height / 2, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -height / 2, -maxRadius), maxPos = new Vec3(maxRadius, height / 2, maxRadius), boundingRadius = height / 2, index = 0, indexArray = [];
        return function generateBottom() {
            for (var lat = 0; lat <= bottomSegments; ++lat) for (var theta = lat * Math.PI / bottomSegments / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                var phi = 2 * lon * Math.PI / sides - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / sides, v = lat / heightSegments;
                if (positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom), 
                normals.push(x, y, z), uvs.push(u, v), lat < bottomSegments && lon < sides) {
                    var seg1 = sides + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
                ++index;
            }
        }(), function generateTorso() {
            for (var slope = (radiusTop - radiusBottom) / torsoHeight, y = 0; y <= torSegments; y++) {
                for (var indexRow = [], lat = y / torSegments, radius = lat * (radiusTop - radiusBottom) + radiusBottom, x = 0; x <= sides; ++x) {
                    var u = x / sides, v = lat * torProp + bottomProp, theta = u * arc - arc / 4, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    positions.push(radius * sinTheta), positions.push(lat * torsoHeight + torOffset), 
                    positions.push(radius * cosTheta), Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta)), 
                    normals.push(temp1$3.x), normals.push(temp1$3.y), normals.push(temp1$3.z), uvs.push(u, v), 
                    indexRow.push(index), ++index;
                }
                indexArray.push(indexRow);
            }
            for (var _y = 0; _y < torSegments; ++_y) for (var _x = 0; _x < sides; ++_x) {
                var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                indices.push(i1), indices.push(i4), indices.push(i2), indices.push(i4), indices.push(i3), 
                indices.push(i2);
            }
        }(), function generateTop() {
            for (var lat = 0; lat <= topSegments; ++lat) for (var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                var phi = 2 * lon * Math.PI / sides - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / sides, v = lat / heightSegments + (1 - topProp);
                if (positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop), normals.push(x, y, z), 
                uvs.push(u, v), lat < topSegments && lon < sides) {
                    var seg1 = sides + 1, a = seg1 * lat + lon + indexArray[torSegments][sides] + 1, b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1, c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1, d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
        }(), {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    },
    circle: function circle(options) {
        var segments = function applyDefaultCircleOptions(options) {
            return (options = applyDefaultGeometryOptions(options)).segments = 64, options;
        }(options).segments, positions = new Array(3 * (segments + 1));
        positions[0] = 0, positions[1] = 0, positions[2] = 0;
        var indices = new Array(1 + 2 * segments);
        indices[0] = 0;
        for (var step = 2 * Math.PI / segments, iSegment = 0; iSegment < segments; ++iSegment) {
            var angle = step * iSegment, x = Math.cos(angle), y = Math.sin(angle), p = 3 * (iSegment + 1);
            positions[p + 0] = x, positions[p + 1] = y, positions[p + 2] = 0;
            var i = 2 * iSegment;
            indices[1 + i] = iSegment + 1, indices[1 + (i + 1)] = iSegment + 2;
        }
        return segments > 0 && (indices[indices.length - 1] = 1), {
            positions: positions,
            indices: indices,
            minPos: {
                x: 1,
                y: 1,
                z: 0
            },
            maxPos: {
                x: -1,
                y: -1,
                z: 0
            },
            boundingRadius: 1,
            primitiveMode: GFXPrimitiveMode.TRIANGLE_FAN
        };
    },
    translate: function translate(geometry, offset) {
        for (var x = offset.x || 0, y = offset.y || 0, z = offset.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
            var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
            geometry.positions[iX] = geometry.positions[iX] + x, geometry.positions[iY] = geometry.positions[iY] + y, 
            geometry.positions[iZ] = geometry.positions[iZ] + z;
        }
        return geometry.minPos && (geometry.minPos.x += x, geometry.minPos.y += y, geometry.minPos.z += z), 
        geometry.maxPos && (geometry.maxPos.x += x, geometry.maxPos.y += y, geometry.maxPos.z += z), 
        geometry;
    },
    scale: function scale(geometry, value) {
        for (var x = value.x || 0, y = value.y || 0, z = value.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
            var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
            geometry.positions[iX] *= x, geometry.positions[iY] *= y, geometry.positions[iZ] *= z;
        }
        return geometry.minPos && (geometry.minPos.x *= x, geometry.minPos.y *= y, geometry.minPos.z *= z), 
        geometry.maxPos && (geometry.maxPos.x *= x, geometry.maxPos.y *= y, geometry.maxPos.z *= z), 
        geometry.boundingRadius = Math.max(Math.max(x, y), z), geometry;
    },
    wireframed: function wireframed(geometry) {
        var indices = geometry.indices;
        if (!indices) return geometry;
        if (geometry.primitiveMode && geometry.primitiveMode !== GFXPrimitiveMode.TRIANGLE_LIST) return geometry;
        for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
            var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
            void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
        }
        return geometry.indices = lines, geometry.primitiveMode = GFXPrimitiveMode.LINE_LIST, 
        geometry;
    },
    wireframe: function wireframe(indices) {
        for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
            var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
            void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
        }
        return lines;
    },
    invWinding: function invWinding(indices) {
        for (var newIB = [], i = 0; i < indices.length; i += 3) newIB.push(indices[i], indices[i + 2], indices[i + 1]);
        return newIB;
    },
    toWavefrontOBJ: function toWavefrontOBJ(primitive) {
        var scale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        if (!primitive.indices || !primitive.uvs || !primitive.normals || void 0 !== primitive.primitiveMode && primitive.primitiveMode !== GFXPrimitiveMode.TRIANGLE_LIST) return "";
        for (var v = primitive.positions, t = primitive.uvs, n = primitive.normals, IB = primitive.indices, V = function V(i) {
            return "".concat(IB[i] + 1, "/").concat(IB[i] + 1, "/").concat(IB[i] + 1);
        }, content = "", i = 0; i < v.length; i += 3) content += "v ".concat(v[i] * scale, " ").concat(v[i + 1] * scale, " ").concat(v[i + 2] * scale, "\n");
        for (var _i = 0; _i < t.length; _i += 2) content += "vt ".concat(t[_i], " ").concat(t[_i + 1], "\n");
        for (var _i2 = 0; _i2 < n.length; _i2 += 3) content += "vn ".concat(n[_i2], " ").concat(n[_i2 + 1], " ").concat(n[_i2 + 2], "\n");
        for (var _i3 = 0; _i3 < IB.length; _i3 += 3) content += "f ".concat(V(_i3), " ").concat(V(_i3 + 1), " ").concat(V(_i3 + 2), "\n");
        return content;
    },
    normals: function normals(positions, normals) {
        for (var length = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, verts = new Array(2 * positions.length), i = 0; i < positions.length / 3; ++i) {
            var i3 = 3 * i, i6 = 6 * i;
            verts[i6 + 0] = positions[i3 + 0], verts[i6 + 1] = positions[i3 + 1], verts[i6 + 2] = positions[i3 + 2], 
            verts[i6 + 3] = positions[i3 + 0] + normals[i3 + 0] * length, verts[i6 + 4] = positions[i3 + 1] + normals[i3 + 1] * length, 
            verts[i6 + 5] = positions[i3 + 2] + normals[i3 + 2] * length;
        }
        return verts;
    },
    applyDefaultGeometryOptions: applyDefaultGeometryOptions
}), Skybox = function(_Model) {
    function Skybox(scene) {
        var _this;
        _classCallCheck(this, Skybox), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Skybox).call(this, scene, null)))._default = builtinResMgr.get("default-cube-texture"), 
        _this._envmap = _this._default, _this._isRGBE = !1, _this._useIBL = !1, _this._material = new Material(), 
        _this._globalBinding = void 0, _this._scene = scene, _this._material.initialize({
            effectName: "pipeline/skybox",
            defines: {
                USE_RGBE_CUBEMAP: _this._isRGBE
            }
        }), _this._globalBinding = _this._scene.root.pipeline.globalBindings.get(UNIFORM_ENVIRONMENT.name);
        var subMeshData = createMesh(box({
            width: 2,
            height: 2,
            length: 2
        })).renderingMesh.getSubmesh(0);
        return _this.initSubModel(0, subMeshData, _this._material), _this._updateGlobalBinding(), 
        _this;
    }
    return _inherits(Skybox, Model), _createClass(Skybox, [ {
        key: "useIBL",
        set: function set(val) {
            this._useIBL = val;
            var pipeline = this._scene.root.pipeline;
            !!pipeline.macros.CC_USE_IBL !== val && (pipeline.macros.CC_USE_IBL = val, this._scene.onPipelineChange(), 
            this._updateGlobalBinding());
        },
        get: function get() {
            return this._useIBL;
        }
    }, {
        key: "envmap",
        set: function set(val) {
            var newEnvmap = val || this._default;
            this._envmap = newEnvmap, this._updateGlobalBinding();
        },
        get: function get() {
            return this._envmap;
        }
    }, {
        key: "isRGBE",
        set: function set(val) {
            val !== this._isRGBE && (this._isRGBE = val, this._material.recompileShaders({
                USE_RGBE_CUBEMAP: this._isRGBE
            }), this.setSubModelMaterial(0, this._material), this._updateGlobalBinding());
        },
        get: function get() {
            return this._isRGBE;
        }
    } ]), _createClass(Skybox, [ {
        key: "_updateGlobalBinding",
        value: function _updateGlobalBinding() {
            var textureView = this._envmap.getGFXTextureView(), sampler = samplerLib.getSampler(this._device, this._envmap.getSamplerHash());
            this._globalBinding.sampler = sampler, this._globalBinding.textureView = textureView;
            var mat = this._material;
            mat.passes[0].bindSampler(UNIFORM_ENVIRONMENT.binding, sampler), mat.passes[0].bindTextureView(UNIFORM_ENVIRONMENT.binding, textureView);
            var _iterator = this._matPSORecord.get(mat), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.pipelineLayout.layouts[0].update();
            }
        }
    } ]), Skybox;
}(), SphereLight = function(_Light) {
    function SphereLight(scene, name, node) {
        var _this;
        return _classCallCheck(this, SphereLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLight).call(this, scene, name, node)))._size = .15, 
        _this._range = 1, _this._luminance = 1700 / nt2lm(_this._size), _this._pos = void 0, 
        _this._aabb = void 0, _this._type = LightType.SPHERE, _this._aabb = aabb.create(), 
        _this._pos = new Vec3(), _this;
    }
    return _inherits(SphereLight, Light), _createClass(SphereLight, [ {
        key: "position",
        get: function get() {
            return this._pos;
        }
    }, {
        key: "size",
        set: function set(size) {
            this._size = size;
        },
        get: function get() {
            return this._size;
        }
    }, {
        key: "range",
        set: function set(range) {
            this._range = range;
        },
        get: function get() {
            return this._range;
        }
    }, {
        key: "luminance",
        set: function set(lum) {
            this._luminance = lum;
        },
        get: function get() {
            return this._luminance;
        }
    }, {
        key: "aabb",
        get: function get() {
            return this._aabb;
        }
    } ]), _createClass(SphereLight, [ {
        key: "update",
        value: function update() {
            this._node && (this._node.getWorldPosition(this._pos), aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range));
        }
    } ]), SphereLight;
}(), _forward$2 = new Vec3(0, 0, -1), _v3$3 = new Vec3(), _qt$3 = new Quat(), _matView = new Mat4(), _matProj = new Mat4(), _matViewProj = new Mat4(), _matViewProjInv = new Mat4(), SpotLight = function(_Light) {
    function SpotLight(scene, name, node) {
        var _this;
        return _classCallCheck(this, SpotLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this, scene, name, node)))._dir = new Vec3(1, -1, -1), 
        _this._size = .15, _this._range = 5, _this._luminance = 1700 / nt2lm(_this._size), 
        _this._spotAngle = Math.cos(Math.PI / 6), _this._pos = void 0, _this._aabb = void 0, 
        _this._frustum = void 0, _this._angle = 0, _this._type = LightType.SPOT, _this._aabb = aabb.create(), 
        _this._frustum = frustum.create(), _this._pos = new Vec3(), _this;
    }
    return _inherits(SpotLight, Light), _createClass(SpotLight, [ {
        key: "position",
        get: function get() {
            return this._pos;
        }
    }, {
        key: "size",
        set: function set(size) {
            this._size = size;
        },
        get: function get() {
            return this._size;
        }
    }, {
        key: "range",
        set: function set(range) {
            this._range = range;
        },
        get: function get() {
            return this._range;
        }
    }, {
        key: "luminance",
        set: function set(lum) {
            this._luminance = lum;
        },
        get: function get() {
            return this._luminance;
        }
    }, {
        key: "direction",
        get: function get() {
            return this._dir;
        }
    }, {
        key: "spotAngle",
        get: function get() {
            return this._spotAngle;
        },
        set: function set(val) {
            this._angle = .5 * val, this._spotAngle = Math.cos(.5 * val);
        }
    }, {
        key: "aabb",
        get: function get() {
            return this._aabb;
        }
    }, {
        key: "frustum",
        get: function get() {
            return this._frustum;
        }
    } ]), _createClass(SpotLight, [ {
        key: "update",
        value: function update() {
            this._node && (this._node.getWorldPosition(this._pos), this._dir = Vec3.transformQuat(_v3$3, _forward$2, this._node.getWorldRotation(_qt$3)), 
            Vec3.normalize(this._dir, this._dir), aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
            this._node.getWorldRT(_matView), Mat4.invert(_matView, _matView), Mat4.perspective(_matProj, this._angle, 1, .001, this._range), 
            Mat4.multiply(_matViewProj, _matProj, _matView), Mat4.invert(_matViewProjInv, _matViewProj), 
            this._frustum.update(_matViewProj, _matViewProjInv));
        }
    } ]), SpotLight;
}(), RenderScene = function() {
    function RenderScene(root) {
        _classCallCheck(this, RenderScene), this._root = void 0, this._name = "", this._cameras = [], 
        this._ambient = void 0, this._skybox = void 0, this._planarShadows = void 0, this._mainLight = void 0, 
        this._defaultMainLightNode = void 0, this._sphereLights = [], this._spotLights = [], 
        this._models = [], this._modelId = 0, this._texturePool = void 0, this._root = root, 
        this._ambient = new Ambient(this), this._defaultMainLightNode = new Node$1("Main Light"), 
        this._mainLight = new DirectionalLight(this, "Main Light", this._defaultMainLightNode), 
        this._mainLight.illuminance = Ambient.SUN_ILLUM, this._mainLight.enabled = !1, this._ambient = new Ambient(this), 
        this._skybox = new Skybox(this), this._planarShadows = new PlanarShadows(this), 
        this._texturePool = new JointsTexturePool(root.device);
    }
    return _createClass(RenderScene, [ {
        key: "root",
        get: function get() {
            return this._root;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "cameras",
        get: function get() {
            return this._cameras;
        }
    }, {
        key: "ambient",
        get: function get() {
            return this._ambient;
        }
    }, {
        key: "skybox",
        get: function get() {
            return this._skybox;
        }
    }, {
        key: "planarShadows",
        get: function get() {
            return this._planarShadows;
        }
    }, {
        key: "defaultMainLightNode",
        get: function get() {
            return this._defaultMainLightNode;
        }
    }, {
        key: "mainLight",
        get: function get() {
            return this._mainLight;
        }
    }, {
        key: "sphereLights",
        get: function get() {
            return this._sphereLights;
        }
    }, {
        key: "spotLights",
        get: function get() {
            return this._spotLights;
        }
    }, {
        key: "models",
        get: function get() {
            return this._models;
        }
    }, {
        key: "texturePool",
        get: function get() {
            return this._texturePool;
        }
    } ], [ {
        key: "registerCreateFunc",
        value: function registerCreateFunc(root) {
            root._createSceneFun = function(_root) {
                return new RenderScene(_root);
            };
        }
    } ]), _createClass(RenderScene, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._name = info.name, this._texturePool.initialize(), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyCameras(), this.destroyPointLights(), this.destroySpotLights(), this.destroyModels(), 
            this._planarShadows.destroy(), this._texturePool.destroy();
        }
    }, {
        key: "createCamera",
        value: function createCamera(info) {
            var camera = new Camera(this, info);
            return this._cameras.push(camera), camera;
        }
    }, {
        key: "destroyCamera",
        value: function destroyCamera(camera) {
            for (var i = 0; i < this._cameras.length; ++i) if (this._cameras[i] === camera) return camera.destroy(), 
            void this._cameras.splice(i, 1);
        }
    }, {
        key: "destroyCameras",
        value: function destroyCameras() {
            var _iterator = this._cameras, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.destroy();
            }
            this._cameras.splice(0);
        }
    }, {
        key: "createSphereLight",
        value: function createSphereLight(name, node) {
            var light = new SphereLight(this, name, node);
            return this._sphereLights.push(light), light;
        }
    }, {
        key: "destroySphereLight",
        value: function destroySphereLight(light) {
            for (var i = 0; i < this._sphereLights.length; ++i) if (this._sphereLights[i] === light) return void this._sphereLights.splice(i, 1);
        }
    }, {
        key: "createSpotLight",
        value: function createSpotLight(name, node) {
            var light = new SpotLight(this, name, node);
            return this._spotLights.push(light), light;
        }
    }, {
        key: "destroySpotLight",
        value: function destroySpotLight(light) {
            for (var i = 0; i < this._spotLights.length; ++i) if (this._spotLights[i] === light) return void this._spotLights.splice(i, 1);
        }
    }, {
        key: "destroyPointLights",
        value: function destroyPointLights() {
            this._sphereLights = [];
        }
    }, {
        key: "destroySpotLights",
        value: function destroySpotLights() {
            this._spotLights = [];
        }
    }, {
        key: "createModel",
        value: function createModel(clazz, node) {
            var model = new clazz(this, node);
            return this._models.push(model), model;
        }
    }, {
        key: "destroyModel",
        value: function destroyModel(model) {
            for (var i = 0; i < this._models.length; ++i) if (this._models[i] === model) return void this._models.splice(i, 1)[0].destroy();
        }
    }, {
        key: "destroyModels",
        value: function destroyModels() {
            var _iterator2 = this._models, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                _ref2.destroy();
            }
            this._models = [];
        }
    }, {
        key: "onPipelineChange",
        value: function onPipelineChange() {
            var _iterator3 = this._models, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                _ref3.onPipelineChange();
            }
            this._skybox.onPipelineChange(), this._planarShadows.onPipelineChange();
        }
    }, {
        key: "generateModelId",
        value: function generateModelId() {
            return this._modelId++;
        }
    }, {
        key: "raycast",
        value: function raycast(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.RaycastMask;
            pool.reset();
            var _iterator4 = this._models, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                var m = _ref4, transform = m.transform;
                if (transform && m.enabled && cc.Layers.check(m.node.layer, mask) && m.modelBounds && (Mat4.invert(m4, transform.getWorldMatrix(m4)), 
                Vec3.transformMat4(modelRay.o, worldRay.o, m4), Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4)), 
                !((distance$1 = intersect.ray_aabb(modelRay, m.modelBounds)) <= 0))) for (var i = 0; i < m.subModelNum; ++i) {
                    var subModel = m.getSubModel(i).subMeshData;
                    if (subModel && subModel.geometricInfo) {
                        var _subModel$geometricIn = subModel.geometricInfo, vb = _subModel$geometricIn.positions, ib = _subModel$geometricIn.indices, sides = _subModel$geometricIn.doubleSided;
                        narrowphase(vb, ib, subModel.primitiveMode, sides);
                    }
                    if (distance$1 < 1 / 0) {
                        var r = pool.add();
                        r.node = m.node, r.distance = distance$1 * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length(), 
                        results[pool.length - 1] = r;
                    }
                }
            }
            return results.length = pool.length, results;
        }
    }, {
        key: "raycastUI",
        value: function raycastUI(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.UI;
            poolUI.reset();
            var canvasComs = cc.director.getScene().getComponentsInChildren(cc.CanvasComponent);
            if (null != canvasComs && canvasComs.length > 0) {
                var canvasNode = canvasComs[0].node;
                null != canvasNode && canvasNode.active && this._raycastUINodeRecursiveChildren(worldRay, mask, canvasNode);
            }
            return resultUIs.length = poolUI.length, resultUIs;
        }
    }, {
        key: "raycastUINode",
        value: function raycastUINode(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.UI, uiNode = arguments.length > 2 ? arguments[2] : void 0, uiTransfrom = uiNode.uiTransfromComp;
            if (null != uiTransfrom && cc.Layers.check(uiNode.layer, mask) && (uiTransfrom.getComputeAABB(aabbUI), 
            !((distance$1 = intersect.ray_aabb(worldRay, aabbUI)) <= 0))) {
                var r = poolUI.add();
                return r.node = uiNode, r.distance = distance$1, r;
            }
        }
    }, {
        key: "_raycastUINodeRecursiveChildren",
        value: function _raycastUINodeRecursiveChildren(worldRay, mask, parent) {
            var result = this.raycastUINode(worldRay, mask, parent);
            null != result && (resultUIs[poolUI.length - 1] = result);
            var _iterator5 = parent.children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                var node = _ref5;
                null != node && node.active && this._raycastUINodeRecursiveChildren(worldRay, mask, node);
            }
        }
    } ]), RenderScene;
}(), modelRay = ray.create(), v3$1 = new Vec3(), m4 = new Mat4(), distance$1 = 1 / 0, tri = triangle.create(), pool = new RecyclePool(function() {
    return {
        node: null,
        distance: 1 / 0
    };
}, 8), results = [], aabbUI = new aabb(), poolUI = new RecyclePool(function() {
    return {
        node: null,
        distance: 1 / 0
    };
}, 8), resultUIs = [], narrowphase = function narrowphase(vb, ib, pm, sides) {
    if (distance$1 = 1 / 0, pm === GFXPrimitiveMode.TRIANGLE_LIST) for (var cnt = ib.length, j = 0; j < cnt; j += 3) {
        var i0 = 3 * ib[j], i1 = 3 * ib[j + 1], i2 = 3 * ib[j + 2];
        Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]), Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]), 
        Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
        var dist = intersect.ray_triangle(modelRay, tri, sides);
        dist <= 0 || dist > distance$1 || (distance$1 = dist);
    } else if (pm === GFXPrimitiveMode.TRIANGLE_STRIP) for (var _cnt = ib.length - 2, rev = 0, _j = 0; _j < _cnt; _j += 1) {
        var _i6 = 3 * ib[_j - rev], _i7 = 3 * ib[_j + rev + 1], _i8 = 3 * ib[_j + 2];
        Vec3.set(tri.a, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]), Vec3.set(tri.b, vb[_i7], vb[_i7 + 1], vb[_i7 + 2]), 
        Vec3.set(tri.c, vb[_i8], vb[_i8 + 1], vb[_i8 + 2]), rev = ~rev;
        var _dist = intersect.ray_triangle(modelRay, tri, sides);
        _dist <= 0 || _dist > distance$1 || (distance$1 = _dist);
    } else if (pm === GFXPrimitiveMode.TRIANGLE_FAN) {
        var _cnt2 = ib.length - 1, _i9 = 3 * ib[0];
        Vec3.set(tri.a, vb[_i9], vb[_i9 + 1], vb[_i9 + 2]);
        for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
            var _i10 = 3 * ib[_j2], _i11 = 3 * ib[_j2 + 1];
            Vec3.set(tri.b, vb[_i10], vb[_i10 + 1], vb[_i10 + 2]), Vec3.set(tri.c, vb[_i11], vb[_i11 + 1], vb[_i11 + 2]);
            var _dist2 = intersect.ray_triangle(modelRay, tri, sides);
            _dist2 <= 0 || _dist2 > distance$1 || (distance$1 = _dist2);
        }
    }
}, vec3_temp = new Vec3(), _worldMatrix$1 = new Mat4();

function fillMeshVertices3D(node, renderer, renderData, color) {
    var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
    buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
    vertexCount = 0, indiceOffset = 0, vertexId = 0);
    var vbuf = buffer.vData, ibuf = buffer.iData;
    node.getWorldMatrix(_worldMatrix$1);
    for (var i = 0; i < vertexCount; i++) {
        var vert = datas[i];
        Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
        vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
        vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.array(vbuf, color, vertexOffset), 
        vertexOffset += 4;
    }
    for (var _i2 = 0, count = vertexCount / 4; _i2 < count; _i2++) {
        var start = vertexId + 4 * _i2;
        ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 2, 
        ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 3, ibuf[indiceOffset++] = start + 2;
    }
}

!function(SpriteType) {
    SpriteType[SpriteType.SIMPLE = 0] = "SIMPLE", SpriteType[SpriteType.SLICED = 1] = "SLICED", 
    SpriteType[SpriteType.FILLED = 3] = "FILLED";
}(SpriteType || (SpriteType = {})), ccenum(SpriteType), function(FillType) {
    FillType[FillType.HORIZONTAL = 0] = "HORIZONTAL", FillType[FillType.VERTICAL = 1] = "VERTICAL", 
    FillType[FillType.RADIAL = 2] = "RADIAL";
}(FillType || (FillType = {})), ccenum(FillType), function(SizeMode) {
    SizeMode[SizeMode.CUSTOM = 0] = "CUSTOM", SizeMode[SizeMode.TRIMMED = 1] = "TRIMMED", 
    SizeMode[SizeMode.RAW = 2] = "RAW";
}(SizeMode || (SizeMode = {})), ccenum(SizeMode);

var _dec$G, _dec2$m, _dec3$b, _dec4$8, _dec5$8, _dec6$7, _dec7$5, _dec8$3, _dec9$2, _dec10$1, _dec11$1, _dec12$1, _class$G, _class2$z, _descriptor$x, _descriptor2$o, _descriptor3$e, _descriptor4$b, _descriptor5$9, _descriptor6$4, _descriptor7$4, _descriptor8$4, _descriptor9$4, _descriptor10$3, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _class3$g, _temp$B, Transition, State, SpriteComponent = (_dec$F = ccclass("cc.SpriteComponent"), 
_dec2$l = executionOrder(110), _dec3$a = menu("UI/Render/Sprite"), _dec4$7 = property({
    type: SpriteAtlas,
    displayOrder: 4
}), _dec5$7 = property({
    type: SpriteFrame,
    displayOrder: 5
}), _dec6$6 = property({
    type: SpriteType,
    displayOrder: 6
}), _dec7$4 = property({
    type: FillType
}), _dec8$2 = property({
    displayOrder: 8
}), _dec9$1 = property({
    type: SizeMode,
    displayOrder: 7
}), _dec$F(_class$F = _dec2$l(_class$F = _dec3$a((_temp$A = _class3$f = function(_UIRenderComponent) {
    function SpriteComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SpriteComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_spriteFrame", _descriptor$w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_type", _descriptor2$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillType", _descriptor3$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sizeMode", _descriptor4$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillCenter", _descriptor5$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillStart", _descriptor6$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillRange", _descriptor7$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_atlas", _descriptor9$3, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SpriteComponent, UIRenderComponent), _createClass(SpriteComponent, [ {
        key: "__preload",
        value: function __preload() {
            _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this) && _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this).call(this), 
            this._spriteFrame && (this._spriteFrame.on("updated", this._markForUpdateUvDirty, this), 
            this._markForUpdateUvDirty());
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(SpriteComponent.prototype), "onEnable", this).call(this), this._activateMaterial();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(SpriteComponent.prototype), "onDestroy", this).call(this), 
            this.destroyRenderData(), this._spriteFrame && this._spriteFrame.off("updated");
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitComp(this, this._spriteFrame.getGFXTextureView(), this._assembler);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            if (!_get(_getPrototypeOf(SpriteComponent.prototype), "_canRender", this).call(this)) return !1;
            var spriteFrame = this._spriteFrame;
            return !(!spriteFrame || !spriteFrame.textureLoaded());
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = SpriteComponent.Assembler.getAssembler(this);
            this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
            this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
            this._renderData.material = this._material, this.markForUpdateRenderData());
        }
    }, {
        key: "_applySpriteSize",
        value: function _applySpriteSize() {
            if (this._spriteFrame) {
                if (SizeMode.RAW === this._sizeMode) {
                    var size = this._spriteFrame.originalSize;
                    this.node.setContentSize(size);
                } else if (SizeMode.TRIMMED === this._sizeMode) {
                    var rect = this._spriteFrame.getRect();
                    this.node.setContentSize(rect.width, rect.height);
                }
                this._activateMaterial();
            }
        }
    }, {
        key: "_resized",
        value: function _resized() {
        }
    }, {
        key: "_activateMaterial",
        value: function _activateMaterial() {
            var spriteFrame = this._spriteFrame, material = this._material;
            cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS ? (spriteFrame && material && (material.setProperty("mainTexture", spriteFrame), 
            this.markForUpdateRenderData()), this._renderData && (this._renderData.material = material)) : this.markForUpdateRenderData();
        }
    }, {
        key: "_applyAtlas",
        value: function _applyAtlas(spriteFrame) {
        }
    }, {
        key: "_onTextureLoaded",
        value: function _onTextureLoaded() {
            this.isValid && this._applySpriteSize();
        }
    }, {
        key: "_applySpriteFrame",
        value: function _applySpriteFrame(oldFrame) {
            var spriteFrame = this._spriteFrame;
            this._renderData && (oldFrame && oldFrame.off("updated"), spriteFrame && spriteFrame.on("updated", this._markForUpdateUvDirty, this), 
            this._renderData.uvDirty || (this._renderData.uvDirty = !oldFrame || !spriteFrame || oldFrame.uvHash !== spriteFrame.uvHash), 
            this._renderDataFlag = this._renderData.uvDirty), spriteFrame && (oldFrame && spriteFrame === oldFrame || (spriteFrame.loaded ? this._onTextureLoaded() : spriteFrame.once("load", this._onTextureLoaded, this)));
        }
    }, {
        key: "_markForUpdateUvDirty",
        value: function _markForUpdateUvDirty() {
            this._renderData && (this._renderData.uvDirty = !0, this._renderDataFlag = !0);
        }
    }, {
        key: "spriteAtlas",
        get: function get() {
            return this._atlas;
        },
        set: function set(value) {
            this._atlas !== value && (this._atlas = value, this.spriteFrame = null);
        }
    }, {
        key: "spriteFrame",
        get: function get() {
            return this._spriteFrame;
        },
        set: function set(value) {
            if (this._spriteFrame !== value) {
                var lastSprite = this._spriteFrame;
                this._spriteFrame = value, this.markForUpdateRenderData(!1), this._applySpriteFrame(lastSprite);
            }
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        },
        set: function set(value) {
            this._type !== value && (this._type = value, this._flushAssembler());
        }
    }, {
        key: "fillType",
        get: function get() {
            return this._fillType;
        },
        set: function set(value) {
            this._fillType !== value && (value === FillType.RADIAL || this._fillType === FillType.RADIAL ? (this.destroyRenderData(), 
            this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), 
            this._fillType = value, this._flushAssembler();
        }
    }, {
        key: "fillCenter",
        get: function get() {
            return this._fillCenter;
        },
        set: function set(value) {
            this._fillCenter.x = value.x, this._fillCenter.y = value.y, this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
        }
    }, {
        key: "fillStart",
        get: function get() {
            return this._fillStart;
        },
        set: function set(value) {
            this._fillStart = clamp(value, -1, 1), this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
        }
    }, {
        key: "fillRange",
        get: function get() {
            return this._fillRange;
        },
        set: function set(value) {
            this._fillRange = clamp(value, 0, 1), this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
        }
    }, {
        key: "trim",
        get: function get() {
            return this._isTrimmedMode;
        },
        set: function set(value) {
            this._isTrimmedMode !== value && (this._isTrimmedMode = value, this._type === SpriteType.SIMPLE && this._renderData && this.markForUpdateRenderData(!0));
        }
    }, {
        key: "sizeMode",
        get: function get() {
            return this._sizeMode;
        },
        set: function set(value) {
            this._sizeMode !== value && (this._sizeMode = value, value !== SizeMode.CUSTOM && this._applySpriteSize());
        }
    } ]), SpriteComponent;
}(), _class3$f.FillType = FillType, _class3$f.Type = SpriteType, _class3$f.SizeMode = SizeMode, 
_applyDecoratedDescriptor((_class2$y = _temp$A).prototype, "spriteAtlas", [ _dec4$7 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "spriteAtlas"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "spriteFrame", [ _dec5$7 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "spriteFrame"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "type", [ _dec6$6 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "type"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "fillType", [ _dec7$4 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "fillType"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "fillCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "fillCenter"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "fillStart", [ property ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "fillStart"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "fillRange", [ property ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "fillRange"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "trim", [ _dec8$2 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "trim"), _class2$y.prototype), 
_applyDecoratedDescriptor(_class2$y.prototype, "sizeMode", [ _dec9$1 ], Object.getOwnPropertyDescriptor(_class2$y.prototype, "sizeMode"), _class2$y.prototype), 
_descriptor$w = _applyDecoratedDescriptor(_class2$y.prototype, "_spriteFrame", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$n = _applyDecoratedDescriptor(_class2$y.prototype, "_type", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return SpriteType.SIMPLE;
    }
}), _descriptor3$d = _applyDecoratedDescriptor(_class2$y.prototype, "_fillType", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return FillType.HORIZONTAL;
    }
}), _descriptor4$a = _applyDecoratedDescriptor(_class2$y.prototype, "_sizeMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return SizeMode.TRIMMED;
    }
}), _descriptor5$8 = _applyDecoratedDescriptor(_class2$y.prototype, "_fillCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(0, 0);
    }
}), _descriptor6$3 = _applyDecoratedDescriptor(_class2$y.prototype, "_fillStart", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$3 = _applyDecoratedDescriptor(_class2$y.prototype, "_fillRange", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$3 = _applyDecoratedDescriptor(_class2$y.prototype, "_isTrimmedMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor9$3 = _applyDecoratedDescriptor(_class2$y.prototype, "_atlas", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$F = _class2$y)) || _class$F) || _class$F) || _class$F);

cc.SpriteComponent = SpriteComponent, function(Transition) {
    Transition[Transition.NONE = 0] = "NONE", Transition[Transition.COLOR = 1] = "COLOR", 
    Transition[Transition.SPRITE = 2] = "SPRITE", Transition[Transition.SCALE = 3] = "SCALE";
}(Transition || (Transition = {})), ccenum(Transition), function(State) {
    State.NORMAL = "normal", State.HOVER = "hover", State.PRESSED = "pressed", State.DISABLED = "disabled";
}(State || (State = {}));

var ButtonComponent = (_dec$G = ccclass("cc.ButtonComponent"), _dec2$m = executionOrder(110), 
_dec3$b = menu("UI/Button"), _dec4$8 = property({
    displayOrder: 1
}), _dec5$8 = property({
    type: Transition,
    displayOrder: 2
}), _dec6$7 = property({
    min: 0,
    max: 10
}), _dec7$5 = property({
    type: SpriteFrame
}), _dec8$3 = property({
    type: SpriteFrame
}), _dec9$2 = property({
    type: SpriteFrame
}), _dec10$1 = property({
    type: SpriteFrame
}), _dec11$1 = property({
    type: Node$1,
    displayOrder: 0
}), _dec12$1 = property({
    type: EventHandler,
    displayOrder: 3
}), _dec$G(_class$G = _dec2$m(_class$G = _dec3$b((_temp$B = _class3$g = function(_Component) {
    function ButtonComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ButtonComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ButtonComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "clickEvents", _descriptor$x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_interactable", _descriptor2$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_transition", _descriptor3$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_normalColor", _descriptor4$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_hoverColor", _descriptor5$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_pressColor", _descriptor6$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_disabledColor", _descriptor7$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_normalSprite", _descriptor8$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_duration", _descriptor12$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_zoomScale", _descriptor13$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_target", _descriptor14$2, _assertThisInitialized(_this)), 
        _this._pressed = !1, _this._hovered = !1, _this._fromColor = new Color(), _this._toColor = new Color(), 
        _this._time = 0, _this._transitionFinished = !0, _this._fromScale = new Vec3(), 
        _this._toScale = new Vec3(), _this._originalScale = new Vec3(), _this._sprite = null, 
        _this._targetScale = new Vec3(), _this;
    }
    return _inherits(ButtonComponent, Component), _createClass(ButtonComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.target || (this.target = this.node);
            var sprite = this.node.getComponent(SpriteComponent);
            sprite && (this._normalSprite = sprite.spriteFrame), this._applyTarget(), this._updateState();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._registerEvent();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._resetState(), this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this), 
            this.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMove, this), this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this), 
            this.node.off(SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), this.node.off(SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), 
            this.node.off(SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
        }
    }, {
        key: "update",
        value: function update(dt) {
            var target = this._target ? this._target : this.node;
            if (!this._transitionFinished && (this._transition === Transition.COLOR || this._transition === Transition.SCALE)) {
                this._time += dt;
                var ratio = 1;
                this._duration > 0 && (ratio = this._time / this._duration), ratio >= 1 && (ratio = 1, 
                this._transitionFinished = !0);
                var renderComp = target.getComponent(UIRenderComponent);
                renderComp && (this._transition === Transition.COLOR ? Color.lerp(renderComp.color, this._fromColor, this._toColor, ratio) : this.transition === Transition.SCALE && (target.getScale(this._targetScale), 
                this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio), this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio), 
                target.setScale(this._targetScale)));
            }
        }
    }, {
        key: "_resizeNodeToTargetNode",
        value: function _resizeNodeToTargetNode() {
            0;
        }
    }, {
        key: "_resetState",
        value: function _resetState() {
            this._pressed = !1, this._hovered = !1;
            var target = this._target;
            if (target) {
                var renderComp = target.getComponent(UIRenderComponent);
                if (renderComp) {
                    var transition = this._transition;
                    transition === Transition.COLOR && this._interactable ? renderComp.color = this._normalColor : transition === Transition.SCALE && target.setScale(this._originalScale), 
                    this._transitionFinished = !0;
                }
            }
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMove, this), 
            this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.on(SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
            this.node.on(SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
        }
    }, {
        key: "_getTargetSprite",
        value: function _getTargetSprite(target) {
            var sprite = null;
            return target && (sprite = target.getComponent(SpriteComponent)), sprite;
        }
    }, {
        key: "_applyTarget",
        value: function _applyTarget() {
            this._sprite = this._getTargetSprite(this._target), this._target && Vec3.copy(this._originalScale, this._target.getScale());
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event) {
            this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), 
            event && (event.propagationStopped = !0));
        }
    }, {
        key: "_onTouchMove",
        value: function _onTouchMove(event) {
            if (this._interactable && this.enabledInHierarchy && this._pressed) {
                if (!event) return !1;
                var touch = event.touch;
                if (!touch) return !1;
                var state, hit = this.node.uiTransfromComp.isHit(touch.getUILocation());
                if (this._transition === Transition.SCALE && this._target) hit ? (Vec3.copy(this._fromScale, this._originalScale), 
                Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, 
                this._transitionFinished = !0, this._target && this._target.setScale(this._originalScale)); else state = hit ? State.PRESSED : State.NORMAL, 
                this._applyTransition(state);
                event && (event.propagationStopped = !0);
            }
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            this._interactable && this.enabledInHierarchy && (this._pressed && (EventHandler.emitEvents(this.clickEvents, event), 
            this.node.emit("click", this)), this._pressed = !1, this._updateState(), event && (event.propagationStopped = !0));
        }
    }, {
        key: "_onTouchCancel",
        value: function _onTouchCancel(event) {
            this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState());
        }
    }, {
        key: "_onMouseMoveIn",
        value: function _onMouseMoveIn(event) {
            !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition !== Transition.SPRITE || this._hoverSprite) && (this._hovered || (this._hovered = !0, 
            this._updateState()));
        }
    }, {
        key: "_onMouseMoveOut",
        value: function _onMouseMoveOut(event) {
            this._hovered && (this._hovered = !1, this._updateState());
        }
    }, {
        key: "_updateState",
        value: function _updateState() {
            var state = this._getButtonState();
            this._applyTransition(state);
        }
    }, {
        key: "_getButtonState",
        value: function _getButtonState() {
            var state = State.NORMAL;
            return this._interactable ? this._pressed ? state = State.PRESSED : this._hovered && (state = State.HOVER) : state = State.DISABLED, 
            state.toString();
        }
    }, {
        key: "_updateColorTransition",
        value: function _updateColorTransition(state) {
            var color = this[state + "Color"], target = this._target;
            if (target) {
                var renderComp = target.getComponent(UIRenderComponent);
                renderComp && (state === State.DISABLED ? renderComp.color = color : (this._fromColor = renderComp.color.clone(), 
                this._toColor = color, this._time = 0, this._transitionFinished = !1));
            }
        }
    }, {
        key: "_updateSpriteTransition",
        value: function _updateSpriteTransition(state) {
            var sprite = this[state + "Sprite"];
            this._sprite && sprite && (this._sprite.spriteFrame = sprite);
        }
    }, {
        key: "_updateScaleTransition",
        value: function _updateScaleTransition(state) {
            this._interactable && (state === State.PRESSED ? this._zoomUp() : this._zoomBack());
        }
    }, {
        key: "_zoomUp",
        value: function _zoomUp() {
            Vec3.copy(this._fromScale, this._originalScale), Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), 
            this._time = 0, this._transitionFinished = !1;
        }
    }, {
        key: "_zoomBack",
        value: function _zoomBack() {
            this._target && (Vec3.copy(this._fromScale, this._target.getScale()), Vec3.copy(this._toScale, this._originalScale), 
            this._time = 0, this._transitionFinished = !1);
        }
    }, {
        key: "_applyTransition",
        value: function _applyTransition(state) {
            var transition = this._transition;
            transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
        }
    }, {
        key: "interactable",
        get: function get() {
            return this._interactable;
        },
        set: function set(value) {
            this._interactable = value, this._updateState(), this._interactable || this._resetState();
        }
    }, {
        key: "_resizeToTarget",
        set: function set(value) {
            value && this._resizeNodeToTargetNode();
        }
    }, {
        key: "transition",
        get: function get() {
            return this._transition;
        },
        set: function set(value) {
            this._transition !== value && (this._transition = value);
        }
    }, {
        key: "normalColor",
        get: function get() {
            return this._normalColor;
        },
        set: function set(value) {
            this._normalColor !== value && (this._normalColor.set(value), this._updateState());
        }
    }, {
        key: "pressedColor",
        get: function get() {
            return this._pressColor;
        },
        set: function set(value) {
            this._pressColor !== value && this._pressColor.set(value);
        }
    }, {
        key: "hoverColor",
        get: function get() {
            return this._hoverColor;
        },
        set: function set(value) {
            this._hoverColor !== value && this._hoverColor.set(value);
        }
    }, {
        key: "disabledColor",
        get: function get() {
            return this._disabledColor;
        },
        set: function set(value) {
            this._disabledColor !== value && (this._disabledColor.set(value), this._updateState());
        }
    }, {
        key: "duration",
        get: function get() {
            return this._duration;
        },
        set: function set(value) {
            this._duration !== value && (this._duration = value);
        }
    }, {
        key: "zoomScale",
        get: function get() {
            return this._zoomScale;
        },
        set: function set(value) {
            this._zoomScale !== value && (this._zoomScale = value);
        }
    }, {
        key: "normalSprite",
        get: function get() {
            return this._normalSprite;
        },
        set: function set(value) {
            if (this._normalSprite !== value) {
                this._normalSprite = value;
                var sprite = this.node.getComponent(SpriteComponent);
                sprite && (sprite.spriteFrame = value), this._updateState();
            }
        }
    }, {
        key: "pressedSprite",
        get: function get() {
            return this._pressedSprite;
        },
        set: function set(value) {
            this._pressedSprite !== value && (this._pressedSprite = value, this._updateState());
        }
    }, {
        key: "hoverSprite",
        get: function get() {
            return this._hoverSprite;
        },
        set: function set(value) {
            this._hoverSprite !== value && (this._hoverSprite = value, this._updateState());
        }
    }, {
        key: "disabledSprite",
        get: function get() {
            return this._disabledSprite;
        },
        set: function set(value) {
            this._disabledSprite !== value && (this._disabledSprite = value, this._updateState());
        }
    }, {
        key: "target",
        get: function get() {
            return this._target;
        },
        set: function set(value) {
            this._target !== value && (this._target = value, this._applyTarget());
        }
    } ]), ButtonComponent;
}(), _class3$g.Transition = Transition, _applyDecoratedDescriptor((_class2$z = _temp$B).prototype, "interactable", [ _dec4$8 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "interactable"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "transition", [ _dec5$8 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "transition"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "normalColor", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "normalColor"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "pressedColor", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "pressedColor"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "hoverColor", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "hoverColor"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "disabledColor", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "disabledColor"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "duration", [ _dec6$7 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "duration"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "zoomScale", [ property ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "zoomScale"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "normalSprite", [ _dec7$5 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "normalSprite"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "pressedSprite", [ _dec8$3 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "pressedSprite"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "hoverSprite", [ _dec9$2 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "hoverSprite"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "disabledSprite", [ _dec10$1 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "disabledSprite"), _class2$z.prototype), 
_applyDecoratedDescriptor(_class2$z.prototype, "target", [ _dec11$1 ], Object.getOwnPropertyDescriptor(_class2$z.prototype, "target"), _class2$z.prototype), 
_descriptor$x = _applyDecoratedDescriptor(_class2$z.prototype, "clickEvents", [ _dec12$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$o = _applyDecoratedDescriptor(_class2$z.prototype, "_interactable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$e = _applyDecoratedDescriptor(_class2$z.prototype, "_transition", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Transition.NONE;
    }
}), _descriptor4$b = _applyDecoratedDescriptor(_class2$z.prototype, "_normalColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(214, 214, 214, 255);
    }
}), _descriptor5$9 = _applyDecoratedDescriptor(_class2$z.prototype, "_hoverColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(211, 211, 211, 255);
    }
}), _descriptor6$4 = _applyDecoratedDescriptor(_class2$z.prototype, "_pressColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor7$4 = _applyDecoratedDescriptor(_class2$z.prototype, "_disabledColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(124, 124, 124, 255);
    }
}), _descriptor8$4 = _applyDecoratedDescriptor(_class2$z.prototype, "_normalSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor9$4 = _applyDecoratedDescriptor(_class2$z.prototype, "_hoverSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor10$3 = _applyDecoratedDescriptor(_class2$z.prototype, "_pressedSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor11$2 = _applyDecoratedDescriptor(_class2$z.prototype, "_disabledSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor12$2 = _applyDecoratedDescriptor(_class2$z.prototype, "_duration", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor13$2 = _applyDecoratedDescriptor(_class2$z.prototype, "_zoomScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1.2;
    }
}), _descriptor14$2 = _applyDecoratedDescriptor(_class2$z.prototype, "_target", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$G = _class2$z)) || _class$G) || _class$G) || _class$G);

cc.ButtonComponent = ButtonComponent;

var _dec$H, _dec2$n, _dec3$c, _dec4$9, _dec5$9, _dec6$8, _dec7$6, _dec8$4, _dec9$3, _dec10$2, _dec11$2, _dec12$2, _dec13$1, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _class$H, _class2$A, _descriptor$y, _descriptor2$p, _descriptor3$f, _descriptor4$c, _descriptor5$a, _descriptor6$5, _descriptor7$5, _descriptor8$5, _descriptor9$5, _descriptor10$4, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14$3, _descriptor15$1, _descriptor16$1, _class3$h, _temp$C, HorizontalTextAlignment, VerticalTextAlignment, Overflow, CacheMode, CanvasPool = function() {
    function CanvasPool() {
        _classCallCheck(this, CanvasPool), this.pool = [];
    }
    return _createClass(CanvasPool, [ {
        key: "get",
        value: function get() {
            var data = this.pool.pop();
            if (!data) {
                var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
                data = {
                    canvas: canvas,
                    context: context
                };
            }
            return data;
        }
    }, {
        key: "put",
        value: function put(canvas) {
            this.pool.length >= 32 || this.pool.push(canvas);
        }
    } ]), CanvasPool;
}();

!function(HorizontalTextAlignment) {
    HorizontalTextAlignment[HorizontalTextAlignment.LEFT = 0] = "LEFT", HorizontalTextAlignment[HorizontalTextAlignment.CENTER = 1] = "CENTER", 
    HorizontalTextAlignment[HorizontalTextAlignment.RIGHT = 2] = "RIGHT";
}(HorizontalTextAlignment || (HorizontalTextAlignment = {})), ccenum(HorizontalTextAlignment), 
function(VerticalTextAlignment) {
    VerticalTextAlignment[VerticalTextAlignment.TOP = 0] = "TOP", VerticalTextAlignment[VerticalTextAlignment.CENTER = 1] = "CENTER", 
    VerticalTextAlignment[VerticalTextAlignment.BOTTOM = 2] = "BOTTOM";
}(VerticalTextAlignment || (VerticalTextAlignment = {})), ccenum(VerticalTextAlignment), 
function(Overflow) {
    Overflow[Overflow.NONE = 0] = "NONE", Overflow[Overflow.CLAMP = 1] = "CLAMP", Overflow[Overflow.SHRINK = 2] = "SHRINK", 
    Overflow[Overflow.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT";
}(Overflow || (Overflow = {})), ccenum(Overflow), function(CacheMode) {
    CacheMode[CacheMode.NONE = 0] = "NONE", CacheMode[CacheMode.BITMAP = 1] = "BITMAP", 
    CacheMode[CacheMode.CHAR = 2] = "CHAR";
}(CacheMode || (CacheMode = {})), ccenum(CacheMode);

var KeyboardReturnType, InputMode, InputFlag, _class$I, LabelComponent = (_dec$H = ccclass("cc.LabelComponent"), 
_dec2$n = executionOrder(110), _dec3$c = menu("UI/Render/Label"), _dec4$9 = property({
    displayOrder: 4,
    multiline: !0
}), _dec5$9 = property({
    type: HorizontalTextAlignment,
    displayOrder: 5
}), _dec6$8 = property({
    type: VerticalTextAlignment,
    displayOrder: 6
}), _dec7$6 = property({
    readonly: !0,
    displayName: "Actual Font Size",
    visible: !1
}), _dec8$4 = property({
    displayOrder: 7
}), _dec9$3 = property({
    displayOrder: 8
}), _dec10$2 = property({
    displayOrder: 8
}), _dec11$2 = property({
    type: Overflow,
    displayOrder: 9
}), _dec12$2 = property({
    displayOrder: 10
}), _dec13$1 = property({
    type: Font,
    displayOrder: 11
}), _dec14$1 = property({
    displayOrder: 12
}), _dec15$1 = property({
    type: CacheMode,
    displayOrder: 13
}), _dec16$1 = property({
    displayOrder: 15
}), _dec17$1 = property({
    displayOrder: 16
}), _dec18$1 = property({
    displayOrder: 17
}), _dec$H(_class$H = _dec2$n(_class$H = _dec3$c((_temp$C = _class3$h = function(_UIRenderComponent) {
    function LabelComponent() {
        var _this;
        return _classCallCheck(this, LabelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LabelComponent).call(this)), "_useOriginalSize", _descriptor$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_string", _descriptor2$p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_actualFontSize", _descriptor5$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontSize", _descriptor6$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontFamily", _descriptor7$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineHeight", _descriptor8$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_overflow", _descriptor9$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_enableWrapText", _descriptor10$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_font", _descriptor11$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor12$3, _assertThisInitialized(_this)), 
        _this._spacingX = 0, _initializerDefineProperty(_this, "_isItalic", _descriptor13$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isBold", _descriptor14$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isUnderline", _descriptor15$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cacheMode", _descriptor16$1, _assertThisInitialized(_this)), 
        _this._N$file = null, _this._texture = null, _this._ttfSpriteFrame = null, _this._userDefinedFont = null, 
        _this._assemblerData = null, _this._fontAtlas = null, _this._letterTexture = null, 
        _this._ttfSpriteFrame = null, _this;
    }
    return _inherits(LabelComponent, UIRenderComponent), _createClass(LabelComponent, [ {
        key: "string",
        get: function get() {
            return this._string;
        },
        set: function set(value) {
            value = value.toString(), this._string !== value && (this._string = value, this.updateRenderData());
        }
    }, {
        key: "horizontalAlign",
        get: function get() {
            return this._horizontalAlign;
        },
        set: function set(value) {
            this._horizontalAlign !== value && (this._horizontalAlign = value, this.updateRenderData());
        }
    }, {
        key: "verticalAlign",
        get: function get() {
            return this._verticalAlign;
        },
        set: function set(value) {
            this._verticalAlign !== value && (this._verticalAlign = value, this.updateRenderData());
        }
    }, {
        key: "actualFontSize",
        get: function get() {
            return this._actualFontSize;
        },
        set: function set(value) {
            this._actualFontSize = value;
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._fontSize;
        },
        set: function set(value) {
            this._fontSize !== value && (this._fontSize = value, this.updateRenderData());
        }
    }, {
        key: "fontFamily",
        get: function get() {
            return this._fontFamily;
        },
        set: function set(value) {
            this._fontFamily !== value && (this._fontFamily = value, this.updateRenderData());
        }
    }, {
        key: "lineHeight",
        get: function get() {
            return this._lineHeight;
        },
        set: function set(value) {
            this._lineHeight !== value && (this._lineHeight = value, this.updateRenderData());
        }
    }, {
        key: "overflow",
        get: function get() {
            return this._overflow;
        },
        set: function set(value) {
            this._overflow !== value && (this._overflow = value, this.updateRenderData());
        }
    }, {
        key: "enableWrapText",
        get: function get() {
            return this._enableWrapText;
        },
        set: function set(value) {
            this._enableWrapText !== value && (this._enableWrapText = value, this.updateRenderData());
        }
    }, {
        key: "font",
        get: function get() {
            return this._font;
        },
        set: function set(value) {
            this._font !== value && (this._isSystemFontUsed = !value, this._font = value, "string" == typeof value && cc.warnID(4e3), 
            this._renderData && (this.destroyRenderData(), this._renderData = null), this.updateRenderData(!0));
        }
    }, {
        key: "useSystemFont",
        get: function get() {
            return this._isSystemFontUsed;
        },
        set: function set(value) {
            this._isSystemFontUsed !== value && (this.destroyRenderData(), this._renderData = null, 
            this._isSystemFontUsed = !!value, value && (this.font = null, this._flushAssembler(), 
            this.updateRenderData()));
        }
    }, {
        key: "cacheMode",
        get: function get() {
            return this._cacheMode;
        },
        set: function set(value) {
            this._cacheMode !== value && (this._cacheMode === CacheMode.CHAR && (this._ttfSpriteFrame = null), 
            this._cacheMode = value, this.updateRenderData(!0));
        }
    }, {
        key: "spriteFrame",
        get: function get() {
            return this._texture;
        }
    }, {
        key: "isBold",
        get: function get() {
            return this._isBold;
        },
        set: function set(value) {
            this._isBold !== value && (this._isBold = value, this.updateRenderData());
        }
    }, {
        key: "isItalic",
        get: function get() {
            return this._isItalic;
        },
        set: function set(value) {
            this._isItalic !== value && (this._isItalic = value, this.updateRenderData());
        }
    }, {
        key: "isUnderline",
        get: function get() {
            return this._isUnderline;
        },
        set: function set(value) {
            this._isUnderline !== value && (this._isUnderline = value, this.updateRenderData());
        }
    }, {
        key: "assemblerData",
        get: function get() {
            return this._assemblerData;
        }
    }, {
        key: "fontAtlas",
        get: function get() {
            return this._fontAtlas;
        },
        set: function set(value) {
            this._fontAtlas = value;
        }
    }, {
        key: "spacingX",
        get: function get() {
            return this._spacingX;
        },
        set: function set(value) {
            this._spacingX !== value && (this._spacingX = value, this.updateRenderData());
        }
    }, {
        key: "_bmFontOriginalSize",
        get: function get() {
            return this._font instanceof BitmapFont ? this._font.fontSize : -1;
        }
    } ]), _createClass(LabelComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(LabelComponent.prototype), "onEnable", this).call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), 
            this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this.updateRenderData(!0);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(LabelComponent.prototype), "onDisable", this).call(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), 
            this._assemblerData = null, this._ttfSpriteFrame && (this._ttfSpriteFrame.destroy(), 
            this._ttfSpriteFrame = null), _get(_getPrototypeOf(LabelComponent.prototype), "onDestroy", this).call(this);
        }
    }, {
        key: "updateRenderData",
        value: function updateRenderData() {
            var force = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.markForUpdateRenderData(), force && (this._flushAssembler(), this._applyFontTexture(force));
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitComp(this, this._texture.getGFXTextureView(), this._assembler);
        }
    }, {
        key: "_updateColor",
        value: function _updateColor() {
            this._font instanceof BitmapFont ? _get(_getPrototypeOf(LabelComponent.prototype), "_updateColor", this).call(this) : this.updateRenderData(!1);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            if (!(_get(_getPrototypeOf(LabelComponent.prototype), "_canRender", this).call(this) && this.node.width && this.node.height && this._string)) return !1;
            var font = this._font;
            if (font && font instanceof BitmapFont) {
                var spriteFrame = font.spriteFrame;
                if (!spriteFrame || !spriteFrame.textureLoaded()) return !1;
            }
            return !0;
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = LabelComponent.Assembler.getAssembler(this);
            this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
            this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
            this._renderData.material = this._material);
        }
    }, {
        key: "_flushMaterial",
        value: function _flushMaterial() {
            var material = this._material;
            material && material.setProperty("mainTexture", this._texture), this._updateMaterial(material);
        }
    }, {
        key: "_applyFontTexture",
        value: function _applyFontTexture(force) {
            var font = this._font;
            if (font instanceof BitmapFont) {
                var spriteFrame = font.spriteFrame, self = this;
                spriteFrame && function onBMFontTextureLoaded() {
                    self._texture = spriteFrame, self._flushMaterial();
                }();
            } else {
                if (this.cacheMode === CacheMode.CHAR && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) this._letterTexture = this._assembler.getAssemblerData(), 
                this._texture = this._letterTexture; else if (!this._ttfSpriteFrame) {
                    this._ttfSpriteFrame = new SpriteFrame(), this._assemblerData = this._assembler.getAssemblerData();
                    var image = new ImageAsset(this._assemblerData.canvas), tex = new Texture2D();
                    tex.image = image, this._ttfSpriteFrame.texture = tex;
                }
                this.cacheMode !== CacheMode.CHAR && (this._texture = this._ttfSpriteFrame), this._flushMaterial();
            }
            force && this._assembler && this.markForUpdateRenderData();
        }
    } ]), LabelComponent;
}(), _class3$h.HorizontalAlign = HorizontalTextAlignment, _class3$h.VerticalAlign = VerticalTextAlignment, 
_class3$h.Overflow = Overflow, _class3$h.CacheMode = CacheMode, _class3$h.CanvasPool = new CanvasPool(), 
_applyDecoratedDescriptor((_class2$A = _temp$C).prototype, "string", [ _dec4$9 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "string"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "horizontalAlign", [ _dec5$9 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "horizontalAlign"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "verticalAlign", [ _dec6$8 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "verticalAlign"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "actualFontSize", [ _dec7$6 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "actualFontSize"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "fontSize", [ _dec8$4 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "fontSize"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "fontFamily", [ _dec9$3 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "fontFamily"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "lineHeight", [ _dec10$2 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "lineHeight"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "overflow", [ _dec11$2 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "overflow"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "enableWrapText", [ _dec12$2 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "enableWrapText"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "font", [ _dec13$1 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "font"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "useSystemFont", [ _dec14$1 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "useSystemFont"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "cacheMode", [ _dec15$1 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "cacheMode"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "isBold", [ _dec16$1 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "isBold"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "isItalic", [ _dec17$1 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "isItalic"), _class2$A.prototype), 
_applyDecoratedDescriptor(_class2$A.prototype, "isUnderline", [ _dec18$1 ], Object.getOwnPropertyDescriptor(_class2$A.prototype, "isUnderline"), _class2$A.prototype), 
_descriptor$y = _applyDecoratedDescriptor(_class2$A.prototype, "_useOriginalSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor2$p = _applyDecoratedDescriptor(_class2$A.prototype, "_string", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "label";
    }
}), _descriptor3$f = _applyDecoratedDescriptor(_class2$A.prototype, "_horizontalAlign", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return HorizontalTextAlignment.CENTER;
    }
}), _descriptor4$c = _applyDecoratedDescriptor(_class2$A.prototype, "_verticalAlign", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return VerticalTextAlignment.CENTER;
    }
}), _descriptor5$a = _applyDecoratedDescriptor(_class2$A.prototype, "_actualFontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$5 = _applyDecoratedDescriptor(_class2$A.prototype, "_fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor7$5 = _applyDecoratedDescriptor(_class2$A.prototype, "_fontFamily", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "Arial";
    }
}), _descriptor8$5 = _applyDecoratedDescriptor(_class2$A.prototype, "_lineHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor9$5 = _applyDecoratedDescriptor(_class2$A.prototype, "_overflow", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Overflow.NONE;
    }
}), _descriptor10$4 = _applyDecoratedDescriptor(_class2$A.prototype, "_enableWrapText", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor11$3 = _applyDecoratedDescriptor(_class2$A.prototype, "_font", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor12$3 = _applyDecoratedDescriptor(_class2$A.prototype, "_isSystemFontUsed", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor13$3 = _applyDecoratedDescriptor(_class2$A.prototype, "_isItalic", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor14$3 = _applyDecoratedDescriptor(_class2$A.prototype, "_isBold", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor15$1 = _applyDecoratedDescriptor(_class2$A.prototype, "_isUnderline", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor16$1 = _applyDecoratedDescriptor(_class2$A.prototype, "_cacheMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return CacheMode.NONE;
    }
}), _class$H = _class2$A)) || _class$H) || _class$H) || _class$H);

cc.LabelComponent = LabelComponent, function(KeyboardReturnType) {
    KeyboardReturnType[KeyboardReturnType.DEFAULT = 0] = "DEFAULT", KeyboardReturnType[KeyboardReturnType.DONE = 1] = "DONE", 
    KeyboardReturnType[KeyboardReturnType.SEND = 2] = "SEND", KeyboardReturnType[KeyboardReturnType.SEARCH = 3] = "SEARCH", 
    KeyboardReturnType[KeyboardReturnType.GO = 4] = "GO", KeyboardReturnType[KeyboardReturnType.NEXT = 5] = "NEXT";
}(KeyboardReturnType || (KeyboardReturnType = {})), Enum(KeyboardReturnType), function(InputMode) {
    InputMode[InputMode.ANY = 0] = "ANY", InputMode[InputMode.EMAIL_ADDR = 1] = "EMAIL_ADDR", 
    InputMode[InputMode.NUMERIC = 2] = "NUMERIC", InputMode[InputMode.PHONE_NUMBER = 3] = "PHONE_NUMBER", 
    InputMode[InputMode.URL = 4] = "URL", InputMode[InputMode.DECIMAL = 5] = "DECIMAL", 
    InputMode[InputMode.SINGLE_LINE = 6] = "SINGLE_LINE";
}(InputMode || (InputMode = {})), Enum(InputMode), function(InputFlag) {
    InputFlag[InputFlag.PASSWORD = 0] = "PASSWORD", InputFlag[InputFlag.SENSITIVE = 1] = "SENSITIVE", 
    InputFlag[InputFlag.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", InputFlag[InputFlag.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", 
    InputFlag[InputFlag.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", 
    InputFlag[InputFlag.DEFAULT = 5] = "DEFAULT";
}(InputFlag || (InputFlag = {})), Enum(InputFlag);

var _matrix$1 = new Mat4(), _matrix_temp = new Mat4(), _vec3 = new Vec3(), _currentEditBoxImpl = null, polyfill = {
    zoomInvalid: !1
};

cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = !0);

var _dec$I, _dec2$o, _dec3$d, _dec4$a, _dec5$a, _dec6$9, _dec7$7, _dec8$5, _dec9$4, _dec10$3, _dec11$3, _dec12$3, _class$J, _class2$B, _descriptor$z, _descriptor2$q, _descriptor3$g, _descriptor4$d, _descriptor5$b, _descriptor6$6, _descriptor7$6, _descriptor8$6, _descriptor9$6, _descriptor10$5, _descriptor11$4, _descriptor12$4, _descriptor13$4, _descriptor14$4, _descriptor15$2, _descriptor16$2, _descriptor17$1, _descriptor18, _descriptor19, _class3$i, _temp$E, EditBoxImpl = ccclass(_class$I = function() {
    function EditBoxImpl() {
        _classCallCheck(this, EditBoxImpl), this._delegate = null, this._inputMode = -1, 
        this._inputFlag = -1, this._returnType = KeyboardReturnType.DEFAULT, this._maxLength = 50, 
        this._text = "", this._placeholderText = "", this._alwaysOnTop = !1, this._size = cc.size(), 
        this._node = null, this._editing = !1, this.__eventListeners = {}, this.__fullscreen = !1, 
        this.__autoResize = !1, this.__rotateScreen = !1, this.__orientationChanged = void 0, 
        this._edTxt = null, this._textColor = Color.WHITE.clone(), this._edFontSize = 14, 
        this._isTextArea = !1;
    }
    return _createClass(EditBoxImpl, [ {
        key: "onEnable",
        value: function onEnable() {
            this._edTxt && (this._alwaysOnTop ? this._edTxt.style.display = "" : this._edTxt.style.display = "none");
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._edTxt && (this._edTxt.style.display = "none");
        }
    }, {
        key: "setTabIndex",
        value: function setTabIndex(index) {
            this._edTxt && (this._edTxt.tabIndex = index);
        }
    }, {
        key: "setFocus",
        value: function setFocus() {
            this._beginEditing();
        }
    }, {
        key: "isFocused",
        value: function isFocused() {
            return this._edTxt ? document.activeElement === this._edTxt : (cc.warnID(4700), 
            !1);
        }
    }, {
        key: "stayOnTop",
        value: function stayOnTop(flag) {
            this._alwaysOnTop !== flag && this._edTxt && (this._alwaysOnTop = flag, this._edTxt.style.display = flag ? "" : "none");
        }
    }, {
        key: "setMaxLength",
        value: function setMaxLength(maxLength) {
            isNaN(maxLength) || (maxLength < 0 && (maxLength = 65535), this._maxLength = maxLength, 
            this._edTxt && (this._edTxt.maxLength = maxLength));
        }
    }, {
        key: "setString",
        value: function setString(text) {
            this._text = text, this._edTxt && (this._edTxt.value = text);
        }
    }, {
        key: "getString",
        value: function getString() {
            return this._text;
        }
    }, {
        key: "setPlaceholderText",
        value: function setPlaceholderText(text) {
            this._placeholderText = text;
        }
    }, {
        key: "getPlaceholderText",
        value: function getPlaceholderText() {
            return this._placeholderText;
        }
    }, {
        key: "setDelegate",
        value: function setDelegate(delegate) {
            this._delegate = delegate;
        }
    }, {
        key: "setInputMode",
        value: function setInputMode(inputMode) {
            this._inputMode !== inputMode && (this._inputMode = inputMode, this.createInput(), 
            this._updateDomInputType(), this._updateSize(this._size.width, this._size.height));
        }
    }, {
        key: "setInputFlag",
        value: function setInputFlag(inputFlag) {
            if (this._inputFlag !== inputFlag) {
                this._inputFlag = inputFlag, this._updateDomInputType();
                var textTransform = "none";
                inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                this._edTxt && (this._edTxt.style.textTransform = textTransform, this._edTxt.value = this._text);
            }
        }
    }, {
        key: "setReturnType",
        value: function setReturnType(returnType) {
            this._returnType = returnType, this._updateDomInputType();
        }
    }, {
        key: "setFontSize",
        value: function setFontSize(fontSize) {
            this._edFontSize = fontSize || this._edFontSize, this._edTxt && (this._edTxt.style.fontSize = this._edFontSize + "px");
        }
    }, {
        key: "setFontColor",
        value: function setFontColor(color) {
            this._textColor = color, this._edTxt && (this._edTxt.style.color = color.toCSS("rgba"));
        }
    }, {
        key: "setSize",
        value: function setSize(width, height) {
            this._size.width = width, this._size.height = height, this._updateSize(width, height);
        }
    }, {
        key: "setNode",
        value: function setNode(node) {
            this._node = node;
        }
    }, {
        key: "update",
        value: function update() {
            this._updateMatrix();
        }
    }, {
        key: "clear",
        value: function clear() {
            this._node = null, this.setDelegate(null), this.removeDom();
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(touch) {}
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded() {
            this._beginEditing();
        }
    }, {
        key: "_beginEditing",
        value: function _beginEditing() {
            cc.sys.isMobile && !this._editing && this._beginEditingOnMobile();
            var self = this;
            function startFocus() {
                self._edTxt && self._edTxt.focus();
            }
            this._edTxt && (this._edTxt.style.display = "", cc.sys.browserType === cc.sys.BROWSER_TYPE_UC ? setTimeout(startFocus, 400) : cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX ? setTimeout(startFocus, 0) : startFocus()), 
            this._editing = !0;
        }
    }, {
        key: "_endEditing",
        value: function _endEditing() {
            var self = this, hideDomInputAndShowLabel = function hideDomInputAndShowLabel() {
                !self._alwaysOnTop && self._edTxt && (self._edTxt.style.display = "none"), self._delegate && self._delegate.editBoxEditingDidEnded && self._delegate.editBoxEditingDidEnded();
            };
            this._editing && (cc.sys.isMobile ? setTimeout(function() {
                self._endEditingOnMobile(), hideDomInputAndShowLabel();
            }, 400) : hideDomInputAndShowLabel()), this._editing = !1;
        }
    }, {
        key: "_updateDomInputType",
        value: function _updateDomInputType() {
            var inputMode = this._inputMode, edTxt = this._edTxt;
            if (edTxt) {
                if (this._isTextArea) {
                    edTxt = edTxt;
                    var textTransform = "none";
                    return this._inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : this._inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                    void (edTxt.style.textTransform = textTransform);
                }
                if (edTxt = edTxt, this._inputFlag !== InputFlag.PASSWORD) {
                    var type = edTxt.type;
                    inputMode === InputMode.EMAIL_ADDR ? type = "email" : inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL ? type = "number" : inputMode === InputMode.PHONE_NUMBER ? (type = "number", 
                    edTxt.pattern = "[0-9]*") : inputMode === InputMode.URL ? type = "url" : (type = "text", 
                    this._returnType === KeyboardReturnType.SEARCH && (type = "search")), edTxt.type = type;
                } else edTxt.type = "password";
            }
        }
    }, {
        key: "_updateSize",
        value: function _updateSize(newWidth, newHeight) {
            var edTxt = this._edTxt;
            edTxt && (edTxt.style.width = newWidth + "px", edTxt.style.height = newHeight + "px");
        }
    }, {
        key: "_updateMatrix",
        value: function _updateMatrix() {
            if (this._edTxt) {
                var node = this._node, scaleX = cc.view._scaleX, scaleY = cc.view._scaleY, viewport = cc.view._viewportRect, dpr = cc.view._devicePixelRatio;
                node.getWorldMatrix(_matrix$1);
                var transform = node.uiTransfromComp;
                transform && Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z), 
                Mat4.transform(_matrix$1, _matrix$1, _vec3);
                var renderComp = node.getComponent(UIRenderComponent);
                if (!renderComp) return !1;
                var canvas = cc.director.root.ui.getScreen(renderComp.visibility);
                if (canvas) {
                    canvas.node.getWorldRT(_matrix_temp);
                    var m12 = _matrix_temp.m12, m13 = _matrix_temp.m13, center = cc.visibleRect.center;
                    _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13), 
                    _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13), 
                    Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1), scaleX /= dpr, scaleY /= dpr;
                    var container = cc.game.container, a = _matrix_temp.m00 * scaleX, b = _matrix$1.m01, c = _matrix$1.m04, d = _matrix_temp.m05 * scaleY, offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
                    offsetX += viewport.x / dpr;
                    var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
                    offsetY += viewport.y / dpr;
                    var tx = _matrix_temp.m12 * scaleX + offsetX, ty = _matrix_temp.m13 * scaleY + offsetY;
                    polyfill.zoomInvalid && (this._updateSize(this._size.width * a, this._size.height * d), 
                    a = 1, d = 1);
                    var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                    this._edTxt.style.transform = matrix, this._edTxt.style["-webkit-transform"] = matrix, 
                    this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
                }
            }
        }
    }, {
        key: "_adjustEditBoxPosition",
        value: function _adjustEditBoxPosition() {
            this._node.getWorldMatrix(_matrix$1);
            var y = _matrix$1.m13, windowHeight = cc.visibleRect.height, windowWidth = cc.visibleRect.width, factor = .5;
            windowWidth > windowHeight && (factor = .7), setTimeout(function() {
                if (window.scrollY < 40 && y < windowHeight * factor) {
                    var scrollOffset = windowHeight * factor - y - window.scrollY;
                    scrollOffset < 35 && (scrollOffset = 35), scrollOffset > 320 && (scrollOffset = 320), 
                    window.scrollTo(0, scrollOffset);
                }
            }, 400);
        }
    }, {
        key: "createInput",
        value: function createInput() {
            this._isTextArea = !1, this._inputMode === InputMode.ANY ? (this._isTextArea = !0, 
            this._createDomTextArea()) : this._createDomInput();
        }
    }, {
        key: "_beginEditingOnMobile",
        value: function _beginEditingOnMobile() {
            var self = this;
            this.__orientationChanged = function() {
                self._adjustEditBoxPosition();
            }, window.addEventListener("orientationchange", this.__orientationChanged), cc.view.isAutoFullScreenEnabled() ? (this.__fullscreen = !0, 
            cc.view.enableAutoFullScreen(!1), cc.screen.exitFullScreen()) : this.__fullscreen = !1, 
            this.__autoResize = cc.view._resizeWithBrowserSize, cc.view.resizeWithBrowserSize(!1), 
            _currentEditBoxImpl = this;
        }
    }, {
        key: "_endEditingOnMobile",
        value: function _endEditingOnMobile() {
            if (this.__rotateScreen) {
                cc.game.container.style["-webkit-transform"] = "rotate(90deg)", cc.game.container.style.transform = "rotate(90deg)";
                var view = cc.view, width = view._originalDesignResolutionSize.width, height = view._originalDesignResolutionSize.height;
                width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy), 
                this.__rotateScreen = !1;
            }
            this.__orientationChanged && window.removeEventListener("orientationchange", this.__orientationChanged), 
            this.__fullscreen && cc.view.enableAutoFullScreen(!0), this.__autoResize && _currentEditBoxImpl === this && cc.view.resizeWithBrowserSize(!0);
        }
    }, {
        key: "_createDomInput",
        value: function _createDomInput() {
            this.removeDom();
            var tmpEdTxt = this._edTxt = document.createElement("input");
            return tmpEdTxt.type = "text", tmpEdTxt.style.fontSize = this._edFontSize + "px", 
            tmpEdTxt.style.color = "#000000", tmpEdTxt.style.border = "0px", tmpEdTxt.style.background = "transparent", 
            tmpEdTxt.style.width = "100%", tmpEdTxt.style.height = "100%", tmpEdTxt.style.outline = "medium", 
            tmpEdTxt.style.padding = "0", tmpEdTxt.style.textTransform = "uppercase", tmpEdTxt.style.display = "none", 
            tmpEdTxt.style.position = "absolute", tmpEdTxt.style.bottom = "0px", tmpEdTxt.style.left = "2px", 
            tmpEdTxt.style["-moz-appearance"] = "textfield", tmpEdTxt.className = "cocosEditBox", 
            tmpEdTxt.style.fontFamily = "Arial", registerInputEventListener(tmpEdTxt, this), 
            tmpEdTxt;
        }
    }, {
        key: "_createDomTextArea",
        value: function _createDomTextArea() {
            this.removeDom();
            var tmpEdTxt = this._edTxt = document.createElement("textarea");
            return tmpEdTxt.style.fontSize = this._edFontSize + "px", tmpEdTxt.style.color = "#000000", 
            tmpEdTxt.style.border = "0", tmpEdTxt.style.background = "transparent", tmpEdTxt.style.width = "100%", 
            tmpEdTxt.style.height = "100%", tmpEdTxt.style.outline = "medium", tmpEdTxt.style.padding = "0", 
            tmpEdTxt.style.resize = "none", tmpEdTxt.style.textTransform = "uppercase", tmpEdTxt.style.overflowY = "scroll", 
            tmpEdTxt.style.display = "none", tmpEdTxt.style.position = "absolute", tmpEdTxt.style.bottom = "0px", 
            tmpEdTxt.style.left = "2px", tmpEdTxt.className = "cocosEditBox", tmpEdTxt.style.fontFamily = "Arial", 
            registerInputEventListener(tmpEdTxt, this, !0), tmpEdTxt;
        }
    }, {
        key: "_addDomToGameContainer",
        value: function _addDomToGameContainer() {
            cc.game.container.appendChild(this._edTxt);
        }
    }, {
        key: "removeDom",
        value: function removeDom() {
            var edTxt = this._edTxt;
            if (edTxt) {
                var cbs = this.__eventListeners;
                edTxt.removeEventListener("compositionstart", cbs.compositionstart), edTxt.removeEventListener("compositionend", cbs.compositionend), 
                edTxt.removeEventListener("input", cbs.input), edTxt.removeEventListener("focus", cbs.focus), 
                edTxt.removeEventListener("keypress", cbs.keypress), edTxt.removeEventListener("blur", cbs.blur), 
                cbs.compositionstart = null, cbs.compositionend = null, cbs.input = null, cbs.focus = null, 
                cbs.keypress = null, cbs.blur = null, contains$1(cc.game.container, edTxt) && cc.game.container.removeChild(edTxt);
            }
            this._edTxt = null;
        }
    }, {
        key: "text",
        get: function get() {
            return this._text;
        },
        set: function set(value) {
            this._text = value;
        }
    }, {
        key: "textColor",
        get: function get() {
            return this._textColor;
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._edFontSize;
        }
    }, {
        key: "returnType",
        set: function set(value) {
            this._returnType = value;
        }
    }, {
        key: "alwayOnTop",
        get: function get() {
            return this._alwaysOnTop;
        }
    }, {
        key: "editing",
        get: function get() {
            return this._editing;
        },
        set: function set(value) {
            this._editing = value;
        }
    }, {
        key: "delegate",
        get: function get() {
            return this._delegate;
        }
    }, {
        key: "eventListeners",
        get: function get() {
            return this.__eventListeners;
        }
    } ]), EditBoxImpl;
}()) || _class$I;

function _inputValueHandle(input, editBoxImpl) {
    input.value.length > editBoxImpl._maxLength && (input.value = input.value.slice(0, editBoxImpl._maxLength)), 
    editBoxImpl._delegate && editBoxImpl._delegate.editBoxTextChanged && editBoxImpl._text !== input.value && (editBoxImpl._text = input.value, 
    editBoxImpl._delegate.editBoxTextChanged(editBoxImpl._text));
}

function registerInputEventListener(tmpEdTxt, editBoxImpl) {
    var isTextarea = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], inputLock = !1, cbs = editBoxImpl.eventListeners;
    cbs.compositionstart = function() {
        inputLock = !0;
    }, tmpEdTxt.addEventListener("compositionstart", cbs.compositionstart), cbs.compositionend = function() {
        inputLock = !1, _inputValueHandle(this, editBoxImpl);
    }, tmpEdTxt.addEventListener("compositionend", cbs.compositionend), cbs.input = function() {
        inputLock || _inputValueHandle(this, editBoxImpl);
    }, tmpEdTxt.addEventListener("input", cbs.input), cbs.focus = function() {
        this.style.fontSize = editBoxImpl.fontSize + "px", this.style.color = editBoxImpl.textColor.toCSS("rgba"), 
        editBoxImpl.alwayOnTop && (editBoxImpl.editing = !0), cc.sys.isMobile && editBoxImpl._beginEditingOnMobile(), 
        editBoxImpl.delegate && editBoxImpl.delegate.editBoxEditingDidBegan && editBoxImpl.delegate.editBoxEditingDidBegan();
    }, tmpEdTxt.addEventListener("focus", cbs.focus), cbs.keypress = function(e) {
        e.keyCode === macro.KEY.enter && (e.propagationStopped = !0, editBoxImpl.delegate && editBoxImpl.delegate.editBoxEditingReturn && editBoxImpl.delegate.editBoxEditingReturn(), 
        isTextarea || (editBoxImpl.text = this.value, editBoxImpl._endEditing(), cc.game.canvas.focus()));
    }, tmpEdTxt.addEventListener("keypress", cbs.keypress), cbs.blur = function() {
        editBoxImpl.text = this.value, editBoxImpl._endEditing();
    }, tmpEdTxt.addEventListener("blur", cbs.blur), editBoxImpl._addDomToGameContainer();
}

function capitalize(string) {
    return string.replace(/(?:^|\s)\S/g, function(a) {
        return a.toUpperCase();
    });
}

function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

var _dec$J, _dec2$p, _dec3$e, _dec4$b, _dec5$b, _dec6$a, _dec7$8, _dec8$6, _class$K, _class2$C, _descriptor$A, _descriptor2$r, _descriptor3$h, _descriptor4$e, _descriptor5$c, _descriptor6$7, _descriptor7$7, _descriptor8$7, _descriptor9$7, _descriptor10$6, _descriptor11$5, _descriptor12$5, _descriptor13$5, _descriptor14$5, _class3$j, _temp$F, EditBoxComponent = (_dec$I = ccclass("cc.EditBoxComponent"), 
_dec2$o = executionOrder(100), _dec3$d = menu("UI/EditBox"), _dec4$a = property({
    type: SpriteFrame
}), _dec5$a = property({
    type: KeyboardReturnType
}), _dec6$9 = property({
    type: InputFlag
}), _dec7$7 = property({
    type: InputMode
}), _dec8$5 = property({
    type: Color
}), _dec9$4 = property({
    type: EventHandler
}), _dec10$3 = property({
    type: EventHandler
}), _dec11$3 = property({
    type: EventHandler
}), _dec12$3 = property({
    type: EventHandler
}), _dec$I(_class$J = _dec2$o(_class$J = _dec3$d(_class$J = executeInEditMode((_temp$E = _class3$i = function(_Component) {
    function EditBoxComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, EditBoxComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "editingDidBegan", _descriptor$z, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "textChanged", _descriptor2$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "editingReturn", _descriptor4$d, _assertThisInitialized(_this)), 
        _this._impl = null, _this._textLabel = null, _this._placeholderLabel = null, _this._background = null, 
        _initializerDefineProperty(_this, "_returnType", _descriptor5$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useOriginalSize", _descriptor6$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_string", _descriptor7$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_tabIndex", _descriptor8$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_backgroundImage", _descriptor9$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_inputFlag", _descriptor10$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_inputMode", _descriptor11$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontSize", _descriptor12$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineHeight", _descriptor13$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_maxLength", _descriptor14$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontColor", _descriptor15$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_placeholder", _descriptor16$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_placeholderFontSize", _descriptor17$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_placeholderFontColor", _descriptor18, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_stayOnTop", _descriptor19, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(EditBoxComponent, Component), _createClass(EditBoxComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this._impl && this._impl.onEnable();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._impl && this._impl.onDisable();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._impl && this._impl.clear();
        }
    }, {
        key: "_init",
        value: function _init() {
            this._createBackgroundSprite(), this._createLabels(), this.node.on(SystemEventType.SIZE_CHANGED, this._resizeChildNodes, this);
            var impl = this._impl = new EditBoxImpl();
            impl.setDelegate(this), impl.setNode(this.node), impl.setInputMode(this._inputMode), 
            impl.setMaxLength(this._maxLength), impl.setInputFlag(this._inputFlag), impl.setReturnType(this._returnType), 
            impl.setTabIndex(this._tabIndex), impl.setFontColor(this._fontColor), impl.setFontSize(this._fontSize), 
            impl.setPlaceholderText(this._placeholder), this._updateStayOnTop(), this._updateString(this._string), 
            this._syncSize();
        }
    }, {
        key: "__preload",
        value: function __preload() {
            this._registerEvent(), this._init();
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_updateStayOnTop",
        value: function _updateStayOnTop() {
            this.stayOnTop ? this._hideLabels() : this._showLabels(), this._impl && this._impl.stayOnTop(this.stayOnTop);
        }
    }, {
        key: "_syncSize",
        value: function _syncSize() {
            var size = this.node.getContentSize();
            this._background && (this._background.node.setAnchorPoint(this.node.getAnchorPoint()), 
            this._background.node.setContentSize(size)), this._updateLabelPosition(size), this._impl && this._impl.setSize(size.width, size.height);
        }
    }, {
        key: "_updateLabelPosition",
        value: function _updateLabelPosition(size) {
            var node = this.node, offx = -node.anchorX * node.width, offy = -node.anchorY * node.height, placeholderLabel = this._placeholderLabel, textLabel = this._textLabel;
            textLabel && (textLabel.node.setContentSize(size.width - 2, size.height), textLabel.node.setPosition(offx + 2, offy + size.height, textLabel.node.getPosition().z), 
            textLabel.verticalAlign = this._inputMode === InputMode.ANY ? VerticalTextAlignment.TOP : VerticalTextAlignment.CENTER, 
            textLabel.enableWrapText = this._inputMode === InputMode.ANY), placeholderLabel && (placeholderLabel.node.setContentSize(size.width - 2, size.height), 
            placeholderLabel.lineHeight = size.height, placeholderLabel.node.setPosition(offx + 2, offy + size.height, placeholderLabel.node.getPosition().z), 
            placeholderLabel.verticalAlign = this._inputMode === InputMode.ANY ? VerticalTextAlignment.TOP : VerticalTextAlignment.CENTER, 
            placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY);
        }
    }, {
        key: "_createBackgroundSprite",
        value: function _createBackgroundSprite() {
            this._background || (this._background = this.node.getComponent(cc.SpriteComponent), 
            this._background || (this._background = this.node.addComponent(cc.SpriteComponent))), 
            this._background.type = cc.SpriteComponent.Type.SLICED, this._background.spriteFrame = this._backgroundImage;
        }
    }, {
        key: "_createLabels",
        value: function _createLabels() {
            if (!this._textLabel) {
                var node = this.node.getChildByName("TEXT_LABEL");
                node || (node = new Node$1("TEXT_LABEL"));
                var textLabel = node.getComponent(LabelComponent);
                node.parent = this.node, textLabel || (textLabel = node.addComponent(LabelComponent)), 
                node.getComponent(UITransformComponent).setAnchorPoint(0, 1), textLabel.color = this._fontColor, 
                textLabel.overflow = LabelComponent.Overflow.CLAMP, textLabel.fontSize = this._fontSize, 
                textLabel.lineHeight = this.lineHeight, this._textLabel = textLabel;
            }
            if (!this._placeholderLabel) {
                var _node = this.node.getChildByName("PLACEHOLDER_LABEL");
                _node || (_node = new Node$1("PLACEHOLDER_LABEL"));
                var placeholderLabel = _node.getComponent(LabelComponent);
                placeholderLabel || (placeholderLabel = _node.addComponent(LabelComponent));
                var transform = _node.getComponent(UITransformComponent);
                _node.parent = this.node, placeholderLabel.color = this._placeholderFontColor, transform.setAnchorPoint(0, 1), 
                placeholderLabel.overflow = LabelComponent.Overflow.CLAMP, placeholderLabel.fontSize = this._placeholderFontSize, 
                placeholderLabel.string = this._placeholder, this._placeholderLabel = placeholderLabel;
            }
        }
    }, {
        key: "_resizeChildNodes",
        value: function _resizeChildNodes() {
            var textLabelNode = this._textLabel && this._textLabel.node;
            textLabelNode && (textLabelNode.setPosition(-this.node.width / 2, this.node.height / 2, textLabelNode.getPosition().z), 
            textLabelNode.width = this.node.width, textLabelNode.height = this.node.height);
            var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
            placeholderLabelNode && (placeholderLabelNode.setPosition(-this.node.width / 2, this.node.height / 2, placeholderLabelNode.getPosition().z), 
            placeholderLabelNode.width = this.node.width, placeholderLabelNode.height = this.node.height);
            var backgroundNode = this._background && this._background.node;
            backgroundNode && (backgroundNode.width = this.node.width, backgroundNode.height = this.node.height);
        }
    }, {
        key: "_showLabels",
        value: function _showLabels() {
            if (this._textLabel) {
                var displayText = this._textLabel.string;
                this._textLabel.node.active = "" !== displayText, this._placeholderLabel && (this._placeholderLabel.node.active = "" === displayText);
            }
        }
    }, {
        key: "_hideLabels",
        value: function _hideLabels() {
            this._textLabel && (this._textLabel.node.active = !1), this._placeholderLabel && (this._placeholderLabel.node.active = !1);
        }
    }, {
        key: "_updateString",
        value: function _updateString(text) {
            var textLabel = this._textLabel;
            if (textLabel) {
                var displayText = text;
                displayText && (displayText = this._updateLabelStringStyle(displayText)), textLabel.string = displayText, 
                this._impl && (this._impl.setString(text), this._impl.editing || this.stayOnTop || this._showLabels());
            }
        }
    }, {
        key: "_updateLabelStringStyle",
        value: function _updateLabelStringStyle(text) {
            var ignorePassword = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], inputFlag = this._inputFlag;
            if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = capitalize(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = capitalizeFirstLetter(text)); else {
                for (var passwordString = "", len = text.length, i = 0; i < len; ++i) passwordString += "";
                text = passwordString;
            }
            return text;
        }
    }, {
        key: "editBoxEditingDidBegan",
        value: function editBoxEditingDidBegan() {
            this._hideLabels(), EventHandler.emitEvents(this.editingDidBegan, this), this.node.emit("editing-did-began", this);
        }
    }, {
        key: "editBoxEditingDidEnded",
        value: function editBoxEditingDidEnded() {
            this.stayOnTop || this._showLabels(), EventHandler.emitEvents(this.editingDidEnded, this), 
            this.node.emit("editing-did-ended", this);
        }
    }, {
        key: "editBoxTextChanged",
        value: function editBoxTextChanged(text) {
            text = this._updateLabelStringStyle(text, !0), this.string = text, EventHandler.emitEvents(this.textChanged, text, this), 
            this.node.emit("text-changed", this);
        }
    }, {
        key: "editBoxEditingReturn",
        value: function editBoxEditingReturn() {
            EventHandler.emitEvents(this.editingReturn, this), this.node.emit("editing-return", this);
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event) {
            this._impl && this._impl._onTouchBegan(event.touch), event.propagationStopped = !0;
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            this._impl && this._impl._onTouchEnded(), event.propagationStopped = !0;
        }
    }, {
        key: "setFocus",
        value: function setFocus() {
            this._impl && this._impl.setFocus();
        }
    }, {
        key: "isFocused",
        value: function isFocused() {
            var isFocused = !1;
            return this._impl && (isFocused = this._impl.isFocused()), isFocused;
        }
    }, {
        key: "update",
        value: function update() {
            this._impl && this._impl.update();
        }
    }, {
        key: "string",
        get: function get() {
            return this._string;
        },
        set: function set(value) {
            this._maxLength >= 0 && value.length >= this._maxLength && (value = value.slice(0, this._maxLength)), 
            this._string = value, this._impl && this._updateString(value);
        }
    }, {
        key: "backgroundImage",
        get: function get() {
            return this._backgroundImage;
        },
        set: function set(value) {
            this._backgroundImage !== value && (this._backgroundImage = value, this._createBackgroundSprite());
        }
    }, {
        key: "returnType",
        get: function get() {
            return this._returnType;
        },
        set: function set(value) {
            this._returnType = value, this._impl && (this._impl.returnType = this._returnType);
        }
    }, {
        key: "inputFlag",
        get: function get() {
            return this._inputFlag;
        },
        set: function set(value) {
            this._inputFlag = value, this._impl && (this._impl.setInputFlag(this._inputFlag), 
            this._updateString(this._string));
        }
    }, {
        key: "inputMode",
        get: function get() {
            return this._inputMode;
        },
        set: function set(value) {
            this._inputMode = value, this._impl && this._impl.setInputMode(this._inputMode);
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._fontSize;
        },
        set: function set(value) {
            this._fontSize !== value && (this._fontSize = value, this._textLabel && (this._textLabel.fontSize = this._fontSize), 
            this._impl && this._impl.setFontSize(this._fontSize));
        }
    }, {
        key: "lineHeight",
        get: function get() {
            return this._lineHeight;
        },
        set: function set(value) {
            this._lineHeight !== value && (this._lineHeight = value, this._textLabel && (this._textLabel.lineHeight = this._lineHeight));
        }
    }, {
        key: "fontColor",
        get: function get() {
            return this._fontColor;
        },
        set: function set(value) {
            if (this._fontColor !== value) {
                if (this._fontColor.set(value), this._textLabel) {
                    var renderComp = this._textLabel.node.getComponent(UIRenderComponent);
                    renderComp && (renderComp.color = this._fontColor);
                }
                this._impl && this._impl.setFontColor(this._fontColor);
            }
        }
    }, {
        key: "placeholder",
        get: function get() {
            return this._placeholder;
        },
        set: function set(value) {
            this._placeholder !== value && (this._placeholder = value, this._placeholderLabel && (this._placeholderLabel.string = this._placeholder), 
            this._impl && this._impl.setPlaceholderText(this._placeholder));
        }
    }, {
        key: "placeholderFontSize",
        get: function get() {
            return this._placeholderFontSize;
        },
        set: function set(value) {
            this._placeholderFontSize !== value && (this._placeholderFontSize = value, this._placeholderLabel && (this._placeholderLabel.fontSize = this._placeholderFontSize));
        }
    }, {
        key: "placeholderFontColor",
        get: function get() {
            return this._placeholderFontColor;
        },
        set: function set(value) {
            if (this._placeholderFontColor !== value && (this._placeholderFontColor = value, 
            this._placeholderLabel)) {
                var comp = this._placeholderLabel.node.getComponent(UIRenderComponent);
                comp && (comp.color = this._placeholderFontColor);
            }
        }
    }, {
        key: "maxLength",
        get: function get() {
            return this._maxLength;
        },
        set: function set(value) {
            this._maxLength !== value && (this._maxLength = value, this._impl && this._impl.setMaxLength(this._maxLength));
        }
    }, {
        key: "stayOnTop",
        get: function get() {
            return this._stayOnTop;
        },
        set: function set(value) {
            this._stayOnTop = value, this._impl && this._updateStayOnTop();
        }
    }, {
        key: "tabIndex",
        get: function get() {
            return this._tabIndex;
        },
        set: function set(value) {
            this._tabIndex = value, this._impl && this._impl.setTabIndex(value);
        }
    } ]), EditBoxComponent;
}(), _class3$i._EditBoxImpl = EditBoxImpl, _class3$i.KeyboardReturnType = KeyboardReturnType, 
_class3$i.InputFlag = InputFlag, _class3$i.InputMode = InputMode, _applyDecoratedDescriptor((_class2$B = _temp$E).prototype, "string", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "string"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "backgroundImage", [ _dec4$a ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "backgroundImage"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "returnType", [ _dec5$a ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "returnType"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "inputFlag", [ _dec6$9 ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "inputFlag"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "inputMode", [ _dec7$7 ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "inputMode"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "fontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "fontSize"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "lineHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "lineHeight"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "fontColor", [ _dec8$5 ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "fontColor"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "placeholder", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "placeholder"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "placeholderFontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "placeholderFontSize"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "placeholderFontColor", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "placeholderFontColor"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "maxLength", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "maxLength"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "stayOnTop", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "stayOnTop"), _class2$B.prototype), 
_applyDecoratedDescriptor(_class2$B.prototype, "tabIndex", [ property ], Object.getOwnPropertyDescriptor(_class2$B.prototype, "tabIndex"), _class2$B.prototype), 
_descriptor$z = _applyDecoratedDescriptor(_class2$B.prototype, "editingDidBegan", [ _dec9$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$q = _applyDecoratedDescriptor(_class2$B.prototype, "textChanged", [ _dec10$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$g = _applyDecoratedDescriptor(_class2$B.prototype, "editingDidEnded", [ _dec11$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor4$d = _applyDecoratedDescriptor(_class2$B.prototype, "editingReturn", [ _dec12$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$b = _applyDecoratedDescriptor(_class2$B.prototype, "_returnType", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return KeyboardReturnType.DEFAULT;
    }
}), _descriptor6$6 = _applyDecoratedDescriptor(_class2$B.prototype, "_useOriginalSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor7$6 = _applyDecoratedDescriptor(_class2$B.prototype, "_string", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor8$6 = _applyDecoratedDescriptor(_class2$B.prototype, "_tabIndex", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$6 = _applyDecoratedDescriptor(_class2$B.prototype, "_backgroundImage", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor10$5 = _applyDecoratedDescriptor(_class2$B.prototype, "_inputFlag", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return InputFlag.DEFAULT;
    }
}), _descriptor11$4 = _applyDecoratedDescriptor(_class2$B.prototype, "_inputMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return InputMode.ANY;
    }
}), _descriptor12$4 = _applyDecoratedDescriptor(_class2$B.prototype, "_fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 20;
    }
}), _descriptor13$4 = _applyDecoratedDescriptor(_class2$B.prototype, "_lineHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor14$4 = _applyDecoratedDescriptor(_class2$B.prototype, "_maxLength", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 20;
    }
}), _descriptor15$2 = _applyDecoratedDescriptor(_class2$B.prototype, "_fontColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor16$2 = _applyDecoratedDescriptor(_class2$B.prototype, "_placeholder", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "Enter text here...";
    }
}), _descriptor17$1 = _applyDecoratedDescriptor(_class2$B.prototype, "_placeholderFontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 20;
    }
}), _descriptor18 = _applyDecoratedDescriptor(_class2$B.prototype, "_placeholderFontColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.GRAY.clone();
    }
}), _descriptor19 = _applyDecoratedDescriptor(_class2$B.prototype, "_stayOnTop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$J = _class2$B)) || _class$J) || _class$J) || _class$J) || _class$J);

cc.EditBoxComponent = EditBoxComponent;

var Type, ResizeMode, AxisDirection, VerticalDirection, HorizontalDirection, NodeEvent = SystemEventType;

!function(Type) {
    Type[Type.NONE = 0] = "NONE", Type[Type.HORIZONTAL = 1] = "HORIZONTAL", Type[Type.VERTICAL = 2] = "VERTICAL", 
    Type[Type.GRID = 3] = "GRID";
}(Type || (Type = {})), ccenum(Type), function(ResizeMode) {
    ResizeMode[ResizeMode.NONE = 0] = "NONE", ResizeMode[ResizeMode.CONTAINER = 1] = "CONTAINER", 
    ResizeMode[ResizeMode.CHILDREN = 2] = "CHILDREN";
}(ResizeMode || (ResizeMode = {})), ccenum(ResizeMode), function(AxisDirection) {
    AxisDirection[AxisDirection.HORIZONTAL = 0] = "HORIZONTAL", AxisDirection[AxisDirection.VERTICAL = 1] = "VERTICAL";
}(AxisDirection || (AxisDirection = {})), ccenum(AxisDirection), function(VerticalDirection) {
    VerticalDirection[VerticalDirection.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", VerticalDirection[VerticalDirection.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM";
}(VerticalDirection || (VerticalDirection = {})), ccenum(VerticalDirection), function(HorizontalDirection) {
    HorizontalDirection[HorizontalDirection.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", HorizontalDirection[HorizontalDirection.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT";
}(HorizontalDirection || (HorizontalDirection = {})), ccenum(HorizontalDirection);

var LineCap, LineJoin, PointFlags, _dec$K, _dec2$q, _dec3$f, _dec4$c, _dec5$c, _dec6$b, _class$L, _class2$D, _descriptor$B, _descriptor2$s, _descriptor3$i, _descriptor4$f, _descriptor5$d, _descriptor6$8, _class3$k, _temp$G, _tempPos$1 = new Vec3(), _tempScale = new Vec3(), LayoutComponent = (_dec$J = ccclass("cc.LayoutComponent"), 
_dec2$p = executionOrder(110), _dec3$e = menu("UI/Layout"), _dec4$b = property({
    type: Type
}), _dec5$b = property({
    type: ResizeMode
}), _dec6$a = property({
    type: AxisDirection
}), _dec7$8 = property({
    type: VerticalDirection
}), _dec8$6 = property({
    type: HorizontalDirection
}), _dec$J(_class$K = _dec2$p(_class$K = _dec3$e(_class$K = executeInEditMode((_temp$F = _class3$j = function(_Component) {
    function LayoutComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, LayoutComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LayoutComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._layoutDirty = !0, 
        _initializerDefineProperty(_this, "_resizeMode", _descriptor$A, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_N$layoutType", _descriptor2$r, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_N$padding", _descriptor3$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cellSize", _descriptor4$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_startAxis", _descriptor5$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingLeft", _descriptor6$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingRight", _descriptor7$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingTop", _descriptor8$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingBottom", _descriptor9$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spacingX", _descriptor10$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spacingY", _descriptor11$5, _assertThisInitialized(_this)), 
        _this._layoutSize = new Size(300, 200), _initializerDefineProperty(_this, "_verticalDirection", _descriptor12$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalDirection", _descriptor13$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_affectedByScale", _descriptor14$5, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(LayoutComponent, Component), _createClass(LayoutComponent, [ {
        key: "updateLayout",
        value: function updateLayout() {
            this._layoutDirty && this.node.children.length > 0 && (this._doLayout(), this._layoutDirty = !1);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._addEventListeners(), this.node.getContentSize().equals(new Size()) && this.node.setContentSize(this._layoutSize), 
            0 !== this._N$padding && this._migratePaddingData(), this._doLayoutDirty();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._removeEventListeners();
        }
    }, {
        key: "_migratePaddingData",
        value: function _migratePaddingData() {
            this._paddingLeft = this._N$padding, this._paddingRight = this._N$padding, this._paddingTop = this._N$padding, 
            this._paddingBottom = this._N$padding, this._N$padding = 0;
        }
    }, {
        key: "_addEventListeners",
        value: function _addEventListeners() {
            cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this), 
            this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this), 
            this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._addChildrenEventListeners();
        }
    }, {
        key: "_removeEventListeners",
        value: function _removeEventListeners() {
            cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this), 
            this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this), 
            this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._removeChildrenEventListeners();
        }
    }, {
        key: "_addChildrenEventListeners",
        value: function _addChildrenEventListeners() {
            var _iterator = this.node.children, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var child = _ref;
                child.on(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
            }
        }
    }, {
        key: "_removeChildrenEventListeners",
        value: function _removeChildrenEventListeners() {
            var _iterator2 = this.node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var child = _ref2;
                child.off(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
            }
        }
    }, {
        key: "_childAdded",
        value: function _childAdded(child) {
            child.on(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
            child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
            child.on("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
        }
    }, {
        key: "_childRemoved",
        value: function _childRemoved(child) {
            child.off(NodeEvent.SCALE_PART, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
            child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
            child.off("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
        }
    }, {
        key: "_resized",
        value: function _resized() {
            this._layoutSize = this.node.getContentSize(), this._doLayoutDirty();
        }
    }, {
        key: "_doLayoutHorizontally",
        value: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
            var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingX = this._paddingLeft, startPos = -layoutAnchor.x * baseWidth;
            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, startPos = (1 - layoutAnchor.x) * baseWidth, 
            paddingX = this._paddingRight);
            var nextX = startPos + sign * paddingX - sign * this._spacingX, rowMaxHeight = 0, tempMaxHeight = 0, secondMaxHeight = 0, row = 0, containerResizeBoundary = 0, maxHeightChildAnchorY = 0, activeChildCount = 0, _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                _ref3.activeInHierarchy && activeChildCount++;
            }
            var newChildWidth = this._cellSize.width;
            this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this._paddingLeft + this._paddingRight) - (activeChildCount - 1) * this._spacingX) / activeChildCount);
            var _iterator4 = children, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                var _child = _ref4;
                if (_child.activeInHierarchy) {
                    _child.getScale(_tempScale);
                    var childScaleX = this._getUsedScaleValue(_tempScale.x), childScaleY = this._getUsedScaleValue(_tempScale.y);
                    this._resizeMode === ResizeMode.CHILDREN && (_child.width = newChildWidth / childScaleX, 
                    this._N$layoutType === Type.GRID && (_child.height = this._cellSize.height / childScaleY));
                    var anchorX = _child.anchorX, childBoundingBoxWidth = _child.width * childScaleX, childBoundingBoxHeight = _child.height * childScaleY;
                    secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight), childBoundingBoxHeight >= tempMaxHeight && (secondMaxHeight = tempMaxHeight, 
                    tempMaxHeight = childBoundingBoxHeight, maxHeightChildAnchorY = _child.getAnchorPoint().y), 
                    this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - _child.anchorX), 
                    nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this._spacingX;
                    var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
                    if (rowBreak) {
                        var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft), leftToRightRowBreak = !1;
                        this._horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth && (leftToRightRowBreak = !0);
                        var rightToLeftRowBreak = !1;
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth && (rightToLeftRowBreak = !0), 
                        (leftToRightRowBreak || rightToLeftRowBreak) && (childBoundingBoxHeight >= tempMaxHeight ? (0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight), 
                        rowMaxHeight += secondMaxHeight, secondMaxHeight = tempMaxHeight) : (rowMaxHeight += tempMaxHeight, 
                        secondMaxHeight = childBoundingBoxHeight, tempMaxHeight = 0), nextX = startPos + sign * (paddingX + anchorX * childBoundingBoxWidth), 
                        row++);
                    }
                    var finalPositionY = fnPositionY(_child, rowMaxHeight, row);
                    baseWidth >= childBoundingBoxWidth + this._paddingLeft + this._paddingRight && applyChildren && (_child.getPosition(_tempPos$1), 
                    _child.setPosition(nextX, finalPositionY, _tempPos$1.z));
                    var signX = 1, tempFinalPositionY = void 0, topMarign = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
                    this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM ? (containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().height, 
                    (tempFinalPositionY = finalPositionY + (signX = -1) * (topMarign * maxHeightChildAnchorY + this._paddingBottom)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().height, 
                    (tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this._paddingTop)) > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)), 
                    nextX += rightBoundaryOfChild;
                }
            }
            return containerResizeBoundary;
        }
    }, {
        key: "_doLayoutVertically",
        value: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
            var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingY = this._paddingBottom, bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight, 
            paddingY = this._paddingTop);
            var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this._spacingY, columnMaxWidth = 0, tempMaxWidth = 0, secondMaxWidth = 0, column = 0, containerResizeBoundary = 0, maxWidthChildAnchorX = 0, activeChildCount = 0, _iterator5 = children, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                _ref5.activeInHierarchy && activeChildCount++;
            }
            var newChildHeight = this._cellSize.height;
            this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this._paddingTop + this._paddingBottom) - (activeChildCount - 1) * this._spacingY) / activeChildCount);
            var _iterator6 = children, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    if ((_i6 = _iterator6.next()).done) break;
                    _ref6 = _i6.value;
                }
                var _child2 = _ref6;
                if (_child2) {
                    var scale = _child2.getScale(), childScaleX = this._getUsedScaleValue(scale.x), childScaleY = this._getUsedScaleValue(scale.y);
                    if (_child2.activeInHierarchy) {
                        this._resizeMode === ResizeMode.CHILDREN && (_child2.height = newChildHeight / childScaleY, 
                        this._N$layoutType === Type.GRID && (_child2.width = this._cellSize.width / childScaleX));
                        var anchorY = _child2.anchorY, childBoundingBoxWidth = _child2.width * childScaleX, childBoundingBoxHeight = _child2.height * childScaleY;
                        secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth), childBoundingBoxWidth >= tempMaxWidth && (secondMaxWidth = tempMaxWidth, 
                        tempMaxWidth = childBoundingBoxWidth, maxWidthChildAnchorX = _child2.getAnchorPoint().x), 
                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - _child2.anchorY), 
                        nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this._spacingY;
                        var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
                        if (columnBreak) {
                            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom), bottomToTopColumnBreak = !1;
                            this._verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight && (bottomToTopColumnBreak = !0);
                            var topToBottomColumnBreak = !1;
                            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight && (topToBottomColumnBreak = !0), 
                            (bottomToTopColumnBreak || topToBottomColumnBreak) && (childBoundingBoxWidth >= tempMaxWidth ? (0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth), 
                            columnMaxWidth += secondMaxWidth, secondMaxWidth = tempMaxWidth) : (columnMaxWidth += tempMaxWidth, 
                            secondMaxWidth = childBoundingBoxWidth, tempMaxWidth = 0), nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight), 
                            column++);
                        }
                        var finalPositionX = fnPositionX(_child2, columnMaxWidth, column);
                        baseHeight >= childBoundingBoxHeight + (this._paddingTop + this._paddingBottom) && applyChildren && (_child2.getPosition(_tempPos$1), 
                        _child2.setPosition(finalPositionX, nextY, _tempPos$1.z));
                        var signX = 1, tempFinalPositionX = void 0, rightMarign = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT ? (signX = -1, containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().width, 
                        (tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this._paddingLeft)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().width, 
                        (tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this._paddingRight)) > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)), 
                        nextY += topBoundaryOfChild;
                    }
                }
            }
            return containerResizeBoundary;
        }
    }, {
        key: "_doLayoutBasic",
        value: function _doLayoutBasic() {
            var allChildrenBoundingBox = null, _iterator7 = this.node.children, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                var _ref7;
                if (_isArray7) {
                    if (_i7 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i7++];
                } else {
                    if ((_i7 = _iterator7.next()).done) break;
                    _ref7 = _i7.value;
                }
                var child = _ref7, childTransform = child.getComponent(UITransformComponent);
                childTransform && (child.activeInHierarchy && (allChildrenBoundingBox ? Rect.union(allChildrenBoundingBox, allChildrenBoundingBox, childTransform.getBoundingBoxToWorld()) : allChildrenBoundingBox = childTransform.getBoundingBoxToWorld()));
            }
            if (allChildrenBoundingBox) {
                var parentTransform = this.node.parent.getComponent(UITransformComponent);
                if (!parentTransform) return;
                Vec3.set(_tempPos$1, allChildrenBoundingBox.x, allChildrenBoundingBox.y, 0);
                var leftBottomInParentSpace = new Vec3();
                parentTransform.convertToNodeSpaceAR(_tempPos$1, leftBottomInParentSpace), Vec3.set(leftBottomInParentSpace, leftBottomInParentSpace.x - this._paddingLeft, leftBottomInParentSpace.y - this._paddingBottom, leftBottomInParentSpace.z), 
                Vec3.set(_tempPos$1, allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height, 0);
                var rightTopInParentSpace = new Vec3();
                parentTransform.convertToNodeSpaceAR(_tempPos$1, rightTopInParentSpace), Vec3.set(rightTopInParentSpace, rightTopInParentSpace.x + this._paddingRight, rightTopInParentSpace.y + this._paddingTop, rightTopInParentSpace.z);
                var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
                if (this.node.getPosition(_tempPos$1), 0 !== newSize.width) {
                    var newAnchorX = (_tempPos$1.x - leftBottomInParentSpace.x) / newSize.width;
                    this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
                }
                if (0 !== newSize.height) {
                    var newAnchorY = (_tempPos$1.y - leftBottomInParentSpace.y) / newSize.height;
                    this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
                }
                this.node.setContentSize(newSize);
            }
        }
    }, {
        key: "_doLayoutGridAxisHorizontal",
        value: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
            var _this2 = this, baseWidth = layoutSize.width, sign = 1, bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height, paddingY = this._paddingBottom;
            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height, 
            paddingY = this._paddingTop);
            var self = this, fnPositionY = function fnPositionY(child, topOffset, row) {
                return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * self._getUsedScaleValue(child.getScale().y) + paddingY + row * _this2._spacingY);
            }, newHeight = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                var boundary = this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !1);
                (newHeight = bottomBoundaryOfLayout - boundary) < 0 && (newHeight *= -1), bottomBoundaryOfLayout = -layoutAnchor.y * newHeight, 
                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight);
            }
            this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
        }
    }, {
        key: "_doLayoutGridAxisVertical",
        value: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
            var _this3 = this, baseHeight = layoutSize.height, sign = 1, leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width, paddingX = this._paddingLeft;
            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width, 
            paddingX = this._paddingRight);
            var self = this, fnPositionX = function fnPositionX(child, leftOffset, column) {
                return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * self._getUsedScaleValue(child.getScale().x) + paddingX + column * _this3._spacingX);
            }, newWidth = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                var boundary = this._doLayoutVertically(baseHeight, !0, fnPositionX, !1);
                (newWidth = leftBoundaryOfLayout - boundary) < 0 && (newWidth *= -1), leftBoundaryOfLayout = -layoutAnchor.x * newWidth, 
                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth);
            }
            this._doLayoutVertically(baseHeight, !0, fnPositionX, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
        }
    }, {
        key: "_doLayoutGrid",
        value: function _doLayoutGrid() {
            var layoutAnchor = this.node.getAnchorPoint(), layoutSize = this.node.getContentSize();
            this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
        }
    }, {
        key: "_getHorizontalBaseWidth",
        value: function _getHorizontalBaseWidth(children) {
            var newWidth = 0, activeChildCount = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                var _iterator8 = children, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i8 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i8++];
                    } else {
                        if ((_i8 = _iterator8.next()).done) break;
                        _ref8 = _i8.value;
                    }
                    var child = _ref8;
                    child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newWidth += child.width * this._getUsedScaleValue(_tempScale.x));
                }
                newWidth += (activeChildCount - 1) * this._spacingX + this._paddingLeft + this._paddingRight;
            } else newWidth = this.node.getContentSize().width;
            return newWidth;
        }
    }, {
        key: "_getVerticalBaseHeight",
        value: function _getVerticalBaseHeight(children) {
            var newHeight = 0, activeChildCount = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                var _iterator9 = children, _isArray9 = Array.isArray(_iterator9), _i9 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i9 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i9++];
                    } else {
                        if ((_i9 = _iterator9.next()).done) break;
                        _ref9 = _i9.value;
                    }
                    var child = _ref9;
                    child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newHeight += child.height * this._getUsedScaleValue(_tempScale.y));
                }
                newHeight += (activeChildCount - 1) * this._spacingY + this._paddingBottom + this._paddingTop;
            } else newHeight = this.node.getContentSize().height;
            return newHeight;
        }
    }, {
        key: "_doLayout",
        value: function _doLayout() {
            if (this._N$layoutType === Type.HORIZONTAL) {
                var newWidth = this._getHorizontalBaseWidth(this.node.children);
                this._doLayoutHorizontally(newWidth, !1, function fnPositionY(child) {
                    return child.getPosition(_tempPos$1), _tempPos$1.y;
                }, !0), this.node.width = newWidth;
            } else if (this._N$layoutType === Type.VERTICAL) {
                var newHeight = this._getVerticalBaseHeight(this.node.children);
                this._doLayoutVertically(newHeight, !1, function fnPositionX(child) {
                    return child.getPosition(_tempPos$1), _tempPos$1.x;
                }, !0), this.node.height = newHeight;
            } else this._N$layoutType === Type.NONE ? this._resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this._N$layoutType === Type.GRID && this._doLayoutGrid();
        }
    }, {
        key: "_getUsedScaleValue",
        value: function _getUsedScaleValue(value) {
            return this._affectedByScale ? Math.abs(value) : 1;
        }
    }, {
        key: "_transformDirty",
        value: function _transformDirty(type) {
            type === SystemEventType.POSITION_PART && this._doLayoutDirty();
        }
    }, {
        key: "_doLayoutDirty",
        value: function _doLayoutDirty() {
            this._layoutDirty = !0;
        }
    }, {
        key: "_doScaleDirty",
        value: function _doScaleDirty() {
            this._layoutDirty = this._layoutDirty || this._affectedByScale;
        }
    }, {
        key: "type",
        get: function get() {
            return this._N$layoutType;
        },
        set: function set(value) {
            this._N$layoutType = value, this._doLayoutDirty();
        }
    }, {
        key: "resizeMode",
        get: function get() {
            return this._resizeMode;
        },
        set: function set(value) {
            this._N$layoutType === Type.NONE && value === ResizeMode.CHILDREN || (this._resizeMode = value, 
            this._doLayoutDirty());
        }
    }, {
        key: "cellSize",
        get: function get() {
            return this._cellSize;
        },
        set: function set(value) {
            this._cellSize !== value && (this._cellSize.set(value), this._doLayoutDirty());
        }
    }, {
        key: "startAxis",
        get: function get() {
            return this._startAxis;
        },
        set: function set(value) {
            this._startAxis !== value && (this._startAxis = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingLeft",
        get: function get() {
            return this._paddingLeft;
        },
        set: function set(value) {
            this._paddingLeft !== value && (this._paddingLeft = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingRight",
        get: function get() {
            return this._paddingRight;
        },
        set: function set(value) {
            this._paddingRight !== value && (this._paddingRight = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingTop",
        get: function get() {
            return this._paddingTop;
        },
        set: function set(value) {
            this._paddingTop !== value && (this._paddingTop = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingBottom",
        get: function get() {
            return this._paddingBottom;
        },
        set: function set(value) {
            this._paddingBottom !== value && (this._paddingBottom = value, this._doLayoutDirty());
        }
    }, {
        key: "spacingX",
        get: function get() {
            return this._spacingX;
        },
        set: function set(value) {
            this._spacingX !== value && (this._spacingX = value, this._doLayoutDirty());
        }
    }, {
        key: "spacingY",
        get: function get() {
            return this._spacingY;
        },
        set: function set(value) {
            this._spacingY !== value && (this._spacingY = value, this._doLayoutDirty());
        }
    }, {
        key: "verticalDirection",
        get: function get() {
            return this._verticalDirection;
        },
        set: function set(value) {
            this._verticalDirection !== value && (this._verticalDirection = value, this._doLayoutDirty());
        }
    }, {
        key: "horizontalDirection",
        get: function get() {
            return this._horizontalDirection;
        },
        set: function set(value) {
            this._horizontalDirection !== value && (this._horizontalDirection = value, this._doLayoutDirty());
        }
    }, {
        key: "padding",
        get: function get() {
            return this._paddingLeft;
        },
        set: function set(value) {
            this._N$padding = value, this._migratePaddingData(), this._doLayoutDirty();
        }
    }, {
        key: "affectedByScale",
        get: function get() {
            return this._affectedByScale;
        },
        set: function set(value) {
            this._affectedByScale = value, this._doLayoutDirty();
        }
    } ]), LayoutComponent;
}(), _class3$j.Type = Type, _class3$j.VerticalDirection = VerticalDirection, _class3$j.HorizontalDirection = HorizontalDirection, 
_class3$j.ResizeMode = ResizeMode, _class3$j.AxisDirection = AxisDirection, _applyDecoratedDescriptor((_class2$C = _temp$F).prototype, "type", [ _dec4$b ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "type"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "resizeMode", [ _dec5$b ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "resizeMode"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "cellSize", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "cellSize"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "startAxis", [ _dec6$a ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "startAxis"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "paddingLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "paddingLeft"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "paddingRight", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "paddingRight"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "paddingTop", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "paddingTop"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "paddingBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "paddingBottom"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "spacingX", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "spacingX"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "spacingY", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "spacingY"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "verticalDirection", [ _dec7$8 ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "verticalDirection"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "horizontalDirection", [ _dec8$6 ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "horizontalDirection"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "padding", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "padding"), _class2$C.prototype), 
_applyDecoratedDescriptor(_class2$C.prototype, "affectedByScale", [ property ], Object.getOwnPropertyDescriptor(_class2$C.prototype, "affectedByScale"), _class2$C.prototype), 
_descriptor$A = _applyDecoratedDescriptor(_class2$C.prototype, "_resizeMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ResizeMode.NONE;
    }
}), _descriptor2$r = _applyDecoratedDescriptor(_class2$C.prototype, "_N$layoutType", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Type.NONE;
    }
}), _descriptor3$h = _applyDecoratedDescriptor(_class2$C.prototype, "_N$padding", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor4$e = _applyDecoratedDescriptor(_class2$C.prototype, "_cellSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Size(40, 40);
    }
}), _descriptor5$c = _applyDecoratedDescriptor(_class2$C.prototype, "_startAxis", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return AxisDirection.HORIZONTAL;
    }
}), _descriptor6$7 = _applyDecoratedDescriptor(_class2$C.prototype, "_paddingLeft", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$7 = _applyDecoratedDescriptor(_class2$C.prototype, "_paddingRight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$7 = _applyDecoratedDescriptor(_class2$C.prototype, "_paddingTop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$7 = _applyDecoratedDescriptor(_class2$C.prototype, "_paddingBottom", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$6 = _applyDecoratedDescriptor(_class2$C.prototype, "_spacingX", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$5 = _applyDecoratedDescriptor(_class2$C.prototype, "_spacingY", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor12$5 = _applyDecoratedDescriptor(_class2$C.prototype, "_verticalDirection", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return VerticalDirection.TOP_TO_BOTTOM;
    }
}), _descriptor13$5 = _applyDecoratedDescriptor(_class2$C.prototype, "_horizontalDirection", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return HorizontalDirection.LEFT_TO_RIGHT;
    }
}), _descriptor14$5 = _applyDecoratedDescriptor(_class2$C.prototype, "_affectedByScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$K = _class2$C)) || _class$K) || _class$K) || _class$K) || _class$K);

cc.LayoutComponent = LayoutComponent, function(LineCap) {
    LineCap[LineCap.BUTT = 0] = "BUTT", LineCap[LineCap.ROUND = 1] = "ROUND", LineCap[LineCap.SQUARE = 2] = "SQUARE";
}(LineCap || (LineCap = {})), ccenum(LineCap), function(LineJoin) {
    LineJoin[LineJoin.BEVEL = 0] = "BEVEL", LineJoin[LineJoin.ROUND = 1] = "ROUND", 
    LineJoin[LineJoin.MITER = 2] = "MITER";
}(LineJoin || (LineJoin = {})), ccenum(LineJoin), function(PointFlags) {
    PointFlags[PointFlags.PT_CORNER = 1] = "PT_CORNER", PointFlags[PointFlags.PT_LEFT = 2] = "PT_LEFT", 
    PointFlags[PointFlags.PT_BEVEL = 4] = "PT_BEVEL", PointFlags[PointFlags.PT_INNERBEVEL = 8] = "PT_INNERBEVEL";
}(PointFlags || (PointFlags = {})), ccenum(PointFlags);

var _dec$L, _dec2$r, _dec3$g, _dec4$d, _dec5$d, _dec6$c, _dec7$9, _class$M, _class2$E, _descriptor$C, _descriptor2$t, _class3$l, _temp$H, GraphicsComponent = (_dec$K = ccclass("cc.GraphicsComponent"), 
_dec2$q = executionOrder(110), _dec3$f = menu("UI/Render/Graphics"), _dec4$c = property({
    type: LineJoin
}), _dec5$c = property({
    type: LineCap
}), _dec6$b = property({
    override: !0,
    visible: !1
}), _dec$K(_class$L = _dec2$q(_class$L = _dec3$f((_temp$G = _class3$k = function(_UIRenderComponent) {
    function GraphicsComponent() {
        var _this;
        return _classCallCheck(this, GraphicsComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GraphicsComponent).call(this))).impl = null, 
        _this.model = null, _initializerDefineProperty(_this, "_lineWidth", _descriptor$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_strokeColor", _descriptor2$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineJoin", _descriptor3$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineCap", _descriptor4$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillColor", _descriptor5$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_miterLimit", _descriptor6$8, _assertThisInitialized(_this)), 
        _this._instanceMaterialType = InstanceMaterialType.ADDCOLOR, _this;
    }
    return _inherits(GraphicsComponent, UIRenderComponent), _createClass(GraphicsComponent, [ {
        key: "lineWidth",
        get: function get() {
            return this._lineWidth;
        },
        set: function set(value) {
            this._lineWidth = value, this.impl && (this.impl.lineWidth = value);
        }
    }, {
        key: "lineJoin",
        get: function get() {
            return this._lineJoin;
        },
        set: function set(value) {
            this._lineJoin = value, this.impl && (this.impl.lineJoin = value);
        }
    }, {
        key: "lineCap",
        get: function get() {
            return this._lineCap;
        },
        set: function set(value) {
            this._lineCap = value, this.impl && (this.impl.lineCap = value);
        }
    }, {
        key: "strokeColor",
        get: function get() {
            return this._strokeColor;
        },
        set: function set(value) {
            this.impl && (this._strokeColor.set(value), this.impl.strokeColor = this._strokeColor);
        }
    }, {
        key: "fillColor",
        get: function get() {
            return this._fillColor;
        },
        set: function set(value) {
            this.impl && (this._fillColor.set(value), this.impl.fillColor = this._fillColor);
        }
    }, {
        key: "miterLimit",
        get: function get() {
            return this._miterLimit;
        },
        set: function set(value) {
            this._miterLimit = value;
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        }
    } ]), _createClass(GraphicsComponent, [ {
        key: "onRestore",
        value: function onRestore() {
            this.impl || this._flushAssembler();
        }
    }, {
        key: "__preload",
        value: function __preload() {
            _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this).call(this), 
            this.impl = this._assembler && this._assembler.createImpl(this);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this._sceneGetter = cc.director.root.ui.getRenderSceneGetter();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this).call(this), 
            this.model && (this.model.enabled = !0), this._activateMaterial();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.model && (this.model.enabled = !1);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this).call(this), 
            this._sceneGetter = null, this.model && (this._getRenderScene().destroyModel(this.model), 
            this.model = null), this.impl && (this.impl.clear(), this.impl = null);
        }
    }, {
        key: "_activateMaterial",
        value: function _activateMaterial() {
            this._material && this._updateMaterial(this._material);
        }
    }, {
        key: "moveTo",
        value: function moveTo(x, y) {
            this.impl && this.impl.moveTo(x, y);
        }
    }, {
        key: "lineTo",
        value: function lineTo(x, y) {
            this.impl && this.impl.lineTo(x, y);
        }
    }, {
        key: "bezierCurveTo",
        value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
            this.impl && this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        }
    }, {
        key: "quadraticCurveTo",
        value: function quadraticCurveTo(cx, cy, x, y) {
            this.impl && this.impl.quadraticCurveTo(cx, cy, x, y);
        }
    }, {
        key: "arc",
        value: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
            this.impl && this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
        }
    }, {
        key: "ellipse",
        value: function ellipse(cx, cy, rx, ry) {
            this.impl && this.impl.ellipse(cx, cy, rx, ry);
        }
    }, {
        key: "circle",
        value: function circle(cx, cy, r) {
            this.impl && this.impl.circle(cx, cy, r);
        }
    }, {
        key: "rect",
        value: function rect(x, y, w, h) {
            this.impl && this.impl.rect(x, y, w, h);
        }
    }, {
        key: "roundRect",
        value: function roundRect(x, y, w, h, r) {
            this.impl && this.impl.roundRect(x, y, w, h, r);
        }
    }, {
        key: "fillRect",
        value: function fillRect(x, y, w, h) {
            this.rect(x, y, w, h), this.fill();
        }
    }, {
        key: "clear",
        value: function clear() {
            var clean = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.impl && (this.impl.clear(clean), this.model && (this.model.destroy(), this.model.scene.destroyModel(this.model), 
            this.model = null));
        }
    }, {
        key: "close",
        value: function close() {
            this.impl && this.impl.close();
        }
    }, {
        key: "stroke",
        value: function stroke() {
            this._assembler.stroke(this);
        }
    }, {
        key: "fill",
        value: function fill() {
            this._assembler.fill(this);
        }
    }, {
        key: "helpInstanceMaterial",
        value: function helpInstanceMaterial() {
            var mat = null;
            this._sharedMaterial ? mat = Material.getInstantiatedMaterial(this._sharedMaterial, new RenderableComponent(), !1) : ((mat = Material.getInstantiatedMaterial(cc.builtinResMgr.get("ui-base-material"), new RenderableComponent(), !1)).recompileShaders({
                USE_LOCAL: !0
            }), mat.onLoaded()), this._updateMaterial(mat), this.impl || (this._flushAssembler(), 
            this.impl = this._assembler && this._assembler.createImpl(this));
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitModel(this, this.model, this._material);
        }
    }, {
        key: "_instanceMaterial",
        value: function _instanceMaterial() {
            this.helpInstanceMaterial();
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = GraphicsComponent.Assembler.getAssembler(this);
            this._assembler !== assembler && (this._assembler = assembler);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            return !!_get(_getPrototypeOf(GraphicsComponent.prototype), "_canRender", this).call(this) && !!this.model;
        }
    } ]), GraphicsComponent;
}(), _class3$k.LineJoin = LineJoin, _class3$k.LineCap = LineCap, _applyDecoratedDescriptor((_class2$D = _temp$G).prototype, "lineJoin", [ _dec4$c ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "lineJoin"), _class2$D.prototype), 
_applyDecoratedDescriptor(_class2$D.prototype, "lineCap", [ _dec5$c ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "lineCap"), _class2$D.prototype), 
_applyDecoratedDescriptor(_class2$D.prototype, "strokeColor", [ property ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "strokeColor"), _class2$D.prototype), 
_applyDecoratedDescriptor(_class2$D.prototype, "fillColor", [ property ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "fillColor"), _class2$D.prototype), 
_applyDecoratedDescriptor(_class2$D.prototype, "miterLimit", [ property ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "miterLimit"), _class2$D.prototype), 
_applyDecoratedDescriptor(_class2$D.prototype, "color", [ _dec6$b ], Object.getOwnPropertyDescriptor(_class2$D.prototype, "color"), _class2$D.prototype), 
_descriptor$B = _applyDecoratedDescriptor(_class2$D.prototype, "_lineWidth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor2$s = _applyDecoratedDescriptor(_class2$D.prototype, "_strokeColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.BLACK.clone();
    }
}), _descriptor3$i = _applyDecoratedDescriptor(_class2$D.prototype, "_lineJoin", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return LineJoin.MITER;
    }
}), _descriptor4$f = _applyDecoratedDescriptor(_class2$D.prototype, "_lineCap", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return LineCap.BUTT;
    }
}), _descriptor5$d = _applyDecoratedDescriptor(_class2$D.prototype, "_fillColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor6$8 = _applyDecoratedDescriptor(_class2$D.prototype, "_miterLimit", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 10;
    }
}), _class$L = _class2$D)) || _class$L) || _class$L) || _class$L);

cc.GraphicsComponent = GraphicsComponent;

var MaskType, _worldMatrix$2 = new Mat4(), _vec2_temp = new Vec2(), _mat4_temp$1 = new Mat4(), _circlepoints = [];

!function(MaskType) {
    MaskType[MaskType.RECT = 0] = "RECT", MaskType[MaskType.ELLIPSE = 1] = "ELLIPSE";
}(MaskType || (MaskType = {})), ccenum(MaskType);

var _dec$M, _dec2$s, _dec3$h, _dec4$e, _dec5$e, _dec6$d, _class$N, _class2$F, _descriptor$D, _descriptor2$u, _descriptor3$j, _descriptor4$g, _descriptor5$e, _class3$m, _temp$I, Mode, MaskComponent = (_dec$L = ccclass("cc.MaskComponent"), 
_dec2$r = executionOrder(110), _dec3$g = menu("UI/Render/Mask"), _dec4$d = property({
    type: MaskType,
    displayOrder: 4
}), _dec5$d = property({
    visible: !1,
    override: !0
}), _dec6$c = property({
    visible: !1,
    override: !0
}), _dec7$9 = property({
    visible: !1,
    override: !0
}), _dec$L(_class$M = _dec2$r(_class$M = _dec3$g((_temp$H = _class3$l = function(_UIRenderComponent) {
    function MaskComponent() {
        var _this;
        return _classCallCheck(this, MaskComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MaskComponent).call(this)), "_type", _descriptor$C, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_segments", _descriptor2$t, _assertThisInitialized(_this)), 
        _this._graphics = null, _this._clearGraphics = null, _this._instanceMaterialType = InstanceMaterialType.ADDCOLOR, 
        _this;
    }
    return _inherits(MaskComponent, UIRenderComponent), _createClass(MaskComponent, [ {
        key: "type",
        get: function get() {
            return this._type;
        },
        set: function set(value) {
            this._type !== value && (this._type = value, this._updateGraphics(), this._renderData && (this.destroyRenderData(), 
            this._renderData = null), this._activateMaterial());
        }
    }, {
        key: "segments",
        get: function get() {
            return this._segments;
        },
        set: function set(value) {
            this._segments = clamp(value, 3, 1e4), this._updateGraphics();
        }
    }, {
        key: "graphics",
        get: function get() {
            return this._graphics;
        }
    }, {
        key: "clearGraphics",
        get: function get() {
            return this._clearGraphics;
        }
    }, {
        key: "dstBlendFactor",
        get: function get() {
            return this._dstBlendFactor;
        },
        set: function set(value) {
            this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "srcBlendFactor",
        get: function get() {
            return this._srcBlendFactor;
        },
        set: function set(value) {
            this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this.markForUpdateRenderData());
        }
    } ]), _createClass(MaskComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._createGraphics();
        }
    }, {
        key: "onRestore",
        value: function onRestore() {
            this._createGraphics(), this._updateGraphics();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(MaskComponent.prototype), "onEnable", this).call(this), this._flushVisibility(), 
            this._clearGraphics && this._clearGraphics.onEnable(), this._updateGraphics(), this._activateMaterial(), 
            this.node.on(SystemEventType.TRANSFORM_CHANGED, this._nodeStateChange, this), cc.view.on("design-resolution-changed", this._updateClearGraphics, this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(MaskComponent.prototype), "onDisable", this).call(this), this._disableGraphics(), 
            this.node.off(SystemEventType.TRANSFORM_CHANGED, this._nodeStateChange), cc.view.off("design-resolution-changed", this._updateClearGraphics);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(MaskComponent.prototype), "onDestroy", this).call(this), this._removeGraphics();
        }
    }, {
        key: "isHit",
        value: function isHit(cameraPt) {
            var node = this.node, size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
            this.node.getWorldMatrix(_worldMatrix$2), Mat4.invert(_mat4_temp$1, _worldMatrix$2), 
            Vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
            var ap = node.getAnchorPoint();
            testPt.x += ap.x * w, testPt.y += ap.y * h;
            var result = !1;
            if (this.type === MaskType.RECT) result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
                var rx = w / 2, ry = h / 2, px = testPt.x - .5 * w, py = testPt.y - .5 * h;
                result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
            }
            return result;
        }
    }, {
        key: "_resizeNodeToTargetNode",
        value: function _resizeNodeToTargetNode() {}
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitComp(this, null, this._assembler);
        }
    }, {
        key: "_postRender",
        value: function _postRender(render) {
            this._postAssembler && render.commitComp(this, null, this._postAssembler);
        }
    }, {
        key: "_nodeStateChange",
        value: function _nodeStateChange(type) {
            type !== SystemEventType.POSITION_PART && (_get(_getPrototypeOf(MaskComponent.prototype), "_nodeStateChange", this).call(this, type), 
            this._updateGraphics());
        }
    }, {
        key: "_resolutionChanged",
        value: function _resolutionChanged() {
            this._updateClearGraphics();
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            return !!_get(_getPrototypeOf(MaskComponent.prototype), "_canRender", this).call(this) && (null !== this._clearGraphics && null !== this._graphics);
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = MaskComponent.Assembler.getAssembler(this), posAssembler = MaskComponent.PostAssembler.getAssembler(this);
            this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
            this._postAssembler !== posAssembler && (this._postAssembler = posAssembler), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
            this._renderData.material = this.sharedMaterial, this.markForUpdateRenderData());
        }
    }, {
        key: "_parentChanged",
        value: function _parentChanged(node) {
            return !!_get(_getPrototypeOf(MaskComponent.prototype), "_parentChanged", this).call(this, node) && (this._flushVisibility(), 
            !0);
        }
    }, {
        key: "_onTextureLoaded",
        value: function _onTextureLoaded() {
            this._renderData && (this._renderData.uvDirty = !0, this._renderData.vertDirty = !0), 
            this.enabledInHierarchy && this._activateMaterial();
        }
    }, {
        key: "_applySpriteFrame",
        value: function _applySpriteFrame(oldFrame) {}
    }, {
        key: "_createGraphics",
        value: function _createGraphics() {
            if (!this._clearGraphics) {
                var clearGraphics = this._clearGraphics = new GraphicsComponent();
                clearGraphics.node = new Node$1("clear-graphics"), clearGraphics.helpInstanceMaterial(), 
                clearGraphics._activateMaterial(), clearGraphics.lineWidth = 0;
                var color = Color.WHITE.clone();
                color.a = 0, this._clearGraphics.fillColor = color, this._updateClearGraphics();
            }
            if (!this._graphics) {
                var graphics = this._graphics = new GraphicsComponent();
                graphics.node = this.node, graphics.node.getWorldMatrix(), graphics.helpInstanceMaterial(), 
                graphics.lineWidth = 0;
                var _color = Color.WHITE.clone();
                _color.a = 0, graphics.fillColor = _color;
            }
        }
    }, {
        key: "_updateClearGraphics",
        value: function _updateClearGraphics() {
            if (this._clearGraphics) {
                console.log("resolution changed");
                var size = cc.visibleRect;
                this._clearGraphics.node.setWorldPosition(size.width / 2, size.height / 2, 0), this._clearGraphics.clear(), 
                this._clearGraphics.rect(-size.width / 2, -size.height / 2, size.width, size.height), 
                this._clearGraphics.fill();
            }
        }
    }, {
        key: "_updateGraphics",
        value: function _updateGraphics() {
            if (this._graphics) {
                var node = this.node, graphics = this._graphics;
                graphics.clear();
                var size = node.getContentSize(), width = size.width, height = size.height, ap = node.getAnchorPoint(), x = -width * ap.x, y = -height * ap.y;
                if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
                    for (var points = function _calculateCircle(center, radius, segements) {
                        _circlepoints.length = 0;
                        for (var anglePerStep = 2 * Math.PI / segements, step = 0; step < segements; ++step) _circlepoints.push(cc.v3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
                        return _circlepoints;
                    }(cc.v3(x + width / 2, y + height / 2, 0), cc.v3(width / 2, height / 2, 0), this._segments), i = 0; i < points.length; ++i) {
                        var point = points[i];
                        0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
                    }
                    graphics.close();
                }
                graphics.fill();
            }
        }
    }, {
        key: "_disableGraphics",
        value: function _disableGraphics() {
            this._graphics && this._graphics.onDisable(), this._clearGraphics && this._clearGraphics.onDisable();
        }
    }, {
        key: "_removeGraphics",
        value: function _removeGraphics() {
            this._graphics && this._graphics.destroy(), this._clearGraphics && this._clearGraphics.destroy();
        }
    }, {
        key: "_flushVisibility",
        value: function _flushVisibility() {
            this._clearGraphics && this._clearGraphics.setVisibility(this._visibility), this._graphics && this._graphics.setVisibility(this._visibility);
        }
    }, {
        key: "_activateMaterial",
        value: function _activateMaterial() {}
    } ]), MaskComponent;
}(), _class3$l.Type = MaskType, _applyDecoratedDescriptor((_class2$E = _temp$H).prototype, "type", [ _dec4$d ], Object.getOwnPropertyDescriptor(_class2$E.prototype, "type"), _class2$E.prototype), 
_applyDecoratedDescriptor(_class2$E.prototype, "segments", [ property ], Object.getOwnPropertyDescriptor(_class2$E.prototype, "segments"), _class2$E.prototype), 
_applyDecoratedDescriptor(_class2$E.prototype, "dstBlendFactor", [ _dec5$d ], Object.getOwnPropertyDescriptor(_class2$E.prototype, "dstBlendFactor"), _class2$E.prototype), 
_applyDecoratedDescriptor(_class2$E.prototype, "srcBlendFactor", [ _dec6$c ], Object.getOwnPropertyDescriptor(_class2$E.prototype, "srcBlendFactor"), _class2$E.prototype), 
_applyDecoratedDescriptor(_class2$E.prototype, "color", [ _dec7$9 ], Object.getOwnPropertyDescriptor(_class2$E.prototype, "color"), _class2$E.prototype), 
_descriptor$C = _applyDecoratedDescriptor(_class2$E.prototype, "_type", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return MaskType.RECT;
    }
}), _descriptor2$t = _applyDecoratedDescriptor(_class2$E.prototype, "_segments", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 64;
    }
}), _class$M = _class2$E)) || _class$M) || _class$M) || _class$M);

cc.MaskComponent = MaskComponent, function(Mode) {
    Mode[Mode.HORIZONTAL = 0] = "HORIZONTAL", Mode[Mode.VERTICAL = 1] = "VERTICAL", 
    Mode[Mode.FILLED = 2] = "FILLED";
}(Mode || (Mode = {})), Enum(Mode);

var _class$O, _class2$G, _descriptor$E, _descriptor2$v, ProgressBarComponent = (_dec$M = ccclass("cc.ProgressBarComponent"), 
_dec2$s = executionOrder(110), _dec3$h = menu("UI/ProgressBar"), _dec4$e = property({
    type: SpriteComponent
}), _dec5$e = property({
    type: Mode
}), _dec6$d = property({
    range: [ 0, 1, .1 ],
    slide: !0
}), _dec$M(_class$N = _dec2$s(_class$N = _dec3$h((_temp$I = _class3$m = function(_Component) {
    function ProgressBarComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ProgressBarComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProgressBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_barSprite", _descriptor$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_mode", _descriptor2$u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_totalLength", _descriptor3$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_progress", _descriptor4$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_reverse", _descriptor5$e, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ProgressBarComponent, Component), _createClass(ProgressBarComponent, [ {
        key: "_initBarSprite",
        value: function _initBarSprite() {
            if (this._barSprite) {
                var entity = this._barSprite.node;
                if (!entity) return;
                var nodeSize = this.node.getContentSize(), nodeAnchor = this.node.getAnchorPoint(), barSpriteSize = entity.getContentSize();
                if (this._barSprite.fillType === SpriteComponent.FillType.RADIAL && (this._mode = Mode.FILLED), 
                this._mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this._mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this._barSprite.fillRange, 
                entity.parent === this.node) {
                    var x = -nodeSize.width * nodeAnchor.x;
                    entity.setPosition(x, 0, 0);
                }
            }
        }
    }, {
        key: "_updateBarStatus",
        value: function _updateBarStatus() {
            if (this._barSprite) {
                var entity = this._barSprite.node;
                if (!entity) return;
                var entityAnchorPoint = entity.getAnchorPoint(), entitySize = entity.getContentSize(), entityPosition = entity.getPosition(), anchorPoint = new Vec2(0, .5), progress = clamp01(this._progress), actualLenth = this._totalLength * progress, finalContentSize = entitySize, totalWidth = 0, totalHeight = 0;
                switch (this._mode) {
                  case Mode.HORIZONTAL:
                    this._reverse && (anchorPoint = new Vec2(1, .5)), finalContentSize = new Size(actualLenth, entitySize.height), 
                    totalWidth = this._totalLength, totalHeight = entitySize.height;
                    break;

                  case Mode.VERTICAL:
                    anchorPoint = this._reverse ? new Vec2(.5, 1) : new Vec2(.5, 0), finalContentSize = new Size(entitySize.width, actualLenth), 
                    totalWidth = entitySize.width, totalHeight = this._totalLength;
                }
                if (this._mode === Mode.FILLED) this._barSprite.type !== cc.SpriteComponent.Type.FILLED ? cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (actualLenth *= -1), 
                this._barSprite.fillRange = actualLenth); else if (this._barSprite.type !== cc.SpriteComponent.Type.FILLED) {
                    var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x, anchorOffsetY = anchorPoint.y - entityAnchorPoint.y, finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                    entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z), 
                    entity.setAnchorPoint(anchorPoint), entity.setContentSize(finalContentSize);
                } else cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
            }
        }
    }, {
        key: "barSprite",
        get: function get() {
            return this._barSprite;
        },
        set: function set(value) {
            this._barSprite !== value && (this._barSprite = value, this._initBarSprite());
        }
    }, {
        key: "mode",
        get: function get() {
            return this._mode;
        },
        set: function set(value) {
            if (this._mode !== value && (this._mode = value, this._barSprite)) {
                var entity = this._barSprite.node;
                if (!entity) return;
                var entitySize = entity.getContentSize();
                this._mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this._mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this._mode === Mode.FILLED && (this.totalLength = this._barSprite.fillRange);
            }
        }
    }, {
        key: "totalLength",
        get: function get() {
            return this._totalLength;
        },
        set: function set(value) {
            this._mode === Mode.FILLED && (value = clamp01(value)), this._totalLength = value, 
            this._updateBarStatus();
        }
    }, {
        key: "progress",
        get: function get() {
            return this._progress;
        },
        set: function set(value) {
            this._progress !== value && (this._progress = value, this._updateBarStatus());
        }
    }, {
        key: "reverse",
        get: function get() {
            return this._reverse;
        },
        set: function set(value) {
            this._reverse !== value && (this._reverse = value, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), 
            this._updateBarStatus());
        }
    } ]), ProgressBarComponent;
}(), _class3$m.Mode = Mode, _applyDecoratedDescriptor((_class2$F = _temp$I).prototype, "barSprite", [ _dec4$e ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "barSprite"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "mode", [ _dec5$e ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "mode"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "totalLength", [ property ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "totalLength"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "progress", [ _dec6$d ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "progress"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "reverse", [ property ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "reverse"), _class2$F.prototype), 
_descriptor$D = _applyDecoratedDescriptor(_class2$F.prototype, "_barSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$u = _applyDecoratedDescriptor(_class2$F.prototype, "_mode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode.HORIZONTAL;
    }
}), _descriptor3$j = _applyDecoratedDescriptor(_class2$F.prototype, "_totalLength", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$g = _applyDecoratedDescriptor(_class2$F.prototype, "_progress", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor5$e = _applyDecoratedDescriptor(_class2$F.prototype, "_reverse", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$N = _class2$F)) || _class$N) || _class$N) || _class$N);

cc.ProgressBarComponent = ProgressBarComponent;

var _dec$O, _dec2$u, _dec3$j, _dec4$f, _dec5$f, _dec6$e, _dec7$a, _class$P, _class2$H, _descriptor$F, _descriptor2$w, _descriptor3$k, _descriptor4$h, _descriptor5$f, _descriptor6$9, _descriptor7$8, _descriptor8$8, _class3$n, _temp$K, LabelOutlineComponent = ccclass("cc.LabelOutlineComponent")(_class$O = executionOrder(110)(_class$O = menu("UI/Render/LabelOutline")((_descriptor$E = _applyDecoratedDescriptor((_class2$G = function(_Component) {
    function LabelOutlineComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, LabelOutlineComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LabelOutlineComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$E, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_width", _descriptor2$v, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(LabelOutlineComponent, Component), _createClass(LabelOutlineComponent, [ {
        key: "_updateRenderData",
        value: function _updateRenderData() {
            var label = this.node.getComponent(LabelComponent);
            label && label.updateRenderData(!0);
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this._updateRenderData());
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(value) {
            this._width !== value && (this._width = value, this._updateRenderData());
        }
    } ]), LabelOutlineComponent;
}()).prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(255, 255, 255, 255);
    }
}), _descriptor2$v = _applyDecoratedDescriptor(_class2$G.prototype, "_width", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$G.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "color"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "width"), _class2$G.prototype), 
_class$O = _class2$G)) || _class$O) || _class$O) || _class$O;

cc.LabelOutlineComponent = LabelOutlineComponent;

var _htmlTextParser = new HtmlTextParser();

var pool$1 = new Pool(function(labelSeg) {
    return !!cc.isValid(labelSeg.node) && !labelSeg.node.getComponent(cc.LabelOutlineComponent);
}, 20);

pool$1.get = function(str, richtext) {
    var labelSeg = this._get();
    labelSeg || (labelSeg = {
        node: new PrivateNode("RICHTEXT_CHILD"),
        comp: null,
        lineCount: 0,
        styleIndex: 0,
        clickHandler: ""
    });
    var labelNode = labelSeg.node;
    labelNode || (labelNode = new PrivateNode("RICHTEXT_CHILD"));
    var labelComponent = labelNode.getComponent(LabelComponent);
    return labelComponent || (labelComponent = labelNode.addComponent(LabelComponent)), 
    labelComponent = labelComponent, labelNode.setPosition(0, 0, 0), labelNode.setAnchorPoint(.5, .5), 
    labelNode.setContentSize(128, 128), "string" != typeof str && (str = "" + str), 
    richtext.font instanceof Font ? labelComponent.font = richtext.font : labelComponent.fontFamily = "Arial", 
    labelComponent.string = str, labelComponent.horizontalAlign = HorizontalTextAlignment.LEFT, 
    labelComponent.verticalAlign = VerticalTextAlignment.TOP, labelComponent.fontSize = richtext.fontSize || 40, 
    labelComponent.overflow = 0, labelComponent.enableWrapText = !0, labelComponent.lineHeight = 40, 
    labelComponent.isBold = !1, labelComponent.isItalic = !1, labelComponent.isUnderline = !1, 
    {
        node: labelNode,
        comp: labelComponent,
        lineCount: 0,
        clickHandler: "",
        styleIndex: 0
    };
};

var _dec$P, _dec2$v, _dec3$k, _dec4$g, _dec5$g, _class$Q, _class2$I, _descriptor$G, _descriptor2$x, _descriptor3$l, _descriptor4$i, _descriptor5$g, _class3$o, _temp$L, RichTextComponent = (_dec$O = ccclass("cc.RichTextComponent"), 
_dec2$u = executionOrder(110), _dec3$j = menu("UI/Render/RichText"), _dec4$f = property({
    multiline: !0
}), _dec5$f = property({
    type: HorizontalTextAlignment
}), _dec6$e = property({
    type: TTFFont
}), _dec7$a = property({
    type: SpriteAtlas
}), _dec$O(_class$P = _dec2$u(_class$P = _dec3$j(_class$P = executeInEditMode((_temp$K = _class3$n = function(_UIComponent) {
    function RichTextComponent() {
        var _this;
        return _classCallCheck(this, RichTextComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RichTextComponent).call(this)), "_lineHeight", _descriptor$F, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_string", _descriptor2$w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontSize", _descriptor4$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_maxWidth", _descriptor5$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_font", _descriptor6$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_imageAtlas", _descriptor7$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor8$8, _assertThisInitialized(_this)), 
        _this._textArray = [], _this._labelSegments = [], _this._labelSegmentsCache = [], 
        _this._linesWidth = [], _this._lineCount = 1, _this._labelWidth = 0, _this._labelHeight = 0, 
        _this._layoutDirty = !0, _this._lineOffsetX = 0, _this._updateRichTextStatus = void 0, 
        _this._updateRichTextStatus = _this._updateRichText, _this;
    }
    return _inherits(RichTextComponent, UIComponent), _createClass(RichTextComponent, [ {
        key: "string",
        get: function get() {
            return this._string;
        },
        set: function set(value) {
            this._string !== value && (this._string = value, this._updateRichTextStatus());
        }
    }, {
        key: "horizontalAlign",
        get: function get() {
            return this._horizontalAlign;
        },
        set: function set(value) {
            this.horizontalAlign !== value && (this._horizontalAlign = value, this._layoutDirty = !0, 
            this._updateRichTextStatus());
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._fontSize;
        },
        set: function set(value) {
            this._fontSize !== value && (this._fontSize = value, this._layoutDirty = !0, this._updateRichTextStatus());
        }
    }, {
        key: "font",
        get: function get() {
            return this._font;
        },
        set: function set(value) {
            this._font !== value && (this._font = value, this._layoutDirty = !0, this._font && this._onTTFLoaded(), 
            this._updateRichTextStatus());
        }
    }, {
        key: "maxWidth",
        get: function get() {
            return this._maxWidth;
        },
        set: function set(value) {
            this._maxWidth !== value && (this._maxWidth = value, this._layoutDirty = !0, this._updateRichTextStatus());
        }
    }, {
        key: "lineHeight",
        get: function get() {
            return this._lineHeight;
        },
        set: function set(value) {
            this._lineHeight !== value && (this._lineHeight = value, this._layoutDirty = !0, 
            this._updateRichTextStatus());
        }
    }, {
        key: "imageAtlas",
        get: function get() {
            return this._imageAtlas;
        },
        set: function set(value) {
            this._imageAtlas !== value && (this._imageAtlas = value, this._layoutDirty = !0, 
            this._updateRichTextStatus());
        }
    }, {
        key: "handleTouchEvent",
        get: function get() {
            return this._handleTouchEvent;
        },
        set: function set(value) {
            this._handleTouchEvent !== value && (this._handleTouchEvent = value, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()));
        }
    } ]), _createClass(RichTextComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1);
        }
    }, {
        key: "start",
        value: function start() {
            this._onTTFLoaded();
        }
    }, {
        key: "onRestore",
        value: function onRestore() {
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            var _iterator = this._labelSegments, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var seg = _ref;
                seg.node.removeFromParent(), pool$1.put(seg);
            }
        }
    }, {
        key: "_addEventListeners",
        value: function _addEventListeners() {
            this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_removeEventListeners",
        value: function _removeEventListeners() {
            this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_updateLabelSegmentTextAttributes",
        value: function _updateLabelSegmentTextAttributes() {
            var _this2 = this;
            this._labelSegments.forEach(function(item) {
                _this2._applyTextAttribute(item);
            });
        }
    }, {
        key: "_createFontLabel",
        value: function _createFontLabel(str) {
            return pool$1.get(str, this);
        }
    }, {
        key: "_onTTFLoaded",
        value: function _onTTFLoaded() {
            if (this._font instanceof TTFFont) if (this._font._nativeAsset) this._layoutDirty = !0, 
            this._updateRichText(); else {
                var self = this;
                cc.loader.load(this._font.nativeUrl, function(err, fontFamily) {
                    self._layoutDirty = !0, self._updateRichText();
                });
            } else this._layoutDirty = !0, this._updateRichText();
        }
    }, {
        key: "_measureText",
        value: function _measureText(styleIndex, string) {
            var self = this, func = function func(s) {
                var label;
                return 0 === self._labelSegmentsCache.length ? (label = self._createFontLabel(s), 
                self._labelSegmentsCache.push(label)) : (label = self._labelSegmentsCache[0]).node.getComponent(LabelComponent).string = s, 
                label.styleIndex = styleIndex, self._applyTextAttribute(label), label.node.getContentSize().width;
            };
            return string ? func(string) : func;
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            var _this3 = this, components = this.node.getComponents(UIComponent), self = this, _loop = function _loop() {
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) return "break";
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) return "break";
                    _ref2 = _i2.value;
                }
                var seg = _ref2, clickHandler = seg.clickHandler;
                clickHandler && _this3._containsTouchLocation(seg, event.touch.getUILocation()) && (components.forEach(function(component) {
                    var func = component[clickHandler];
                    component.enabledInHierarchy && func && func.call(self, event);
                }), event.propagationStopped = !0);
            }, _iterator2 = this._labelSegments, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if ("break" === _loop()) break;
            }
        }
    }, {
        key: "_containsTouchLocation",
        value: function _containsTouchLocation(label, point) {
            var comp = label.node.getComponent(UITransformComponent);
            return !!comp && comp.getBoundingBoxToWorld().contains(point);
        }
    }, {
        key: "_resetState",
        value: function _resetState() {
            for (var _this4 = this, children = this.node.children, _loop2 = function _loop2(i) {
                var child = children[i];
                if (("RICHTEXT_CHILD" === child.name || "RICHTEXT_Image_CHILD" === child.name) && (child.parent === _this4.node ? child.parent = null : children.splice(i, 1), 
                "RICHTEXT_CHILD" === child.name)) {
                    var index = _this4._labelSegments.findIndex(function(seg) {
                        return seg.node === child;
                    });
                    -1 !== index && pool$1.put(_this4._labelSegments[index]);
                }
            }, i = children.length - 1; i >= 0; i--) _loop2(i);
            this._labelSegments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, 
            this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, 
            this._layoutDirty = !0;
        }
    }, {
        key: "_activateChildren",
        value: function _activateChildren(active) {
            for (var i = this.node.children.length - 1; i >= 0; i--) {
                var child = this.node.children[i];
                "RICHTEXT_CHILD" !== child.name && "RICHTEXT_Image_CHILD" !== child.name || (child.active = active);
            }
        }
    }, {
        key: "_addLabelSegment",
        value: function _addLabelSegment(stringToken, styleIndex) {
            var labelSegment;
            if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
                var label = (labelSegment = this._labelSegmentsCache.pop()).node.getComponent(LabelComponent);
                label && (label.string = stringToken);
            }
            return labelSegment.styleIndex = styleIndex, labelSegment.lineCount = this._lineCount, 
            labelSegment.node.setAnchorPoint(0, 0), this._applyTextAttribute(labelSegment), 
            this.node.addChild(labelSegment.node), this._labelSegments.push(labelSegment), labelSegment;
        }
    }, {
        key: "_updateRichTextWithMaxWidth",
        value: function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
            var fragmentWidth = labelWidth;
            if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) for (var checkStartIndex = 0; this._lineOffsetX <= this.maxWidth; ) {
                var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length), checkString = labelString.substr(checkStartIndex, checkEndIndex), checkStringWidth = this._measureText(styleIndex, checkString);
                if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
                    if (checkStartIndex > 0) {
                        var remainingString = labelString.substr(0, checkStartIndex);
                        this._addLabelSegment(remainingString, styleIndex), labelString = labelString.substr(checkStartIndex, labelString.length), 
                        fragmentWidth = this._measureText(styleIndex, labelString);
                    }
                    this._updateLineInfo();
                    break;
                }
                this._lineOffsetX += checkStringWidth, checkStartIndex += checkEndIndex;
            }
            if (fragmentWidth > this.maxWidth) for (var fragments = fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex)), k = 0; k < fragments.length; ++k) {
                var splitString = fragments[k], labelSize = this._addLabelSegment(splitString, styleIndex).node.getContentSize();
                this._lineOffsetX += labelSize.width, fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
            } else this._lineOffsetX += fragmentWidth, this._addLabelSegment(labelString, styleIndex);
        }
    }, {
        key: "_isLastComponentCR",
        value: function _isLastComponentCR(stringToken) {
            return stringToken.length - 1 === stringToken.lastIndexOf("\n");
        }
    }, {
        key: "_updateLineInfo",
        value: function _updateLineInfo() {
            this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++;
        }
    }, {
        key: "_needsUpdateTextLayout",
        value: function _needsUpdateTextLayout(newTextArray) {
            if (this._layoutDirty || !this._textArray || !newTextArray) return !0;
            if (this._textArray.length !== newTextArray.length) return !0;
            for (var i = 0; i < this._textArray.length; i++) {
                var oldItem = this._textArray[i], newItem = newTextArray[i];
                if (oldItem.text !== newItem.text) return !0;
                if (oldItem.style) {
                    if (newItem.style) {
                        if (!!newItem.style.outline != !!oldItem.style.outline) return !0;
                        if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) return !0;
                        if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) return !0;
                    } else if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage || oldItem.style.outline) return !0;
                } else if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage || newItem.style.outline)) return !0;
            }
            return !1;
        }
    }, {
        key: "_addRichTextImageElement",
        value: function _addRichTextImageElement(richTextElement) {
            if (richTextElement.style) {
                var spriteFrameName = richTextElement.style.src, spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
                if (spriteFrame) {
                    var spriteNode = new PrivateNode("RICHTEXT_Image_CHILD"), spriteComponent = spriteNode.addComponent(SpriteComponent);
                    spriteNode.setAnchorPoint(0, 0), spriteComponent.type = cc.SpriteComponent.Type.SLICED, 
                    spriteComponent.sizeMode = cc.SpriteComponent.SizeMode.CUSTOM, this.node.addChild(spriteNode);
                    var obj = {
                        node: spriteNode,
                        comp: spriteComponent,
                        lineCount: 0,
                        clickHandler: "",
                        styleIndex: 0
                    };
                    this._labelSegments.push(obj);
                    var spriteRect = spriteFrame.getRect(), scaleFactor = 1, spriteWidth = spriteRect.width, spriteHeight = spriteRect.height, expectWidth = richTextElement.style.imageWidth, expectHeight = richTextElement.style.imageHeight;
                    if (void 0 !== expectHeight && expectHeight > 0 && expectHeight < this.lineHeight ? (spriteWidth *= scaleFactor = expectHeight / spriteHeight, 
                    spriteHeight *= scaleFactor) : (spriteWidth *= scaleFactor = this.lineHeight / spriteHeight, 
                    spriteHeight *= scaleFactor), void 0 !== expectWidth && expectWidth > 0 && (spriteWidth = expectWidth), 
                    this.maxWidth > 0 ? (this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo(), 
                    this._lineOffsetX += spriteWidth) : (this._lineOffsetX += spriteWidth, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), 
                    spriteComponent.spriteFrame = spriteFrame, spriteNode.setContentSize(spriteWidth, spriteHeight), 
                    obj.lineCount = this._lineCount, richTextElement.style.event) {
                        var c = "click";
                        richTextElement.style.event[c] && (obj.clickHandler = richTextElement.style.event[c]);
                    }
                } else cc.warnID(4400);
            }
        }
    }, {
        key: "_updateRichText",
        value: function _updateRichText() {
            if (this.enabled) {
                var newTextArray = _htmlTextParser.parse(this._string);
                if (!this._needsUpdateTextLayout(newTextArray)) return this._textArray = newTextArray.slice(), 
                void this._updateLabelSegmentTextAttributes();
                this._textArray = newTextArray.slice(), this._resetState();
                for (var labelSize, lastEmptyLine = !1, i = 0; i < this._textArray.length; ++i) {
                    var richTextElement = this._textArray[i], text = richTextElement.text;
                    if (void 0 !== text) {
                        if ("" === text) {
                            if (richTextElement.style && richTextElement.style.isNewLine) {
                                this._updateLineInfo();
                                continue;
                            }
                            if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
                                this._addRichTextImageElement(richTextElement);
                                continue;
                            }
                        }
                        for (var multilineTexts = text.split("\n"), j = 0; j < multilineTexts.length; ++j) {
                            var labelString = multilineTexts[j];
                            if ("" !== labelString) if (lastEmptyLine = !1, this.maxWidth > 0) {
                                var labelWidth = this._measureText(i, labelString);
                                this._updateRichTextWithMaxWidth(labelString, labelWidth, i), multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
                            } else labelSize = this._addLabelSegment(labelString, i).node.getContentSize(), 
                            this._lineOffsetX += labelSize.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), 
                            multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo(); else {
                                if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
                                this._updateLineInfo(), lastEmptyLine = !0;
                            }
                        }
                    }
                }
                lastEmptyLine || this._linesWidth.push(this._lineOffsetX), this.maxWidth > 0 && (this._labelWidth = this.maxWidth), 
                this._labelHeight = this._lineCount * this.lineHeight, this.node.setContentSize(this._labelWidth, this._labelHeight), 
                this._updateRichTextPosition(), this._layoutDirty = !1;
            }
        }
    }, {
        key: "_getFirstWordLen",
        value: function _getFirstWordLen(text, startIndex, textLen) {
            var character = text.charAt(startIndex);
            if (isUnicodeCJK(character) || isUnicodeSpace(character)) return 1;
            for (var len = 1, index = startIndex + 1; index < textLen && (!isUnicodeSpace(character = text.charAt(index)) && !isUnicodeCJK(character)); ++index) len++;
            return len;
        }
    }, {
        key: "_updateRichTextPosition",
        value: function _updateRichTextPosition() {
            var nextTokenX = 0, nextLineIndex = 1, totalLineCount = this._lineCount, _iterator3 = this._labelSegments, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var label = _ref3, lineCount = label.lineCount;
                lineCount > nextLineIndex && (nextTokenX = 0, nextLineIndex = lineCount);
                var lineOffsetX = 0;
                switch (this.horizontalAlign) {
                  case HorizontalTextAlignment.LEFT:
                    lineOffsetX = -this._labelWidth / 2;
                    break;

                  case HorizontalTextAlignment.CENTER:
                    lineOffsetX = -this._linesWidth[lineCount - 1] / 2;
                    break;

                  case HorizontalTextAlignment.RIGHT:
                    lineOffsetX = this._labelWidth / 2 - this._linesWidth[lineCount - 1];
                }
                var labelSize = label.node.getContentSize(), pos = label.node.getPosition();
                label.node.setPosition(nextTokenX + lineOffsetX, this.lineHeight * (totalLineCount - lineCount) - this._labelHeight / 2, pos.x), 
                lineCount === nextLineIndex && (nextTokenX += labelSize.width);
            }
        }
    }, {
        key: "_convertLiteralColorValue",
        value: function _convertLiteralColorValue(color) {
            var colorValue = color.toUpperCase();
            return Color[colorValue] ? Color[colorValue] : new Color().fromHEX(color);
        }
    }, {
        key: "_applyTextAttribute",
        value: function _applyTextAttribute(labelSeg) {
            var labelComponent = labelSeg.node.getComponent(LabelComponent);
            if (labelComponent) {
                var textStyle, index = labelSeg.styleIndex;
                labelComponent.lineHeight = this.lineHeight, labelComponent.horizontalAlign = HorizontalTextAlignment.LEFT, 
                labelComponent.verticalAlign = VerticalTextAlignment.CENTER, this._textArray[index] && (textStyle = this._textArray[index].style);
                var labelComp = labelSeg.node.getComponent(LabelComponent);
                if (labelComp && (textStyle && textStyle.color ? labelComp.color = this._convertLiteralColorValue(textStyle.color) : labelComp.color = this._convertLiteralColorValue("white")), 
                labelComponent.isBold = !(!textStyle || !textStyle.bold), labelComponent.isItalic = !(!textStyle || !textStyle.italic), 
                labelComponent.isUnderline = !(!textStyle || !textStyle.underline), textStyle && textStyle.outline) {
                    var labelOutlineComponent = labelSeg.node.getComponent(LabelOutlineComponent);
                    labelOutlineComponent || (labelOutlineComponent = labelSeg.node.addComponent(LabelOutlineComponent)), 
                    labelOutlineComponent.color = this._convertLiteralColorValue(textStyle.outline.color), 
                    labelOutlineComponent.width = textStyle.outline.width;
                }
                if (textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this._fontSize, 
                labelComponent.updateRenderData(!0), textStyle && textStyle.event) {
                    var c = "click";
                    textStyle.event[c] && (labelSeg.clickHandler = textStyle.event[c]);
                }
            }
        }
    } ]), RichTextComponent;
}(), _class3$n.HorizontalAlign = HorizontalTextAlignment, _class3$n.VerticalAlign = VerticalTextAlignment, 
_applyDecoratedDescriptor((_class2$H = _temp$K).prototype, "string", [ _dec4$f ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "string"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "horizontalAlign", [ _dec5$f ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "horizontalAlign"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "fontSize", [ property ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "fontSize"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "font", [ _dec6$e ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "font"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "maxWidth", [ property ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "maxWidth"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "lineHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "lineHeight"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "imageAtlas", [ _dec7$a ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "imageAtlas"), _class2$H.prototype), 
_applyDecoratedDescriptor(_class2$H.prototype, "handleTouchEvent", [ property ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "handleTouchEvent"), _class2$H.prototype), 
_descriptor$F = _applyDecoratedDescriptor(_class2$H.prototype, "_lineHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor2$w = _applyDecoratedDescriptor(_class2$H.prototype, "_string", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "<color=#00ff00>Rich</c><color=#0fffff>Text</color>";
    }
}), _descriptor3$k = _applyDecoratedDescriptor(_class2$H.prototype, "_horizontalAlign", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return HorizontalTextAlignment.LEFT;
    }
}), _descriptor4$h = _applyDecoratedDescriptor(_class2$H.prototype, "_fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor5$f = _applyDecoratedDescriptor(_class2$H.prototype, "_maxWidth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$9 = _applyDecoratedDescriptor(_class2$H.prototype, "_font", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor7$8 = _applyDecoratedDescriptor(_class2$H.prototype, "_imageAtlas", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor8$8 = _applyDecoratedDescriptor(_class2$H.prototype, "_handleTouchEvent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _class$P = _class2$H)) || _class$P) || _class$P) || _class$P) || _class$P);

cc.RichTextComponent = RichTextComponent;

var Direction, ZERO = new Vec3(), _tempPos_1 = new Vec3(), _tempPos_2 = new Vec3(), defaultAnchor = new Vec2(), _tempColor = new Color();

!function(Direction) {
    Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
}(Direction || (Direction = {})), ccenum(Direction);

var _class$R, ScrollBarComponent = (_dec$P = ccclass("cc.ScrollBarComponent"), _dec2$v = executionOrder(110), 
_dec3$k = menu("UI/ScrollBar"), _dec4$g = property({
    type: SpriteComponent
}), _dec5$g = property({
    type: Direction
}), _dec$P(_class$Q = _dec2$v(_class$Q = _dec3$k((_temp$L = _class3$o = function(_Component) {
    function ScrollBarComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ScrollBarComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_scrollView", _descriptor$G, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_handle", _descriptor2$x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$g, _assertThisInitialized(_this)), 
        _this._touching = !1, _this._opacity = 255, _this._autoHideRemainingTime = 0, _this;
    }
    return _inherits(ScrollBarComponent, Component), _createClass(ScrollBarComponent, [ {
        key: "hide",
        value: function hide() {
            this._autoHideRemainingTime = 0, this._setOpacity(0);
        }
    }, {
        key: "show",
        value: function show() {
            this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity);
        }
    }, {
        key: "onScroll",
        value: function onScroll(outOfBoundary) {
            if (this._scrollView) {
                var content = this._scrollView.content;
                if (content) {
                    var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize(), barSize = this.node.getContentSize();
                    if (!this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                        this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                        var contentMeasure = 0, scrollViewMeasure = 0, outOfBoundaryValue = 0, contentPosition = 0, handleNodeMeasure = 0;
                        this._direction === Direction.HORIZONTAL ? (contentMeasure = contentSize.width, 
                        scrollViewMeasure = scrollViewSize.width, handleNodeMeasure = barSize.width, outOfBoundaryValue = outOfBoundary.x, 
                        contentPosition = -this._convertToScrollViewSpace(content).x) : this._direction === Direction.VERTICAL && (contentMeasure = contentSize.height, 
                        scrollViewMeasure = scrollViewSize.height, handleNodeMeasure = barSize.height, outOfBoundaryValue = outOfBoundary.y, 
                        contentPosition = -this._convertToScrollViewSpace(content).y);
                        var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue), position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
                        this._updateLength(length), this._updateHanlderPosition(position);
                    }
                }
            }
        }
    }, {
        key: "setScrollView",
        value: function setScrollView(scrollView) {
            this._scrollView = scrollView;
        }
    }, {
        key: "onTouchBegan",
        value: function onTouchBegan() {
            this._enableAutoHide && (this._touching = !0);
        }
    }, {
        key: "onTouchEnded",
        value: function onTouchEnded() {
            if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize();
                        if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
                    }
                }
                this._autoHideRemainingTime = this._autoHideTime;
            }
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            var renderComp = this.node.getComponent(SpriteComponent);
            renderComp && (this._opacity = renderComp.color.a);
        }
    }, {
        key: "start",
        value: function start() {
            this._enableAutoHide && this._setOpacity(0);
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._processAutoHide(dt);
        }
    }, {
        key: "_convertToScrollViewSpace",
        value: function _convertToScrollViewSpace(content) {
            if (!this._scrollView) return ZERO;
            var ap = content.getAnchorPoint(), contentSize = content.getContentSize(), scrollViewSpacePos = new Vec3(-ap.x * contentSize.width, -ap.y * contentSize.height, 0);
            return content.uiTransfromComp.convertToWorldSpaceAR(scrollViewSpacePos, scrollViewSpacePos), 
            ap = this._scrollView.node.getAnchorPoint(), contentSize = this._scrollView.node.getContentSize(), 
            scrollViewSpacePos.x += ap.x * contentSize.width, scrollViewSpacePos.y += ap.y * contentSize.height, 
            this._scrollView.node.uiTransfromComp.convertToNodeSpaceAR(scrollViewSpacePos, scrollViewSpacePos), 
            scrollViewSpacePos;
        }
    }, {
        key: "_setOpacity",
        value: function _setOpacity(opacity) {
            if (this._handle) {
                var renderComp = this.node.getComponent(SpriteComponent);
                renderComp && (_tempColor.set(renderComp.color), _tempColor.a = opacity, renderComp.color = _tempColor), 
                (renderComp = this._handle.getComponent(SpriteComponent)) && (_tempColor.set(renderComp.color), 
                _tempColor.a = opacity, renderComp.color = _tempColor);
            }
        }
    }, {
        key: "_updateHanlderPosition",
        value: function _updateHanlderPosition(position) {
            if (this._handle) {
                var oldPosition = this._fixupHandlerPosition();
                this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
            }
        }
    }, {
        key: "_fixupHandlerPosition",
        value: function _fixupHandlerPosition() {
            var barSize = this.node.getContentSize(), barAnchor = this.node.getAnchorPoint(), handleSize = this.handle.node.getContentSize(), handleParent = this.handle.node.parent;
            Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
            var leftBottomWorldPosition = this.node.uiTransfromComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2), fixupPosition = new Vec3();
            return handleParent.uiTransfromComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition), 
            this.direction === Direction.HORIZONTAL ? fixupPosition = new Vec3(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, 0) : this.direction === Direction.VERTICAL && (fixupPosition = new Vec3(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, 0)), 
            this.handle.node.setPosition(fixupPosition), fixupPosition;
        }
    }, {
        key: "_conditionalDisableScrollBar",
        value: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
            return contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL || contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL;
        }
    }, {
        key: "_calculateLength",
        value: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
            var denominatorValue = contentMeasure;
            return outOfBoundary && (denominatorValue += 20 * (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary)), 
            handleNodeMeasure * (scrollViewMeasure / denominatorValue);
        }
    }, {
        key: "_calculatePosition",
        value: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
            var denominatorValue = contentMeasure - scrollViewMeasure;
            outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
            var positionRatio = 0;
            denominatorValue && (positionRatio = clamp01(positionRatio = contentPosition / denominatorValue));
            var position = (handleNodeMeasure - actualLenth) * positionRatio;
            return this._direction === Direction.VERTICAL ? new Vec3(0, position, 0) : new Vec3(position, 0, 0);
        }
    }, {
        key: "_updateLength",
        value: function _updateLength(length) {
            if (this._handle) {
                var handleNode = this._handle.node, handleNodeSize = handleNode.getContentSize(), anchor = handleNode.getAnchorPoint();
                anchor.x === defaultAnchor.x && anchor.y === defaultAnchor.y || handleNode.setAnchorPoint(defaultAnchor), 
                this._direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
            }
        }
    }, {
        key: "_processAutoHide",
        value: function _processAutoHide(deltaTime) {
            if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= deltaTime, 
            this._autoHideRemainingTime <= this._autoHideTime)) {
                this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
                this._setOpacity(opacity);
            }
        }
    }, {
        key: "handle",
        get: function get() {
            return this._handle;
        },
        set: function set(value) {
            this._handle !== value && (this._handle = value, this.onScroll(cc.v2(0, 0)));
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value, this.onScroll(new Vec3()));
        }
    }, {
        key: "enableAutoHide",
        get: function get() {
            return this._enableAutoHide;
        },
        set: function set(value) {
            this._enableAutoHide !== value && (this._enableAutoHide = value, this._enableAutoHide && this._setOpacity(0));
        }
    }, {
        key: "autoHideTime",
        get: function get() {
            return this._autoHideTime;
        },
        set: function set(value) {
            this._autoHideTime !== value && (this._autoHideTime = value);
        }
    } ]), ScrollBarComponent;
}(), _class3$o.Direction = Direction, _applyDecoratedDescriptor((_class2$I = _temp$L).prototype, "handle", [ _dec4$g ], Object.getOwnPropertyDescriptor(_class2$I.prototype, "handle"), _class2$I.prototype), 
_applyDecoratedDescriptor(_class2$I.prototype, "direction", [ _dec5$g ], Object.getOwnPropertyDescriptor(_class2$I.prototype, "direction"), _class2$I.prototype), 
_applyDecoratedDescriptor(_class2$I.prototype, "enableAutoHide", [ property ], Object.getOwnPropertyDescriptor(_class2$I.prototype, "enableAutoHide"), _class2$I.prototype), 
_applyDecoratedDescriptor(_class2$I.prototype, "autoHideTime", [ property ], Object.getOwnPropertyDescriptor(_class2$I.prototype, "autoHideTime"), _class2$I.prototype), 
_descriptor$G = _applyDecoratedDescriptor(_class2$I.prototype, "_scrollView", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$x = _applyDecoratedDescriptor(_class2$I.prototype, "_handle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$l = _applyDecoratedDescriptor(_class2$I.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction.HORIZONTAL;
    }
}), _descriptor4$i = _applyDecoratedDescriptor(_class2$I.prototype, "_enableAutoHide", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$g = _applyDecoratedDescriptor(_class2$I.prototype, "_autoHideTime", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class$Q = _class2$I)) || _class$Q) || _class$Q) || _class$Q);

cc.ScrollBarComponent = ScrollBarComponent;

var _dec$R, _dec2$x, _dec3$l, _dec4$h, _dec5$h, _dec6$f, _dec7$b, _dec8$7, _class$S, _class2$J, _descriptor$H, _descriptor2$y, _descriptor3$m, _descriptor4$j, _descriptor5$h, _descriptor6$a, _descriptor7$9, _descriptor8$9, _descriptor9$8, _descriptor10$7, _descriptor11$6, _class3$p, _temp$M, ViewGroupComponent = ccclass("cc.ViewGroupComponent")(_class$R = executionOrder(110)(_class$R = function(_Component) {
    function ViewGroupComponent() {
        return _classCallCheck(this, ViewGroupComponent), _possibleConstructorReturn(this, _getPrototypeOf(ViewGroupComponent).apply(this, arguments));
    }
    return _inherits(ViewGroupComponent, Component), ViewGroupComponent;
}()) || _class$R) || _class$R;

cc.ViewGroupComponent = ViewGroupComponent;

var ScrollViewEventType, NodeEvent$1 = SystemEventType, ZERO$1 = new Vec3(), _tempPos$2 = new Vec3(), getTimeInMilliseconds = function getTimeInMilliseconds() {
    return new Date().getMilliseconds();
};

!function(ScrollViewEventType) {
    ScrollViewEventType[ScrollViewEventType.SCROLL_TO_TOP = 0] = "SCROLL_TO_TOP", ScrollViewEventType[ScrollViewEventType.SCROLL_TO_BOTTOM = 1] = "SCROLL_TO_BOTTOM", 
    ScrollViewEventType[ScrollViewEventType.SCROLL_TO_LEFT = 2] = "SCROLL_TO_LEFT", 
    ScrollViewEventType[ScrollViewEventType.SCROLL_TO_RIGHT = 3] = "SCROLL_TO_RIGHT", 
    ScrollViewEventType[ScrollViewEventType.SCROLLING = 4] = "SCROLLING", ScrollViewEventType[ScrollViewEventType.BOUNCE_TOP = 5] = "BOUNCE_TOP", 
    ScrollViewEventType[ScrollViewEventType.BOUNCE_BOTTOM = 6] = "BOUNCE_BOTTOM", ScrollViewEventType[ScrollViewEventType.BOUNCE_LEFT = 7] = "BOUNCE_LEFT", 
    ScrollViewEventType[ScrollViewEventType.BOUNCE_RIGHT = 8] = "BOUNCE_RIGHT", ScrollViewEventType[ScrollViewEventType.SCROLL_ENDED = 9] = "SCROLL_ENDED", 
    ScrollViewEventType[ScrollViewEventType.TOUCH_UP = 10] = "TOUCH_UP", ScrollViewEventType[ScrollViewEventType.AUTOSCROLL_ENDED_WITH_THRESHOLD = 11] = "AUTOSCROLL_ENDED_WITH_THRESHOLD", 
    ScrollViewEventType[ScrollViewEventType.SCROLL_BEGAN = 12] = "SCROLL_BEGAN";
}(ScrollViewEventType || (ScrollViewEventType = {})), ccenum(ScrollViewEventType);

var _dec$S, _dec2$y, _dec3$m, _dec4$i, _dec5$i, _dec6$g, _dec7$c, _class$T, _class2$K, _descriptor$I, _descriptor2$z, _descriptor3$n, _descriptor4$k, _class3$q, _temp$N, eventMap = {
    "scroll-to-top": ScrollViewEventType.SCROLL_TO_TOP,
    "scroll-to-bottom": ScrollViewEventType.SCROLL_TO_BOTTOM,
    "scroll-to-left": ScrollViewEventType.SCROLL_TO_LEFT,
    "scroll-to-right": ScrollViewEventType.SCROLL_TO_RIGHT,
    scrolling: ScrollViewEventType.SCROLLING,
    "bounce-bottom": ScrollViewEventType.BOUNCE_BOTTOM,
    "bounce-left": ScrollViewEventType.BOUNCE_LEFT,
    "bounce-right": ScrollViewEventType.BOUNCE_RIGHT,
    "bounce-top": ScrollViewEventType.BOUNCE_TOP,
    "scroll-ended": ScrollViewEventType.SCROLL_ENDED,
    "touch-up": ScrollViewEventType.TOUCH_UP,
    "scroll-ended-with-threshold": ScrollViewEventType.AUTOSCROLL_ENDED_WITH_THRESHOLD,
    "scroll-began": ScrollViewEventType.SCROLL_BEGAN
}, ScrollViewComponent = (_dec$R = ccclass("cc.ScrollViewComponent"), _dec2$x = executionOrder(110), 
_dec3$l = menu("UI/ScrollView"), _dec4$h = property({
    type: Node$1
}), _dec5$h = property({
    type: ScrollBarComponent
}), _dec6$f = property({
    type: ScrollBarComponent
}), _dec7$b = property({
    range: [ 0, 1, .1 ]
}), _dec8$7 = property({
    range: [ 0, 10 ]
}), _dec$R(_class$S = _dec2$x(_class$S = _dec3$l((_temp$M = _class3$p = function(_ViewGroupComponent) {
    function ScrollViewComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ScrollViewComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "horizontal", _descriptor$H, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "vertical", _descriptor2$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "inertia", _descriptor3$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "brake", _descriptor4$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "elastic", _descriptor5$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "bounceDuration", _descriptor6$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "scrollEvents", _descriptor7$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor8$9, _assertThisInitialized(_this)), 
        _this._autoScrolling = !1, _this._scrolling = !1, _initializerDefineProperty(_this, "_content", _descriptor9$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$6, _assertThisInitialized(_this)), 
        _this._topBoundary = 0, _this._bottomBoundary = 0, _this._leftBoundary = 0, _this._rightBoundary = 0, 
        _this._touchMoveDisplacements = [], _this._touchMoveTimeDeltas = [], _this._touchMovePreviousTimestamp = 0, 
        _this._touchMoved = !1, _this._autoScrollAttenuate = !1, _this._autoScrollStartPosition = new Vec3(), 
        _this._autoScrollTargetDelta = new Vec3(), _this._autoScrollTotalTime = 0, _this._autoScrollAccumulatedTime = 0, 
        _this._autoScrollCurrentlyOutOfBoundary = !1, _this._autoScrollBraking = !1, _this._autoScrollBrakingStartPosition = new Vec3(), 
        _this._outOfBoundaryAmount = new Vec3(), _this._outOfBoundaryAmountDirty = !0, _this._stopMouseWheel = !1, 
        _this._mouseWheelEventElapsedTime = 0, _this._isScrollEndedWithThresholdEventFired = !1, 
        _this._scrollEventEmitMask = 0, _this._isBouncing = !1, _this._contentPos = new Vec3(), 
        _this._deltaPos = new Vec3(), _this;
    }
    return _inherits(ScrollViewComponent, ViewGroupComponent), _createClass(ScrollViewComponent, [ {
        key: "scrollToBottom",
        value: function scrollToBottom(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 0),
                applyToHorizontal: !1,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta, !0);
        }
    }, {
        key: "scrollToTop",
        value: function scrollToTop(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 1),
                applyToHorizontal: !1,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToLeft",
        value: function scrollToLeft(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 0),
                applyToHorizontal: !0,
                applyToVertical: !1
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToRight",
        value: function scrollToRight(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(1, 0),
                applyToHorizontal: !0,
                applyToVertical: !1
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToTopLeft",
        value: function scrollToTopLeft(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 1),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToTopRight",
        value: function scrollToTopRight(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(1, 1),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToBottomLeft",
        value: function scrollToBottomLeft(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 0),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToBottomRight",
        value: function scrollToBottomRight(timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(1, 0),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToOffset",
        value: function scrollToOffset(offset, timeInSecond, attenuated) {
            var maxScrollOffset = this.getMaxScrollOffset(), anchor = new Vec2(0, 0);
            0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x, 
            0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y, 
            this.scrollTo(anchor, timeInSecond, attenuated);
        }
    }, {
        key: "getScrollOffset",
        value: function getScrollOffset() {
            var topDelta = this._getContentTopBoundary() - this._topBoundary, leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
            return new Vec3(leftDeta, topDelta, 0);
        }
    }, {
        key: "getMaxScrollOffset",
        value: function getMaxScrollOffset() {
            var scrollSize = this.node.getContentSize(), contentSize = this._content.getContentSize(), horizontalMaximizeOffset = contentSize.width - scrollSize.width, verticalMaximizeOffset = contentSize.height - scrollSize.height;
            return new Vec3(horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0, verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0, 0);
        }
    }, {
        key: "scrollToPercentHorizontal",
        value: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(percent, 0),
                applyToHorizontal: !0,
                applyToVertical: !1
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollTo",
        value: function scrollTo(anchor, timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(anchor),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToPercentVertical",
        value: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, percent),
                applyToHorizontal: !1,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "stopAutoScroll",
        value: function stopAutoScroll() {
            this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        }
    }, {
        key: "setContentPosition",
        value: function setContentPosition(position) {
            position.equals(this.getContentPosition(), 1e-4) || (this._content.setPosition(position), 
            this._outOfBoundaryAmountDirty = !0);
        }
    }, {
        key: "getContentPosition",
        value: function getContentPosition() {
            return this._content ? (this._content.getPosition(this._contentPos), this._contentPos) : ZERO$1;
        }
    }, {
        key: "isScrolling",
        value: function isScrolling() {
            return this._scrolling;
        }
    }, {
        key: "isAutoScrolling",
        value: function isAutoScrolling() {
            return this._autoScrolling;
        }
    }, {
        key: "getScrollEndedEventTiming",
        value: function getScrollEndedEventTiming() {
            return 1e-4;
        }
    }, {
        key: "start",
        value: function start() {
            this._calculateBoundary(), this._content && cc.director.once(cc.Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._registerEvent(), this.content && (this.content.on(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this), 
            this.content.on(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view && (this.view.on(NodeEvent$1.POSITION_PART, this._calculateBoundary, this), 
            this.view.on(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view.on(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this))), 
            this._showScrollbar();
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._autoScrolling && this._processAutoScrolling(dt);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._unregisterEvent(), this.content && (this.content.off(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this), 
            this.content.off(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view && (this.view.off(NodeEvent$1.POSITION_PART, this._calculateBoundary, this), 
            this.view.off(NodeEvent$1.SCALE_PART, this._calculateBoundary, this), this.view.off(NodeEvent$1.SIZE_CHANGED, this._calculateBoundary, this))), 
            this._hideScrollbar(), this.stopAutoScroll();
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(NodeEvent$1.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(NodeEvent$1.TOUCH_MOVE, this._onTouchMoved, this, !0), 
            this.node.on(NodeEvent$1.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(NodeEvent$1.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
            this.node.on(NodeEvent$1.MOUSE_WHEEL, this._onMouseWheel, this, !0);
        }
    }, {
        key: "_unregisterEvent",
        value: function _unregisterEvent() {
            this.node.off(NodeEvent$1.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(NodeEvent$1.TOUCH_MOVE, this._onTouchMoved, this, !0), 
            this.node.off(NodeEvent$1.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(NodeEvent$1.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
            this.node.off(NodeEvent$1.MOUSE_WHEEL, this._onMouseWheel, this, !0);
        }
    }, {
        key: "_onMouseWheel",
        value: function _onMouseWheel(event, captureListeners) {
            if (this.enabledInHierarchy && !this._hasNestedViewGroup(event, captureListeners)) {
                var deltaMove = new Vec3(), wheelPrecision = -.1;
                0, this.vertical ? deltaMove = new Vec3(0, event.getScrollY() * wheelPrecision, 0) : this.horizontal && (deltaMove = new Vec3(event.getScrollY() * wheelPrecision, 0, 0)), 
                this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(deltaMove), this._stopMouseWheel || (this._handlePressLogic(), 
                this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), 
                this._stopPropagationIfTargetIsMe(event);
            }
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event, captureListeners) {
            this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(event, captureListeners) || (this._content && this._handlePressLogic(), 
            this._touchMoved = !1, this._stopPropagationIfTargetIsMe(event)));
        }
    }, {
        key: "_onTouchMoved",
        value: function _onTouchMoved(event, captureListeners) {
            if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners) && event && event.touch) {
                var touch = event.touch;
                if (this._content && this._handleMoveLogic(touch), this.cancelInnerEvents) {
                    var deltaMove = new Vec2(touch.getUILocation());
                    if (deltaMove.subtract(touch.getStartLocation()), deltaMove.length() > 7 && !this._touchMoved && event.target !== this.node) {
                        var cancelEvent = new EventTouch(event.getTouches(), event.bubbles);
                        cancelEvent.type = NodeEvent$1.TOUCH_CANCEL, cancelEvent.touch = event.touch, cancelEvent.simulate = !0, 
                        event.target.dispatchEvent(cancelEvent), this._touchMoved = !0;
                    }
                    this._stopPropagationIfTargetIsMe(event);
                }
            }
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event, captureListeners) {
            if (this.enabledInHierarchy && this._content && event && !this._hasNestedViewGroup(event, captureListeners)) {
                this._dispatchEvent("touch-up");
                var touch = event.touch;
                this._content && this._handleReleaseLogic(touch), this._touchMoved ? event.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(event);
            }
        }
    }, {
        key: "_onTouchCancelled",
        value: function _onTouchCancelled(event, captureListeners) {
            if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                if (event && !event.simulate) {
                    var touch = event.touch;
                    this._content && this._handleReleaseLogic(touch);
                }
                this._stopPropagationIfTargetIsMe(event);
            }
        }
    }, {
        key: "_calculateBoundary",
        value: function _calculateBoundary() {
            if (this.content) {
                var layout = this.content.getComponent(LayoutComponent);
                layout && layout.enabledInHierarchy && layout.updateLayout();
                var viewSize = this.view.getContentSize(), anchorX = viewSize.width * this.view.anchorX, anchorY = viewSize.height * this.view.anchorY;
                this._leftBoundary = -anchorX, this._bottomBoundary = -anchorY, this._rightBoundary = this._leftBoundary + viewSize.width, 
                this._topBoundary = this._bottomBoundary + viewSize.height, this._moveContentToTopLeft(viewSize);
            }
        }
    }, {
        key: "_hasNestedViewGroup",
        value: function _hasNestedViewGroup(event, captureListeners) {
            if (event && event.eventPhase === cc.Event.CAPTURING_PHASE) {
                if (captureListeners) {
                    var _iterator = captureListeners, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var item = _ref;
                        if (this.node === item) return !(!event.target || !event.target.getComponent(ViewGroupComponent));
                        if (item.getComponent(ViewGroupComponent)) return !0;
                    }
                }
                return !1;
            }
        }
    }, {
        key: "_handleReleaseLogic",
        value: function _handleReleaseLogic(touch) {
            var delta = touch.getUIDelta();
            Vec3.set(this._deltaPos, delta.x, delta.y, 0), this._gatherTouchMove(this._deltaPos), 
            this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent("scroll-ended"));
        }
    }, {
        key: "_startInertiaScroll",
        value: function _startInertiaScroll(touchMoveVelocity) {
            var inertiaTotalMovement = new Vec3(touchMoveVelocity);
            inertiaTotalMovement.multiplyScalar(.7), this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
        }
    }, {
        key: "_calculateAttenuatedFactor",
        value: function _calculateAttenuatedFactor(distance) {
            return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
        }
    }, {
        key: "_startAttenuatingAutoScroll",
        value: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
            var time = this._calculateAutoScrollTimeByInitalSpeed(initialVelocity.length()), targetDelta = new Vec3(deltaMove);
            targetDelta.normalize();
            var contentSize = this._content.getContentSize(), scrollviewSize = this.node.getContentSize(), totalMoveWidth = contentSize.width - scrollviewSize.width, totalMoveHeight = contentSize.height - scrollviewSize.height, attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth), attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
            targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, 
            targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake), 
            targetDelta.z = 0;
            var originalMoveLength = deltaMove.length(), factor = targetDelta.length() / originalMoveLength;
            if (targetDelta.add(deltaMove), this.brake > 0 && factor > 7) {
                factor = Math.sqrt(factor);
                var a = new Vec3(deltaMove);
                a.multiplyScalar(factor), targetDelta.set(a), targetDelta.add(deltaMove);
            }
            this.brake > 0 && factor > 3 && (time *= factor = 3), 0 === this.brake && factor > 1 && (time *= factor), 
            this._startAutoScroll(targetDelta, time, !0);
        }
    }, {
        key: "_calculateAutoScrollTimeByInitalSpeed",
        value: function _calculateAutoScrollTimeByInitalSpeed(initalSpeed) {
            return Math.sqrt(Math.sqrt(initalSpeed / 5));
        }
    }, {
        key: "_startAutoScroll",
        value: function _startAutoScroll(deltaMove, timeInSecond) {
            var attenuated = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
            this._autoScrolling = !0, this._autoScrollTargetDelta = adjustedDeltaMove, this._autoScrollAttenuate = attenuated, 
            Vec3.copy(this._autoScrollStartPosition, this.getContentPosition()), this._autoScrollTotalTime = timeInSecond, 
            this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, 
            this._autoScrollBrakingStartPosition = new Vec3();
            var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
            currentOutOfBoundary.equals(ZERO$1, 1e-4) || (this._autoScrollCurrentlyOutOfBoundary = !0);
        }
    }, {
        key: "_calculateTouchMoveVelocity",
        value: function _calculateTouchMoveVelocity() {
            var totalTime = 0;
            if ((totalTime = this._touchMoveTimeDeltas.reduce(function(a, b) {
                return a + b;
            }, totalTime)) <= 0 || totalTime >= .5) return new Vec3();
            var totalMovement = new Vec3();
            return totalMovement = this._touchMoveDisplacements.reduce(function(a, b) {
                return a.add(b), a;
            }, totalMovement), new Vec3(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, 0);
        }
    }, {
        key: "_flattenVectorByDirection",
        value: function _flattenVectorByDirection(vector) {
            var result = vector;
            return result.x = this.horizontal ? result.x : 0, result.y = this.vertical ? result.y : 0, 
            result;
        }
    }, {
        key: "_moveContent",
        value: function _moveContent(deltaMove, canStartBounceBack) {
            var adjustedMove = this._flattenVectorByDirection(deltaMove);
            _tempPos$2.set(this.getContentPosition()), _tempPos$2.add(adjustedMove), this.setContentPosition(_tempPos$2);
            var outOfBoundary = this._getHowMuchOutOfBoundary();
            this._updateScrollBar(outOfBoundary), this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
        }
    }, {
        key: "_getContentLeftBoundary",
        value: function _getContentLeftBoundary() {
            return this.getContentPosition().x - this._content.getAnchorPoint().x * this._content.getContentSize().width;
        }
    }, {
        key: "_getContentRightBoundary",
        value: function _getContentRightBoundary() {
            var contentSize = this._content.getContentSize();
            return this._getContentLeftBoundary() + contentSize.width;
        }
    }, {
        key: "_getContentTopBoundary",
        value: function _getContentTopBoundary() {
            var contentSize = this._content.getContentSize();
            return this._getContentBottomBoundary() + contentSize.height;
        }
    }, {
        key: "_getContentBottomBoundary",
        value: function _getContentBottomBoundary() {
            return this.getContentPosition().y - this._content.getAnchorPoint().y * this._content.getContentSize().height;
        }
    }, {
        key: "_getHowMuchOutOfBoundary",
        value: function _getHowMuchOutOfBoundary(addition) {
            if ((addition = addition || new Vec3()).equals(ZERO$1, 1e-4) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
            var outOfBoundaryAmount = new Vec3();
            return this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x)), 
            this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y)), 
            addition.equals(ZERO$1, 1e-4) && (this._outOfBoundaryAmount = outOfBoundaryAmount, 
            this._outOfBoundaryAmountDirty = !1), outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
        }
    }, {
        key: "_updateScrollBar",
        value: function _updateScrollBar(outOfBoundary) {
            this._horizontalScrollBar && this._horizontalScrollBar.onScroll(outOfBoundary), 
            this.verticalScrollBar && this.verticalScrollBar.onScroll(outOfBoundary);
        }
    }, {
        key: "_onScrollBarTouchBegan",
        value: function _onScrollBarTouchBegan() {
            this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan();
        }
    }, {
        key: "_onScrollBarTouchEnded",
        value: function _onScrollBarTouchEnded() {
            this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded();
        }
    }, {
        key: "_dispatchEvent",
        value: function _dispatchEvent(event) {
            if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
                var flag = 1 << eventMap[event];
                if (this._scrollEventEmitMask & flag) return;
                this._scrollEventEmitMask |= flag;
            }
            cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]), 
            this.node.emit(event, this);
        }
    }, {
        key: "_adjustContentOutOfBoundary",
        value: function _adjustContentOutOfBoundary() {
            if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
                var outOfBoundary = this._getHowMuchOutOfBoundary(new Vec3()), newPosition = new Vec3(this.getContentPosition());
                newPosition.add(outOfBoundary), this._content && (this._content.setPosition(newPosition), 
                this._updateScrollBar(ZERO$1));
            }
        }
    }, {
        key: "_hideScrollbar",
        value: function _hideScrollbar() {
            this._horizontalScrollBar && this._horizontalScrollBar.hide(), this.verticalScrollBar && this.verticalScrollBar.hide();
        }
    }, {
        key: "_showScrollbar",
        value: function _showScrollbar() {
            this._horizontalScrollBar && this._horizontalScrollBar.show(), this.verticalScrollBar && this.verticalScrollBar.show();
        }
    }, {
        key: "_stopPropagationIfTargetIsMe",
        value: function _stopPropagationIfTargetIsMe(event) {
            event && event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && (event.propagationStopped = !0);
        }
    }, {
        key: "_processDeltaMove",
        value: function _processDeltaMove(deltaMove) {
            this._scrollChildren(deltaMove), this._gatherTouchMove(deltaMove);
        }
    }, {
        key: "_handleMoveLogic",
        value: function _handleMoveLogic(touch) {
            var delta = touch.getUIDelta();
            Vec3.set(this._deltaPos, delta.x, delta.y, 0), this._processDeltaMove(this._deltaPos);
        }
    }, {
        key: "_scrollChildren",
        value: function _scrollChildren(deltaMove) {
            var outOfBoundary, realMove = deltaMove = this._clampDelta(deltaMove);
            this.elastic && (outOfBoundary = this._getHowMuchOutOfBoundary(), realMove.x *= 0 === outOfBoundary.x ? 1 : .5, 
            realMove.y *= 0 === outOfBoundary.y ? 1 : .5), this.elastic || (outOfBoundary = this._getHowMuchOutOfBoundary(realMove), 
            realMove.add(outOfBoundary));
            var scrollEventType = "", pos = new Vec3();
            if (this._content.getPosition(pos), realMove.y > 0) pos.y - this._content.anchorY * this._content.height + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom"); else if (realMove.y < 0) {
                pos.y - this._content.anchorY * this._content.height + this._content.height + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
            } else if (realMove.x < 0) {
                pos.x - this._content.anchorX * this._content.width + this._content.width + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
            } else if (realMove.x > 0) {
                pos.x - this._content.anchorX * this._content.width + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
            }
            this._moveContent(realMove, !1), 0 === realMove.x && 0 === realMove.y || (this._scrolling || (this._scrolling = !0, 
            this._dispatchEvent("scroll-began")), this._dispatchEvent("scrolling")), scrollEventType.length > 0 && this._dispatchEvent(scrollEventType);
        }
    }, {
        key: "_handlePressLogic",
        value: function _handlePressLogic() {
            this._autoScrolling && this._dispatchEvent("scroll-ended"), this._autoScrolling = !1, 
            this._isBouncing = !1, this._touchMovePreviousTimestamp = getTimeInMilliseconds(), 
            this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan();
        }
    }, {
        key: "_clampDelta",
        value: function _clampDelta(delta) {
            var contentSize = this._content.getContentSize(), scrollViewSize = this.node.getContentSize();
            return contentSize.width < scrollViewSize.width && (delta.x = 0), contentSize.height < scrollViewSize.height && (delta.y = 0), 
            delta;
        }
    }, {
        key: "_gatherTouchMove",
        value: function _gatherTouchMove(delta) {
            for (delta = this._clampDelta(delta); this._touchMoveDisplacements.length >= 5; ) this._touchMoveDisplacements.shift(), 
            this._touchMoveTimeDeltas.shift();
            this._touchMoveDisplacements.push(delta);
            var timeStamp = getTimeInMilliseconds();
            this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3), 
            this._touchMovePreviousTimestamp = timeStamp;
        }
    }, {
        key: "_startBounceBackIfNeeded",
        value: function _startBounceBackIfNeeded() {
            if (!this.elastic) return !1;
            var bounceBackAmount = this._getHowMuchOutOfBoundary();
            if ((bounceBackAmount = this._clampDelta(bounceBackAmount)).equals(ZERO$1, 1e-4)) return !1;
            var bounceBackTime = Math.max(this.bounceDuration, 0);
            return this._startAutoScroll(bounceBackAmount, bounceBackTime, !0), this._isBouncing || (bounceBackAmount.y > 0 && this._dispatchEvent("bounce-top"), 
            bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom"), bounceBackAmount.x > 0 && this._dispatchEvent("bounce-right"), 
            bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left"), this._isBouncing = !0), 
            !0;
        }
    }, {
        key: "_processInertiaScroll",
        value: function _processInertiaScroll() {
            if (!this._startBounceBackIfNeeded() && this.inertia) {
                var touchMoveVelocity = this._calculateTouchMoveVelocity();
                !touchMoveVelocity.equals(_tempPos$2, 1e-4) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
            }
            this._onScrollBarTouchEnded();
        }
    }, {
        key: "_isOutOfBoundary",
        value: function _isOutOfBoundary() {
            return !this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4);
        }
    }, {
        key: "_isNecessaryAutoScrollBrake",
        value: function _isNecessaryAutoScrollBrake() {
            if (this._autoScrollBraking) return !0;
            if (this._isOutOfBoundary()) {
                if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, 
                this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = this.getContentPosition(), 
                !0;
            } else this._autoScrollCurrentlyOutOfBoundary = !1;
            return !1;
        }
    }, {
        key: "_processAutoScrolling",
        value: function _processAutoScrolling(dt) {
            var isAutoScrollBrake = this._isNecessaryAutoScrollBrake(), brakingFactor = isAutoScrollBrake ? .05 : 1;
            this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
            var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
            this._autoScrollAttenuate && (percentage = function quintEaseOut(time) {
                return (time -= 1) * time * time * time * time + 1;
            }(percentage));
            var a = new Vec3(this._autoScrollTargetDelta);
            a.multiplyScalar(percentage);
            var newPosition = new Vec3(this._autoScrollStartPosition);
            newPosition.add(a);
            var reachedEnd = Math.abs(percentage - 1) <= 1e-4;
            if (Math.abs(percentage - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent("scroll-ended-with-threshold"), 
            this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
                var brakeOffsetPosition = new Vec3(newPosition);
                brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition), isAutoScrollBrake && brakeOffsetPosition.multiplyScalar(brakingFactor), 
                newPosition.set(this._autoScrollBrakingStartPosition), newPosition.add(brakeOffsetPosition);
            } else {
                var moveDelta = new Vec3(newPosition);
                moveDelta.subtract(this.getContentPosition());
                var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                outOfBoundary.equals(ZERO$1, 1e-4) || (newPosition.add(outOfBoundary), reachedEnd = !0);
            }
            reachedEnd && (this._autoScrolling = !1);
            var deltaMove = new Vec3(newPosition);
            deltaMove.subtract(this.getContentPosition()), this._moveContent(this._clampDelta(deltaMove), reachedEnd), 
            this._dispatchEvent("scrolling"), this._autoScrolling || (this._isBouncing = !1, 
            this._scrolling = !1, this._dispatchEvent("scroll-ended"));
        }
    }, {
        key: "_checkMouseWheel",
        value: function _checkMouseWheel(dt) {
            if (!this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4)) return this._processInertiaScroll(), 
            this.unschedule(this._checkMouseWheel), void (this._stopMouseWheel = !1);
            this._mouseWheelEventElapsedTime += dt, this._mouseWheelEventElapsedTime > .1 && (this._onScrollBarTouchEnded(), 
            this.unschedule(this._checkMouseWheel), this._stopMouseWheel = !1);
        }
    }, {
        key: "_calculateMovePercentDelta",
        value: function _calculateMovePercentDelta(options) {
            var anchor = options.anchor, applyToHorizontal = options.applyToHorizontal, applyToVertical = options.applyToVertical;
            this._calculateBoundary(), anchor.clampf(new Vec2(0, 0), new Vec2(1, 1));
            var scrollSize = this.node.getContentSize(), contentSize = this._content.getContentSize(), bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
            bottomDeta = -bottomDeta;
            var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
            leftDeta = -leftDeta;
            var moveDelta = new Vec3(), totalScrollDelta = 0;
            return applyToHorizontal && (totalScrollDelta = contentSize.width - scrollSize.width, 
            moveDelta.x = leftDeta - totalScrollDelta * anchor.x), applyToVertical && (totalScrollDelta = contentSize.height - scrollSize.height, 
            moveDelta.y = bottomDeta - totalScrollDelta * anchor.y), moveDelta;
        }
    }, {
        key: "_moveContentToTopLeft",
        value: function _moveContentToTopLeft(scrollViewSize) {
            var contentSize = this._content.getContentSize(), bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
            bottomDeta = -bottomDeta;
            var moveDelta = new Vec3(), totalScrollDelta = 0, leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
            leftDeta = -leftDeta, contentSize.height < scrollViewSize.height ? (totalScrollDelta = contentSize.height - scrollViewSize.height, 
            moveDelta.y = bottomDeta - totalScrollDelta, this.verticalScrollBar && this.verticalScrollBar.hide()) : this.verticalScrollBar && this.verticalScrollBar.show(), 
            contentSize.width < scrollViewSize.width ? (totalScrollDelta = contentSize.width - scrollViewSize.width, 
            moveDelta.x = leftDeta, this._horizontalScrollBar && this._horizontalScrollBar.hide()) : this._horizontalScrollBar && this._horizontalScrollBar.show(), 
            this._moveContent(moveDelta), this._adjustContentOutOfBoundary();
        }
    }, {
        key: "content",
        get: function get() {
            return this._content;
        },
        set: function set(value) {
            this._content !== value && (this._content = value, this._calculateBoundary());
        }
    }, {
        key: "horizontalScrollBar",
        get: function get() {
            return this._horizontalScrollBar;
        },
        set: function set(value) {
            this._horizontalScrollBar !== value && (this._horizontalScrollBar = value, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), 
            this._updateScrollBar(ZERO$1)));
        }
    }, {
        key: "verticalScrollBar",
        get: function get() {
            return this._verticalScrollBar;
        },
        set: function set(value) {
            this._verticalScrollBar !== value && (this._verticalScrollBar = value, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), 
            this._updateScrollBar(ZERO$1)));
        }
    }, {
        key: "view",
        get: function get() {
            return this._content ? this._content.parent : null;
        }
    } ]), ScrollViewComponent;
}(), _class3$p.EventType = ScrollViewEventType, _applyDecoratedDescriptor((_class2$J = _temp$M).prototype, "content", [ _dec4$h ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "content"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "horizontalScrollBar", [ _dec5$h ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "horizontalScrollBar"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "verticalScrollBar", [ _dec6$f ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "verticalScrollBar"), _class2$J.prototype), 
_descriptor$H = _applyDecoratedDescriptor(_class2$J.prototype, "horizontal", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor2$y = _applyDecoratedDescriptor(_class2$J.prototype, "vertical", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$m = _applyDecoratedDescriptor(_class2$J.prototype, "inertia", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$j = _applyDecoratedDescriptor(_class2$J.prototype, "brake", [ _dec7$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .5;
    }
}), _descriptor5$h = _applyDecoratedDescriptor(_class2$J.prototype, "elastic", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor6$a = _applyDecoratedDescriptor(_class2$J.prototype, "bounceDuration", [ _dec8$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor7$9 = _applyDecoratedDescriptor(_class2$J.prototype, "scrollEvents", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor8$9 = _applyDecoratedDescriptor(_class2$J.prototype, "cancelInnerEvents", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor9$8 = _applyDecoratedDescriptor(_class2$J.prototype, "_content", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor10$7 = _applyDecoratedDescriptor(_class2$J.prototype, "_horizontalScrollBar", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor11$6 = _applyDecoratedDescriptor(_class2$J.prototype, "_verticalScrollBar", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$S = _class2$J)) || _class$S) || _class$S) || _class$S);

cc.ScrollViewComponent = ScrollViewComponent;

var Direction$1, _tempPos$3 = new Vec3();

!function(Direction) {
    Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
}(Direction$1 || (Direction$1 = {})), ccenum(Direction$1);

var _dec$T, _dec2$z, _dec3$n, _dec4$j, _class$U, _class2$L, _descriptor$J, _descriptor2$A, SliderComponent = (_dec$S = ccclass("cc.SliderComponent"), 
_dec2$y = executionOrder(110), _dec3$m = menu("UI/Slider"), _dec4$i = property({
    type: SpriteComponent
}), _dec5$i = property({
    type: Direction$1
}), _dec6$g = property({
    slide: !0,
    range: [ 0, 1, .01 ]
}), _dec7$c = property({
    type: EventHandler
}), _dec$S(_class$T = _dec2$y(_class$T = _dec3$m((_temp$N = _class3$q = function(_Component) {
    function SliderComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SliderComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SliderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "slideEvents", _descriptor$I, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_handle", _descriptor2$z, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_progress", _descriptor4$k, _assertThisInitialized(_this)), 
        _this._offset = new Vec3(), _this._dragging = !1, _this._touchHandle = !1, _this._handlelocalPos = new Vec3(), 
        _this._touchPos = new Vec3(), _this;
    }
    return _inherits(SliderComponent, Component), _createClass(SliderComponent, [ {
        key: "__preload",
        value: function __preload() {
            this._updateHandlePosition();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._updateHandlePosition(), this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this), 
            this.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this), 
            this.node.on(SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), this._handle && this._handle.isValid && (this._handle.node.on(SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
            this._handle.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this));
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
            this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.off(SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
            this._handle && this._handle.isValid && (this._handle.node.off(SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
            this._handle.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this));
        }
    }, {
        key: "_onHandleDragStart",
        value: function _onHandleDragStart(event) {
            if (event && this._handle && this._handle.node.uiTransfromComp) {
                this._dragging = !0, this._touchHandle = !0;
                var touhPos = event.touch.getUILocation();
                Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0), this._handle.node.uiTransfromComp.convertToNodeSpaceAR(this._touchPos, this._offset), 
                event.propagationStopped = !0;
            }
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event) {
            this._handle && event && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(event.touch), 
            event.propagationStopped = !0);
        }
    }, {
        key: "_onTouchMoved",
        value: function _onTouchMoved(event) {
            this._dragging && event && (this._handleSliderLogic(event.touch), event.propagationStopped = !0);
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            this._dragging = !1, this._touchHandle = !1, this._offset = cc.v2(), event && (event.propagationStopped = !0);
        }
    }, {
        key: "_onTouchCancelled",
        value: function _onTouchCancelled(event) {
            this._dragging = !1, event && (event.propagationStopped = !0);
        }
    }, {
        key: "_handleSliderLogic",
        value: function _handleSliderLogic(touch) {
            this._updateProgress(touch), this._emitSlideEvent();
        }
    }, {
        key: "_emitSlideEvent",
        value: function _emitSlideEvent() {
            cc.Component.EventHandler.emitEvents(this.slideEvents, this), this.node.emit("slide", this);
        }
    }, {
        key: "_updateProgress",
        value: function _updateProgress(touch) {
            if (this._handle && touch) {
                var touchPos = touch.getUILocation();
                Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                var localTouchPos = this.node.uiTransfromComp.convertToNodeSpaceAR(this._touchPos, _tempPos$3);
                this.direction === Direction$1.Horizontal ? this.progress = clamp01(.5 + (localTouchPos.x - this._offset.x) / this.node.width) : this.progress = clamp01(.5 + (localTouchPos.y - this._offset.y) / this.node.height);
            }
        }
    }, {
        key: "_updateHandlePosition",
        value: function _updateHandlePosition() {
            this._handle && (this._handlelocalPos.set(this._handle.node.getPosition()), this._direction === Direction$1.Horizontal ? this._handlelocalPos.x = -this.node.width * this.node.anchorX + this.progress * this.node.width : this._handlelocalPos.y = -this.node.height * this.node.anchorY + this.progress * this.node.height, 
            this._handle.node.setPosition(this._handlelocalPos));
        }
    }, {
        key: "handle",
        get: function get() {
            return this._handle;
        },
        set: function set(value) {
            this._handle !== value && (this._handle = value);
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value);
        }
    }, {
        key: "progress",
        get: function get() {
            return this._progress;
        },
        set: function set(value) {
            this._progress !== value && (this._progress = value, this._updateHandlePosition());
        }
    } ]), SliderComponent;
}(), _class3$q.Direction = Direction$1, _applyDecoratedDescriptor((_class2$K = _temp$N).prototype, "handle", [ _dec4$i ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "handle"), _class2$K.prototype), 
_applyDecoratedDescriptor(_class2$K.prototype, "direction", [ _dec5$i ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "direction"), _class2$K.prototype), 
_applyDecoratedDescriptor(_class2$K.prototype, "progress", [ _dec6$g ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "progress"), _class2$K.prototype), 
_descriptor$I = _applyDecoratedDescriptor(_class2$K.prototype, "slideEvents", [ _dec7$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$z = _applyDecoratedDescriptor(_class2$K.prototype, "_handle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$n = _applyDecoratedDescriptor(_class2$K.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction$1.Horizontal;
    }
}), _descriptor4$k = _applyDecoratedDescriptor(_class2$K.prototype, "_progress", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _class$T = _class2$K)) || _class$T) || _class$T) || _class$T);

cc.SliderComponent = SliderComponent;

var _dec$U, _dec2$A, _dec3$o, _dec4$k, _dec5$j, _dec6$h, _class$V, _class2$M, _descriptor$K, _descriptor2$B, _descriptor3$o, _descriptor4$l, ToggleContainerComponent = (_dec$T = ccclass("cc.ToggleContainerComponent"), 
_dec2$z = executionOrder(110), _dec3$n = menu("UI/ToggleContainer"), _dec4$j = property({
    type: EventHandler
}), _dec$T(_class$U = _dec2$z(_class$U = _dec3$n(_class$U = executeInEditMode((_descriptor$J = _applyDecoratedDescriptor((_class2$L = function(_Component) {
    function ToggleContainerComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ToggleContainerComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleContainerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor2$A, _assertThisInitialized(_this)), 
        _this._toggleItems = [], _this;
    }
    return _inherits(ToggleContainerComponent, Component), _createClass(ToggleContainerComponent, [ {
        key: "start",
        value: function start() {
            this._makeAtLeastOneToggleChecked();
        }
    }, {
        key: "updateToggles",
        value: function updateToggles(toggle) {
            this.enabledInHierarchy && toggle.isChecked && (this.toggleItems.forEach(function(item) {
                item !== toggle && item.isChecked && item.enabled && (item.isChecked = !1);
            }), this.checkEvents && EventHandler.emitEvents(this.checkEvents, toggle));
        }
    }, {
        key: "addToggle",
        value: function addToggle(toggle) {
            -1 === this._toggleItems.indexOf(toggle) && this._toggleItems.push(toggle), this._allowOnlyOneToggleChecked();
        }
    }, {
        key: "removeToggle",
        value: function removeToggle(toggle) {
            var index = this._toggleItems.indexOf(toggle);
            index > -1 && this._toggleItems.splice(index, 1), this._makeAtLeastOneToggleChecked();
        }
    }, {
        key: "_allowOnlyOneToggleChecked",
        value: function _allowOnlyOneToggleChecked() {
            var isChecked = !1;
            return this._toggleItems.forEach(function(item) {
                isChecked && item.enabled && (item.isChecked = !1), item.isChecked && item.enabled && (isChecked = !0);
            }), isChecked;
        }
    }, {
        key: "_makeAtLeastOneToggleChecked",
        value: function _makeAtLeastOneToggleChecked() {
            this._allowOnlyOneToggleChecked() || this._allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = !0);
        }
    }, {
        key: "allowSwitchOff",
        get: function get() {
            return this._allowSwitchOff;
        },
        set: function set(value) {
            this._allowSwitchOff = value;
        }
    }, {
        key: "toggleItems",
        get: function get() {
            return this._toggleItems;
        }
    } ]), ToggleContainerComponent;
}()).prototype, "checkEvents", [ _dec4$j ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$A = _applyDecoratedDescriptor(_class2$L.prototype, "_allowSwitchOff", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$L.prototype, "allowSwitchOff", [ property ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "allowSwitchOff"), _class2$L.prototype), 
_class$U = _class2$L)) || _class$U) || _class$U) || _class$U) || _class$U);

cc.ToggleContainerComponent = ToggleContainerComponent;

var _class$W, ToggleComponent = (_dec$U = ccclass("cc.ToggleComponent"), _dec2$A = executionOrder(110), 
_dec3$o = menu("UI/Toggle"), _dec4$k = property({
    type: ToggleContainerComponent
}), _dec5$j = property({
    type: SpriteComponent
}), _dec6$h = property({
    type: EventHandler
}), _dec$U(_class$V = _dec2$A(_class$V = _dec3$o(_class$V = executeInEditMode((_applyDecoratedDescriptor((_class2$M = function(_ButtonComponent) {
    function ToggleComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ToggleComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$K, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isChecked", _descriptor2$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_toggleGroup", _descriptor3$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_checkMark", _descriptor4$l, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ToggleComponent, ButtonComponent), _createClass(ToggleComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(ToggleComponent.prototype), "onEnable", this).call(this), this._registerToggleEvent(), 
            this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(ToggleComponent.prototype), "onDisable", this).call(this), 
            this._unregisterToggleEvent(), this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.removeToggle(this);
        }
    }, {
        key: "toggle",
        value: function toggle() {
            var group = this.toggleGroup || this._toggleContainer;
            group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !this.isChecked, 
            group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
        }
    }, {
        key: "check",
        value: function check() {
            var group = this.toggleGroup || this._toggleContainer;
            group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !0, 
            group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
        }
    }, {
        key: "uncheck",
        value: function uncheck() {
            var group = this.toggleGroup || this._toggleContainer;
            group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !1, 
            this._emitToggleEvents());
        }
    }, {
        key: "_updateCheckMark",
        value: function _updateCheckMark() {
            this._checkMark && (this._checkMark.node.active = !!this.isChecked);
        }
    }, {
        key: "_registerToggleEvent",
        value: function _registerToggleEvent() {
            this.node.on("click", this.toggle, this);
        }
    }, {
        key: "_unregisterToggleEvent",
        value: function _unregisterToggleEvent() {
            this.node.off("click", this.toggle, this);
        }
    }, {
        key: "_emitToggleEvents",
        value: function _emitToggleEvents() {
            this.node.emit("toggle", this), this.checkEvents && EventHandler.emitEvents(this.checkEvents, this);
        }
    }, {
        key: "isChecked",
        get: function get() {
            return this._isChecked;
        },
        set: function set(value) {
            this._isChecked !== value && (this._isChecked = value, this._updateCheckMark());
        }
    }, {
        key: "toggleGroup",
        get: function get() {
            return this._toggleGroup;
        },
        set: function set(value) {
            this._toggleGroup !== value && (this._toggleGroup && this._toggleGroup.removeToggle(this), 
            this._toggleGroup = value, this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this));
        }
    }, {
        key: "checkMark",
        get: function get() {
            return this._checkMark;
        },
        set: function set(value) {
            this._checkMark !== value && (this._checkMark = value);
        }
    }, {
        key: "_resizeToTarget",
        set: function set(value) {
            value && this._resizeNodeToTargetNode();
        }
    }, {
        key: "_toggleContainer",
        get: function get() {
            this.node.parent;
            return null;
        }
    } ]), ToggleComponent;
}()).prototype, "isChecked", [ property ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "isChecked"), _class2$M.prototype), 
_applyDecoratedDescriptor(_class2$M.prototype, "toggleGroup", [ _dec4$k ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "toggleGroup"), _class2$M.prototype), 
_applyDecoratedDescriptor(_class2$M.prototype, "checkMark", [ _dec5$j ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "checkMark"), _class2$M.prototype), 
_descriptor$K = _applyDecoratedDescriptor(_class2$M.prototype, "checkEvents", [ _dec6$h ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$B = _applyDecoratedDescriptor(_class2$M.prototype, "_isChecked", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$o = _applyDecoratedDescriptor(_class2$M.prototype, "_toggleGroup", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$l = _applyDecoratedDescriptor(_class2$M.prototype, "_checkMark", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$V = _class2$M)) || _class$V) || _class$V) || _class$V) || _class$V);

cc.ToggleComponent = ToggleComponent;

var _class$X, _class2$N, _temp$R, UIModelComponent = ccclass("cc.UIModelComponent")(_class$W = executionOrder(110)(_class$W = menu("UI/Model")(_class$W = function(_UIComponent) {
    function UIModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._modelComponent = null, 
        _this;
    }
    return _inherits(UIModelComponent, UIComponent), _createClass(UIModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent ? (this._modelComponent._sceneGetter = cc.director.root.ui.getRenderSceneGetter(), 
            this._modelComponent.recreateModel()) : console.warn("Use this component on a node".concat(this.node && this.node.name, " that has a model component"));
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent && (this._modelComponent._sceneGetter = null, 
            this._modelComponent.recreateModel());
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {
            return !!this._modelComponent && (render.commitModel.call(render, this, this._modelComponent._getModel(), this._modelComponent.material), 
            !0);
        }
    }, {
        key: "update",
        value: function update() {
            this._fitUIRenderQueue();
        }
    }, {
        key: "_fitUIRenderQueue",
        value: function _fitUIRenderQueue() {
            if (this._modelComponent) {
                for (var matNum = this._modelComponent.sharedMaterials.length, i = 0; i < matNum; i++) {
                    var material = this._modelComponent.getMaterial(i);
                    if (null != material) {
                        for (var passes = material.passes, ea = material.effectAsset, techIdx = material.technique, passNum = passes.length, needReconstruct = !1, j = 0; j < passNum; j++) {
                            if (!passes[j].blendState.targets[0].blend) needReconstruct = !0, passes[j].blendState.targets[0].blend = !0, 
                            passes[j].overridePipelineStates(ea.techniques[techIdx].passes[j], {
                                blendState: passes[j].blendState
                            });
                        }
                        needReconstruct && material._onPassesChange();
                    }
                }
                for (var _i = 0; _i < matNum; _i++) {
                    var _material = this._modelComponent.getMaterial(_i);
                    if (null != _material) {
                        var _iterator = _material.passes, _isArray = Array.isArray(_iterator), _i2 = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i2 >= _iterator.length) break;
                                _ref = _iterator[_i2++];
                            } else {
                                if ((_i2 = _iterator.next()).done) break;
                                _ref = _i2.value;
                            }
                            _ref._priority = RenderPriority.MAX - 11;
                        }
                    }
                }
            }
        }
    }, {
        key: "modelComponent",
        get: function get() {
            return this._modelComponent;
        }
    } ]), UIModelComponent;
}()) || _class$W) || _class$W) || _class$W;

cc.UIModelComponent = UIModelComponent;

var WebViewEventType, _mat4_temp$2 = new Mat4();

!function(WebViewEventType) {
    WebViewEventType[WebViewEventType.LOADING = 0] = "LOADING", WebViewEventType[WebViewEventType.LOADED = 1] = "LOADED", 
    WebViewEventType[WebViewEventType.ERROR = 2] = "ERROR", WebViewEventType[WebViewEventType.JS_EVALUATED = 3] = "JS_EVALUATED";
}(WebViewEventType || (WebViewEventType = {}));

var polyfill$1 = {
    devicePixelRatio: !1,
    enableDiv: !1
};

sys.os === sys.OS_IOS && (polyfill$1.enableDiv = !0), sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill$1.enableBG = !0) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill$1.closeHistory = !0);

var _dec$X, _dec2$C, _dec3$q, _dec4$l, _class$Y, _class2$O, _descriptor$L, _descriptor2$C, _class3$r, _temp$S, WebViewImpl = ccclass("cc.WebviewImpl")((_temp$R = _class2$N = function() {
    function WebViewImpl() {
        _classCallCheck(this, WebViewImpl), this._EventList = new Map(), this._visible = !1, 
        this._div = null, this._iframe = null, this._forceUpdate = !0, this._m00 = 0, this._m01 = 0, 
        this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._w = 0, this._h = 0, 
        this._eventListeners = {
            load: function load() {},
            error: function error() {}
        };
    }
    return _createClass(WebViewImpl, [ {
        key: "createDomElementIfNeeded",
        value: function createDomElementIfNeeded(w, h) {
            this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
        }
    }, {
        key: "removeDom",
        value: function removeDom() {
            var div = this._div;
            div && (contains$1(cc.game.container, div) && cc.game.container.removeChild(div), 
            this._div = null);
            var iframe = this._iframe;
            if (iframe) {
                var cbs = this._eventListeners;
                iframe.removeEventListener("load", cbs.load), iframe.removeEventListener("error", cbs.error), 
                cbs.load = null, cbs.error = null, this._iframe = null;
            }
        }
    }, {
        key: "loadURL",
        value: function loadURL(url) {
            var iframe = this._iframe;
            if (iframe) {
                iframe.src = url;
                var self = this;
                iframe.addEventListener("load", function cb() {
                    self._updateVisibility(), iframe.removeEventListener("load", cb);
                }), this._dispatchEvent(WebViewImpl.EventType.LOADING);
            }
        }
    }, {
        key: "stopLoading",
        value: function stopLoading() {
            cc.logID(7800);
        }
    }, {
        key: "reload",
        value: function reload() {
            var iframe = this._iframe;
            if (iframe) {
                var win = iframe.contentWindow;
                win && win.location && win.location.reload();
            }
        }
    }, {
        key: "canGoBack",
        value: function canGoBack() {
            return cc.logID(7801), !0;
        }
    }, {
        key: "canGoForward",
        value: function canGoForward() {
            return cc.logID(7802), !0;
        }
    }, {
        key: "goBack",
        value: function goBack() {
            try {
                if (WebViewImpl.Polyfill.closeHistory) return cc.logID(7803);
                var iframe = this._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.history.back.call(win);
                }
            } catch (err) {
                cc.log(err);
            }
        }
    }, {
        key: "goForward",
        value: function goForward() {
            try {
                if (WebViewImpl.Polyfill.closeHistory) return cc.logID(7804);
                var iframe = this._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.history.forward.call(win);
                }
            } catch (err) {
                cc.log(err);
            }
        }
    }, {
        key: "evaluateJS",
        value: function evaluateJS(str) {
            var iframe = this._iframe;
            if (iframe) iframe.contentWindow;
        }
    }, {
        key: "setScalesPageToFit",
        value: function setScalesPageToFit() {
            cc.logID(7805);
        }
    }, {
        key: "setEventListener",
        value: function setEventListener(event, callback) {
            this._EventList[event] = callback;
        }
    }, {
        key: "removeEventListener",
        value: function removeEventListener(event) {
            this._EventList[event] = null;
        }
    }, {
        key: "_dispatchEvent",
        value: function _dispatchEvent(event) {
            var callback = this._EventList[event];
            callback && this._iframe && callback.call(this, this, this._iframe.src);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.removeDom();
        }
    }, {
        key: "setVisible",
        value: function setVisible(visible) {
            this._visible !== visible && (this._visible = !!visible, this._updateVisibility());
        }
    }, {
        key: "updateMatrix",
        value: function updateMatrix(node) {
            if (this._div && this._visible) {
                node.getWorldMatrix(_mat4_temp$2);
                var contentSize = node.getContentSize();
                if (this._forceUpdate || this._m00 !== _mat4_temp$2.m00 || this._m01 !== _mat4_temp$2.m01 || this._m04 !== _mat4_temp$2.m04 || this._m05 !== _mat4_temp$2.m05 || this._m12 !== _mat4_temp$2.m12 || this._m13 !== _mat4_temp$2.m13 || this._w !== contentSize.width || this._h !== contentSize.height) {
                    this._m00 = _mat4_temp$2.m00, this._m01 = _mat4_temp$2.m01, this._m04 = _mat4_temp$2.m04, 
                    this._m05 = _mat4_temp$2.m05, this._m12 = _mat4_temp$2.m12, this._m13 = _mat4_temp$2.m13, 
                    this._w = contentSize.width, this._h = contentSize.height;
                    var scaleX = cc.view._scaleX, scaleY = cc.view._scaleY, dpr = cc.view._devicePixelRatio;
                    scaleX /= dpr, scaleY /= dpr;
                    var container = cc.game.container, a = _mat4_temp$2.m00 * scaleX, b = _mat4_temp$2.m01, c = _mat4_temp$2.m04, d = _mat4_temp$2.m05 * scaleY, offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0, offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                    this._updateSize(this._w, this._h);
                    var w = this._div.clientWidth * scaleX, h = this._div.clientHeight * scaleY, ap = node.getAnchorPoint(), appx = w * _mat4_temp$2.m00 * ap.x, appy = h * _mat4_temp$2.m05 * ap.y, matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + (_mat4_temp$2.m12 * scaleX - appx + offsetX) + "," + -(_mat4_temp$2.m13 * scaleY - appy + offsetY) + ")";
                    this._div.style.transform = matrix, this._div.style["-webkit-transform"] = matrix, 
                    this._div.style["transform-origin"] = "0px 100% 0px", this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
                    var renderComp = node.getComponent(UIRenderComponent);
                    renderComp && this._setOpacity(renderComp.color.a);
                }
            }
        }
    }, {
        key: "setOnJSCallback",
        value: function setOnJSCallback(callback) {}
    }, {
        key: "setJavascriptInterfaceScheme",
        value: function setJavascriptInterfaceScheme(scheme) {}
    }, {
        key: "loadData",
        value: function loadData(data, MIMEType, encoding, baseURL) {}
    }, {
        key: "loadHTMLString",
        value: function loadHTMLString(string, baseURL) {}
    }, {
        key: "_updateVisibility",
        value: function _updateVisibility() {
            if (this._div) {
                var div = this._div;
                this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden", 
                this._forceUpdate = !0;
            }
        }
    }, {
        key: "_updateSize",
        value: function _updateSize(w, h) {
            var div = this._div;
            div && (div.style.width = w + "px", div.style.height = h + "px");
        }
    }, {
        key: "_initEvent",
        value: function _initEvent() {
            var iframe = this._iframe;
            if (iframe) {
                var cbs = this._eventListeners, self = this;
                cbs.load = function() {
                    self._dispatchEvent(WebViewImpl.EventType.LOADED);
                }, cbs.error = function() {
                    self._dispatchEvent(WebViewImpl.EventType.ERROR);
                }, iframe.addEventListener("load", cbs.load), iframe.addEventListener("error", cbs.error);
            }
        }
    }, {
        key: "_initStyle",
        value: function _initStyle() {
            if (this._div) {
                var div = this._div;
                div.style.position = "absolute", div.style.bottom = "0px", div.style.left = "0px";
            }
        }
    }, {
        key: "_setOpacity",
        value: function _setOpacity(opacity) {
            var iframe = this._iframe;
            iframe && iframe.style && (iframe.style.opacity = (opacity / 255).toString());
        }
    }, {
        key: "_createDom",
        value: function _createDom(w, h) {
            WebViewImpl.Polyfill.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", 
            this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), 
            this._div.appendChild(this._iframe), this._iframe.style.width = "100%", this._iframe.style.height = "100%") : this._div = this._iframe = document.createElement("iframe"), 
            WebViewImpl.Polyfill.enableBG && (this._div.style.background = "#FFF"), this._div.style.background = "#FFF", 
            this._div.style.height = h + "px", this._div.style.width = w + "px", this._div.style.overflow = "scroll", 
            this._iframe.style.border = "none", cc.game.container.appendChild(this._div), this._updateVisibility();
        }
    }, {
        key: "_createNativeControl",
        value: function _createNativeControl(w, h) {
            this._createDom(w, h), this._initStyle(), this._initEvent();
        }
    } ]), WebViewImpl;
}(), _class2$N.Polyfill = polyfill$1, _class2$N.EventType = WebViewEventType, _class$X = _temp$R)) || _class$X, EventType = WebViewEventType;

function emptyCallback() {}

var _class$Z, WebviewComponent = (_dec$X = ccclass("cc.WebviewComponent"), _dec2$C = menu("UI/WebView"), 
_dec3$q = executionOrder(100), _dec4$l = property({
    type: EventHandler
}), _dec$X(_class$Y = _dec2$C(_class$Y = _dec3$q((_temp$S = _class3$r = function(_UIComponent) {
    function WebviewComponent() {
        var _this;
        return _classCallCheck(this, WebviewComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(WebviewComponent).call(this)), "webviewEvents", _descriptor$L, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_url", _descriptor2$C, _assertThisInitialized(_this)), 
        _this._impl = null, _this._impl = new WebViewImpl(), _this;
    }
    return _inherits(WebviewComponent, UIComponent), _createClass(WebviewComponent, [ {
        key: "url",
        get: function get() {
            return this._url;
        },
        set: function set(url) {
            this._url = url;
            var impl = this._impl;
            impl && impl.loadURL(url);
        }
    } ]), _createClass(WebviewComponent, [ {
        key: "onRestore",
        value: function onRestore() {
            this._impl || (this._impl = new WebViewImpl());
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            if (this._impl) {
                var impl = this._impl;
                impl.createDomElementIfNeeded(this.node.width, this.node.height), impl.loadURL(this._url), 
                impl.setVisible(!0), impl.setEventListener(EventType.LOADED, this._onWebViewLoaded.bind(this)), 
                impl.setEventListener(EventType.LOADING, this._onWebViewLoading.bind(this)), impl.setEventListener(EventType.ERROR, this._onWebViewLoadError.bind(this));
            }
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            if (this._impl) {
                var impl = this._impl;
                impl.setVisible(!1), impl.setEventListener(EventType.LOADED, emptyCallback), impl.setEventListener(EventType.LOADING, emptyCallback), 
                impl.setEventListener(EventType.ERROR, emptyCallback);
            }
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._impl && (this._impl.destroy(), this._impl = null);
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._impl && this._impl.updateMatrix(this.node);
        }
    }, {
        key: "setJavascriptInterfaceScheme",
        value: function setJavascriptInterfaceScheme(scheme) {
            this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
        }
    }, {
        key: "setOnJSCallback",
        value: function setOnJSCallback(callback) {
            this._impl && this._impl.setOnJSCallback(callback);
        }
    }, {
        key: "evaluateJS",
        value: function evaluateJS(str) {
            this._impl && this._impl.evaluateJS(str);
        }
    }, {
        key: "_onWebViewLoaded",
        value: function _onWebViewLoaded() {
            EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADED), this.node.emit("loaded", this);
        }
    }, {
        key: "_onWebViewLoading",
        value: function _onWebViewLoading() {
            return EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADING), this.node.emit("loading", this), 
            !0;
        }
    }, {
        key: "_onWebViewLoadError",
        value: function _onWebViewLoadError() {
            EventHandler.emitEvents(this.webviewEvents, this, EventType.ERROR), this.node.emit("error", this);
        }
    } ]), WebviewComponent;
}(), _class3$r.EventType = EventType, _applyDecoratedDescriptor((_class2$O = _temp$S).prototype, "url", [ property ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "url"), _class2$O.prototype), 
_descriptor$L = _applyDecoratedDescriptor(_class2$O.prototype, "webviewEvents", [ _dec4$l ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$C = _applyDecoratedDescriptor(_class2$O.prototype, "_url", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$Y = _class2$O)) || _class$Y) || _class$Y) || _class$Y);

cc.WebviewComponent = WebviewComponent;

var _dec$Z, _dec2$E, _dec3$s, _dec4$m, _dec5$k, _dec6$i, _class$_, _class2$P, _descriptor$M, _descriptor2$D, _descriptor3$p, _descriptor4$m, _class3$s, _temp$T, UIReorderComponent = ccclass("cc.UIReorderComponent")(_class$Z = menu("UI/Reorder")(_class$Z = executionOrder(110)(_class$Z = disallowMultiple(_class$Z = executeInEditMode(_class$Z = function(_UIComponent) {
    function UIReorderComponent() {
        return _classCallCheck(this, UIReorderComponent), _possibleConstructorReturn(this, _getPrototypeOf(UIReorderComponent).apply(this, arguments));
    }
    return _inherits(UIReorderComponent, UIComponent), UIReorderComponent;
}()) || _class$Z) || _class$Z) || _class$Z) || _class$Z) || _class$Z;

cc.UIReorderComponent = UIReorderComponent;

var Direction$2, _color = new Color();

!function(Direction) {
    Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
}(Direction$2 || (Direction$2 = {})), ccenum(Direction$2);

var _dec$_, _dec2$F, _dec3$t, _dec4$n, _dec5$l, _dec6$j, _dec7$d, _dec8$8, _dec9$5, _dec10$4, _dec11$4, _dec12$4, _dec13$2, _dec14$2, _dec15$2, _class$$, _class2$Q, _descriptor$N, _descriptor2$E, _descriptor3$q, _descriptor4$n, _descriptor5$i, _descriptor6$b, _descriptor7$a, _descriptor8$a, _descriptor9$9, _descriptor10$8, _descriptor11$7, _descriptor12$6, _class3$t, _temp$U, PageViewIndicatorComponent = (_dec$Z = ccclass("cc.PageViewIndicatorComponent"), 
_dec2$E = executionOrder(110), _dec3$s = menu("UI/PageViewIndicator"), _dec4$m = property({
    type: SpriteFrame
}), _dec5$k = property({
    type: Direction$2
}), _dec6$i = property({
    type: Size
}), _dec$Z(_class$_ = _dec2$E(_class$_ = _dec3$s((_temp$T = _class3$s = function(_Component) {
    function PageViewIndicatorComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, PageViewIndicatorComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewIndicatorComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spacing", _descriptor$M, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cellSize", _descriptor4$m, _assertThisInitialized(_this)), 
        _this._layout = null, _this._pageView = null, _this._indicators = [], _this;
    }
    return _inherits(PageViewIndicatorComponent, Component), _createClass(PageViewIndicatorComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._updateLayout();
        }
    }, {
        key: "setPageView",
        value: function setPageView(target) {
            this._pageView = target, this._refresh();
        }
    }, {
        key: "_updateLayout",
        value: function _updateLayout() {
            this._layout = this.getComponent(LayoutComponent), this._layout || (this._layout = this.addComponent(LayoutComponent));
            var layout = this._layout;
            this.direction === Direction$2.HORIZONTAL ? (layout.type = LayoutComponent.Type.HORIZONTAL, 
            layout.spacingX = this.spacing) : this.direction === Direction$2.VERTICAL && (layout.type = LayoutComponent.Type.VERTICAL, 
            layout.spacingY = this.spacing), layout.resizeMode = LayoutComponent.ResizeMode.CONTAINER;
        }
    }, {
        key: "_createIndicator",
        value: function _createIndicator() {
            var node = new Node$1();
            return node.addComponent(SpriteComponent).spriteFrame = this.spriteFrame, node.parent = this.node, 
            node.width = this.cellSize.width, node.height = this.cellSize.height, node;
        }
    }, {
        key: "_changedState",
        value: function _changedState() {
            var indicators = this._indicators;
            if (0 !== indicators.length && this._pageView) {
                var idx = this._pageView.curPageIdx;
                if (!(idx >= indicators.length)) {
                    for (var i = 0; i < indicators.length; ++i) {
                        var node = indicators[i];
                        if (node._uiComp) {
                            var uiComp = node._uiComp;
                            _color.set(uiComp.color), _color.a = 127.5, uiComp.color = _color;
                        }
                    }
                    if (indicators[idx]._uiComp) {
                        var comp = indicators[idx]._uiComp;
                        _color.set(comp.color), _color.a = 255, comp.color = _color;
                    }
                }
            }
        }
    }, {
        key: "_refresh",
        value: function _refresh() {
            if (this._pageView) {
                var indicators = this._indicators, pages = this._pageView.getPages();
                if (pages.length !== indicators.length) {
                    var i = 0;
                    if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else for (i = indicators.length - pages.length; i > 0; --i) {
                        var node = indicators[i - 1];
                        this.node.removeChild(node), indicators.splice(i - 1, 1);
                    }
                    this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout(), 
                    this._changedState();
                }
            }
        }
    }, {
        key: "spriteFrame",
        get: function get() {
            return this._spriteFrame;
        },
        set: function set(value) {
            this._spriteFrame !== value && (this._spriteFrame = value);
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value);
        }
    }, {
        key: "cellSize",
        get: function get() {
            return this._cellSize;
        },
        set: function set(value) {
            this._cellSize !== value && (this._cellSize = value);
        }
    } ]), PageViewIndicatorComponent;
}(), _class3$s.Direction = Direction$2, _applyDecoratedDescriptor((_class2$P = _temp$T).prototype, "spriteFrame", [ _dec4$m ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "spriteFrame"), _class2$P.prototype), 
_applyDecoratedDescriptor(_class2$P.prototype, "direction", [ _dec5$k ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "direction"), _class2$P.prototype), 
_applyDecoratedDescriptor(_class2$P.prototype, "cellSize", [ _dec6$i ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "cellSize"), _class2$P.prototype), 
_descriptor$M = _applyDecoratedDescriptor(_class2$P.prototype, "spacing", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$D = _applyDecoratedDescriptor(_class2$P.prototype, "_spriteFrame", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$p = _applyDecoratedDescriptor(_class2$P.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction$2.HORIZONTAL;
    }
}), _descriptor4$m = _applyDecoratedDescriptor(_class2$P.prototype, "_cellSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Size(20, 20);
    }
}), _class$_ = _class2$P)) || _class$_) || _class$_) || _class$_);

cc.PageViewIndicatorComponent = PageViewIndicatorComponent;

var SizeMode$1, Direction$3, PageViewEventType, _temp_vec2 = new Vec2();

!function(SizeMode) {
    SizeMode[SizeMode.Unified = 0] = "Unified", SizeMode[SizeMode.Free = 1] = "Free";
}(SizeMode$1 || (SizeMode$1 = {})), ccenum(SizeMode$1), function(Direction) {
    Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
}(Direction$3 || (Direction$3 = {})), ccenum(Direction$3), function(PageViewEventType) {
    PageViewEventType[PageViewEventType.PAGE_TURNING = 0] = "PAGE_TURNING";
}(PageViewEventType || (PageViewEventType = {})), ccenum(PageViewEventType);

var PageViewComponent = (_dec$_ = ccclass("cc.PageViewComponent"), _dec2$F = executionOrder(110), 
_dec3$t = menu("UI/PageView"), _dec4$n = property({
    type: SizeMode$1
}), _dec5$l = property({
    type: Direction$3
}), _dec6$j = property({
    slide: !0,
    range: [ 0, 1, .01 ]
}), _dec7$d = property({
    slide: !0,
    range: [ 0, 1, .01 ]
}), _dec8$8 = property({
    type: PageViewIndicatorComponent
}), _dec9$5 = property({
    type: ScrollBarComponent,
    visible: !1,
    override: !0
}), _dec10$4 = property({
    type: ScrollBarComponent,
    visible: !1,
    override: !0
}), _dec11$4 = property({
    visible: !1,
    override: !0
}), _dec12$4 = property({
    visible: !1,
    override: !0
}), _dec13$2 = property({
    visible: !1,
    override: !0
}), _dec14$2 = property({
    visible: !1,
    override: !0
}), _dec15$2 = property({
    type: EventHandler
}), _dec$_(_class$$ = _dec2$F(_class$$ = _dec3$t((_temp$U = _class3$t = function(_ScrollViewComponent) {
    function PageViewComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, PageViewComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "autoPageTurningThreshold", _descriptor$N, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "horizontal", _descriptor2$E, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "vertical", _descriptor3$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "scrollEvents", _descriptor5$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "pageEvents", _descriptor7$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sizeMode", _descriptor8$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor9$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_indicator", _descriptor12$6, _assertThisInitialized(_this)), 
        _this._curPageIdx = 0, _this._lastPageIdx = 0, _this._pages = [], _this._initContentPos = new Vec3(), 
        _this._scrollCenterOffsetX = [], _this._scrollCenterOffsetY = [], _this._touchBeganPosition = new Vec3(), 
        _this._touchEndPosition = new Vec3(), _this;
    }
    return _inherits(PageViewComponent, ScrollViewComponent), _createClass(PageViewComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.node.on(SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(PageViewComponent.prototype), "onEnable", this).call(this), 
            this.node.on("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(PageViewComponent.prototype), "onDisable", this).call(this), 
            this.node.off("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this._initPages(), this.indicator && this.indicator.setPageView(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.node.off(SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
        }
    }, {
        key: "getCurrentPageIndex",
        value: function getCurrentPageIndex() {
            return this._curPageIdx;
        }
    }, {
        key: "setCurrentPageIndex",
        value: function setCurrentPageIndex(index) {
            this.scrollToPage(index, 1);
        }
    }, {
        key: "getPages",
        value: function getPages() {
            return this._pages;
        }
    }, {
        key: "addPage",
        value: function addPage(page) {
            page && -1 === this._pages.indexOf(page) && this.content && (this.content.addChild(page), 
            this._pages.push(page), this._updatePageView());
        }
    }, {
        key: "insertPage",
        value: function insertPage(page, index) {
            index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content || (index >= this._pages.length ? this.addPage(page) : (this._pages.splice(index, 0, page), 
            this.content.insertChild(page, index), this._updatePageView()));
        }
    }, {
        key: "removePage",
        value: function removePage(page) {
            if (page && this.content) {
                var index = this._pages.indexOf(page);
                -1 !== index ? this.removePageAtIndex(index) : cc.warnID(4300, page.name);
            }
        }
    }, {
        key: "removePageAtIndex",
        value: function removePageAtIndex(index) {
            var pageList = this._pages;
            if (!(index < 0 || index >= pageList.length)) {
                var page = pageList[index];
                page && this.content && (this.content.removeChild(page), pageList.splice(index, 1), 
                this._updatePageView());
            }
        }
    }, {
        key: "removeAllPages",
        value: function removeAllPages() {
            if (this.content) {
                for (var locPages = this._pages, i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
                this._pages.length = 0, this._updatePageView();
            }
        }
    }, {
        key: "scrollToPage",
        value: function scrollToPage(idx) {
            var timeInSecond = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            idx < 0 || idx >= this._pages.length || (timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3, 
            this._curPageIdx = idx, this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, !0), 
            this.indicator && this.indicator._changedState());
        }
    }, {
        key: "getScrollEndedEventTiming",
        value: function getScrollEndedEventTiming() {
            return this.pageTurningEventTiming;
        }
    }, {
        key: "_updatePageView",
        value: function _updatePageView() {
            var layout = this.content.getComponent(LayoutComponent);
            layout && layout.enabled && layout.updateLayout();
            var pageCount = this._pages.length;
            this._curPageIdx >= pageCount && (this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1, 
            this._lastPageIdx = this._curPageIdx);
            for (var contentPos = this._initContentPos, i = 0; i < pageCount; ++i) {
                var pos = this._pages[i].position;
                this.direction === Direction$3.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x) : this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
            }
            this.indicator && this.indicator._refresh();
        }
    }, {
        key: "_updateAllPagesSize",
        value: function _updateAllPagesSize() {
            if (this.content && this.view && this._sizeMode === SizeMode$1.Unified) for (var locPages = this._pages, selfSize = this.view.getContentSize(), i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
        }
    }, {
        key: "_handleReleaseLogic",
        value: function _handleReleaseLogic() {
            this._autoScrollToPage(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent("scroll-ended"));
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event, captureListeners) {
            event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchBeganPosition, _temp_vec2.x, _temp_vec2.y, 0), 
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchBegan", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onTouchMoved",
        value: function _onTouchMoved(event, captureListeners) {
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchMoved", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event, captureListeners) {
            event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchEnded", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onTouchCancelled",
        value: function _onTouchCancelled(event, captureListeners) {
            event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchCancelled", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onMouseWheel",
        value: function _onMouseWheel() {}
    }, {
        key: "_syncScrollDirection",
        value: function _syncScrollDirection() {
            this.horizontal = this.direction === Direction$3.Horizontal, this.vertical = this.direction === Direction$3.Vertical;
        }
    }, {
        key: "_syncSizeMode",
        value: function _syncSizeMode() {
            var view = this.view;
            if (this.content && view) {
                var layout = this.content.getComponent(LayoutComponent);
                if (layout) {
                    if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
                        var lastPage = this._pages[this._pages.length - 1];
                        this.direction === Direction$3.Horizontal ? (layout.paddingLeft = (view.width - this._pages[0].width) / 2, 
                        layout.paddingRight = (view.width - lastPage.width) / 2) : this.direction === Direction$3.Vertical && (layout.paddingTop = (view.height - this._pages[0].height) / 2, 
                        layout.paddingBottom = (view.height - lastPage.height) / 2);
                    }
                    layout.updateLayout();
                }
            }
        }
    }, {
        key: "_initPages",
        value: function _initPages() {
            if (this.content) {
                this._initContentPos = this.content.position;
                for (var children = this.content.children, i = 0; i < children.length; ++i) {
                    var page = children[i];
                    this._pages.indexOf(page) >= 0 || this._pages.push(page);
                }
                this._syncScrollDirection(), this._syncSizeMode(), this._updatePageView();
            }
        }
    }, {
        key: "_dispatchPageTurningEvent",
        value: function _dispatchPageTurningEvent() {
            this._lastPageIdx !== this._curPageIdx && (this._lastPageIdx = this._curPageIdx, 
            EventHandler.emitEvents(this.pageEvents, this, PageViewEventType.PAGE_TURNING), 
            this.node.emit("page-turning", this));
        }
    }, {
        key: "_isQuicklyScrollable",
        value: function _isQuicklyScrollable(touchMoveVelocity) {
            if (this.direction === Direction$3.Horizontal) {
                if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return !0;
            } else if (this.direction === Direction$3.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return !0;
            return !1;
        }
    }, {
        key: "_moveOffsetValue",
        value: function _moveOffsetValue(idx) {
            var offset = new Vec3();
            if (this._sizeMode === SizeMode$1.Free) this.direction === Direction$3.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction$3.Vertical && (offset.y = this._scrollCenterOffsetY[idx]); else {
                var view = this.view;
                if (!view) return offset;
                this.direction === Direction$3.Horizontal ? offset.x = idx * view.width : this.direction === Direction$3.Vertical && (offset.y = idx * view.height);
            }
            return offset;
        }
    }, {
        key: "_getDragDirection",
        value: function _getDragDirection(moveOffset) {
            return this._direction === Direction$3.Horizontal ? 0 === moveOffset.x ? 0 : moveOffset.x > 0 ? 1 : -1 : 0 === moveOffset.y ? 0 : moveOffset.y < 0 ? 1 : -1;
        }
    }, {
        key: "_isScrollable",
        value: function _isScrollable(offset, index, nextIndex) {
            if (this._sizeMode === SizeMode$1.Free) {
                var curPageCenter = 0, nextPageCenter = 0;
                if (this.direction === Direction$3.Horizontal) return curPageCenter = this._scrollCenterOffsetX[index], 
                nextPageCenter = this._scrollCenterOffsetX[nextIndex], Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                if (this.direction === Direction$3.Vertical) return curPageCenter = this._scrollCenterOffsetY[index], 
                nextPageCenter = this._scrollCenterOffsetY[nextIndex], Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            } else {
                var view = this.view;
                if (!view) return;
                if (this.direction === Direction$3.Horizontal) return Math.abs(offset.x) >= view.width * this.scrollThreshold;
                if (this.direction === Direction$3.Vertical) return Math.abs(offset.y) >= view.height * this.scrollThreshold;
            }
        }
    }, {
        key: "_autoScrollToPage",
        value: function _autoScrollToPage() {
            var bounceBackStarted = this._startBounceBackIfNeeded(), moveOffset = new Vec3();
            if (Vec3.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition), 
            bounceBackStarted) {
                var dragDirection = this._getDragDirection(moveOffset);
                if (0 === dragDirection) return;
                this._curPageIdx = dragDirection > 0 ? this._pages.length - 1 : 0, this.indicator && this.indicator._changedState();
            } else {
                var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset), timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
                if (nextIndex < this._pages.length) {
                    if (this._isScrollable(moveOffset, index, nextIndex)) return void this.scrollToPage(nextIndex, timeInSecond);
                    var touchMoveVelocity = this._calculateTouchMoveVelocity();
                    if (this._isQuicklyScrollable(touchMoveVelocity)) return void this.scrollToPage(nextIndex, timeInSecond);
                }
                this.scrollToPage(index, timeInSecond);
            }
        }
    }, {
        key: "sizeMode",
        get: function get() {
            return this._sizeMode;
        },
        set: function set(value) {
            this._sizeMode !== value && (this._sizeMode = value, this._syncSizeMode());
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value, this._syncScrollDirection());
        }
    }, {
        key: "scrollThreshold",
        get: function get() {
            return this._scrollThreshold;
        },
        set: function set(value) {
            this._scrollThreshold !== value && (this._scrollThreshold = value);
        }
    }, {
        key: "pageTurningEventTiming",
        get: function get() {
            return this._pageTurningEventTiming;
        },
        set: function set(value) {
            this._pageTurningEventTiming !== value && (this._pageTurningEventTiming = value);
        }
    }, {
        key: "indicator",
        get: function get() {
            return this._indicator;
        },
        set: function set(value) {
            this._indicator !== value && (this._indicator = value, this.indicator && this.indicator.setPageView(this));
        }
    }, {
        key: "curPageIdx",
        get: function get() {
            return this._curPageIdx;
        }
    }, {
        key: "verticalScrollBar",
        get: function get() {
            return this._verticalScrollBar;
        }
    }, {
        key: "horizontalScrollBar",
        get: function get() {
            return this._horizontalScrollBar;
        }
    } ]), PageViewComponent;
}(), _class3$t.SizeMode = SizeMode$1, _class3$t.Direction = Direction$3, _class3$t.EventType = PageViewEventType, 
_applyDecoratedDescriptor((_class2$Q = _temp$U).prototype, "sizeMode", [ _dec4$n ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "sizeMode"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "direction", [ _dec5$l ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "direction"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "scrollThreshold", [ _dec6$j ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "scrollThreshold"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "pageTurningEventTiming", [ _dec7$d ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "pageTurningEventTiming"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "indicator", [ _dec8$8 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "indicator"), _class2$Q.prototype), 
_descriptor$N = _applyDecoratedDescriptor(_class2$Q.prototype, "autoPageTurningThreshold", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 100;
    }
}), _applyDecoratedDescriptor(_class2$Q.prototype, "verticalScrollBar", [ _dec9$5 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "verticalScrollBar"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "horizontalScrollBar", [ _dec10$4 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "horizontalScrollBar"), _class2$Q.prototype), 
_descriptor2$E = _applyDecoratedDescriptor(_class2$Q.prototype, "horizontal", [ _dec11$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$q = _applyDecoratedDescriptor(_class2$Q.prototype, "vertical", [ _dec12$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$n = _applyDecoratedDescriptor(_class2$Q.prototype, "cancelInnerEvents", [ _dec13$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor5$i = _applyDecoratedDescriptor(_class2$Q.prototype, "scrollEvents", [ _dec14$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor6$b = _applyDecoratedDescriptor(_class2$Q.prototype, "pageTurningSpeed", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .3;
    }
}), _descriptor7$a = _applyDecoratedDescriptor(_class2$Q.prototype, "pageEvents", [ _dec15$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor8$a = _applyDecoratedDescriptor(_class2$Q.prototype, "_sizeMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return SizeMode$1.Unified;
    }
}), _descriptor9$9 = _applyDecoratedDescriptor(_class2$Q.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction$3.Horizontal;
    }
}), _descriptor10$8 = _applyDecoratedDescriptor(_class2$Q.prototype, "_scrollThreshold", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .5;
    }
}), _descriptor11$7 = _applyDecoratedDescriptor(_class2$Q.prototype, "_pageTurningEventTiming", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor12$6 = _applyDecoratedDescriptor(_class2$Q.prototype, "_indicator", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$$ = _class2$Q)) || _class$$) || _class$$) || _class$$);

cc.PageViewComponent = PageViewComponent;

var RenderQueue$1, PassStage, _stageOffset = 0, _name2stageID = {}, config_addStage = function addStage(name) {
    if (void 0 === _name2stageID[name]) {
        var stageID = 1 << _stageOffset;
        _name2stageID[name] = stageID, _stageOffset += 1;
    }
};

!function(RenderQueue) {
    RenderQueue[RenderQueue.OPAQUE = 0] = "OPAQUE", RenderQueue[RenderQueue.TRANSPARENT = 1] = "TRANSPARENT", 
    RenderQueue[RenderQueue.OVERLAY = 2] = "OVERLAY";
}(RenderQueue$1 || (RenderQueue$1 = {})), function(PassStage) {
    PassStage[PassStage.DEFAULT = 1] = "DEFAULT", PassStage[PassStage.FORWARD = 2] = "FORWARD", 
    PassStage[PassStage.SHADOWCAST = 4] = "SHADOWCAST";
}(PassStage || (PassStage = {}));

var eTerrainCircleBrushType, HeightField = function() {
    function HeightField(w, h) {
        _classCallCheck(this, HeightField), this.data = new Uint16Array(), this.w = 0, this.h = 0, 
        this.w = w, this.h = h, this.data = new Uint16Array(w * h);
        for (var i = 0; i < w * h; ++i) this.data[i] = 0;
    }
    return _createClass(HeightField, [ {
        key: "set",
        value: function set(i, j, value) {
            this.data[j * this.w + i] = value;
        }
    }, {
        key: "get",
        value: function get(i, j) {
            return this.data[j * this.w + i];
        }
    }, {
        key: "getClamp",
        value: function getClamp(i, j) {
            return i = clamp(i, 0, this.w - 1), j = clamp(j, 0, this.h - 1), this.get(i, j);
        }
    }, {
        key: "getAt",
        value: function getAt(x, y) {
            var fx = x / this.w, fy = y / this.h, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            ix0 = clamp(ix0, 0, this.w - 1), iz0 = clamp(iz0, 0, this.h - 1), ix1 = clamp(ix1, 0, this.w - 1), 
            iz1 = clamp(iz1, 0, this.h - 1);
            var a = this.get(ix0, iz0), b = this.get(ix1, iz0), c = this.get(ix0, iz1), d = this.get(ix1, iz1), m = .5 * (b + c);
            return dx + dz <= 1 ? d = m + (m - a) : a = m + (m - d), (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
        }
    } ]), HeightField;
}(), TerrainBrush = function() {
    function TerrainBrush() {
        _classCallCheck(this, TerrainBrush), this.material = null, this.position = new Vec3(0, 0, 0), 
        this.radius = 5, this.strength = 1;
    }
    return _createClass(TerrainBrush, [ {
        key: "getDelta",
        value: function getDelta(x, z) {
            return 0;
        }
    }, {
        key: "update",
        value: function update(pos) {
            this.position = pos;
        }
    } ]), TerrainBrush;
}(), TerrainBrushData = function() {
    function TerrainBrushData() {
        _classCallCheck(this, TerrainBrushData), this.bmin = [ 0, 0 ], this.bmax = [ 0, 0 ];
    }
    return _createClass(TerrainBrushData, [ {
        key: "width",
        value: function width() {
            return this.bmax[0] - this.bmax[0] + 1;
        }
    }, {
        key: "height",
        value: function height() {
            return this.bmax[1] - this.bmax[1] + 1;
        }
    } ]), TerrainBrushData;
}();

!function(eTerrainCircleBrushType) {
    eTerrainCircleBrushType[eTerrainCircleBrushType.Linear = 0] = "Linear", eTerrainCircleBrushType[eTerrainCircleBrushType.Smooth = 1] = "Smooth", 
    eTerrainCircleBrushType[eTerrainCircleBrushType.Spherical = 2] = "Spherical", eTerrainCircleBrushType[eTerrainCircleBrushType.Tip = 3] = "Tip";
}(eTerrainCircleBrushType || (eTerrainCircleBrushType = {}));

var eTerrainEditorMode, TerrainCircleBrush = function(_TerrainBrush) {
    function TerrainCircleBrush() {
        var _this;
        return _classCallCheck(this, TerrainCircleBrush), (_this = _possibleConstructorReturn(this, _getPrototypeOf(TerrainCircleBrush).call(this))).type = eTerrainCircleBrushType.Linear, 
        _this.falloff = .5, _this._updateMaterial(), _this;
    }
    return _inherits(TerrainCircleBrush, TerrainBrush), _createClass(TerrainCircleBrush, [ {
        key: "setType",
        value: function setType(type) {
            this.type !== type && (this.type = type, this._updateMaterial());
        }
    }, {
        key: "getType",
        value: function getType() {
            return this.type;
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial() {
            var effect = cc.EffectAsset.get("editor/terrain-circle-brush");
            null != effect && (this.material = new Material(), this.material.initialize({
                effectAsset: effect,
                defines: this._getTypeDefine()
            }));
        }
    }, {
        key: "_getTypeDefine",
        value: function _getTypeDefine() {
            switch (this.type) {
              case eTerrainCircleBrushType.Linear:
                return {
                    LINEAR: 1
                };

              case eTerrainCircleBrushType.Smooth:
                return {
                    SMOOTH: 1
                };

              case eTerrainCircleBrushType.Spherical:
                return {
                    SPHERICAL: 1
                };

              case eTerrainCircleBrushType.Tip:
                return {
                    TIP: 1
                };
            }
            return {
                LINEAR: 1
            };
        }
    }, {
        key: "_calculateFalloff_Linear",
        value: function _calculateFalloff_Linear(Distance, Radius, Falloff) {
            return Distance <= Radius ? 1 : Distance > Radius + Falloff ? 0 : Math.max(0, 1 - (Distance - Radius) / Falloff);
        }
    }, {
        key: "_calculateFalloff_Spherical",
        value: function _calculateFalloff_Spherical(Distance, Radius, Falloff) {
            var y = this._calculateFalloff_Linear(Distance, Radius, Falloff);
            return y * y * (3 - 2 * y);
        }
    }, {
        key: "_calculateFalloff_Smooth",
        value: function _calculateFalloff_Smooth(Distance, Radius, Falloff) {
            if (Distance <= Radius) return 1;
            if (Distance > Radius + Falloff) return 0;
            var y = (Distance - Radius) / Falloff;
            return Math.sqrt(1 - y * y);
        }
    }, {
        key: "_calculateFalloff_Tip",
        value: function _calculateFalloff_Tip(Distance, Radius, Falloff) {
            if (Distance <= Radius) return 1;
            if (Distance > Radius + Falloff) return 0;
            var y = (Falloff + Radius - Distance) / Falloff;
            return 1 - Math.sqrt(1 - y * y);
        }
    }, {
        key: "getDelta",
        value: function getDelta(x, z) {
            var DetlaX = x - this.position.x, DeltaZ = z - this.position.z, Distance = Math.sqrt(DetlaX * DetlaX + DeltaZ * DeltaZ), Radius = (1 - this.falloff) * this.radius, Falloff = this.falloff * this.radius, k = 0;
            switch (this.type) {
              case eTerrainCircleBrushType.Linear:
                k = this._calculateFalloff_Linear(Distance, Radius, Falloff);
                break;

              case eTerrainCircleBrushType.Smooth:
                k = this._calculateFalloff_Smooth(Distance, Radius, Falloff);
                break;

              case eTerrainCircleBrushType.Spherical:
                k = this._calculateFalloff_Spherical(Distance, Radius, Falloff);
                break;

              case eTerrainCircleBrushType.Tip:
                k = this._calculateFalloff_Tip(Distance, Radius, Falloff);
            }
            return k * this.strength;
        }
    }, {
        key: "update",
        value: function update(pos) {
            if (_get(_getPrototypeOf(TerrainCircleBrush.prototype), "update", this).call(this, pos), 
            null != this.material) {
                var Radius = (1 - this.falloff) * this.radius, Falloff = this.falloff * this.radius, BrushPos = pos, BrushParams = new Vec4();
                BrushParams.x = Radius, BrushParams.y = Falloff, this.material.setProperty("BrushPos", BrushPos), 
                this.material.setProperty("BrushParams", BrushParams);
            }
        }
    } ]), TerrainCircleBrush;
}();

!function(eTerrainEditorMode) {
    eTerrainEditorMode[eTerrainEditorMode.MANAGE = 0] = "MANAGE", eTerrainEditorMode[eTerrainEditorMode.SCULPT = 1] = "SCULPT", 
    eTerrainEditorMode[eTerrainEditorMode.PAINT = 2] = "PAINT";
}(eTerrainEditorMode || (eTerrainEditorMode = {}));

var _class$10, _class2$R, _descriptor$O, _descriptor2$F, _descriptor3$r, _descriptor4$o, _class4$2, _class5$2, _descriptor5$j, _descriptor6$c, _class7$1, _class8$1, _descriptor7$b, _dec4$o, _dec5$m, _dec6$k, _dec7$e, _dec8$9, _dec9$6, _dec10$5, _class10$1, _class11$1, _descriptor8$b, _descriptor9$a, _descriptor10$9, _descriptor11$8, _descriptor12$7, _dec$10, _dec2$H, _dec3$v, _dec4$p, _dec5$n, _dec6$l, _class$11, _class2$S, _descriptor$P, _descriptor2$G, _descriptor3$s, _descriptor4$p, _descriptor5$k, _descriptor6$d, _descriptor7$c, _descriptor8$c, _descriptor9$b, _descriptor10$a, _descriptor11$9, _descriptor12$8, _descriptor13$6, _descriptor14$6, _class3$u, _temp$W, TerrainEditorMode = function() {
    function TerrainEditorMode() {
        _classCallCheck(this, TerrainEditorMode);
    }
    return _createClass(TerrainEditorMode, [ {
        key: "onUpdate",
        value: function onUpdate(terrain, dtime) {}
    } ]), TerrainEditorMode;
}(), TerrainEditorManage = function(_TerrainEditorMode) {
    function TerrainEditorManage() {
        return _classCallCheck(this, TerrainEditorManage), _possibleConstructorReturn(this, _getPrototypeOf(TerrainEditorManage).apply(this, arguments));
    }
    return _inherits(TerrainEditorManage, TerrainEditorMode), TerrainEditorManage;
}(), TERRAIN_MAX_LAYER_COUNT = 256, TerrainInfo = ccclass("cc.TerrainInfo")((_descriptor$O = _applyDecoratedDescriptor((_class2$R = function() {
    function TerrainInfo() {
        _classCallCheck(this, TerrainInfo), _initializerDefineProperty(this, "tileSize", _descriptor$O, this), 
        _initializerDefineProperty(this, "blockCount", _descriptor2$F, this), _initializerDefineProperty(this, "weightMapSize", _descriptor3$r, this), 
        _initializerDefineProperty(this, "lightMapSize", _descriptor4$o, this), this._tileCount = [ 0, 0 ], 
        this._vertexCount = [ 0, 0 ], this._size = new Size(0, 0);
    }
    return _createClass(TerrainInfo, [ {
        key: "initialize",
        value: function initialize() {
            this._tileCount[0] = 32 * this.blockCount[0], this._tileCount[1] = 32 * this.blockCount[1], 
            this._vertexCount[0] = this._tileCount[0] + 1, this._vertexCount[1] = this._tileCount[1] + 1, 
            this._size.width = this._tileCount[0] * this.tileSize, this._size.height = this._tileCount[1] * this.tileSize;
        }
    }, {
        key: "tileCount",
        get: function get() {
            return this._tileCount;
        }
    }, {
        key: "vertexCount",
        get: function get() {
            return this._vertexCount;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        }
    } ]), TerrainInfo;
}()).prototype, "tileSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor2$F = _applyDecoratedDescriptor(_class2$R.prototype, "blockCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [ 1, 1 ];
    }
}), _descriptor3$r = _applyDecoratedDescriptor(_class2$R.prototype, "weightMapSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 128;
    }
}), _descriptor4$o = _applyDecoratedDescriptor(_class2$R.prototype, "lightMapSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 128;
    }
}), _class$10 = _class2$R)) || _class$10, TerrainLayer = ccclass("cc.TerrainLayer")((_descriptor5$j = _applyDecoratedDescriptor((_class5$2 = function TerrainLayer() {
    _classCallCheck(this, TerrainLayer), _initializerDefineProperty(this, "detailMap", _descriptor5$j, this), 
    _initializerDefineProperty(this, "tileSize", _descriptor6$c, this);
}).prototype, "detailMap", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor6$c = _applyDecoratedDescriptor(_class5$2.prototype, "tileSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class4$2 = _class5$2)) || _class4$2, TerrainRenderable = function(_RenderableComponent) {
    function TerrainRenderable() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TerrainRenderable);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TerrainRenderable)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
        _this._meshData = null, _this._brushMaterial = null, _this._currentMaterial = null, 
        _this._currentMaterialLayers = 0, _this;
    }
    return _inherits(TerrainRenderable, RenderableComponent), _createClass(TerrainRenderable, [ {
        key: "destroy",
        value: function destroy() {
            this._invalidMaterial(), null != this._model && (this._getRenderScene().destroyModel(this._model), 
            this._model = null), _get(_getPrototypeOf(TerrainRenderable.prototype), "destroy", this).call(this);
        }
    }, {
        key: "_invalidMaterial",
        value: function _invalidMaterial() {
            null != this._currentMaterial && (this._clearMaterials(), this._currentMaterial = null, 
            null != this._model && (this._model.enabled = !1));
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial(block, init) {
            if (null != this._meshData && null != this._model) {
                var nlayers = block.getMaxLayer();
                if (null == this._currentMaterial || nlayers !== this._currentMaterialLayers) {
                    if (this._currentMaterial = new Material(), this._currentMaterial.initialize({
                        effectAsset: cc.EffectAsset.get("builtin-terrain"),
                        defines: block._getMaterialDefines(nlayers)
                    }), null !== this._brushMaterial) this._currentMaterial.passes.push(this._brushMaterial.passes[0]);
                    init && this._model.initSubModel(0, this._meshData, this._currentMaterial), this.setMaterial(this._currentMaterial, 0), 
                    this._currentMaterialLayers = nlayers, this._model.enabled = !0;
                }
            }
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(idx, mtl) {
            null != this._model && this._onRebuildPSO(idx, mtl || this._getBuiltinMaterial());
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(idx, material) {
            this._model && this._model.setSubModelMaterial(idx, material);
        }
    }, {
        key: "_clearMaterials",
        value: function _clearMaterials() {
            null != this._model && this._onMaterialModified(0, null);
        }
    }, {
        key: "_getBuiltinMaterial",
        value: function _getBuiltinMaterial() {
            return builtinResMgr.get("missing-material");
        }
    } ]), TerrainRenderable;
}(), TerrainBlockInfo = ccclass("cc.TerrainBlockInfo")((_descriptor7$b = _applyDecoratedDescriptor((_class8$1 = function TerrainBlockInfo() {
    _classCallCheck(this, TerrainBlockInfo), _initializerDefineProperty(this, "layers", _descriptor7$b, this);
}).prototype, "layers", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [ -1, -1, -1, -1 ];
    }
}), _class7$1 = _class8$1)) || _class7$1, TerrainBlock = function() {
    function TerrainBlock(t, i, j) {
        _classCallCheck(this, TerrainBlock), this._terrain = void 0, this._info = void 0, 
        this._node = void 0, this._renderable = void 0, this._index = [ 1, 1 ], this._weightMap = null, 
        this._terrain = t, this._info = t.getBlockInfo(i, j), this._index[0] = i, this._index[1] = j, 
        this._node = new PrivateNode(""), this._node.setParent(this._terrain.node), this._node._objFlags |= cc.Object.Flags.DontSave, 
        this._renderable = this._node.addComponent(TerrainRenderable);
    }
    return _createClass(TerrainBlock, [ {
        key: "build",
        value: function build() {
            for (var gfxDevice = cc.director.root.device, vertexData = new Float32Array(8712), index = 0, j = 0; j < 33; ++j) for (var i = 0; i < 33; ++i) {
                var x = 32 * this._index[0] + i, y = 32 * this._index[1] + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / 32, j / 32);
                vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                vertexData[index++] = uv.x, vertexData[index++] = uv.y;
            }
            var vertexBuffer = gfxDevice.createBuffer({
                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 8 * Float32Array.BYTES_PER_ELEMENT * 33 * 33,
                stride: 8 * Float32Array.BYTES_PER_ELEMENT
            });
            vertexBuffer.update(vertexData);
            var gfxAttributes = [ {
                name: GFXAttributeName.ATTR_POSITION,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_NORMAL,
                format: GFXFormat.RGB32F
            }, {
                name: GFXAttributeName.ATTR_TEX_COORD,
                format: GFXFormat.RG32F
            } ];
            this._renderable._meshData = {
                attributes: gfxAttributes,
                vertexBuffers: [ vertexBuffer ],
                indexBuffer: this._terrain.getSharedIndexBuffer(),
                primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST
            }, this._renderable._model = this._renderable._getRenderScene().createModel(Model, this._node), 
            this._updateWeightMap(), this._updateMaterial(!0);
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            this._updateHeight(), this._updateWeightMap(), this._renderable._invalidMaterial(), 
            this._updateMaterial(!1);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            null != this._renderable && this._renderable.destroy(), null != this._node && this._node.destroy(), 
            null != this._weightMap && this._weightMap.destroy();
        }
    }, {
        key: "update",
        value: function update() {
            this._updateMaterial(!1);
            var mtl = this._renderable._currentMaterial;
            if (null != mtl) {
                var nlayers = this.getMaxLayer(), uvScale = new Vec4(1, 1, 1, 1);
                if (0 === nlayers) if (-1 !== this.layers[0]) {
                    var l0 = this._terrain.getLayer(this.layers[0]);
                    null != l0 && (uvScale.x = 1 / l0.tileSize), mtl.setProperty("detailMap0", null != l0 ? l0.detailMap : null);
                } else mtl.setProperty("detailMap0", cc.builtinResMgr.get("default-texture")); else if (1 === nlayers) {
                    var _l = this._terrain.getLayer(this.layers[0]), l1 = this._terrain.getLayer(this.layers[1]);
                    null != _l && (uvScale.x = 1 / _l.tileSize), null != l1 && (uvScale.y = 1 / l1.tileSize), 
                    mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l ? _l.detailMap : null), 
                    mtl.setProperty("detailMap1", null != l1 ? l1.detailMap : null);
                } else if (2 === nlayers) {
                    var _l2 = this._terrain.getLayer(this.layers[0]), _l3 = this._terrain.getLayer(this.layers[1]), l2 = this._terrain.getLayer(this.layers[2]);
                    null != _l2 && (uvScale.x = 1 / _l2.tileSize), null != _l3 && (uvScale.y = 1 / _l3.tileSize), 
                    null != l2 && (uvScale.z = 1 / l2.tileSize), mtl.setProperty("weightMap", this._weightMap), 
                    mtl.setProperty("detailMap0", null != _l2 ? _l2.detailMap : null), mtl.setProperty("detailMap1", null != _l3 ? _l3.detailMap : null), 
                    mtl.setProperty("detailMap2", null != l2 ? l2.detailMap : null);
                } else if (3 === nlayers) {
                    var _l4 = this._terrain.getLayer(this.layers[0]), _l5 = this._terrain.getLayer(this.layers[1]), _l6 = this._terrain.getLayer(this.layers[2]), l3 = this._terrain.getLayer(this.layers[3]);
                    null != _l4 && (uvScale.x = 1 / _l4.tileSize), null != _l5 && (uvScale.y = 1 / _l5.tileSize), 
                    null != _l6 && (uvScale.z = 1 / _l6.tileSize), null != l3 && (uvScale.z = 1 / l3.tileSize), 
                    mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l4 ? _l4.detailMap : null), 
                    mtl.setProperty("detailMap1", null != _l5 ? _l5.detailMap : null), mtl.setProperty("detailMap2", null != _l6 ? _l6.detailMap : null), 
                    mtl.setProperty("detailMap3", null != l3 ? l3.detailMap : null);
                }
                mtl.setProperty("UVScale", uvScale);
            }
        }
    }, {
        key: "setBrushMaterial",
        value: function setBrushMaterial(mtl) {
            this._renderable._brushMaterial !== mtl && (this._renderable._brushMaterial = mtl, 
            this._renderable._invalidMaterial());
        }
    }, {
        key: "getTerrain",
        value: function getTerrain() {
            return this._terrain;
        }
    }, {
        key: "getIndex",
        value: function getIndex() {
            return this._index;
        }
    }, {
        key: "getRect",
        value: function getRect() {
            var rect = new Rect();
            return rect.x = 32 * this._index[0], rect.y = 32 * this._index[1], rect.width = 32, 
            rect.height = 32, rect;
        }
    }, {
        key: "setLayer",
        value: function setLayer(index, layerId) {
            this.layers[index] !== layerId && (this.layers[index] = layerId, this._renderable._invalidMaterial(), 
            this._updateMaterial(!1));
        }
    }, {
        key: "getLayer",
        value: function getLayer(index) {
            return this.layers[index];
        }
    }, {
        key: "getMaxLayer",
        value: function getMaxLayer() {
            return this.layers[3] >= 0 ? 3 : this.layers[2] >= 0 ? 2 : this.layers[1] >= 0 ? 1 : 0;
        }
    }, {
        key: "_getMaterialDefines",
        value: function _getMaterialDefines(nlayers) {
            return 0 === nlayers ? {
                LAYERS: 1
            } : 1 === nlayers ? {
                LAYERS: 2
            } : 2 === nlayers ? {
                LAYERS: 3
            } : 3 === nlayers ? {
                LAYERS: 4
            } : {
                LAYERS: 0
            };
        }
    }, {
        key: "_invalidMaterial",
        value: function _invalidMaterial() {
            this._renderable._invalidMaterial();
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial(init) {
            this._renderable._updateMaterial(this, init);
        }
    }, {
        key: "_updateHeight",
        value: function _updateHeight() {
            if (null != this._renderable._meshData) {
                for (var vertexData = new Float32Array(8712), index = 0, j = 0; j < 33; ++j) for (var i = 0; i < 33; ++i) {
                    var x = 32 * this._index[0] + i, y = 32 * this._index[1] + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / 33, j / 33);
                    vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                    vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                    vertexData[index++] = uv.x, vertexData[index++] = uv.y;
                }
                this._renderable._meshData.vertexBuffers[0].update(vertexData);
            }
        }
    }, {
        key: "_updateWeightMap",
        value: function _updateWeightMap() {
            if (0 !== this.getMaxLayer()) {
                null == this._weightMap && (this._weightMap = new Texture2D(), this._weightMap.create(this._terrain.info.weightMapSize, this._terrain.info.weightMapSize, PixelFormat.RGBA8888), 
                this._weightMap.setFilters(Filter.LINEAR, Filter.LINEAR), this._weightMap.setWrapMode(WrapMode.CLAMP_TO_EDGE, WrapMode.CLAMP_TO_EDGE));
                for (var weightData = new Uint8Array(this._terrain.info.weightMapSize * this._terrain.info.weightMapSize * 4), weightIndex = 0, j = 0; j < this._terrain.info.weightMapSize; ++j) for (var i = 0; i < this._terrain.info.weightMapSize; ++i) {
                    var x = this._index[0] * this._terrain.info.weightMapSize + i, y = this._index[1] * this._terrain.info.weightMapSize + j, w = this._terrain.getWeight(x, y);
                    weightData[4 * weightIndex + 0] = Math.floor(255 * w.x), weightData[4 * weightIndex + 1] = Math.floor(255 * w.y), 
                    weightData[4 * weightIndex + 2] = Math.floor(255 * w.z), weightData[4 * weightIndex + 3] = Math.floor(255 * w.w), 
                    weightIndex += 1;
                }
                this._weightMap.uploadData(weightData.buffer);
            } else null != this._weightMap && (this._weightMap.destroy(), this._weightMap = null);
        }
    }, {
        key: "layers",
        get: function get() {
            return this._info.layers;
        }
    } ]), TerrainBlock;
}(), Terrain = (_dec4$o = ccclass("cc.Terrain"), _dec5$m = menu("Components/Terrain"), 
_dec6$k = property({
    type: TerrainInfo,
    visible: !0
}), _dec7$e = property({
    type: TerrainLayer,
    visible: !0
}), _dec8$9 = property({
    visible: !1
}), _dec9$6 = property({
    visible: !1
}), _dec10$5 = property({
    visible: !1
}), _dec4$o(_class10$1 = _dec5$m(_class10$1 = executeInEditMode((_descriptor8$b = _applyDecoratedDescriptor((_class11$1 = function(_Component) {
    function Terrain() {
        var _this2;
        _classCallCheck(this, Terrain), _initializerDefineProperty(_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Terrain).call(this)), "_info", _descriptor8$b, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_layers", _descriptor9$a, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_heights", _descriptor10$9, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_weights", _descriptor11$8, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_blockInfos", _descriptor12$7, _assertThisInitialized(_this2)), 
        _this2._normals = [], _this2._blocks = [], _this2._sharedIndexBuffer = null;
        for (var i = 0; i < TERRAIN_MAX_LAYER_COUNT; ++i) _this2._layers.push(null);
        return _this2;
    }
    return _inherits(Terrain, Component), _createClass(Terrain, [ {
        key: "build",
        value: function build(info) {
            return this._info.tileSize = info.tileSize, this._info.blockCount[0] = info.blockCount[0], 
            this._info.blockCount[1] = info.blockCount[1], this._info.weightMapSize = info.weightMapSize, 
            this._info.lightMapSize = info.lightMapSize, this._info.initialize(), this._buildImp();
        }
    }, {
        key: "rebuild",
        value: function rebuild(info) {
            info.initialize();
            for (var blockInfos = [], i = 0; i < info.blockCount[0] * info.blockCount[1]; ++i) blockInfos.push(new TerrainBlockInfo());
            for (var w = Math.min(this.info.blockCount[0], info.blockCount[0]), h = Math.min(this.info.blockCount[1], info.blockCount[1]), j = 0; j < h; ++j) for (var _i2 = 0; _i2 < w; ++_i2) {
                var index0 = j * info.vertexCount[0] + _i2, index1 = j * this.info.vertexCount[0] + _i2;
                blockInfos[index0] = this._blockInfos[index1];
            }
            this._blockInfos = blockInfos;
            var _iterator = this._blocks, _isArray = Array.isArray(_iterator), _i3 = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i3 >= _iterator.length) break;
                    _ref = _iterator[_i3++];
                } else {
                    if ((_i3 = _iterator.next()).done) break;
                    _ref = _i3.value;
                }
                _ref.destroy();
            }
            this._blocks = [], this._rebuildHeights(info), this._rebuildWeights(info), this._info.tileSize = info.tileSize, 
            this._info.blockCount[0] = info.blockCount[0], this._info.blockCount[1] = info.blockCount[1], 
            this._info.weightMapSize = info.weightMapSize, this._info.lightMapSize = info.lightMapSize, 
            this._info.initialize(), this._buildNormals();
            for (var _j2 = 0; _j2 < this._info.blockCount[1]; ++_j2) for (var _i4 = 0; _i4 < this._info.blockCount[0]; ++_i4) this._blocks.push(new TerrainBlock(this, _i4, _j2));
            var _iterator2 = this._blocks, _isArray2 = Array.isArray(_iterator2), _i5 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i5 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i5++];
                } else {
                    if ((_i5 = _iterator2.next()).done) break;
                    _ref2 = _i5.value;
                }
                _ref2.build();
            }
        }
    }, {
        key: "importHeightField",
        value: function importHeightField(hf, heightScale) {
            for (var index = 0, j = 0; j < this._info.vertexCount[1]; ++j) for (var i = 0; i < this._info.vertexCount[0]; ++i) {
                var u = i / this._info.tileCount[0], v = j / this._info.tileCount[1], h = hf.getAt(u * hf.w, v * hf.h) * heightScale;
                this._heights[index++] = h;
            }
            this._buildNormals();
            var _iterator3 = this._blocks, _isArray3 = Array.isArray(_iterator3), _i7 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i7 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i7++];
                } else {
                    if ((_i7 = _iterator3.next()).done) break;
                    _ref3 = _i7.value;
                }
                _ref3._updateHeight();
            }
        }
    }, {
        key: "exportHeightField",
        value: function exportHeightField(hf, heightScale) {
            for (var index = 0, j = 0; j < hf.h; ++j) for (var i = 0; i < hf.w; ++i) {
                var u = i / (hf.w - 1), v = j / (hf.h - 1), x = u * this._info.size.width, y = v * this._info.size.height, h = this.getHeightAt(x, y);
                null != h && (hf.data[index++] = h * heightScale);
            }
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            for (var gfxDevice = cc.director.root.device, indexData = new Uint16Array(6144), index = 0, j = 0; j < 32; ++j) for (var i = 0; i < 32; ++i) {
                var a = 33 * j + i, b = 33 * j + i + 1, c = 33 * (j + 1) + i, d = 33 * (j + 1) + i + 1;
                indexData[index++] = a, indexData[index++] = c, indexData[index++] = b, indexData[index++] = b, 
                indexData[index++] = c, indexData[index++] = d;
            }
            this._sharedIndexBuffer = gfxDevice.createBuffer({
                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 32 * Uint16Array.BYTES_PER_ELEMENT * 32 * 6,
                stride: Uint16Array.BYTES_PER_ELEMENT
            }), this._sharedIndexBuffer.update(indexData);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            0 === this._blocks.length && this._buildImp();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            var _iterator4 = this._blocks, _isArray4 = Array.isArray(_iterator4), _i9 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i9 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i9++];
                } else {
                    if ((_i9 = _iterator4.next()).done) break;
                    _ref4 = _i9.value;
                }
                _ref4.destroy();
            }
            this._blocks = [];
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            for (var i = 0; i < this._layers.length; ++i) this._layers[i] = null;
            null != this._sharedIndexBuffer && this._sharedIndexBuffer.destroy();
        }
    }, {
        key: "update",
        value: function update(dtime) {
            var _iterator5 = this._blocks, _isArray5 = Array.isArray(_iterator5), _i10 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i10 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i10++];
                } else {
                    if ((_i10 = _iterator5.next()).done) break;
                    _ref5 = _i10.value;
                }
                _ref5.update();
            }
        }
    }, {
        key: "addLayer",
        value: function addLayer(layer) {
            for (var i = 0; i < this._layers.length; ++i) if (null == this._layers[i]) return this._layers[i] = layer, 
            i;
            return -1;
        }
    }, {
        key: "setLayer",
        value: function setLayer(i, layer) {
            this._layers[i] = layer;
        }
    }, {
        key: "removeLayer",
        value: function removeLayer(id) {
            this._layers[id] = null;
        }
    }, {
        key: "getLayer",
        value: function getLayer(id) {
            return this._layers[id];
        }
    }, {
        key: "getPosition",
        value: function getPosition(i, j) {
            var x = i * this._info.tileSize, z = j * this._info.tileSize, y = this.getHeight(i, j);
            return new Vec3(x, y, z);
        }
    }, {
        key: "setHeight",
        value: function setHeight(i, j, h) {
            this._heights[j * this._info.vertexCount[0] + i] = h;
        }
    }, {
        key: "getHeight",
        value: function getHeight(i, j) {
            return this._heights[j * this._info.vertexCount[0] + i];
        }
    }, {
        key: "getHeightClamp",
        value: function getHeightClamp(i, j) {
            return i = clamp(i, 0, this._info.vertexCount[0] - 1), j = clamp(j, 0, this._info.vertexCount[1] - 1), 
            this.getHeight(i, j);
        }
    }, {
        key: "getHeightAt",
        value: function getHeightAt(x, y) {
            var fx = x / this._info.vertexCount[0], fy = y / this._info.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            if (ix0 < 0 || ix0 > this._info.vertexCount[0] - 1 || iz0 < 0 || iz0 > this._info.vertexCount[1] - 1) return null;
            ix0 = clamp(ix0, 0, this._info.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this._info.vertexCount[1] - 1), 
            ix1 = clamp(ix1, 0, this._info.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this._info.vertexCount[1] - 1);
            var a = this.getHeight(ix0, iz0), b = this.getHeight(ix1, iz0), c = this.getHeight(ix0, iz1), d = this.getHeight(ix1, iz1), m = .5 * (b + c);
            return dx + dz <= 1 ? d = m + (m - a) : a = m + (m - d), (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
        }
    }, {
        key: "_setNormal",
        value: function _setNormal(i, j, n) {
            var index = j * this._info.vertexCount[0] + i;
            this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z;
        }
    }, {
        key: "getNormal",
        value: function getNormal(i, j) {
            var index = j * this._info.vertexCount[0] + i, n = new Vec3();
            return n.x = this._normals[3 * index + 0], n.y = this._normals[3 * index + 1], n.z = this._normals[3 * index + 2], 
            n;
        }
    }, {
        key: "getNormalAt",
        value: function getNormalAt(x, y) {
            var fx = x / this._info.vertexCount[0], fy = y / this._info.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            if (ix0 < 0 || ix0 > this._info.vertexCount[0] - 1 || iz0 < 0 || iz0 > this._info.vertexCount[1] - 1) return null;
            ix0 = clamp(ix0, 0, this._info.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this._info.vertexCount[1] - 1), 
            ix1 = clamp(ix1, 0, this._info.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this._info.vertexCount[1] - 1);
            var a = this.getNormal(ix0, iz0), b = this.getNormal(ix1, iz0), c = this.getNormal(ix0, iz1), d = this.getNormal(ix1, iz1), m = new Vec3();
            Vec3.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
            a.subtract(d), a.add(m));
            var n1 = new Vec3(), n2 = new Vec3(), n = new Vec3();
            return Vec3.lerp(n1, a, b, dx), Vec3.lerp(n2, c, d, dx), Vec3.lerp(n, n1, n2, dz), 
            n;
        }
    }, {
        key: "setWeight",
        value: function setWeight(i, j, w) {
            var index = j * this.info.weightMapSize * this.info.blockCount[0] + i;
            this._weights[4 * index + 0] = 255 * w.x, this._weights[4 * index + 1] = 255 * w.y, 
            this._weights[4 * index + 2] = 255 * w.z, this._weights[4 * index + 3] = 255 * w.w;
        }
    }, {
        key: "getWeight",
        value: function getWeight(i, j) {
            var index = j * this.info.weightMapSize * this.info.blockCount[0] + i, w = new Vec4();
            return w.x = this._weights[4 * index + 0] / 255, w.y = this._weights[4 * index + 1] / 255, 
            w.z = this._weights[4 * index + 2] / 255, w.w = this._weights[4 * index + 3] / 255, 
            w;
        }
    }, {
        key: "getWeightAt",
        value: function getWeightAt(x, y) {
            var fx = x / this._info.vertexCount[0], fy = y / this._info.vertexCount[1], ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            if (ix0 < 0 || ix0 > this._info.vertexCount[0] - 1 || iz0 < 0 || iz0 > this._info.vertexCount[1] - 1) return null;
            ix0 = clamp(ix0, 0, this._info.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this._info.vertexCount[1] - 1), 
            ix1 = clamp(ix1, 0, this._info.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this._info.vertexCount[1] - 1);
            var a = this.getWeight(ix0, iz0), b = this.getWeight(ix1, iz0), c = this.getWeight(ix0, iz1), d = this.getWeight(ix1, iz1), m = new Vec4();
            Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d = new Vec4(), Vec4.subtract(d, m, a).add(m)) : (a = new Vec4(), 
            Vec4.subtract(a, m, d).add(m));
            var n1 = new Vec4(), n2 = new Vec4(), n = new Vec4();
            return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
            n;
        }
    }, {
        key: "getBlockInfo",
        value: function getBlockInfo(i, j) {
            return this._blockInfos[j * this._info.blockCount[0] + i];
        }
    }, {
        key: "getBlock",
        value: function getBlock(i, j) {
            return this._blocks[j * this._info.blockCount[0] + i];
        }
    }, {
        key: "getBlocks",
        value: function getBlocks() {
            return this._blocks;
        }
    }, {
        key: "getSharedIndexBuffer",
        value: function getSharedIndexBuffer() {
            return this._sharedIndexBuffer;
        }
    }, {
        key: "rayCheck",
        value: function rayCheck(start, dir, step) {
            var i = 0, trace = start, position = null, dstep = new Vec3();
            if (dstep.set(dir), dstep.multiplyScalar(step), dir.equals(new Vec3(0, 1, 0))) {
                var y = this.getHeightAt(trace.x, trace.z);
                null != y && trace.y <= y && (position = new Vec3(trace.x, y, trace.z));
            } else if (dir.equals(new Vec3(0, -1, 0))) {
                var _y2 = this.getHeightAt(trace.x, trace.z);
                null != _y2 && trace.y >= _y2 && (position = new Vec3(trace.x, _y2, trace.z));
            } else for (;i++ < 2e3; ) {
                var _y3 = this.getHeightAt(trace.x, trace.z);
                if (null != _y3 && trace.y <= _y3) {
                    position = new Vec3(trace.x, _y3, trace.z);
                    break;
                }
                trace.add(dstep);
            }
            return position;
        }
    }, {
        key: "_calcuNormal",
        value: function _calcuNormal(x, z) {
            var right, up, flip = 1, here = this.getPosition(x, z);
            x < this._info.vertexCount[0] - 1 ? right = this.getPosition(x + 1, z) : (flip *= -1, 
            right = this.getPosition(x - 1, z)), z < this._info.vertexCount[1] - 1 ? up = this.getPosition(x, z + 1) : (flip *= -1, 
            up = this.getPosition(x, z - 1)), right.subtract(here), up.subtract(here);
            var normal = new Vec3();
            return normal.set(up), normal.cross(right), normal.multiplyScalar(flip), normal.normalize(), 
            normal;
        }
    }, {
        key: "_buildNormals",
        value: function _buildNormals() {
            for (var index = 0, y = 0; y < this._info.vertexCount[1]; ++y) for (var x = 0; x < this._info.vertexCount[0]; ++x) {
                var n = this._calcuNormal(x, y);
                this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z, 
                index += 1;
            }
        }
    }, {
        key: "_buildImp",
        value: function _buildImp() {
            if (this._blocks.length > 0) return !0;
            if (this._info.initialize(), 0 === this._info.blockCount[0] || 0 === this._info.blockCount[1]) return !1;
            var vcount = this._info.vertexCount[0] * this._info.vertexCount[1];
            if (this._heights.length !== vcount) {
                this._heights = new Array(vcount), this._normals = new Array(3 * vcount);
                for (var i = 0; i < vcount; ++i) this._heights[i] = 0, this._normals[3 * i + 0] = 0, 
                this._normals[3 * i + 1] = 1, this._normals[3 * i + 2] = 0;
            } else this._normals = new Array(3 * vcount), this._buildNormals();
            var weightMapComplexityU = this.info.weightMapSize * this.info.blockCount[0], weightMapComplexityV = this.info.weightMapSize * this.info.blockCount[1];
            if (this._weights.length !== weightMapComplexityU * weightMapComplexityV * 4) {
                this._weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);
                for (var _i11 = 0; _i11 < weightMapComplexityU * weightMapComplexityV; ++_i11) this._weights[4 * _i11 + 0] = 255, 
                this._weights[4 * _i11 + 1] = 0, this._weights[4 * _i11 + 2] = 0, this._weights[4 * _i11 + 3] = 0;
            }
            if (this._blockInfos.length !== this.info.blockCount[0] * this.info.blockCount[1]) {
                this._blockInfos = [];
                for (var j = 0; j < this.info.blockCount[1]; ++j) for (var _i12 = 0; _i12 < this.info.blockCount[0]; ++_i12) this._blockInfos.push(new TerrainBlockInfo());
            }
            for (var _j3 = 0; _j3 < this.info.blockCount[1]; ++_j3) for (var _i13 = 0; _i13 < this.info.blockCount[0]; ++_i13) this._blocks.push(new TerrainBlock(this, _i13, _j3));
            var _iterator6 = this._blocks, _isArray6 = Array.isArray(_iterator6), _i14 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i14 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i14++];
                } else {
                    if ((_i14 = _iterator6.next()).done) break;
                    _ref6 = _i14.value;
                }
                _ref6.build();
            }
        }
    }, {
        key: "_rebuildHeights",
        value: function _rebuildHeights(info) {
            if (this.info.vertexCount[0] === info.vertexCount[0] && this.info.vertexCount[1] === info.vertexCount[1]) return !1;
            for (var heights = new Array(info.vertexCount[0] * info.vertexCount[1]), i = 0; i < heights.length; ++i) heights[i] = 0;
            for (var w = Math.min(this.info.vertexCount[0], info.vertexCount[0]), h = Math.min(this.info.vertexCount[1], info.vertexCount[1]), j = 0; j < h; ++j) for (var _i16 = 0; _i16 < w; ++_i16) {
                var index0 = j * info.vertexCount[0] + _i16, index1 = j * this.info.vertexCount[0] + _i16;
                heights[index0] = this._heights[index1];
            }
            return this._heights = heights, !0;
        }
    }, {
        key: "_rebuildWeights",
        value: function _rebuildWeights(info) {
            var _this3 = this, oldWeightMapSize = this.info.weightMapSize, oldWeightMapComplexityU = this.info.weightMapSize * this.info.blockCount[0], oldWeightMapComplexityV = this.info.weightMapSize * this.info.blockCount[1], weightMapComplexityU = info.weightMapSize * info.blockCount[0], weightMapComplexityV = info.weightMapSize * info.blockCount[1];
            if (weightMapComplexityU === oldWeightMapComplexityU && weightMapComplexityV === oldWeightMapComplexityV) return !1;
            for (var weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4), i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) weights[4 * i + 0] = 255, 
            weights[4 * i + 1] = 0, weights[4 * i + 2] = 0, weights[4 * i + 3] = 0;
            for (var w = Math.min(info.blockCount[0], this.info.blockCount[0]), h = Math.min(info.blockCount[1], this.info.blockCount[1]), getOldWeight = function getOldWeight(_i, _j, _weights) {
                var index = _j * oldWeightMapComplexityU + _i, weight = new Vec4();
                return weight.x = _weights[4 * index + 0] / 255, weight.y = _weights[4 * index + 1] / 255, 
                weight.z = _weights[4 * index + 2] / 255, weight.w = _weights[4 * index + 3] / 255, 
                weight;
            }, sampleOldWeight = function sampleOldWeight(_x, _y, _xoff, _yoff, _weights) {
                var ix0 = Math.floor(_x), iz0 = Math.floor(_y), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = _x - ix0, dz = _y - iz0, a = getOldWeight(ix0 + _xoff, iz0 + _yoff, _this3._weights), b = getOldWeight(ix1 + _xoff, iz0 + _yoff, _this3._weights), c = getOldWeight(ix0 + _xoff, iz1 + _yoff, _this3._weights), d = getOldWeight(ix1 + _xoff, iz1 + _yoff, _this3._weights), m = new Vec4();
                Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
                a.subtract(d), a.add(m));
                var n1 = new Vec4(), n2 = new Vec4(), n = new Vec4();
                return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
                n;
            }, j = 0; j < h; ++j) for (var _i17 = 0; _i17 < w; ++_i17) for (var uoff = _i17 * oldWeightMapSize, voff = j * oldWeightMapSize, v = 0; v < this.info.weightMapSize; ++v) for (var u = 0; u < this.info.weightMapSize; ++u) {
                var _w = void 0;
                if (info.weightMapSize == oldWeightMapSize) _w = getOldWeight(u + uoff, v + voff, this._weights); else _w = sampleOldWeight(u / (this.info.weightMapSize - 1) * (oldWeightMapSize - 1), v / (this.info.weightMapSize - 1) * (oldWeightMapSize - 1), uoff, voff, this._weights);
                var du = _i17 * this.info.weightMapSize + u, index = (j * this.info.weightMapSize + v) * weightMapComplexityU + du;
                weights[4 * index + 0] = 255 * _w.x, weights[4 * index + 1] = 255 * _w.y, weights[4 * index + 2] = 255 * _w.z, 
                weights[4 * index + 3] = 255 * _w.w;
            }
            return this._weights = weights, !0;
        }
    }, {
        key: "info",
        get: function get() {
            return this._info;
        }
    } ]), Terrain;
}()).prototype, "_info", [ _dec6$k ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new TerrainInfo();
    }
}), _descriptor9$a = _applyDecoratedDescriptor(_class11$1.prototype, "_layers", [ _dec7$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor10$9 = _applyDecoratedDescriptor(_class11$1.prototype, "_heights", [ _dec8$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor11$8 = _applyDecoratedDescriptor(_class11$1.prototype, "_weights", [ _dec9$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Uint8Array();
    }
}), _descriptor12$7 = _applyDecoratedDescriptor(_class11$1.prototype, "_blockInfos", [ _dec10$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class10$1 = _class11$1)) || _class10$1) || _class10$1) || _class10$1), TerrainHeightData = function TerrainHeightData() {
    _classCallCheck(this, TerrainHeightData), this.x = 0, this.y = 0, this.value = 0;
}, TerrainHeightOperation = function() {
    function TerrainHeightOperation() {
        _classCallCheck(this, TerrainHeightOperation), this.data = new Array();
    }
    return _createClass(TerrainHeightOperation, [ {
        key: "push",
        value: function push(x, y, value) {
            var _iterator = this.data, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var i = _ref;
                if (i.x === x && i.y === y) return;
            }
            var point = new TerrainHeightData();
            point.x = x, point.y = y, point.value = value, this.data.push(point);
        }
    }, {
        key: "apply",
        value: function apply(terrain) {
            var _iterator2 = this.data, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var i = _ref2;
                terrain.setHeight(i.x, i.y, i.value);
            }
            var _iterator3 = this.data, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var _i6 = _ref3, n = terrain._calcuNormal(_i6.x, _i6.y);
                terrain._setNormal(_i6.x, _i6.y, n);
            }
            var changelist = new Array(), _iterator4 = terrain.getBlocks(), _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                var _i7 = _ref4, rect = _i7.getRect(), _iterator5 = this.data, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i8 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i8++];
                    } else {
                        if ((_i8 = _iterator5.next()).done) break;
                        _ref5 = _i8.value;
                    }
                    var j = _ref5;
                    rect.contains(new Vec2(j.x, j.y)) && TerrainHeightOperation.addChangeList(changelist, _i7);
                }
            }
            for (var _i5 = 0, _changelist = changelist; _i5 < _changelist.length; _i5++) {
                _changelist[_i5]._updateHeight();
            }
        }
    } ], [ {
        key: "addChangeList",
        value: function addChangeList(changelist, block) {
            var _iterator6 = changelist, _isArray6 = Array.isArray(_iterator6), _i10 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i10 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i10++];
                } else {
                    if ((_i10 = _iterator6.next()).done) break;
                    _ref6 = _i10.value;
                }
                if (_ref6 === block) return;
            }
            changelist.push(block);
        }
    } ]), TerrainHeightOperation;
}(), TerrainHeightUndoRedo = function(_TerrainHeightOperati) {
    function TerrainHeightUndoRedo() {
        return _classCallCheck(this, TerrainHeightUndoRedo), _possibleConstructorReturn(this, _getPrototypeOf(TerrainHeightUndoRedo).apply(this, arguments));
    }
    return _inherits(TerrainHeightUndoRedo, TerrainHeightOperation), TerrainHeightUndoRedo;
}(), TerrainWeightData = function TerrainWeightData() {
    _classCallCheck(this, TerrainWeightData), this.x = 0, this.y = 0, this.value = new Vec4();
}, TerrainWeightOperation = function() {
    function TerrainWeightOperation() {
        _classCallCheck(this, TerrainWeightOperation), this.data = new Array();
    }
    return _createClass(TerrainWeightOperation, [ {
        key: "push",
        value: function push(x, y, value) {
            var _iterator7 = this.data, _isArray7 = Array.isArray(_iterator7), _i11 = 0;
            for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                var _ref7;
                if (_isArray7) {
                    if (_i11 >= _iterator7.length) break;
                    _ref7 = _iterator7[_i11++];
                } else {
                    if ((_i11 = _iterator7.next()).done) break;
                    _ref7 = _i11.value;
                }
                var i = _ref7;
                if (i.x === x && i.y === y) return;
            }
            var point = new TerrainWeightData();
            point.x = x, point.y = y, point.value = value, this.data.push(point);
        }
    }, {
        key: "apply",
        value: function apply(terrain) {
            var _iterator8 = this.data, _isArray8 = Array.isArray(_iterator8), _i12 = 0;
            for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                var _ref8;
                if (_isArray8) {
                    if (_i12 >= _iterator8.length) break;
                    _ref8 = _iterator8[_i12++];
                } else {
                    if ((_i12 = _iterator8.next()).done) break;
                    _ref8 = _i12.value;
                }
                var i = _ref8;
                terrain.setWeight(i.x, i.y, i.value);
            }
            var changelist = new Array(), _iterator9 = terrain.getBlocks(), _isArray9 = Array.isArray(_iterator9), _i13 = 0;
            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                var _ref9;
                if (_isArray9) {
                    if (_i13 >= _iterator9.length) break;
                    _ref9 = _iterator9[_i13++];
                } else {
                    if ((_i13 = _iterator9.next()).done) break;
                    _ref9 = _i13.value;
                }
                var block = _ref9, rect = new Rect();
                rect.x = block.getIndex()[0] * terrain.info.weightMapSize, rect.y = block.getIndex()[1] * terrain.info.weightMapSize, 
                rect.width = terrain.info.weightMapSize, rect.height = terrain.info.weightMapSize;
                var _iterator10 = this.data, _isArray10 = Array.isArray(_iterator10), _i15 = 0;
                for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                    var _ref10;
                    if (_isArray10) {
                        if (_i15 >= _iterator10.length) break;
                        _ref10 = _iterator10[_i15++];
                    } else {
                        if ((_i15 = _iterator10.next()).done) break;
                        _ref10 = _i15.value;
                    }
                    var p = _ref10;
                    rect.contains(new Vec2(p.x, p.y)) && TerrainWeightOperation.addChangeList(changelist, block);
                }
            }
            for (var _i14 = 0, _changelist2 = changelist; _i14 < _changelist2.length; _i14++) {
                _changelist2[_i14]._updateWeightMap();
            }
        }
    } ], [ {
        key: "addChangeList",
        value: function addChangeList(changelist, block) {
            var _iterator11 = changelist, _isArray11 = Array.isArray(_iterator11), _i17 = 0;
            for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                var _ref11;
                if (_isArray11) {
                    if (_i17 >= _iterator11.length) break;
                    _ref11 = _iterator11[_i17++];
                } else {
                    if ((_i17 = _iterator11.next()).done) break;
                    _ref11 = _i17.value;
                }
                if (_ref11 === block) return;
            }
            changelist.push(block);
        }
    } ]), TerrainWeightOperation;
}(), TerrainBlockLayerData = function TerrainBlockLayerData(block, layers) {
    _classCallCheck(this, TerrainBlockLayerData), this.block = void 0, this.layers = void 0, 
    this.block = block, this.layers = layers;
}, TerrainWeightUndoRedo = function(_TerrainWeightOperati) {
    function TerrainWeightUndoRedo() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TerrainWeightUndoRedo);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TerrainWeightUndoRedo)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).blockLayers = new Array(), 
        _this;
    }
    return _inherits(TerrainWeightUndoRedo, TerrainWeightOperation), _createClass(TerrainWeightUndoRedo, [ {
        key: "pushBlock",
        value: function pushBlock(block, layers) {
            var _iterator12 = this.blockLayers, _isArray12 = Array.isArray(_iterator12), _i18 = 0;
            for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                var _ref12;
                if (_isArray12) {
                    if (_i18 >= _iterator12.length) break;
                    _ref12 = _iterator12[_i18++];
                } else {
                    if ((_i18 = _iterator12.next()).done) break;
                    _ref12 = _i18.value;
                }
                if (_ref12.block === block) return;
            }
            this.blockLayers.push(new TerrainBlockLayerData(block, layers));
        }
    }, {
        key: "apply",
        value: function apply(terrain) {
            _get(_getPrototypeOf(TerrainWeightUndoRedo.prototype), "apply", this).call(this, terrain);
            var _iterator13 = this.blockLayers, _isArray13 = Array.isArray(_iterator13), _i19 = 0;
            for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                var _ref13;
                if (_isArray13) {
                    if (_i19 >= _iterator13.length) break;
                    _ref13 = _iterator13[_i19++];
                } else {
                    if ((_i19 = _iterator13.next()).done) break;
                    _ref13 = _i19.value;
                }
                var i = _ref13, block = i.block, layers = i.layers;
                block.setLayer(0, layers[0]), block.setLayer(1, layers[1]), block.setLayer(2, layers[2]), 
                block.setLayer(3, layers[3]);
            }
        }
    } ]), TerrainWeightUndoRedo;
}(), TerrainEditorPaint = function(_TerrainEditorMode) {
    function TerrainEditorPaint() {
        var _this;
        _classCallCheck(this, TerrainEditorPaint), (_this = _possibleConstructorReturn(this, _getPrototypeOf(TerrainEditorPaint).call(this)))._brush = void 0, 
        _this._undo = null, _this._currentLayer = -1;
        var brush = new TerrainCircleBrush();
        return brush.strength = 5, _this._brush = brush, _this;
    }
    return _inherits(TerrainEditorPaint, TerrainEditorMode), _createClass(TerrainEditorPaint, [ {
        key: "setCurrentLayer",
        value: function setCurrentLayer(layer) {
            this._currentLayer = layer;
        }
    }, {
        key: "getCurrentLayer",
        value: function getCurrentLayer() {
            return this._currentLayer;
        }
    }, {
        key: "onUpdate",
        value: function onUpdate(terrain, dtime) {
            null != this._undo && this._updateWeight(terrain, dtime);
        }
    }, {
        key: "onUpdateBrushPosition",
        value: function onUpdateBrushPosition(terrain, pos) {
            this._brush.update(pos);
            var _iterator = terrain.getBlocks(), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var i = _ref, index = i.getIndex(), bound = new Rect();
                bound.x = 32 * index[0] * terrain.info.tileSize, bound.y = 32 * index[1] * terrain.info.tileSize, 
                bound.width = 32 * terrain.info.tileSize, bound.height = 32 * terrain.info.tileSize;
                var brushRect = new Rect();
                brushRect.x = this._brush.position.x - this._brush.radius, brushRect.y = this._brush.position.z - this._brush.radius, 
                brushRect.width = 2 * this._brush.radius, brushRect.height = 2 * this._brush.radius, 
                bound.intersects(brushRect) ? i.setBrushMaterial(this._brush.material) : i.setBrushMaterial(null);
            }
        }
    }, {
        key: "onMouseDown",
        value: function onMouseDown() {
            -1 !== this._currentLayer && (this._undo = new TerrainWeightUndoRedo());
        }
    }, {
        key: "onMouseUp",
        value: function onMouseUp() {
            this._undo = null;
        }
    }, {
        key: "_updateWeight",
        value: function _updateWeight(terrain, dtime) {
            var uWeigthComplexity = terrain.info.weightMapSize * terrain.info.blockCount[0], vWeigthComplexity = terrain.info.weightMapSize * terrain.info.blockCount[1];
            if (0 !== uWeigthComplexity && 0 !== vWeigthComplexity) {
                var x1 = this._brush.position.x - this._brush.radius, y1 = this._brush.position.z - this._brush.radius, x2 = this._brush.position.x + this._brush.radius, y2 = this._brush.position.z + this._brush.radius;
                if (x1 /= terrain.info.size.width, y1 /= terrain.info.size.height, x2 /= terrain.info.size.width, 
                y2 /= terrain.info.size.height, x1 *= uWeigthComplexity - 1, y1 *= vWeigthComplexity - 1, 
                x2 *= uWeigthComplexity - 1, y2 *= vWeigthComplexity - 1, x1 = Math.floor(x1), y1 = Math.floor(y1), 
                x2 = Math.floor(x2), y2 = Math.floor(y2), !(x1 > uWeigthComplexity - 1 || x2 < 0 || y1 > vWeigthComplexity - 1 || y2 < 0)) {
                    x1 = clamp(x1, 0, uWeigthComplexity - 1), y1 = clamp(y1, 0, vWeigthComplexity - 1), 
                    x2 = clamp(x2, 0, uWeigthComplexity - 1), y2 = clamp(y2, 0, vWeigthComplexity - 1);
                    for (var op = new TerrainWeightOperation(), y = y1; y <= y2; ++y) for (var x = x1; x <= x2; ++x) {
                        var w = terrain.getWeight(x, y), bx = Math.floor(x / terrain.info.weightMapSize), by = Math.floor(y / terrain.info.weightMapSize), block = terrain.getBlock(bx, by), layers = [ block.getLayer(0), block.getLayer(1), block.getLayer(2), block.getLayer(3) ], xpos = x / (uWeigthComplexity - 1) * terrain.info.size.width, ypos = y / (vWeigthComplexity - 1) * terrain.info.size.height, delta = this._brush.getDelta(xpos, ypos) * dtime;
                        if (0 !== delta) {
                            if (layers[0] === this._currentLayer) w.x += delta; else if (layers[1] === this._currentLayer) w.y += delta; else if (layers[2] === this._currentLayer) w.z += delta; else if (layers[3] === this._currentLayer) w.w += delta; else if (-1 === layers[0]) block.setLayer(0, this._currentLayer), 
                            w.x += delta; else if (-1 === layers[1]) block.setLayer(1, this._currentLayer), 
                            w.y += delta; else if (-1 === layers[3]) block.setLayer(2, this._currentLayer), 
                            w.z += delta; else {
                                if (-1 !== layers[4]) continue;
                                block.setLayer(3, this._currentLayer), w.w += delta;
                            }
                            var sum = w.x + w.y + w.z + w.w;
                            sum > 0 && w.multiplyScalar(1 / sum), null != this._undo && (this._undo.push(x, y, terrain.getWeight(x, y)), 
                            this._undo.pushBlock(block, layers)), op.push(x, y, w);
                        }
                    }
                    op.apply(terrain);
                }
            }
        }
    } ]), TerrainEditorPaint;
}(), TerrainEditorSculpt = function(_TerrainEditorMode) {
    function TerrainEditorSculpt() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TerrainEditorSculpt);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TerrainEditorSculpt)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._brush = new TerrainCircleBrush(), 
        _this._undo = null, _this;
    }
    return _inherits(TerrainEditorSculpt, TerrainEditorMode), _createClass(TerrainEditorSculpt, [ {
        key: "onUpdate",
        value: function onUpdate(terrain, dtime) {
            null != this._undo && this._updateHeight(terrain, dtime, !1);
        }
    }, {
        key: "onUpdateBrushPosition",
        value: function onUpdateBrushPosition(terrain, pos) {
            this._brush.update(pos);
            var _iterator = terrain.getBlocks(), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var block = _ref, index = block.getIndex(), bound = new Rect();
                bound.x = 32 * index[0] * terrain.info.tileSize, bound.y = 32 * index[1] * terrain.info.tileSize, 
                bound.width = 32 * terrain.info.tileSize, bound.height = 32 * terrain.info.tileSize;
                var brushRect = new Rect();
                brushRect.x = this._brush.position.x - this._brush.radius, brushRect.y = this._brush.position.z - this._brush.radius, 
                brushRect.width = 2 * this._brush.radius, brushRect.height = 2 * this._brush.radius, 
                bound.intersects(brushRect) ? block.setBrushMaterial(this._brush.material) : block.setBrushMaterial(null);
            }
        }
    }, {
        key: "onMouseDown",
        value: function onMouseDown() {
            this._undo = new TerrainHeightUndoRedo();
        }
    }, {
        key: "onMouseUp",
        value: function onMouseUp() {
            this._undo = null;
        }
    }, {
        key: "_updateHeight",
        value: function _updateHeight(terrain, dtime, shift_pressed) {
            var x1 = this._brush.position.x - this._brush.radius, y1 = this._brush.position.z - this._brush.radius, x2 = this._brush.position.x + this._brush.radius, y2 = this._brush.position.z + this._brush.radius;
            if (x1 /= terrain.info.tileSize, y1 /= terrain.info.tileSize, x2 /= terrain.info.tileSize, 
            y2 /= terrain.info.tileSize, x1 = Math.floor(x1), y1 = Math.floor(y1), x2 = Math.floor(x2), 
            y2 = Math.floor(y2), !(x1 > terrain.info.vertexCount[0] - 1 || x2 < 0 || y1 > terrain.info.vertexCount[1] - 1 || y2 < 0)) {
                x1 = clamp(x1, 0, terrain.info.vertexCount[0] - 1), y1 = clamp(y1, 0, terrain.info.vertexCount[1] - 1), 
                x2 = clamp(x2, 0, terrain.info.vertexCount[0] - 1), y2 = clamp(y2, 0, terrain.info.vertexCount[1] - 1);
                for (var op = new TerrainHeightOperation(), y = y1; y <= y2; ++y) for (var x = x1; x <= x2; ++x) {
                    var h = terrain.getHeight(x, y);
                    null != this._undo && this._undo.push(x, y, h);
                    var xpos = x * terrain.info.tileSize, ypos = y * terrain.info.tileSize, delta = this._brush.getDelta(xpos, ypos) * dtime;
                    shift_pressed ? h -= delta : h += delta, op.push(x, y, h);
                }
                op.apply(terrain);
            }
        }
    } ]), TerrainEditorSculpt;
}(), ProjectionType = Enum({
    ORTHO: 0,
    PERSPECTIVE: 1
}), CameraClearFlag = Enum({
    SOLID_COLOR: GFXClearFlag.ALL,
    DEPTH_ONLY: GFXClearFlag.DEPTH_STENCIL,
    DONT_CLEAR: GFXClearFlag.NONE
}), c4_1 = new Color(), CameraComponent = (_dec$10 = ccclass("cc.CameraComponent"), 
_dec2$H = menu("Components/CameraComponent"), _dec3$v = property({
    type: ProjectionType
}), _dec4$p = property({
    type: CameraClearFlag
}), _dec5$n = property({
    visible: !1
}), _dec6$l = property({
    type: RenderTexture
}), _dec$10(_class$11 = _dec2$H(_class$11 = executeInEditMode((_temp$W = _class3$u = function(_Component) {
    function CameraComponent() {
        var _this;
        return _classCallCheck(this, CameraComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CameraComponent).call(this)), "_projection", _descriptor$P, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_priority", _descriptor2$G, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fov", _descriptor3$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_orthoHeight", _descriptor4$p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_near", _descriptor5$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_far", _descriptor6$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor7$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_depth", _descriptor8$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_stencil", _descriptor9$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_clearFlags", _descriptor10$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_rect", _descriptor11$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_screenScale", _descriptor12$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_visibility", _descriptor13$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_targetTexture", _descriptor14$6, _assertThisInitialized(_this)), 
        _this._camera = null, _this._editorWindow = null, _this;
    }
    return _inherits(CameraComponent, Component), _createClass(CameraComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneChanged, this), 
            this._getEditorWindow();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._camera ? this._camera.enabled = !0 : (this._createCamera(), this._camera.enabled = !0, 
            this._updateTargetTexture());
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._camera && (this._camera.enabled = !1);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._editorWindow = null, this._camera && (this._targetTexture && this._targetTexture.removeCamera(this._camera), 
            this._getRenderScene().destroyCamera(this._camera), this._camera = null);
        }
    }, {
        key: "screenPointToRay",
        value: function screenPointToRay(x, y, out) {
            return out || (out = ray.create()), this._camera && this._camera.screenPointToRay(out, x, y), 
            out;
        }
    }, {
        key: "worldToScreen",
        value: function worldToScreen(worldPos, out) {
            return out || (out = new Vec3()), this._camera && this._camera.worldToScreen(out, worldPos), 
            out;
        }
    }, {
        key: "screenToWorld",
        value: function screenToWorld(screenPos, out) {
            return out || (out = this.node.getWorldPosition()), this._camera && this._camera.screenToWorld(out, screenPos), 
            out;
        }
    }, {
        key: "_createCamera",
        value: function _createCamera() {
            var _this2 = this;
            if (this.node.scene) {
                var scene = this._getRenderScene();
                if ((!this._camera || !scene.cameras.find(function(c) {
                    return c === _this2._camera;
                })) && (this._camera = scene.createCamera({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    priority: this._priority
                }), this._camera)) {
                    this._camera.viewport = this._rect, this._camera.fov = toRadian(this._fov), this._camera.orthoHeight = this._orthoHeight, 
                    this._camera.nearClip = this._near, this._camera.farClip = this._far;
                    var r = this._color.r / 255, g = this._color.g / 255, b = this._color.b / 255, a = this._color.a / 255;
                    this._camera.clearColor = {
                        r: r,
                        g: g,
                        b: b,
                        a: a
                    }, this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, 
                    this._camera.clearFlag = this._clearFlags, this._camera.visibility = this._visibility;
                }
            }
        }
    }, {
        key: "onSceneChanged",
        value: function onSceneChanged(scene) {
            this._camera && this._camera.scene !== scene.renderScene && (this._targetTexture && this._targetTexture.removeCamera(this._camera), 
            this._createCamera(), this._camera.enabled = !0, this._updateTargetTexture());
        }
    }, {
        key: "_getEditorWindow",
        value: function _getEditorWindow() {
            cc.director.root, 0;
        }
    }, {
        key: "_updateTargetTexture",
        value: function _updateTargetTexture() {
            if (this._camera) if (this._targetTexture) {
                var window = this._targetTexture.getGFXWindow();
                this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height), 
                this._targetTexture.addCamera(this._camera);
            } else this._camera.changeTargetWindow(this._editorWindow);
        }
    }, {
        key: "projection",
        get: function get() {
            return this._projection;
        },
        set: function set(val) {
            this._projection = val, this._camera && (this._camera.projectionType = val);
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(val) {
            this._priority = val;
        }
    }, {
        key: "fov",
        get: function get() {
            return this._fov;
        },
        set: function set(val) {
            this._fov = val, this._camera && (this._camera.fov = toRadian(val));
        }
    }, {
        key: "orthoHeight",
        get: function get() {
            return this._orthoHeight;
        },
        set: function set(val) {
            this._orthoHeight = val, this._camera && (this._camera.orthoHeight = val);
        }
    }, {
        key: "near",
        get: function get() {
            return this._near;
        },
        set: function set(val) {
            this._near = val, this._camera && (this._camera.nearClip = val);
        }
    }, {
        key: "far",
        get: function get() {
            return this._far;
        },
        set: function set(val) {
            this._far = val, this._camera && (this._camera.farClip = val);
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            this._color.set(val), this._camera && (Color.set(c4_1, val.r / 255, val.g / 255, val.b / 255, val.a / 255), 
            this._camera.clearColor = c4_1);
        }
    }, {
        key: "depth",
        get: function get() {
            return this._depth;
        },
        set: function set(val) {
            this._depth = val, this._camera && (this._camera.clearDepth = val);
        }
    }, {
        key: "stencil",
        get: function get() {
            return this._stencil;
        },
        set: function set(val) {
            this._stencil = val, this._camera && (this._camera.clearStencil = val);
        }
    }, {
        key: "clearFlags",
        get: function get() {
            return this._clearFlags;
        },
        set: function set(val) {
            this._clearFlags = val, this._camera && (this._camera.clearFlag = val);
        }
    }, {
        key: "rect",
        get: function get() {
            return this._rect;
        },
        set: function set(val) {
            this._rect = val, this._camera && (this._camera.viewport = val);
        }
    }, {
        key: "screenScale",
        get: function get() {
            return this._screenScale;
        },
        set: function set(val) {
            this._screenScale = val, this._camera && (this._camera.screenScale = val);
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._visibility;
        },
        set: function set(val) {
            this._visibility = val, this._camera && (this._camera.visibility = val);
        }
    }, {
        key: "targetTexture",
        get: function get() {
            return this._targetTexture;
        },
        set: function set(value) {
            this._targetTexture !== value && (!value && this._camera && this._targetTexture.removeCamera(this._camera), 
            this._targetTexture = value, this._updateTargetTexture());
        }
    } ]), CameraComponent;
}(), _class3$u.ProjectionType = ProjectionType, _descriptor$P = _applyDecoratedDescriptor((_class2$S = _temp$W).prototype, "_projection", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ProjectionType.PERSPECTIVE;
    }
}), _descriptor2$G = _applyDecoratedDescriptor(_class2$S.prototype, "_priority", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$s = _applyDecoratedDescriptor(_class2$S.prototype, "_fov", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 45;
    }
}), _descriptor4$p = _applyDecoratedDescriptor(_class2$S.prototype, "_orthoHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 10;
    }
}), _descriptor5$k = _applyDecoratedDescriptor(_class2$S.prototype, "_near", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor6$d = _applyDecoratedDescriptor(_class2$S.prototype, "_far", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1e3;
    }
}), _descriptor7$c = _applyDecoratedDescriptor(_class2$S.prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color("#334C78");
    }
}), _descriptor8$c = _applyDecoratedDescriptor(_class2$S.prototype, "_depth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor9$b = _applyDecoratedDescriptor(_class2$S.prototype, "_stencil", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$a = _applyDecoratedDescriptor(_class2$S.prototype, "_clearFlags", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return CameraClearFlag.SOLID_COLOR;
    }
}), _descriptor11$9 = _applyDecoratedDescriptor(_class2$S.prototype, "_rect", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Rect(0, 0, 1, 1);
    }
}), _descriptor12$8 = _applyDecoratedDescriptor(_class2$S.prototype, "_screenScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor13$6 = _applyDecoratedDescriptor(_class2$S.prototype, "_visibility", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor14$6 = _applyDecoratedDescriptor(_class2$S.prototype, "_targetTexture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$S.prototype, "projection", [ _dec3$v ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "projection"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "priority", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "priority"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "fov", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "fov"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "orthoHeight", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "orthoHeight"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "near", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "near"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "far", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "far"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "color"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "depth", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "depth"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "stencil", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "stencil"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "clearFlags", [ _dec4$p ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "clearFlags"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "rect", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "rect"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "screenScale", [ _dec5$n ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "screenScale"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "visibility", [ property ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "visibility"), _class2$S.prototype), 
_applyDecoratedDescriptor(_class2$S.prototype, "targetTexture", [ _dec6$l ], Object.getOwnPropertyDescriptor(_class2$S.prototype, "targetTexture"), _class2$S.prototype), 
_class$11 = _class2$S)) || _class$11) || _class$11) || _class$11), TerrainEditor = function() {
    function TerrainEditor() {
        _classCallCheck(this, TerrainEditor), this._terrain = null, this._modes = [ new TerrainEditorManage(), new TerrainEditorSculpt(), new TerrainEditorPaint() ], 
        this._currentMode = null, TerrainEditor.Instance = this, this.setMode(eTerrainEditorMode.SCULPT);
    }
    return _createClass(TerrainEditor, [ {
        key: "setEditTerrain",
        value: function setEditTerrain(t) {
            this._terrain = t;
        }
    }, {
        key: "setMode",
        value: function setMode(mode) {
            var m = this._modes[mode];
            if (this._currentMode = m, null != this._terrain) {
                var _iterator = this._terrain.getBlocks(), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.setBrushMaterial(null);
                }
            }
        }
    }, {
        key: "getMode",
        value: function getMode(mode) {
            return this._modes[mode];
        }
    }, {
        key: "getCurrentMode",
        value: function getCurrentMode() {
            return this._currentMode;
        }
    }, {
        key: "getCurrentModeType",
        value: function getCurrentModeType() {
            return this._currentMode === this._modes[0] ? eTerrainEditorMode.MANAGE : this._currentMode === this._modes[1] ? eTerrainEditorMode.SCULPT : this._currentMode === this._modes[2] ? eTerrainEditorMode.PAINT : eTerrainEditorMode.SCULPT;
        }
    }, {
        key: "setCurrentLayer",
        value: function setCurrentLayer(id) {
            this.getMode(eTerrainEditorMode.PAINT).setCurrentLayer(id);
        }
    }, {
        key: "update",
        value: function update(dtime) {
            null != this._currentMode && null != this._terrain && this._currentMode.onUpdate(this._terrain, dtime);
        }
    }, {
        key: "onMouseDown",
        value: function onMouseDown(id, x, y) {
            if (null != this._terrain) {
                var sculptMode = this.getMode(eTerrainEditorMode.SCULPT), paintMode = this.getMode(eTerrainEditorMode.PAINT);
                this._currentMode === sculptMode ? sculptMode.onMouseDown() : this._currentMode === paintMode && paintMode.onMouseDown();
            }
        }
    }, {
        key: "onMouseUp",
        value: function onMouseUp(id, x, y) {
            if (null != this._terrain) {
                var sculptMode = this.getMode(eTerrainEditorMode.SCULPT), paintMode = this.getMode(eTerrainEditorMode.PAINT);
                this._currentMode === sculptMode ? sculptMode.onMouseUp() : this._currentMode === paintMode && paintMode.onMouseUp();
            }
        }
    }, {
        key: "onMouseMove",
        value: function onMouseMove(camera, x, y) {
            if (null != this._terrain) {
                this._terrain.node.scene;
                if (null != camera) {
                    var cameraComponent = camera.getComponent(CameraComponent);
                    if (null == cameraComponent) return;
                    var from = camera.getPosition(), to = new Vec3();
                    cameraComponent.screenToWorld(new Vec3(x, y, 0), to);
                    var dir = new Vec3();
                    Vec3.subtract(dir, to, from), Vec3.normalize(dir, dir);
                    var vhit = this._terrain.rayCheck(from, dir, .1);
                    if (null == vhit) return;
                    var sculptMode = this.getMode(eTerrainEditorMode.SCULPT), paintMode = this.getMode(eTerrainEditorMode.PAINT);
                    this._currentMode === sculptMode ? sculptMode.onUpdateBrushPosition(this._terrain, vhit) : this._currentMode === paintMode && paintMode.onUpdateBrushPosition(this._terrain, vhit);
                }
            }
        }
    } ]), TerrainEditor;
}();

TerrainEditor.Instance = void 0;

var ParticleBatchModel = function(_Model) {
    function ParticleBatchModel(scene, node) {
        var _this;
        return _classCallCheck(this, ParticleBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleBatchModel).call(this, scene, node)))._capacity = void 0, 
        _this._vertAttrs = void 0, _this._vertSize = void 0, _this._vBuffer = void 0, _this._vertAttrsFloatCount = void 0, 
        _this._vdataF32 = void 0, _this._vdataUint32 = void 0, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
        _this._subMeshData = void 0, _this._mesh = void 0, _this._vertCount = 0, _this._indexCount = 0, 
        _this._type = "particle-batch", _this._capacity = 0, _this._vertAttrs = null, _this._vertSize = 0, 
        _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, _this._vdataUint32 = null, 
        _this._iaInfo = {
            drawInfos: [ {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            } ]
        }, _this._iaInfoBuffer = _this._device.createBuffer({
            usage: GFXBufferUsageBit.INDIRECT,
            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
            size: GFX_DRAW_INFO_SIZE,
            stride: 1
        }), _this._subMeshData = null, _this._mesh = null, _this;
    }
    return _inherits(ParticleBatchModel, Model), _createClass(ParticleBatchModel, [ {
        key: "setCapacity",
        value: function setCapacity(capacity) {
            var capChanged = this._capacity !== capacity;
            this._capacity = capacity, this._inited && capChanged && this._recreateBuffer();
        }
    }, {
        key: "setVertexAttributes",
        value: function setVertexAttributes(mesh, attrs) {
            if (this._mesh !== mesh || this._vertAttrs !== attrs) {
                this._mesh = mesh, this._vertAttrs = attrs, this._vertSize = 0;
                var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var a = _ref;
                    a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                }
                this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer), 
                this._inited = !0;
            }
        }
    }, {
        key: "_createSubMeshData",
        value: function _createSubMeshData() {
            this._subMeshData && this.destroySubMeshData(), this._vertCount = 4, this._indexCount = 6, 
            this._mesh && (this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count, 
            this._indexCount = this._mesh.struct.primitives[0].indexView.count);
            var vertexBuffer = this._device.createBuffer({
                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: this._vertSize * this._capacity * this._vertCount,
                stride: this._vertSize
            }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
            if (this._mesh) {
                var vIdx = this._vertAttrs.findIndex(function(val) {
                    return val.name === GFXAttributeName.ATTR_TEX_COORD2;
                }), vOffset = this._vertAttrs[vIdx++].offset;
                if (this._mesh.copyAttribute(0, GFXAttributeName.ATTR_POSITION, vBuffer, this._vertSize, vOffset), 
                vOffset = this._vertAttrs[vIdx++].offset, this._mesh.copyAttribute(0, GFXAttributeName.ATTR_NORMAL, vBuffer, this._vertSize, vOffset), 
                vOffset = this._vertAttrs[this._vertAttrs.findIndex(function(val) {
                    return val.name === GFXAttributeName.ATTR_TEX_COORD;
                })].offset, this._mesh.copyAttribute(0, GFXAttributeName.ATTR_TEX_COORD, vBuffer, this._vertSize, vOffset), 
                vOffset = this._vertAttrs[vIdx++].offset, !this._mesh.copyAttribute(0, GFXAttributeName.ATTR_COLOR, vBuffer, this._vertSize, vOffset)) for (var vb = new Uint32Array(vBuffer), iVertex = 0; iVertex < this._vertCount; ++iVertex) vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = cc.Color.WHITE._val;
                for (var vbFloatArray = new Float32Array(vBuffer), i = 1; i < this._capacity; i++) vbFloatArray.copyWithin(i * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
            }
            vertexBuffer.update(vBuffer);
            var indices = new Uint16Array(this._capacity * this._indexCount);
            if (this._mesh) {
                this._mesh.copyIndices(0, indices);
                for (var _i2 = 1; _i2 < this._capacity; _i2++) for (var j = 0; j < this._indexCount; j++) indices[_i2 * this._indexCount + j] = indices[j] + _i2 * this._vertCount;
            } else for (var dst = 0, _i3 = 0; _i3 < this._capacity; ++_i3) {
                var baseIdx = 4 * _i3;
                indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
            }
            var indexBuffer = this._device.createBuffer({
                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                stride: Uint16Array.BYTES_PER_ELEMENT
            });
            return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
            this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount, this._iaInfoBuffer.update(this._iaInfo), 
            this._subMeshData = {
                vertexBuffers: [ vertexBuffer ],
                indexBuffer: indexBuffer,
                indirectBuffer: this._iaInfoBuffer,
                attributes: this._vertAttrs,
                primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST
            }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
        }
    }, {
        key: "setSubModelMaterial",
        value: function setSubModelMaterial(idx, mat) {
            this.initLocalBindings(mat), _get(_getPrototypeOf(ParticleBatchModel.prototype), "setSubModelMaterial", this).call(this, idx, mat);
        }
    }, {
        key: "addParticleVertexData",
        value: function addParticleVertexData(index, pvdata) {
            if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
                var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                this._vdataF32[_offset++] = pvdata[0].x, this._vdataF32[_offset++] = pvdata[0].y, 
                this._vdataF32[_offset++] = pvdata[0].z, _offset += 2, this._vdataF32[_offset++] = pvdata[1].z, 
                this._vdataF32[_offset++] = pvdata[2].x, this._vdataF32[_offset++] = pvdata[2].y, 
                this._vdataUint32[_offset++] = pvdata[3];
            } else {
                var offset = index * this._vertAttrsFloatCount;
                this._vdataF32[offset++] = pvdata[0].x, this._vdataF32[offset++] = pvdata[0].y, 
                this._vdataF32[offset++] = pvdata[0].z, this._vdataF32[offset++] = pvdata[1].x, 
                this._vdataF32[offset++] = pvdata[1].y, this._vdataF32[offset++] = pvdata[1].z, 
                this._vdataF32[offset++] = pvdata[2].x, this._vdataF32[offset++] = pvdata[2].y, 
                this._vdataUint32[offset++] = pvdata[3], pvdata[4] && (this._vdataF32[offset++] = pvdata[4].x, 
                this._vdataF32[offset++] = pvdata[4].y, this._vdataF32[offset++] = pvdata[4].z);
            }
        }
    }, {
        key: "updateIA",
        value: function updateIA(count) {
            this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
            this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.getSubModel(0).inputAssembler.indexCount = 0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _get(_getPrototypeOf(ParticleBatchModel.prototype), "destroy", this).call(this), 
            this._vBuffer = null, this._vdataF32 = null, this._subMeshData && this.destroySubMeshData(), 
            this._iaInfoBuffer.destroy(), this._subMeshData = null;
        }
    }, {
        key: "_recreateBuffer",
        value: function _recreateBuffer() {
            this._vBuffer = this._createSubMeshData(), this.getSubModel(0).updateCommandBuffer(), 
            this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
        }
    }, {
        key: "destroySubMeshData",
        value: function destroySubMeshData() {
            var _iterator2 = this._subMeshData.vertexBuffers, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i4 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i4++];
                } else {
                    if ((_i4 = _iterator2.next()).done) break;
                    _ref2 = _i4.value;
                }
                _ref2.destroy();
            }
            this._subMeshData.indexBuffer.destroy();
        }
    } ]), ParticleBatchModel;
}(), addStage = config_addStage;

cc.samplerLib = samplerLib;

var renderer = Object.freeze({
    addStage: addStage,
    samplerLib: samplerLib,
    createIA: function createIA(device, data) {
        if (!data.positions) return console.error("The data must have positions field"), 
        null;
        for (var verts = [], vcount = data.positions.length / 3, i = 0; i < vcount; ++i) verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]), 
        data.normals && verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]), 
        data.uvs && verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]), data.colors && verts.push(data.colors[3 * i], data.uvs[3 * i + 1], data.colors[3 * i + 2]);
        var vfmt = [];
        vfmt.push({
            name: GFXAttributeName.ATTR_POSITION,
            format: GFXFormat.RGB32F
        }), data.normals && vfmt.push({
            name: GFXAttributeName.ATTR_NORMAL,
            format: GFXFormat.RGB32F
        }), data.uvs && vfmt.push({
            name: GFXAttributeName.ATTR_TEX_COORD,
            format: GFXFormat.RG32F
        }), data.colors && vfmt.push({
            name: GFXAttributeName.ATTR_COLOR,
            format: GFXFormat.RGB32F
        });
        var vb = device.createBuffer({
            usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
            size: 4 * verts.length,
            stride: 4 * verts.length / vcount
        });
        vb.update(new Float32Array(verts));
        var ib = device.createBuffer({
            usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
            size: 2 * data.indices.length,
            stride: 2
        });
        return ib.update(new Uint16Array(data.indices)), device.createInputAssembler({
            attributes: vfmt,
            vertexBuffers: [ vb ],
            indexBuffer: ib
        });
    },
    get RenderQueue() {
        return RenderQueue$1;
    },
    get PassStage() {
        return PassStage;
    },
    Pass: Pass,
    programLib: programLib,
    Light: Light,
    Camera: Camera,
    Model: Model,
    ParticleBatchModel: ParticleBatchModel,
    SkinningModel: SkinningModel,
    TerrainEditorPaint: TerrainEditorPaint,
    TextureBufferPool: TextureBufferPool,
    TerrainBrush: TerrainBrush,
    TerrainBrushData: TerrainBrushData,
    get eTerrainCircleBrushType() {
        return eTerrainCircleBrushType;
    },
    TerrainCircleBrush: TerrainCircleBrush,
    TerrainEditorManage: TerrainEditorManage,
    get eTerrainEditorMode() {
        return eTerrainEditorMode;
    },
    TerrainEditorMode: TerrainEditorMode,
    HeightField: HeightField,
    TerrainEditorSculpt: TerrainEditorSculpt,
    TerrainEditor: TerrainEditor,
    TerrainHeightData: TerrainHeightData,
    TerrainHeightOperation: TerrainHeightOperation,
    TerrainHeightUndoRedo: TerrainHeightUndoRedo,
    TerrainWeightData: TerrainWeightData,
    TerrainWeightOperation: TerrainWeightOperation,
    TerrainBlockLayerData: TerrainBlockLayerData,
    TerrainWeightUndoRedo: TerrainWeightUndoRedo,
    TERRAIN_MAX_LEVELS: 4,
    TERRAIN_MAX_BLEND_LAYERS: 4,
    TERRAIN_MAX_LAYER_COUNT: TERRAIN_MAX_LAYER_COUNT,
    TERRAIN_BLOCK_TILE_COMPLEXITY: 32,
    TERRAIN_BLOCK_VERTEX_COMPLEXITY: 33,
    TERRAIN_BLOCK_VERTEX_SIZE: 8,
    TERRAIN_NORTH_INDEX: 0,
    TERRAIN_SOUTH_INDEX: 1,
    TERRAIN_WEST_INDEX: 2,
    TERRAIN_EAST_INDEX: 3,
    TerrainInfo: TerrainInfo,
    TerrainLayer: TerrainLayer,
    TerrainVertex: function TerrainVertex() {
        _classCallCheck(this, TerrainVertex), this.position = new Vec3(0, 0, 0), this.normal = new Vec3(0, 1, 0), 
        this.uv = new Vec2(0, 0);
    },
    TerrainRenderable: TerrainRenderable,
    TerrainBlockInfo: TerrainBlockInfo,
    TerrainBlock: TerrainBlock,
    Terrain: Terrain,
    get JointsMediumType() {
        return JointsMediumType;
    },
    selectJointsMediumType: selectJointsMediumType,
    JointsTexturePool: JointsTexturePool,
    getJointsTextureSampler: getJointsTextureSampler
}), vfmt = [ {
    name: GFXAttributeName.ATTR_POSITION,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD,
    format: GFXFormat.RG32F
}, {
    name: GFXAttributeName.ATTR_COLOR,
    format: GFXFormat.RGBA32F
} ], UIVertexFormat = Object.freeze({
    vfmt: vfmt
}), Aim = function Aim(i, x, y) {
    _classCallCheck(this, Aim), this.i = void 0, this.x = void 0, this.y = void 0, this.prev = null, 
    this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, 
    this.i = i, this.x = x, this.y = y;
};

function linkedList(datas, start, end, dim, clockwise) {
    var i = 0, last = null;
    if (clockwise === function signedArea(datas, start, end, dim) {
        for (var sum = 0, i = start, j = end - dim; i < end; i += dim) sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]), 
        j = i;
        return sum;
    }(datas, start, end, dim) > 0) for (i = start; i < end; i += dim) last = insertNode(i, datas[i], datas[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = insertNode(i, datas[i], datas[i + 1], last);
    return last && equals$1(last, last.next) && (removeNode(last), last = last.next), 
    last;
}

function filterPoints(start) {
    var end = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (!start) return start;
    end || (end = start);
    var p = start, again = !1;
    do {
        if (again = !1, p.steiner || !equals$1(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
            if (removeNode(p), (p = end = p.prev) === p.next) return null;
            again = !0;
        }
    } while (again || p !== end);
    return end;
}

function earcutLinked(ear, triangles, dim, minX, minY, size) {
    var pass = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
    if (ear) {
        !pass && size && function indexCurve(start, minX, minY, size) {
            var p = start;
            do {
                null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size)), p.prevZ = p.prev, p.nextZ = p.next, 
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null, p.prevZ = null, function sortLinked(list) {
                var i = 0, p = null, q = null, e = null, tail = null, numMerges = 0, pSize = 0, qSize = 0, inSize = 1;
                do {
                    for (p = list, list = null, tail = null, numMerges = 0; p; ) {
                        for (numMerges++, q = p, pSize = 0, i = 0; i < inSize && (pSize++, q = q.nextZ); i++) ;
                        for (qSize = inSize; pSize > 0 || qSize > 0 && q; ) 0 === pSize ? (e = q, q = q.nextZ, 
                        qSize--) : 0 !== qSize && q ? p.z <= q.z ? (e = p, p = p.nextZ, pSize--) : (e = q, 
                        q = q.nextZ, qSize--) : (e = p, p = p.nextZ, pSize--), tail ? tail.nextZ = e : list = e, 
                        e.prevZ = tail, tail = e;
                        p = q;
                    }
                    tail.nextZ = null, inSize *= 2;
                } while (numMerges > 1);
                return list;
            }(p);
        }(ear, minX, minY, size);
        for (var stop = ear, prev = null, next = null; ear.prev !== ear.next; ) if (prev = ear.prev, 
        next = ear.next, size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) triangles.push(prev.i / dim), 
        triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, 
        stop = next.next; else if ((ear = next) === stop) {
            pass ? 1 === pass ? earcutLinked(ear = cureLocalIntersections(ear, triangles, dim), triangles, dim, minX, minY, size, 2) : 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
            break;
        }
    }
}

function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return !1;
    for (var p = ear.next.next; p !== ear.prev; ) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
        p = p.next;
    }
    return !0;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return !1;
    for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size), p = ear.nextZ; p && p.z <= maxZ; ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
        p = p.nextZ;
    }
    for (p = ear.prevZ; p && p.z >= minZ; ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
        p = p.prevZ;
    }
    return !0;
}

function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        !equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), 
        triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), 
        p = start = b), p = p.next;
    } while (p !== start);
    return p;
}

function splitEarcut(start, triangles, dim, minX, minY, size) {
    var a = start;
    do {
        for (var b = a.next.next; b !== a.prev; ) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                var c = splitPolygon(a, b);
                return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, size), 
                void earcutLinked(c, triangles, dim, minX, minY, size);
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function compareX(a, b) {
    return a.x - b.x;
}

function eliminateHole(hole, outerNode) {
    if (outerNode = function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -1 / 0, m = null;
        do {
            if (hy <= p.y && hy >= p.next.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    if (qx = x, x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) return null;
        if (hx === qx) return m.prev;
        var tan, stop = m, mx = m.x, my = m.y, tanMin = 1 / 0;
        p = m.next;
        for (;p !== stop; ) hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole) && (m = p, 
        tanMin = tan), p = p.next;
        return m;
    }(hole, outerNode)) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

function zOrder(x, y, minX, minY, size) {
    return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) / size) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) / size) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
}

function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        p.x < leftmost.x && (leftmost = p), p = p.next;
    } while (p !== start);
    return leftmost;
}

function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
            p = p.next;
        } while (p !== a);
        return !1;
    }(a, b) && locallyInside(a, b) && locallyInside(b, a) && function middleInside(a, b) {
        var p = a, inside = !1, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), 
            p = p.next;
        } while (p !== a);
        return inside;
    }(a, b);
}

function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

function equals$1(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

function intersects(p1, q1, p2, q2) {
    return !!(equals$1(p1, q1) && equals$1(p2, q2) || equals$1(p1, q2) && equals$1(p2, q1)) || area(p1, q1, p2) > 0 != area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 != area(p2, q2, q1) > 0;
}

function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

function splitPolygon(a, b) {
    var a2 = new Aim(a.i, a.x, a.y), b2 = new Aim(b.i, b.x, b.y), an = a.next, bp = b.prev;
    return a.next = b, b.prev = a, a2.next = an, an.prev = a2, b2.next = a2, a2.prev = b2, 
    bp.next = b2, b2.prev = bp, b2;
}

function insertNode(i, x, y, last) {
    var p = new Aim(i, x, y);
    return last ? (p.next = last.next, p.prev = last, last.next.prev = p, last.next = p) : (p.prev = p, 
    p.next = p), p;
}

function removeNode(p) {
    p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), 
    p.nextZ && (p.nextZ.prevZ = p.prevZ);
}

function earcut(datas, holeIndices, dim) {
    dim = dim || 3;
    var hasHoles = holeIndices ? holeIndices.length : 0, outerLen = hasHoles ? holeIndices[0] * dim : datas.length, outerNode = linkedList(datas, 0, outerLen, dim, !0), triangles = [];
    if (!outerNode) return triangles;
    var minX = 0, minY = 0, maxX = 0, maxY = 0, x = 0, y = 0, size = 0;
    if (hasHoles && (outerNode = function eliminateHoles(datas, holeIndices, outerNode, dim) {
        var len, queue = [], i = 0, list = null;
        for (i = 0, len = holeIndices.length; i < len; i++) (list = linkedList(datas, holeIndices[i] * dim, i < len - 1 ? holeIndices[i + 1] * dim : datas.length, dim, !1)) && (list === list.next && (list.steiner = !0), 
        queue.push(getLeftmost(list)));
        if (queue.sort(compareX), !outerNode) return outerNode;
        for (i = 0; i < queue.length; i++) eliminateHole(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next);
        return outerNode;
    }(datas, holeIndices, outerNode, dim)), datas.length > 80 * dim) {
        minX = maxX = datas[0], minY = maxY = datas[1];
        for (var i = dim; i < outerLen; i += dim) (x = datas[i]) < minX && (minX = x), (y = datas[i + 1]) < minY && (minY = y), 
        x > maxX && (maxX = x), y > maxY && (maxY = y);
        size = Math.max(maxX - minX, maxY - minY);
    }
    return earcutLinked(outerNode, triangles, dim, minX, minY, size), triangles;
}

var PI = Math.PI, min$2 = Math.min, max$2 = Math.max, cos = Math.cos, sin = Math.sin, abs$1 = Math.abs, sign$1 = Math.sign, KAPPA90 = .5522847493;

function ellipse(ctx, cx, cy, rx, ry) {
    ctx.moveTo(cx - rx, cy), ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry), 
    ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy), 
    ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry), 
    ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy), 
    ctx.close();
}

for (var Point = function(_Vec) {
    function Point(x, y) {
        var _this;
        return _classCallCheck(this, Point), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this, x, y))).dx = 0, 
        _this.dy = 0, _this.dmx = 0, _this.dmy = 0, _this.flags = 0, _this.len = 0, _this.reset(), 
        _this;
    }
    return _inherits(Point, Vec2), _createClass(Point, [ {
        key: "reset",
        value: function reset() {
            this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0;
        }
    } ]), Point;
}(), Path = function() {
    function Path() {
        _classCallCheck(this, Path), this.closed = !1, this.nbevel = 0, this.complex = !0, 
        this.points = [], this.reset();
    }
    return _createClass(Path, [ {
        key: "reset",
        value: function reset() {
            this.closed = !1, this.nbevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = [];
        }
    } ]), Path;
}(), Impl = function() {
    function Impl() {
        _classCallCheck(this, Impl), this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, 
        this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = Color.WHITE.clone(), 
        this.lineCap = LineCap.BUTT, this.strokeColor = Color.BLACK.clone(), this.lineJoin = LineJoin.MITER, 
        this.lineWidth = 0, this.pointsOffset = 0, this._commandx = 0, this._commandy = 0, 
        this._points = [], this._renderDatasPool = new RecyclePool(function() {
            return new IARenderData();
        }, 16), this._renderDatas = [], this._curPath = null;
    }
    return _createClass(Impl, [ {
        key: "moveTo",
        value: function moveTo(x, y) {
            this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), 
            this._addPath(), this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, 
            this._commandy = y;
        }
    }, {
        key: "lineTo",
        value: function lineTo(x, y) {
            this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, this._commandy = y;
        }
    }, {
        key: "bezierCurveTo",
        value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
            var path = this._curPath, last = path.points[path.points.length - 1];
            last && (last.x !== c1x || last.y !== c1y || c2x !== x || c2y !== y ? (!function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
                var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234, dx, dy, d2, d3;
                level > 10 || (x34 = .5 * (x3 + x4), y34 = .5 * (y3 + y4), x123 = .5 * ((x12 = .5 * (x1 + x2)) + (x23 = .5 * (x2 + x3))), 
                y123 = .5 * ((y12 = .5 * (y1 + y2)) + (y23 = .5 * (y2 + y3))), ((d2 = abs$1((x2 - x4) * (dy = y4 - y1) - (y2 - y4) * (dx = x4 - x1))) + (d3 = abs$1((x3 - x4) * dy - (y3 - y4) * dx))) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy) ? ctx.addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type) : (tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234 = .5 * (x123 + (x234 = .5 * (x23 + x34))), y1234 = .5 * (y123 + (y234 = .5 * (y23 + y34))), level + 1, 0), 
                tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type)));
            }(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER), this._commandx = x, 
            this._commandy = y) : this.lineTo(x, y));
        }
    }, {
        key: "quadraticCurveTo",
        value: function quadraticCurveTo(cx, cy, x, y) {
            var x0 = this._commandx, y0 = this._commandy;
            this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
        }
    }, {
        key: "arc",
        value: function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
            !function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
                var hda, ndivs, a = 0, da = 0, kappa = 0, dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0, px = 0, py = 0, ptanx = 0, ptany = 0, i = 0;
                if (da = endAngle - startAngle, counterclockwise = counterclockwise || !1) if (abs$1(da) >= 2 * PI) da = 2 * PI; else for (;da < 0; ) da += 2 * PI; else if (abs$1(da) >= 2 * PI) da = 2 * -PI; else for (;da > 0; ) da -= 2 * PI;
                for (ndivs = 0 | max$2(1, min$2(abs$1(da) / (.5 * PI) + .5, 5)), kappa = abs$1(4 / 3 * (1 - cos(hda = da / ndivs / 2)) / sin(hda)), 
                counterclockwise || (kappa = -kappa), i = 0; i <= ndivs; i++) x = cx + (dx = cos(a = startAngle + da * (i / ndivs))) * r, 
                y = cy + (dy = sin(a)) * r, tanx = -dy * r * kappa, tany = dx * r * kappa, 0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y), 
                px = x, py = y, ptanx = tanx, ptany = tany;
            }(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        }
    }, {
        key: "ellipse",
        value: function ellipse$1(cx, cy, rx, ry) {
            ellipse(this, cx, cy, rx, ry), this._curPath.complex = !1;
        }
    }, {
        key: "circle",
        value: function circle(cx, cy, r) {
            ellipse(this, cx, cy, r, r), this._curPath.complex = !1;
        }
    }, {
        key: "rect",
        value: function rect(x, y, w, h) {
            this.moveTo(x, y), this.lineTo(x + w, y), this.lineTo(x + w, y + h), this.lineTo(x, y + h), 
            this.close(), this._curPath.complex = !1;
        }
    }, {
        key: "roundRect",
        value: function roundRect$1(x, y, w, h, r) {
            !function roundRect(ctx, x, y, w, h, r) {
                if (r < .1) ctx.rect(x, y, w, h); else {
                    var rx = min$2(r, .5 * abs$1(w)) * sign$1(w), ry = min$2(r, .5 * abs$1(h)) * sign$1(h);
                    ctx.moveTo(x, y + ry), ctx.lineTo(x, y + h - ry), ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h), 
                    ctx.lineTo(x + w - rx, y + h), ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry), 
                    ctx.lineTo(x + w, y + ry), ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y), 
                    ctx.lineTo(x + rx, y), ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry), 
                    ctx.close();
                }
            }(this, x, y, w, h, r), this._curPath.complex = !1;
        }
    }, {
        key: "clear",
        value: function clear() {
            var clean = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, 
            this._curPath = null, this.paths.length = 0, this._points.length = 0;
            for (var datas = this._renderDatas, i = 0, l = datas.length; i < l; i++) {
                var data = datas[i];
                data && data.reset();
            }
            this._renderDatas.length = 0, clean && this._renderDatasPool.reset();
        }
    }, {
        key: "close",
        value: function close() {
            this._curPath.closed = !0;
        }
    }, {
        key: "requestRenderData",
        value: function requestRenderData() {
            var renderData = this._renderDatasPool.add();
            return this._renderDatas.push(renderData), renderData;
        }
    }, {
        key: "getRenderDatas",
        value: function getRenderDatas() {
            return 0 === this._renderDatas.length && this.requestRenderData(), this._renderDatas;
        }
    }, {
        key: "addPoint",
        value: function addPoint(x, y, flags) {
            var path = this._curPath;
            if (path) {
                var points = this._points, pathPoints = path.points, pt = points[this.pointsOffset++];
                pt ? (pt.x = x, pt.y = y) : (pt = new Point(x, y), points.push(pt)), pt.flags = flags, 
                pathPoints.push(pt);
            }
        }
    }, {
        key: "_addPath",
        value: function _addPath() {
            var offset = this.pathLength, path = this.paths[offset];
            return path ? path.reset() : (path = new Path(), this.paths.push(path)), this.pathLength++, 
            this._curPath = path, path;
        }
    } ]), Impl;
}(), PI$1 = Math.PI, min$3 = Math.min, max$3 = Math.max, ceil = Math.ceil, acos = Math.acos, cos$1 = Math.cos, sin$1 = Math.sin, atan2 = Math.atan2, attrs = vfmt, positions = [], uvs = [], colors$1 = [], indices = [], _renderData = null, _impl = null, _curColor = new Color(), vec3_temps = [], i$2 = 0; i$2 < 4; i$2++) vec3_temps.push(new Vec3());

function clamp$1(v, minNum, maxNum) {
    return v < minNum ? minNum : v > maxNum ? maxNum : v;
}

var graphicsAssembler = {
    useModel: !0,
    createImpl: function createImpl(graphics) {
        return new Impl();
    },
    updateRenderData: function updateRenderData(graphics) {
        for (var datas = graphics.impl ? graphics.impl.getRenderDatas() : [], _i = 0, l = datas.length; _i < l; _i++) datas[_i].material = graphics.material;
    },
    fillBuffers: function fillBuffers(graphics, renderer) {},
    renderIA: function renderIA(graphics, renderer) {},
    getRenderData: function getRenderData(graphics, cverts) {
        if (!_impl) return null;
        var renderDatas = _impl.getRenderDatas(), renderData = renderDatas[_impl.dataOffset];
        if (!renderData) return null;
        var meshbuffer = renderData, maxVertsCount = meshbuffer ? meshbuffer.vertexCount + cverts : 0;
        return (maxVertsCount > 65535 || 3 * maxVertsCount > 131070) && (++_impl.dataOffset, 
        _impl.dataOffset < renderDatas.length ? renderData = renderDatas[_impl.dataOffset] : (renderData = _impl.requestRenderData(), 
        renderDatas[_impl.dataOffset] = renderData), renderData.material = graphics.material, 
        meshbuffer = renderData), meshbuffer && meshbuffer.vertexCount < maxVertsCount && meshbuffer.request(cverts, 3 * cverts), 
        renderData;
    },
    stroke: function stroke(graphics) {
        Color.copy(_curColor, graphics.strokeColor), graphics.impl && (this._flattenPaths(graphics.impl), 
        this._expandStroke(graphics), graphics.impl.updatePathOffset = !0, this.end(graphics));
    },
    fill: function fill(graphics) {
        Color.copy(_curColor, graphics.fillColor), this._expandFill(graphics), graphics.impl && (graphics.impl.updatePathOffset = !0), 
        this.end(graphics);
    },
    end: function end(graphics) {
        var scene = cc.director.root.ui.renderScene;
        graphics.model && (graphics.model.destroy(), scene.destroyModel(graphics.model), 
        graphics.model = null);
        var impl = graphics.impl, primitiveMode = GFXPrimitiveMode.TRIANGLE_LIST, renderDatas = impl && impl.getRenderDatas();
        if (renderDatas) {
            var i = 0;
            positions.length = 0, uvs.length = 0, colors$1.length = 0, indices.length = 0;
            var _iterator = renderDatas, _isArray = Array.isArray(_iterator), _i2 = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i2 >= _iterator.length) break;
                    _ref = _iterator[_i2++];
                } else {
                    if ((_i2 = _iterator.next()).done) break;
                    _ref = _i2.value;
                }
                var renderData = _ref, len = renderData.byteCount >> 2, vData = renderData.vData;
                for (i = 0; i < len; ) positions.push(vData[i++]), positions.push(vData[i++]), positions.push(vData[i++]), 
                uvs.push(vData[i++]), uvs.push(vData[i++]), colors$1.push(vData[i++]), colors$1.push(vData[i++]), 
                colors$1.push(vData[i++]), colors$1.push(vData[i++]);
                len = renderData.indiceCount;
                var iData = renderData.iData;
                for (i = 0; i < len; ) indices.push(iData[i++]);
            }
            var mesh = createMesh({
                primitiveMode: primitiveMode,
                positions: positions,
                uvs: uvs,
                colors: colors$1,
                attributes: attrs,
                indices: indices
            }, void 0, {
                calculateBounds: !1
            });
            graphics.model = scene.createModel(Model, graphics.node), graphics.model.initSubModel(0, mesh.getSubMesh(0), graphics.material), 
            graphics.model.enabled = !0;
        }
    },
    _expandStroke: function _expandStroke(graphics) {
        var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
        if (_impl = graphics.impl) {
            var ncap = function curveDivs(r, arc, tol) {
                var da = 2 * acos(r / (r + tol));
                return max$3(2, ceil(arc / da));
            }(w, PI$1, _impl.tessTol);
            this._calculateJoins(_impl, w, lineJoin, miterLimit);
            for (var paths = _impl.paths, cverts = 0, _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
                var path = paths[_i3], pointsLength = path.points.length;
                lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1), 
                path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
            }
            var meshbuffer = _renderData = this.getRenderData(graphics, cverts);
            if (meshbuffer) {
                for (var vData = meshbuffer.vData, iData = meshbuffer.iData, _i4 = _impl.pathOffset, _l = _impl.pathLength; _i4 < _l; _i4++) {
                    var _path = paths[_i4], pts = _path.points, _pointsLength = pts.length, offset = meshbuffer.vertexStart, p0 = void 0, p1 = void 0, start = 0, end = 0, loop = _path.closed;
                    if (loop ? (p0 = pts[_pointsLength - 1], p1 = pts[0], start = 0, end = _pointsLength) : (p0 = pts[0], 
                    p1 = pts[1], start = 1, end = _pointsLength - 1), !loop) {
                        var dPos = new Point(p1.x, p1.y);
                        dPos.subtract(p0), dPos.normalize();
                        var dx = dPos.x, dy = dPos.y;
                        lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
                    }
                    for (var j = start; j < end; ++j) lineJoin === LineJoin.ROUND ? this._roundJoin(p0, p1, w, w, ncap) : 0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) ? this._bevelJoin(p0, p1, w, w) : (this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w), 
                    this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w)), p0 = p1, p1 = pts[j + 1];
                    if (loop) {
                        var vDataoOfset = 9 * offset, data = vData.slice(vDataoOfset, vDataoOfset + 9);
                        vData.set(data, 9 * meshbuffer.vertexStart), vDataoOfset += 9, meshbuffer.vertexStart++, 
                        data = vData.slice(vDataoOfset, vDataoOfset + 9), vData.set(data, 9 * meshbuffer.vertexStart), 
                        meshbuffer.vertexStart++;
                    } else {
                        var _dPos = new Point(p1.x, p1.y);
                        _dPos.subtract(p0), _dPos.normalize();
                        var _dx = _dPos.x, _dy = _dPos.y;
                        lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
                    }
                    for (var indicesOffset = meshbuffer.indiceStart, begin = offset + 2, over = meshbuffer.vertexStart; begin < over; begin++) iData[indicesOffset++] = begin - 2, 
                    iData[indicesOffset++] = begin - 1, iData[indicesOffset++] = begin;
                    if (meshbuffer.indiceStart = indicesOffset, indicesOffset !== meshbuffer.indiceCount) {
                        var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                        meshbuffer.iData.set(arr, indicesOffset);
                    }
                }
                _renderData = null, _impl = null;
            }
        }
    },
    _expandFill: function _expandFill(graphics) {
        if (_impl = graphics.impl) {
            for (var paths = _impl.paths, cverts = 0, _i5 = _impl.pathOffset, l = _impl.pathLength; _i5 < l; _i5++) {
                cverts += paths[_i5].points.length;
            }
            var renderData = _renderData = this.getRenderData(graphics, cverts);
            if (renderData) {
                for (var meshbuffer = renderData, vData = meshbuffer.vData, iData = meshbuffer.iData, _i6 = _impl.pathOffset, _l2 = _impl.pathLength; _i6 < _l2; _i6++) {
                    var _path2 = paths[_i6], pts = _path2.points, _pointsLength2 = pts.length;
                    if (0 !== _pointsLength2) {
                        for (var vertexOffset = renderData.vertexStart, j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
                        var indicesOffset = renderData.indiceStart;
                        if (_path2.complex) {
                            for (var earcutData = [], _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                                var vDataOffset = 9 * _j;
                                earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]);
                            }
                            var newIndices = earcut(earcutData, null, 3);
                            if (!newIndices || 0 === newIndices.length) continue;
                            for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                        } else for (var first = vertexOffset, start = vertexOffset + 2, _end = meshbuffer.vertexStart; start < _end; start++) iData[indicesOffset++] = first, 
                        iData[indicesOffset++] = start - 1, iData[indicesOffset++] = start;
                        if (meshbuffer.indiceStart = indicesOffset, indicesOffset !== meshbuffer.indiceCount) {
                            var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                            meshbuffer.iData.set(arr, indicesOffset);
                        }
                    }
                }
                _renderData = null, _impl = null;
            }
        }
    },
    _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
        var iw = 0;
        w > 0 && (iw = 1 / w);
        for (var paths = impl.paths, _i7 = impl.pathOffset, l = impl.pathLength; _i7 < l; _i7++) {
            var path = paths[_i7], pts = path.points, ptsLength = pts.length, p0 = pts[ptsLength - 1], p1 = pts[0];
            path.nbevel = 0;
            for (var j = 0; j < ptsLength; j++) {
                var dmr2, limit, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
                if (p1.dmx = .5 * (dlx0 + dlx1), p1.dmy = .5 * (dly0 + dly1), (dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy) > 1e-6) {
                    var scale = 1 / dmr2;
                    scale > 600 && (scale = 600), p1.dmx *= scale, p1.dmy *= scale;
                }
                p1.dx * p0.dy - p0.dx * p1.dy > 0 && (p1.flags |= PointFlags.PT_LEFT), dmr2 * (limit = max$3(11, min$3(p0.len, p1.len) * iw)) * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL), 
                p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL), 
                0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++, 
                p0 = p1, p1 = pts[j + 1];
            }
        }
    },
    _flattenPaths: function _flattenPaths(impl) {
        for (var paths = impl.paths, _i8 = impl.pathOffset, l = impl.pathLength; _i8 < l; _i8++) {
            var path = paths[_i8], pts = path.points, p0 = pts[pts.length - 1], p1 = pts[0];
            p0.equals(p1) && (path.closed = !0, pts.pop(), p0 = pts[pts.length - 1]);
            for (var j = 0, size = pts.length; j < size; j++) {
                var dPos = new Point(p1.x, p1.y);
                dPos.subtract(p0), p0.len = dPos.length(), (dPos.x || dPos.y) && dPos.normalize(), 
                p0.dx = dPos.x, p0.dy = dPos.y, p0 = p1, p1 = pts[j + 1];
            }
        }
    },
    _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
        var x = p1.x, y = p1.y, x0 = 0, y0 = 0, x1 = 0, y1 = 0;
        return 0 !== bevel ? (x0 = x + p0.dy * w, y0 = y - p0.dx * w, x1 = x + p1.dy * w, 
        y1 = y - p1.dx * w) : (x0 = x1 = x + p1.dmx * w, y0 = y1 = y + p1.dmy * w), [ x0, y0, x1, y1 ];
    },
    _buttCap: function _buttCap(p, dx, dy, w, d) {
        var px = p.x - dx * d, py = p.y - dy * d, dlx = dy, dly = -dx;
        this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
    },
    _roundCapStart: function _roundCapStart(p, dx, dy, w, ncap) {
        for (var px = p.x, py = p.y, dlx = dy, dly = -dx, _i9 = 0; _i9 < ncap; _i9++) {
            var a = _i9 / (ncap - 1) * PI$1, ax = cos$1(a) * w, ay = sin$1(a) * w;
            this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay), this._vset(px, py);
        }
        this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
    },
    _roundCapEnd: function _roundCapEnd(p, dx, dy, w, ncap) {
        var px = p.x, py = p.y, dlx = dy, dly = -dx;
        this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
        for (var _i10 = 0; _i10 < ncap; _i10++) {
            var a = _i10 / (ncap - 1) * PI$1, ax = cos$1(a) * w, ay = sin$1(a) * w;
            this._vset(px, py), this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
        }
    },
    _roundJoin: function _roundJoin(p0, p1, lw, rw, ncap) {
        var dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx, p1x = p1.x, p1y = p1.y;
        if (0 != (p1.flags & PointFlags.PT_LEFT)) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw), lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], a0 = atan2(-dly0, -dlx0), a1 = atan2(-dly1, -dlx1);
            a1 > a0 && (a1 -= 2 * PI$1), this._vset(lx0, ly0), this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
            for (var n = clamp$1(ceil((a0 - a1) / PI$1) * ncap, 2, ncap), _i11 = 0; _i11 < n; _i11++) {
                var a = a0 + _i11 / (n - 1) * (a1 - a0), rx = p1x + cos$1(a) * rw, ry = p1y + sin$1(a) * rw;
                this._vset(p1x, p1y), this._vset(rx, ry);
            }
            this._vset(lx1, ly1), this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
        } else {
            var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw), rx0 = _out[0], ry0 = _out[1], rx1 = _out[2], ry1 = _out[3], _a = atan2(dly0, dlx0), _a2 = atan2(dly1, dlx1);
            _a2 < _a && (_a2 += 2 * PI$1), this._vset(p1x + dlx0 * rw, p1y + dly0 * rw, 0), 
            this._vset(rx0, ry0, 0);
            for (var _n = clamp$1(ceil((_a2 - _a) / PI$1) * ncap, 2, ncap), _i12 = 0; _i12 < _n; _i12++) {
                var _a3 = _a + _i12 / (_n - 1) * (_a2 - _a), lx = p1x + cos$1(_a3) * lw, ly = p1y + sin$1(_a3) * lw;
                this._vset(lx, ly, 0), this._vset(p1x, p1y, 0);
            }
            this._vset(p1x + dlx1 * rw, p1y + dly1 * rw), this._vset(rx1, ry1);
        }
    },
    _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
        var rx0 = 0, ry0 = 0, rx1 = 0, ry1 = 0, lx0 = 0, ly0 = 0, lx1 = 0, ly1 = 0, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
        if (p1.flags & PointFlags.PT_LEFT) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
            lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], this._vset(lx0, ly0, 0), 
            this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw, 0), this._vset(lx1, ly1, 0), this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw, 0);
        } else {
            var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
            rx0 = _out2[0], ry0 = _out2[1], rx1 = _out2[2], ry1 = _out2[3], this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw, 0), 
            this._vset(rx0, ry0), this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw, 0), this._vset(rx1, ry1);
        }
    },
    _vset: function _vset(x, y) {
        if (_renderData) {
            var meshbuffer = _renderData, dataOffset = 9 * meshbuffer.vertexStart, vData = meshbuffer.vData;
            vData[dataOffset++] = x, vData[dataOffset++] = y, vData[dataOffset++] = 0, vData[dataOffset++] = 1, 
            vData[dataOffset++] = 1, Color.array(vData, _curColor, dataOffset), meshbuffer.vertexStart++;
        }
    }
}, graphicsAssemblerManager = {
    getAssembler: function getAssembler(sprite) {
        return graphicsAssembler;
    }
};

GraphicsComponent.Assembler = graphicsAssemblerManager;

var FontLetterDefinition = function FontLetterDefinition() {
    _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.width = 0, 
    this.height = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.validDefinition = !1, 
    this.xAdvance = 0;
}, FontAtlas = function() {
    function FontAtlas(fntConfig) {
        _classCallCheck(this, FontAtlas), this._letterDefinitions = {};
    }
    return _createClass(FontAtlas, [ {
        key: "letterDefinitions",
        get: function get() {
            return this._letterDefinitions;
        }
    } ]), _createClass(FontAtlas, [ {
        key: "addLetterDefinitions",
        value: function addLetterDefinitions(letter, letterDefinition) {
            this._letterDefinitions[letter] = letterDefinition;
        }
    }, {
        key: "cloneLetterDefinition",
        value: function cloneLetterDefinition() {
            for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                var _key = _Object$keys[_i], value = new FontLetterDefinition();
                cc.js.mixin(value, this._letterDefinitions[_key]), copyLetterDefinitions[_key] = value;
            }
            return copyLetterDefinitions;
        }
    }, {
        key: "assignLetterDefinitions",
        value: function assignLetterDefinitions(letterDefinition) {
            for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                var _key2 = _Object$keys2[_i2], newValue = letterDefinition[_key2], oldValue = this._letterDefinitions[_key2];
                cc.js.mixin(oldValue, newValue);
            }
        }
    }, {
        key: "scaleFontLetterDefinition",
        value: function scaleFontLetterDefinition(scaleFactor) {
            for (var _i3 = 0, _Object$keys3 = Object.keys(this._letterDefinitions); _i3 < _Object$keys3.length; _i3++) {
                var fontDefinition = _Object$keys3[_i3], letterDefinitions = this._letterDefinitions[fontDefinition];
                letterDefinitions.width *= scaleFactor, letterDefinitions.height *= scaleFactor, 
                letterDefinitions.offsetX *= scaleFactor, letterDefinitions.offsetY *= scaleFactor, 
                letterDefinitions.xAdvance *= scaleFactor;
            }
        }
    }, {
        key: "getLetterDefinitionForChar",
        value: function getLetterDefinitionForChar(_char) {
            return this._letterDefinitions.hasOwnProperty(_char.charCodeAt(0)) ? this._letterDefinitions[_char.charCodeAt(0)] : null;
        }
    } ]), FontAtlas;
}();

cc.FontAtlas = FontAtlas;

var LetterInfo = function LetterInfo() {
    _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.positionX = 0, 
    this.positionY = 0, this.lineIndex = 0;
}, _tmpRect = new Rect(), _comp = null, _horizontalKernings = [], _lettersInfo = [], _linesWidth = [], _linesOffsetX = [], _labelDimensions = new Size(), _fontAtlas = null, _fntConfig = null, _numberOfLines = 0, _textDesiredHeight = 0, _letterOffsetY = 0, _tailoredTopY = 0, _tailoredBottomY = 0, _bmfontScale = 1, _spriteFrame = null, _string = "", _fontSize = 0, _originFontSize = 0, _contentSize = new Size(), _hAlign = 0, _vAlign = 0, _spacingX = 0, _lineHeight = 0, _overflow = 0, _isWrapText = !1, _labelWidth = 0, _labelHeight = 0, _maxLineWidth = 0, bmfont = {
    createData: function createData(comp) {
        return comp.requestRenderData();
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        fillMeshVertices3D(comp.node, renderer, comp.renderData, comp.color);
    },
    appendQuad: function appendQuad(comp, spriteframe, rect, rotated, x, y, scale) {
        var renderData = comp.renderData;
        if (renderData) {
            var dataOffset = renderData.dataLength;
            renderData.dataLength += 4, renderData.vertexCount = renderData.dataLength, renderData.indiceCount = renderData.dataLength / 2 * 3;
            var datas = renderData.datas, texw = spriteframe.width, texh = spriteframe.height, rectWidth = rect.width, rectHeight = rect.height, l = 0, b = 0, t = 0, r = 0;
            rotated ? (l = rect.x / texw, r = (rect.x + rectHeight) / texw, b = (rect.y + rectWidth) / texh, 
            t = rect.y / texh, datas[dataOffset].u = l, datas[dataOffset].v = t, datas[dataOffset + 1].u = l, 
            datas[dataOffset + 1].v = b, datas[dataOffset + 2].u = r, datas[dataOffset + 2].v = t, 
            datas[dataOffset + 3].u = r, datas[dataOffset + 3].v = b) : (l = rect.x / texw, 
            r = (rect.x + rectWidth) / texw, b = (rect.y + rectHeight) / texh, t = rect.y / texh, 
            datas[dataOffset].u = l, datas[dataOffset].v = b, datas[dataOffset + 1].u = r, datas[dataOffset + 1].v = b, 
            datas[dataOffset + 2].u = l, datas[dataOffset + 2].v = t, datas[dataOffset + 3].u = r, 
            datas[dataOffset + 3].v = t), datas[dataOffset].x = x, datas[dataOffset].y = y - rectHeight * scale, 
            datas[dataOffset + 1].x = x + rectWidth * scale, datas[dataOffset + 1].y = y - rectHeight * scale, 
            datas[dataOffset + 2].x = x, datas[dataOffset + 2].y = y, datas[dataOffset + 3].x = x + rectWidth * scale, 
            datas[dataOffset + 3].y = y;
        }
    }
};

addon(bmfont, {
    updateRenderData: function updateRenderData(comp) {
        comp.renderData && comp.renderData.vertDirty && _comp !== comp && (_comp = comp, 
        this._updateProperties(), this._updateContent(), _comp.actualFontSize = _fontSize, 
        _comp.node.setContentSize(_contentSize), _comp.renderData.vertDirty = _comp.renderData.uvDirty = !1, 
        _comp = null, this._resetProperties());
    },
    _updateFontScale: function _updateFontScale() {
        _bmfontScale = _fontSize / _originFontSize;
    },
    _updateProperties: function _updateProperties() {
        if (_comp) {
            var fontAsset = _comp.font;
            if (fontAsset) {
                if (_spriteFrame = fontAsset.spriteFrame, _fntConfig = fontAsset.fntConfig, !(_fontAtlas = _comp.fontAtlas)) {
                    _fontAtlas = new FontAtlas(_fntConfig);
                    for (var fontDict = _fntConfig.fontDefDictionary, _i4 = 0, _Object$keys4 = Object.keys(fontDict); _i4 < _Object$keys4.length; _i4++) {
                        var fontDef = _Object$keys4[_i4], letterDefinition = new FontLetterDefinition(), rect = fontDict[fontDef].rect;
                        letterDefinition.offsetX = fontDict[fontDef].xOffset, letterDefinition.offsetY = fontDict[fontDef].yOffset, 
                        letterDefinition.width = rect.width, letterDefinition.height = rect.height, letterDefinition.u = rect.x, 
                        letterDefinition.v = rect.y, letterDefinition.textureID = 0, letterDefinition.validDefinition = !0, 
                        letterDefinition.xAdvance = fontDict[fontDef].xAdvance, _fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                    }
                    _comp.fontAtlas = _fontAtlas;
                }
                _string = _comp.string.toString(), _fontSize = _comp.fontSize, _originFontSize = _fntConfig.fontSize;
                var contentSize = _comp.node.getContentSize();
                _contentSize.width = contentSize.width, _contentSize.height = contentSize.height, 
                _hAlign = _comp.horizontalAlign, _vAlign = _comp.verticalAlign, _spacingX = _comp.spacingX, 
                _overflow = _comp.overflow, _lineHeight = _comp.lineHeight, _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || _comp.enableWrapText), 
                this._setupBMFontOverflowMetrics();
            }
        }
    },
    _resetProperties: function _resetProperties() {
        _fontAtlas = null, _fntConfig = null, _spriteFrame = null;
    },
    _updateContent: function _updateContent() {
        this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText();
    },
    _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
        for (var string = _string, stringLen = string.length, kerningDict = _fntConfig.kerningDict, horizontalKernings = _horizontalKernings, prev = -1, i = 0; i < stringLen; ++i) {
            var _key3 = string.charCodeAt(i), kerningAmount = kerningDict[prev << 16 | 65535 & _key3] || 0;
            horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0, prev = _key3;
        }
    },
    _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2();
        this._updateFontScale();
        for (var letterDefinitions = _fontAtlas.letterDefinitions, index = 0; index < textLen; ) {
            var character = _string.charAt(index);
            if ("\n" !== character) {
                for (var tokenLen = nextTokenFunc(_string, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                    var letterIndex = index + tmp;
                    if ("\r" !== (character = _string.charAt(letterIndex))) if (letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)) {
                        var letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
                        if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                            _linesWidth.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, nextTokenY -= _lineHeight * _bmfontScale + 0, 
                            newLine = !0;
                            break;
                        }
                        letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale, 
                        this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex), 
                        letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]), 
                        nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, tokenRight = letterPosition.x + letterDef.width * _bmfontScale, 
                        tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.height * _bmfontScale);
                    } else this._recordPlaceholderInfo(letterIndex, character), console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character); else this._recordPlaceholderInfo(letterIndex, character);
                }
                newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                lowestY > tokenLowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                index += tokenLen);
            } else _linesWidth.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, 
            nextTokenY -= _lineHeight * _bmfontScale + 0, this._recordPlaceholderInfo(index, character), 
            index++;
        }
        return _linesWidth.push(letterRight), _textDesiredHeight = (_numberOfLines = lineIndex + 1) * _lineHeight * _bmfontScale, 
        _numberOfLines > 1 && (_textDesiredHeight += 0 * (_numberOfLines - 1)), _contentSize.width = _labelWidth, 
        _contentSize.height = _labelHeight, _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2))), 
        _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2))), 
        _tailoredTopY = _contentSize.height, _tailoredBottomY = 0, highestY > 0 && (_tailoredTopY = _contentSize.height + highestY), 
        lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY), 
        !0;
    },
    _getFirstCharLen: function _getFirstCharLen() {
        return 1;
    },
    _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
        var len = 1, letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character);
        if (!letterDef) return len;
        for (var nextLetterX = letterDef._xAdvance * _bmfontScale + _spacingX, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
        letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)); ++index) {
            if (nextLetterX + letterDef._offsetX * _bmfontScale + letterDef._width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) return len;
            if (nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
            len++;
        }
        return len;
    },
    _multilineTextWrapByWord: function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
    },
    _multilineTextWrapByChar: function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
    },
    _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char2) {
        if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo();
            _lettersInfo.push(tmpInfo);
        }
        _lettersInfo[letterIndex].char = _char2, _lettersInfo[letterIndex].valid = !1;
    },
    _recordLetterInfo: function _recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo();
            _lettersInfo.push(tmpInfo);
        }
        var cIndex = character.charCodeAt(0);
        _lettersInfo[letterIndex].lineIndex = lineIndex, _lettersInfo[letterIndex].char = character, 
        _lettersInfo[letterIndex].valid = letterDefinitions[cIndex].validDefinition, _lettersInfo[letterIndex].positionX = letterPosition.x, 
        _lettersInfo[letterIndex].positionY = letterPosition.y;
    },
    _alignText: function _alignText() {
        _textDesiredHeight = 0, _linesWidth.length = 0, this._multilineTextWrapByWord(), 
        this._computeAlignmentOffset(), _overflow === Overflow.SHRINK && _fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), 
        this._updateQuads() || _overflow === Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
    },
    _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = !0;
        fontSize || (fontSize = .1, shouldUpdateContent = !1), _fontSize = fontSize, shouldUpdateContent && this._updateContent();
    },
    _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
        for (var fontSize = _fontSize, originalLineHeight = _lineHeight, fontAtlas = _fontAtlas, i = 0, tempLetterDefinition = fontAtlas ? fontAtlas.cloneLetterDefinition() : {}, flag = !0; lambda(); ) {
            var newFontSize = fontSize - ++i;
            if (flag = !1, newFontSize <= 0) break;
            var scale = newFontSize / fontSize;
            fontAtlas && (fontAtlas.assignLetterDefinitions(tempLetterDefinition), fontAtlas.scaleFontLetterDefinition(scale)), 
            _lineHeight = originalLineHeight * scale, this._multilineTextWrapByWord(), this._computeAlignmentOffset();
        }
        _lineHeight = originalLineHeight, fontAtlas && fontAtlas.assignLetterDefinitions(tempLetterDefinition), 
        flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
    },
    _isVerticalClamp: function _isVerticalClamp() {
        return _textDesiredHeight > _contentSize.height;
    },
    _isHorizontalClamp: function _isHorizontalClamp() {
        if (_fontAtlas) {
            for (var letterDefinitions = _fontAtlas.letterDefinitions, letterClamp = !1, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo[ctr];
                if (letterInfo.valid) {
                    var letterDef = letterDefinitions[letterInfo.char], px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale, lineIndex = letterInfo.lineIndex;
                    if (_labelWidth > 0) if (_isWrapText) {
                        if (_linesWidth[lineIndex] > _contentSize.width && (px > _contentSize.width || px < 0)) {
                            letterClamp = !0;
                            break;
                        }
                    } else if (px > _contentSize.width) {
                        letterClamp = !0;
                        break;
                    }
                }
            }
            return letterClamp;
        }
    },
    _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth[lineIndex], letterOverClamp = px > _contentSize.width || px < 0;
        return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
    },
    _updateQuads: function _updateQuads() {
        if (!_comp) return !1;
        var letterDefinitions = _fontAtlas ? _fontAtlas.letterDefinitions : {}, texture = _spriteFrame, node = _comp.node, renderData = _comp.renderData;
        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
        for (var anchorPoint = node.getAnchorPoint(), contentSize = _contentSize, appx = anchorPoint.x * contentSize.width, appy = anchorPoint.y * contentSize.height, ret = !0, ctr = 0, l = _string.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo[ctr];
            if (letterInfo.valid) {
                var letterDef = letterDefinitions[letterInfo.char.charCodeAt(0)];
                if (letterDef) {
                    _tmpRect.height = letterDef.height, _tmpRect.width = letterDef.width, _tmpRect.x = letterDef.u, 
                    _tmpRect.y = letterDef.v;
                    var py = letterInfo.positionY + _letterOffsetY;
                    if (_labelHeight > 0) {
                        if (py > _tailoredTopY) {
                            var clipTop = py - _tailoredTopY;
                            _tmpRect.y += clipTop, _tmpRect.height -= clipTop, py -= clipTop;
                        }
                        py - letterDef.height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
                    }
                    var lineIndex = letterInfo.lineIndex, px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
                    if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === Overflow.SHRINK) {
                        if (_contentSize.width > letterDef.width) {
                            ret = !1;
                            break;
                        }
                        _tmpRect.width = 0;
                    }
                    if (_spriteFrame && _tmpRect.height > 0 && _tmpRect.width > 0) {
                        var isRotated = _spriteFrame.isRotated(), originalSize = _spriteFrame.getOriginalSize(), rect = _spriteFrame.getRect(), offset = _spriteFrame.getOffset(), trimmedLeft = offset.x + (originalSize.width - rect.width) / 2, trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                        if (isRotated) {
                            var originalX = _tmpRect.x;
                            _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop, _tmpRect.y = originalX + rect.y - trimmedLeft, 
                            _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
                        } else _tmpRect.x += rect.x - trimmedLeft, _tmpRect.y += rect.y + trimmedTop;
                        var letterPositionX = letterInfo.positionX + _linesOffsetX[letterInfo.lineIndex];
                        this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appx, py - appy, _bmfontScale);
                    }
                } else console.warn("Can't find letter in this bitmap-font");
            }
        }
        return ret;
    },
    appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
    _computeAlignmentOffset: function _computeAlignmentOffset() {
        switch (_linesOffsetX.length = 0, _hAlign) {
          case HorizontalTextAlignment.LEFT:
            for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
            break;

          case HorizontalTextAlignment.CENTER:
            for (var _i5 = 0, l = _linesWidth.length; _i5 < l; _i5++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i5]) / 2);
            break;

          case HorizontalTextAlignment.RIGHT:
            for (var _i6 = 0, _l = _linesWidth.length; _i6 < _l; _i6++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i6]);
        }
        switch (_vAlign) {
          case VerticalTextAlignment.TOP:
            _letterOffsetY = _contentSize.height;
            break;

          case VerticalTextAlignment.CENTER:
            _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
            break;

          case VerticalTextAlignment.BOTTOM:
            _letterOffsetY = _textDesiredHeight;
        }
    },
    _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize.width, newHeight = _contentSize.height;
        _overflow === Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow === Overflow.NONE && (newWidth = 0, 
        newHeight = 0), _labelWidth = newWidth, _labelHeight = newHeight, _labelDimensions.width = newWidth, 
        _labelDimensions.height = newHeight, _maxLineWidth = newWidth;
    }
});

var Overflow$1 = LabelComponent.Overflow, WHITE = Color.WHITE.clone(), space = 2, TextAlignment = LabelComponent.HorizontalAlign, VerticalTextAlignment$1 = LabelComponent.VerticalAlign, LetterInfo$1 = function LetterInfo() {
    _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.x = 0, 
    this.y = 0, this.line = 0, this.hash = "";
}, FontLetterDefinition$1 = function FontLetterDefinition() {
    _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.w = 0, 
    this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, 
    this.xAdvance = 0;
}, LetterTexture = function() {
    function LetterTexture(_char, labelInfo) {
        _classCallCheck(this, LetterTexture), this.spriteframe = null, this.labelInfo = void 0, 
        this.char = void 0, this.data = null, this.canvas = null, this.context = null, this.width = 0, 
        this.height = 0, this.hash = void 0, this.char = _char, this.labelInfo = labelInfo, 
        this.hash = _char.charCodeAt(0) + labelInfo.hash;
    }
    return _createClass(LetterTexture, [ {
        key: "updateRenderData",
        value: function updateRenderData() {
            this._updateProperties(), this._updateTexture();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.spriteframe.destroy(), this.spriteframe = null;
        }
    }, {
        key: "_updateProperties",
        value: function _updateProperties() {
            if (this.spriteframe = new SpriteFrame(), this.data = LabelComponent.CanvasPool.get(), 
            this.canvas = this.data.canvas, this.context = this.data.context, this.context) {
                this.context.font = this.labelInfo.fontDesc;
                var width = safeMeasureText(this.context, this.char);
                this.width = parseFloat(width.toFixed(2)), this.height = this.labelInfo.fontSize;
            }
            this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height);
            var image = new ImageAsset(this.canvas);
            this.spriteframe.texture.image = image;
        }
    }, {
        key: "_updateTexture",
        value: function _updateTexture() {
            if (this.context && this.canvas) {
                var context = this.context, labelInfo = this.labelInfo, width = this.canvas.width, height = this.canvas.height;
                context.textAlign = "center", context.textBaseline = "middle", context.clearRect(0, 0, width, height), 
                context.fillStyle = "rgba(255, 255, 255, 0.005)", context.fillRect(0, 0, width, height), 
                context.font = labelInfo.fontDesc;
                var startX = width / 2, startY = height / 2, color = labelInfo.color;
                if (context.lineJoin = "round", context.fillStyle = "rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ", 1, ")"), 
                labelInfo.isOutlined) {
                    var strokeColor = labelInfo.out || WHITE;
                    context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                    context.lineWidth = 2 * labelInfo.margin, context.strokeText(this.char, startX, startY);
                }
                context.fillText(this.char, startX, startY), this.spriteframe.texture.updateImage();
            }
        }
    } ]), LetterTexture;
}(), LetterRenderTexture = function(_Texture2D) {
    function LetterRenderTexture() {
        return _classCallCheck(this, LetterRenderTexture), _possibleConstructorReturn(this, _getPrototypeOf(LetterRenderTexture).apply(this, arguments));
    }
    return _inherits(LetterRenderTexture, Texture2D), _createClass(LetterRenderTexture, [ {
        key: "initWithSize",
        value: function initWithSize(width, height) {
            var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888;
            this.destroy(), this.reset({
                width: width,
                height: height,
                format: format
            }), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "drawTextureAt",
        value: function drawTextureAt(texture, x, y) {
            var gfxTexture = this.getGFXTexture();
            if (texture.image && gfxTexture) {
                var gfxDevice = this._getGFXDevice();
                if (gfxDevice) {
                    var region = {
                        buffOffset: 0,
                        buffStride: 0,
                        buffTexHeight: 0,
                        texOffset: {
                            x: x,
                            y: y,
                            z: 0
                        },
                        texExtent: {
                            width: texture.image.width,
                            height: texture.image.height,
                            depth: 1
                        },
                        texSubres: {
                            baseMipLevel: 0,
                            levelCount: 1,
                            baseArrayLayer: 0,
                            layerCount: 1
                        }
                    };
                    gfxDevice.copyTexImagesToTexture([ texture.image.data ], gfxTexture, [ region ]);
                } else console.warn("Unable to get device");
            }
        }
    } ]), LetterRenderTexture;
}(), LetterAtlas = function() {
    function LetterAtlas(width, height) {
        _classCallCheck(this, LetterAtlas), this.texture = void 0, this._x = space, this._y = space, 
        this._nexty = space, this._width = 0, this._height = 0, this._letterDefinitions = new Map(), 
        this._imageAssets = [], this._dirty = !1, this.texture = new LetterRenderTexture(), 
        this.texture.initWithSize(width, height), this._width = width, this._height = height, 
        cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
    }
    return _createClass(LetterAtlas, [ {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    } ]), _createClass(LetterAtlas, [ {
        key: "insertLetterTexture",
        value: function insertLetterTexture(letterTexture) {
            var texture = letterTexture.spriteframe, device = cc.director.root.device;
            if (!(texture && this.texture && device && texture.image)) return null;
            var width = texture.width, height = texture.height;
            if (this._x + width + space > this._width && (this._x = space, this._y = this._nexty), 
            this._y + height > this._nexty && (this._nexty = this._y + height + space), this._nexty > this._height) return null;
            this.texture.drawTextureAt(texture, this._x, this._y), this._dirty = !0;
            var letterDefinition = new FontLetterDefinition$1();
            return letterDefinition.u = this._x, letterDefinition.v = this._y, letterDefinition.texture = this.texture, 
            letterDefinition.valid = !0, letterDefinition.w = letterTexture.width, letterDefinition.h = letterTexture.height, 
            letterDefinition.xAdvance = letterTexture.width, this._x += width + space, this._letterDefinitions.set(letterTexture.hash, letterDefinition), 
            letterDefinition;
        }
    }, {
        key: "update",
        value: function update() {
            this._dirty && (this._dirty = !1);
        }
    }, {
        key: "reset",
        value: function reset() {
            this._x = space, this._y = space, this._nexty = space, this._letterDefinitions.clear();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.reset(), this.texture && this.texture.destroy();
        }
    }, {
        key: "beforeSceneLoad",
        value: function beforeSceneLoad() {
            this.destroy();
            var texture = new LetterRenderTexture();
            texture.initWithSize(this._width, this._height), this.texture = texture;
        }
    }, {
        key: "getLetter",
        value: function getLetter(key) {
            return this._letterDefinitions.get(key);
        }
    }, {
        key: "addLetterDefinitions",
        value: function addLetterDefinitions(key, letterDefinition) {
            this._letterDefinitions[key] = letterDefinition;
        }
    }, {
        key: "cloneLetterDefinition",
        value: function cloneLetterDefinition() {
            for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i], value = new FontLetterDefinition$1();
                mixin(value, this._letterDefinitions[key]), copyLetterDefinitions[key] = value;
            }
            return copyLetterDefinitions;
        }
    }, {
        key: "assignLetterDefinitions",
        value: function assignLetterDefinitions(letterDefinitions) {
            var _this = this;
            letterDefinitions.forEach(function(value, key) {
                mixin(_this._letterDefinitions[key], value);
            });
        }
    }, {
        key: "scaleFontLetterDefinition",
        value: function scaleFontLetterDefinition(scaleFactor) {
            for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                var fontDefinition = _Object$keys2[_i2], letterDefinitions = this._letterDefinitions[fontDefinition];
                letterDefinitions.w *= scaleFactor, letterDefinitions.h *= scaleFactor, letterDefinitions.offsetX *= scaleFactor, 
                letterDefinitions.offsetY *= scaleFactor, letterDefinitions.xAdvance *= scaleFactor;
            }
        }
    }, {
        key: "getLetterDefinitionForChar",
        value: function getLetterDefinitionForChar(_char2, labelInfo) {
            var hash = _char2.charCodeAt(0) + labelInfo.hash, letterDefinition = this._letterDefinitions.get(hash);
            if (!letterDefinition) {
                var temp = new LetterTexture(_char2, labelInfo);
                temp.updateRenderData(), letterDefinition = this.insertLetterTexture(temp), temp.destroy();
            }
            return letterDefinition;
        }
    } ]), LetterAtlas;
}(), _tmpRect$1 = new Rect(), _comp$1 = null, _horizontalKernings$1 = [], _lettersInfo$1 = [], _linesWidth$1 = [], _linesOffsetX$1 = [], _labelDimensions$1 = new Size(), _fontAtlas$1 = null, _numberOfLines$1 = 0, _textDesiredHeight$1 = 0, _letterOffsetY$1 = 0, _tailoredTopY$1 = 0, _tailoredBottomY$1 = 0, _bmfontScale$1 = 1, _string$1 = "", _fontSize$1 = 0, _originFontSize$1 = 0, _contentSize$1 = new Size(), _hAlign$1 = 0, _vAlign$1 = 0, _spacingX$1 = 0, _lineHeight$1 = 0, _overflow$1 = 0, _isWrapText$1 = !1, _labelWidth$1 = 0, _labelHeight$1 = 0, _maxLineWidth$1 = 0, _fontFamily = "", _isBold = !1, _labelInfo = {
    fontSize: 0,
    lineHeight: 0,
    hash: "",
    fontFamily: "",
    fontDesc: "Arial",
    hAlign: 0,
    vAlign: 0,
    color: WHITE,
    isOutlined: !1,
    out: WHITE,
    margin: 0
}, letterFont = {
    getAssemblerData: function getAssemblerData() {
        return _fontAtlas$1 || (_fontAtlas$1 = new LetterAtlas(1024, 1024)), _fontAtlas$1.texture;
    },
    updateRenderData: function updateRenderData(comp) {
        comp.renderData && comp.renderData.vertDirty && _comp$1 !== comp && (_comp$1 = comp, 
        this._updateFontFamily(comp), _labelInfo.fontFamily = _fontFamily, this._updateProperties(), 
        _labelInfo.fontDesc = this._getFontDesc(), this._updateContent(), _comp$1.actualFontSize = _fontSize$1, 
        _comp$1.node.setContentSize(_contentSize$1), _comp$1.renderData.vertDirty = _comp$1.renderData.uvDirty = !1, 
        _comp$1 = null, this._resetProperties());
    },
    _updateFontScale: function _updateFontScale() {
        _bmfontScale$1 = _fontSize$1 / _originFontSize$1;
    },
    _updateProperties: function _updateProperties() {
        if (_comp$1) {
            _string$1 = _comp$1.string.toString(), _fontSize$1 = _comp$1.fontSize, _originFontSize$1 = _fontSize$1;
            var contentSize = _comp$1.node.getContentSize();
            _contentSize$1.width = contentSize.width, _contentSize$1.height = contentSize.height, 
            _hAlign$1 = _comp$1.horizontalAlign, _vAlign$1 = _comp$1.verticalAlign, _spacingX$1 = _comp$1.spacingX, 
            _overflow$1 = _comp$1.overflow, _lineHeight$1 = _comp$1.lineHeight, _isBold = _comp$1.isBold, 
            _isWrapText$1 = _overflow$1 !== Overflow$1.NONE && (_overflow$1 === Overflow$1.RESIZE_HEIGHT || _comp$1.enableWrapText);
            var outline = _comp$1.getComponent(LabelOutlineComponent);
            outline && outline.enabled ? (_labelInfo.isOutlined = !0, _labelInfo.margin = outline.width, 
            _labelInfo.out = outline.color, _labelInfo.out.a = outline.color.a * _comp$1.color.a / 255) : (_labelInfo.isOutlined = !1, 
            _labelInfo.margin = 0), _labelInfo.lineHeight = _lineHeight$1, _labelInfo.fontSize = _fontSize$1, 
            _labelInfo.fontFamily = _fontFamily, _labelInfo.color = _comp$1.color, _labelInfo.hash = this._computeHash(_labelInfo), 
            this._setupBMFontOverflowMetrics();
        }
    },
    _updateFontFamily: function _updateFontFamily(comp) {
        comp.useSystemFont ? _fontFamily = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily = comp.font._nativeAsset : (_fontFamily = cc.loader.getRes(comp.font.nativeUrl)) || cc.loader.load(comp.font.nativeUrl, function(err, fontFamily) {
            _fontFamily = fontFamily || "Arial", comp.font && (comp.font._nativeAsset = fontFamily), 
            comp.updateRenderData(!0);
        }) : _fontFamily = "Arial";
    },
    _computeHash: function _computeHash(labelInfo) {
        var color = labelInfo.color.toHEX("#rrggbb"), out = "";
        return labelInfo.isOutlined && (out = labelInfo.out.toHEX("#rrggbb")), "" + labelInfo.fontSize + labelInfo.fontFamily + color + out;
    },
    _getFontDesc: function _getFontDesc() {
        var fontDesc = _fontSize$1.toString() + "px ";
        return fontDesc += _fontFamily, _isBold && (fontDesc = "bold " + fontDesc), fontDesc;
    },
    _resetProperties: function _resetProperties() {},
    _updateContent: function _updateContent() {
        this._updateFontScale(), this._alignText();
    },
    _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
    _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string$1.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2(0, 0);
        this._updateFontScale();
        for (var index = 0; index < textLen; ) {
            var character = _string$1.charAt(index);
            if ("\n" !== character) {
                for (var tokenLen = nextTokenFunc(_string$1, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                    var letterIndex = index + tmp;
                    if ("\r" !== (character = _string$1.charAt(letterIndex))) if (letterDef = _fontAtlas$1 && _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)) {
                        var letterX = nextLetterX + letterDef.offsetX * _bmfontScale$1;
                        if (_isWrapText$1 && _maxLineWidth$1 > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character)) {
                            _linesWidth$1.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + 0, 
                            newLine = !0;
                            break;
                        }
                        letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale$1, 
                        this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex), letterIndex + 1 < _horizontalKernings$1.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings$1[letterIndex + 1]), 
                        nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, tokenRight = letterPosition.x + letterDef.w * _bmfontScale$1, 
                        tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale$1 && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale$1);
                    } else this._recordPlaceholderInfo(letterIndex, character); else this._recordPlaceholderInfo(letterIndex, character);
                }
                newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                lowestY > tokenLowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                index += tokenLen);
            } else _linesWidth$1.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, 
            nextTokenY -= _lineHeight$1 * _bmfontScale$1 + 0, this._recordPlaceholderInfo(index, character), 
            index++;
        }
        return _linesWidth$1.push(letterRight), _textDesiredHeight$1 = (_numberOfLines$1 = lineIndex + 1) * _lineHeight$1 * _bmfontScale$1, 
        _numberOfLines$1 > 1 && (_textDesiredHeight$1 += 0 * (_numberOfLines$1 - 1)), _contentSize$1.width = _labelWidth$1, 
        _contentSize$1.height = _labelHeight$1, _labelWidth$1 <= 0 && (_contentSize$1.width = parseFloat(longestLine.toFixed(2))), 
        _labelHeight$1 <= 0 && (_contentSize$1.height = parseFloat(_textDesiredHeight$1.toFixed(2))), 
        _tailoredTopY$1 = _contentSize$1.height, _tailoredBottomY$1 = 0, highestY > 0 && (_tailoredTopY$1 = _contentSize$1.height + highestY), 
        lowestY < -_textDesiredHeight$1 && (_tailoredBottomY$1 = _textDesiredHeight$1 + lowestY), 
        !0;
    },
    _getFirstCharLen: function _getFirstCharLen() {
        return 1;
    },
    _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
        if (_fontAtlas$1) {
            var len = 1, letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo);
            if (!letterDef) return len;
            for (var nextLetterX = letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
            letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)); ++index) {
                if (nextLetterX + letterDef.offsetX * _bmfontScale$1 + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character) && _maxLineWidth$1 > 0) return len;
                if (nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                len++;
            }
            return len;
        }
    },
    _multilineTextWrapByWord: function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
    },
    _multilineTextWrapByChar: function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
    },
    _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char3) {
        if (letterIndex >= _lettersInfo$1.length) {
            var tmpInfo = new LetterInfo$1();
            _lettersInfo$1.push(tmpInfo);
        }
        _lettersInfo$1[letterIndex].char = _char3, _lettersInfo$1[letterIndex].hash = _char3.charCodeAt(0) + _labelInfo.hash, 
        _lettersInfo$1[letterIndex].valid = !1;
    },
    _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo$1.length) {
            var tmpInfo = new LetterInfo$1();
            _lettersInfo$1.push(tmpInfo);
        }
        var key = character.charCodeAt(0) + _labelInfo.hash;
        _lettersInfo$1[letterIndex].line = lineIndex, _lettersInfo$1[letterIndex].char = character, 
        _lettersInfo$1[letterIndex].hash = key;
        var fontLetter = _fontAtlas$1 && _fontAtlas$1.getLetter(key);
        _lettersInfo$1[letterIndex].valid = !!fontLetter && !!fontLetter.valid, _lettersInfo$1[letterIndex].x = letterPosition.x, 
        _lettersInfo$1[letterIndex].y = letterPosition.y;
    },
    _alignText: function _alignText() {
        _textDesiredHeight$1 = 0, _linesWidth$1.length = 0, this._multilineTextWrapByWord(), 
        this._computeAlignmentOffset(), this._updateQuads();
    },
    _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = !0;
        fontSize || (fontSize = .1, shouldUpdateContent = !1), _fontSize$1 = fontSize, shouldUpdateContent && this._updateContent();
    },
    _isVerticalClamp: function _isVerticalClamp() {
        return _textDesiredHeight$1 > _contentSize$1.height;
    },
    _isHorizontalClamp: function _isHorizontalClamp() {
        for (var letterClamp = !1, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo$1[ctr];
            if (letterInfo.valid) {
                var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                if (!letterDef) continue;
                var px = letterInfo.x + letterDef.w * _bmfontScale$1, lineIndex = letterInfo.line;
                if (_labelWidth$1 > 0) if (_isWrapText$1) {
                    if (_linesWidth$1[lineIndex] > _contentSize$1.width && (px > _contentSize$1.width || px < 0)) {
                        letterClamp = !0;
                        break;
                    }
                } else if (px > _contentSize$1.width) {
                    letterClamp = !0;
                    break;
                }
            }
        }
        return letterClamp;
    },
    _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth$1[lineIndex], letterOverClamp = px > _contentSize$1.width || px < 0;
        return _isWrapText$1 ? wordWidth > _contentSize$1.width && letterOverClamp : letterOverClamp;
    },
    _updateQuads: function _updateQuads() {
        if (_comp$1 && _fontAtlas$1) {
            var texture = _fontAtlas$1.texture, node = _comp$1.node, renderData = _comp$1.renderData;
            renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
            for (var contentSize = _contentSize$1, ap = node.getAnchorPoint(), appx = ap.x * contentSize.width, appy = ap.y * contentSize.height, ret = !0, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo$1[ctr];
                if (letterInfo.valid) {
                    var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                    if (letterDef) {
                        _tmpRect$1.height = letterDef.h, _tmpRect$1.width = letterDef.w, _tmpRect$1.x = letterDef.u, 
                        _tmpRect$1.y = letterDef.v;
                        var py = letterInfo.y + _letterOffsetY$1;
                        if (_labelHeight$1 > 0) {
                            if (py > _tailoredTopY$1) {
                                var clipTop = py - _tailoredTopY$1;
                                _tmpRect$1.y += clipTop, _tmpRect$1.height -= clipTop, py -= clipTop;
                            }
                            py - letterDef.h * _bmfontScale$1 < _tailoredBottomY$1 && (_tmpRect$1.height = py < _tailoredBottomY$1 ? 0 : py - _tailoredBottomY$1);
                        }
                        var lineIndex = letterInfo.line, px = letterInfo.x + letterDef.w / 2 * _bmfontScale$1 + _linesOffsetX$1[lineIndex];
                        if (_labelWidth$1 > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow$1 === Overflow$1.CLAMP) _tmpRect$1.width = 0; else if (_overflow$1 === Overflow$1.SHRINK) {
                            if (_contentSize$1.width > letterDef.w) {
                                ret = !1;
                                break;
                            }
                            _tmpRect$1.width = 0;
                        }
                        if (_tmpRect$1.height > 0 && _tmpRect$1.width > 0) {
                            var letterPositionX = letterInfo.x + _linesOffsetX$1[letterInfo.line];
                            this.appendQuad(renderData, texture, _tmpRect$1, !1, letterPositionX - appx, py - appy, _bmfontScale$1);
                        }
                    }
                }
            }
            return ret;
        }
    },
    appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {},
    _computeAlignmentOffset: function _computeAlignmentOffset() {
        switch (_linesOffsetX$1.length = 0, _hAlign$1) {
          case TextAlignment.LEFT:
            for (var i = 0; i < _numberOfLines$1; ++i) _linesOffsetX$1.push(0);
            break;

          case TextAlignment.CENTER:
            for (var _i3 = 0, l = _linesWidth$1.length; _i3 < l; _i3++) _linesOffsetX$1.push((_contentSize$1.width - _linesWidth$1[_i3]) / 2);
            break;

          case TextAlignment.RIGHT:
            for (var _i4 = 0, _l = _linesWidth$1.length; _i4 < _l; _i4++) _linesOffsetX$1.push(_contentSize$1.width - _linesWidth$1[_i4]);
        }
        switch (_vAlign$1) {
          case VerticalTextAlignment$1.TOP:
            _letterOffsetY$1 = _contentSize$1.height;
            break;

          case VerticalTextAlignment$1.CENTER:
            _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1) / 2;
            break;

          case VerticalTextAlignment$1.BOTTOM:
            _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1);
        }
    },
    _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize$1.width, newHeight = _contentSize$1.height;
        _overflow$1 === Overflow$1.RESIZE_HEIGHT && (newHeight = 0), _overflow$1 === Overflow$1.NONE && (newWidth = 0, 
        newHeight = 0), _labelWidth$1 = newWidth, _labelHeight$1 = newHeight, _labelDimensions$1.width = newWidth, 
        _labelDimensions$1.height = newHeight, _maxLineWidth$1 = newWidth;
    }
}, WHITE$1 = cc.color(255, 255, 255, 255), letter = {
    createData: function createData(comp) {
        return comp.requestRenderData();
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        if (comp.renderData) {
            var node = comp.node;
            WHITE$1.a = comp.color.a, fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
        }
    },
    appendQuad: bmfont.appendQuad
};

addon(letter, letterFont);

var Overflow$2 = LabelComponent.Overflow, WHITE$2 = Color.WHITE.clone(), OUTLINE_SUPPORTED = cc.js.isChildClassOf(LabelOutlineComponent, Component), _context = null, _canvas = null, _texture = null, _fontDesc = "", _string$2 = "", _fontSize$2 = 0, _drawFontsize = 0, _splitedStrings = [], _canvasSize = new Size(), _lineHeight$2 = 0, _hAlign$2 = 0, _vAlign$2 = 0, _color$1 = new Color(), _fontFamily$1 = "", _overflow$2 = Overflow$2.NONE, _isWrapText$2 = !1, _isOutlined = !1, _outlineColor = new Color(), _outlineWidth = 0, _margin = 0, _isBold$1 = !1, _isItalic = !1, _isUnderline = !1, _canvasPool = new CanvasPool(), ttfUtils = {
    getAssemblerData: function getAssemblerData() {
        var labelCanvas = document.createElement("canvas"), sharedLabelData = {
            canvas: labelCanvas,
            context: labelCanvas.getContext("2d")
        };
        return sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1, sharedLabelData;
    },
    resetAssemblerData: function resetAssemblerData(assemblerData) {
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && assemblerData && _canvasPool.put(assemblerData);
    },
    updateRenderData: function updateRenderData(comp) {
        comp.renderData && comp.renderData.vertDirty && (this._updateFontFamly(comp), this._updateProperties(comp), 
        this._calculateLabelFont(), this._calculateSplitedStrings(), this._updateLabelDimensions(), 
        this._calculateTextBaseline(), this._updateTexture(), comp.actualFontSize = _fontSize$2, 
        comp.node.setContentSize(_canvasSize), this.updateVerts(comp), comp.markForUpdateRenderData(!1), 
        _context = null, _canvas = null, _texture = null);
    },
    updateVerts: function updateVerts(comp) {},
    _updateFontFamly: function _updateFontFamly(comp) {
        comp.useSystemFont ? _fontFamily$1 = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily$1 = comp.font._nativeAsset : cc.loader.load(comp.font.nativeUrl, function(err, fontFamily) {
            _fontFamily$1 = fontFamily || "Arial", comp.updateRenderData(!0);
        }) : _fontFamily$1 = "Arial";
    },
    _updateProperties: function _updateProperties(comp) {
        var assemblerData = comp.assemblerData;
        if (assemblerData) {
            _context = assemblerData.context, _canvas = assemblerData.canvas, _texture = comp.spriteFrame, 
            _string$2 = comp.string.toString(), _fontSize$2 = comp.fontSize, _drawFontsize = _fontSize$2, 
            _overflow$2 = comp.overflow, _canvasSize.width = comp.node.width, _canvasSize.height = comp.node.height, 
            _lineHeight$2 = comp.lineHeight, _hAlign$2 = comp.horizontalAlign, _vAlign$2 = comp.verticalAlign, 
            _color$1 = comp.color, _isBold$1 = comp.isBold, _isItalic = comp.isItalic, _isUnderline = comp.isUnderline, 
            _isWrapText$2 = _overflow$2 !== Overflow$2.NONE && (_overflow$2 === Overflow$2.RESIZE_HEIGHT || comp.enableWrapText);
            var outline = OUTLINE_SUPPORTED && comp.getComponent(LabelOutlineComponent);
            outline && outline.enabled ? (_isOutlined = !0, _margin = _outlineWidth = outline.width, 
            (_outlineColor = outline.color.clone()).a = _outlineColor.a * comp.color.a / 255) : (_isOutlined = !1, 
            _margin = 0);
        }
    },
    _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
        var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
        return labelX = _hAlign$2 === HorizontalTextAlignment.RIGHT ? _canvasSize.width - _margin : _hAlign$2 === HorizontalTextAlignment.CENTER ? _canvasSize.width / 2 : 0 + _margin, 
        firstLinelabelY = _vAlign$2 === VerticalTextAlignment.TOP ? 0 : _vAlign$2 === VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
        cc.v2(labelX, firstLinelabelY);
    },
    _updateTexture: function _updateTexture() {
        if (_context && _canvas) {
            _context.clearRect(0, 0, _canvas.width, _canvas.height), _context.font = _fontDesc;
            var underlineStartPosition, startPosition = this._calculateFillTextStartPosition(), lineHeight = this._getLineHeight();
            _context.lineJoin = "round", _context.fillStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")");
            for (var i = 0; i < _splitedStrings.length; ++i) {
                if (_isOutlined) {
                    var strokeColor = _outlineColor || WHITE$2;
                    _context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                    _context.lineWidth = 2 * _outlineWidth, _context.strokeText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                }
                _context.fillText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight), 
                _isUnderline && (underlineStartPosition = this._calculateUnderlineStartPosition(), 
                _context.save(), _context.beginPath(), _context.lineWidth = _fontSize$2 / 8, _context.strokeStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")"), 
                _context.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1), 
                _context.lineTo(underlineStartPosition.x + _canvas.width, underlineStartPosition.y + i * lineHeight - 1), 
                _context.stroke(), _context.restore());
            }
            if (_texture) if (_texture instanceof SpriteFrame) {
                var tex = _texture.texture;
                tex.image = tex.image;
            } else _texture.image = _texture.image;
        }
    },
    _calculateUnderlineStartPosition: function _calculateUnderlineStartPosition() {
        var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
        return labelX = 0 + _margin, firstLinelabelY = _vAlign$2 === VerticalTextAlignment.TOP ? _fontSize$2 : _vAlign$2 === VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + _fontSize$2 / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
        cc.v2(labelX, firstLinelabelY);
    },
    _updateLabelDimensions: function _updateLabelDimensions() {
        if (_context) {
            var paragraphedStrings = _string$2.split("\n");
            if (_overflow$2 === Overflow$2.RESIZE_HEIGHT) _canvasSize.height = _splitedStrings.length * this._getLineHeight(); else if (_overflow$2 === Overflow$2.NONE) {
                _splitedStrings = paragraphedStrings;
                var canvasSizeX = 0, canvasSizeY = 0, _iterator = paragraphedStrings, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var paraLength = safeMeasureText(_context, _ref);
                    canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                }
                canvasSizeY = _splitedStrings.length * this._getLineHeight(), _canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * _margin, 
                _canvasSize.height = parseFloat(canvasSizeY.toFixed(2)), _isItalic && (_canvasSize.width += _drawFontsize * Math.tan(.20943951));
            }
            _canvas && (_canvas.width = _canvasSize.width, _canvas.height = _canvasSize.height);
        }
    },
    _calculateTextBaseline: function _calculateTextBaseline() {
        var hAlign, vAlign;
        hAlign = _hAlign$2 === HorizontalTextAlignment.RIGHT ? "right" : _hAlign$2 === HorizontalTextAlignment.CENTER ? "center" : "left", 
        vAlign = _vAlign$2 === VerticalTextAlignment.TOP ? "top" : _vAlign$2 === VerticalTextAlignment.CENTER ? "middle" : "bottom", 
        _context && (_context.textAlign = hAlign, _context.textBaseline = vAlign);
    },
    _calculateSplitedStrings: function _calculateSplitedStrings() {
        if (_context) {
            var paragraphedStrings = _string$2.split("\n");
            if (_isWrapText$2) {
                _splitedStrings = [];
                var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, _iterator2 = paragraphedStrings, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var textFragment = fragmentText(_ref2, safeMeasureText(_context, _ref2), canvasWidthNoMargin, this._measureText(_context));
                    _splitedStrings = _splitedStrings.concat(textFragment);
                }
            } else _splitedStrings = paragraphedStrings;
        }
    },
    _getFontDesc: function _getFontDesc() {
        var fontDesc = _fontSize$2.toString() + "px ";
        return fontDesc += _fontFamily$1, _isBold$1 && (fontDesc = "bold " + fontDesc), 
        _isItalic && (fontDesc = "italic " + fontDesc), fontDesc;
    },
    _getLineHeight: function _getLineHeight() {
        var nodeSpacingY = _lineHeight$2;
        return 0 | (nodeSpacingY = 0 === nodeSpacingY ? _fontSize$2 : nodeSpacingY * _fontSize$2 / _drawFontsize);
    },
    _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
        var paragraphLength = [], _iterator3 = paragraphedStrings, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
            var _ref3;
            if (_isArray3) {
                if (_i3 >= _iterator3.length) break;
                _ref3 = _iterator3[_i3++];
            } else {
                if ((_i3 = _iterator3.next()).done) break;
                _ref3 = _i3.value;
            }
            var width = safeMeasureText(ctx, _ref3);
            paragraphLength.push(width);
        }
        return paragraphLength;
    },
    _measureText: function _measureText(ctx) {
        return function(string) {
            return safeMeasureText(ctx, string);
        };
    },
    _calculateLabelFont: function _calculateLabelFont() {
        if (_context && (_fontDesc = this._getFontDesc(), _context.font = _fontDesc, _overflow$2 === Overflow$2.SHRINK)) {
            var paragraphedStrings = _string$2.split("\n"), paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
            _splitedStrings = paragraphedStrings;
            var i = 0, totalHeight = 0, maxLength = 0;
            if (_isWrapText$2) {
                var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, canvasHeightNoMargin = _canvasSize.height - 2 * _margin;
                if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) return _fontDesc = this._getFontDesc(), 
                void (_context.font = _fontDesc);
                totalHeight = canvasHeightNoMargin + 1, maxLength = canvasWidthNoMargin + 1;
                for (var actualFontSize = _fontSize$2 + 1, textFragment = [], tryDivideByTwo = !0, startShrinkFontSize = 0 | actualFontSize; totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin; ) {
                    if (tryDivideByTwo ? actualFontSize = startShrinkFontSize / 2 | 0 : startShrinkFontSize = actualFontSize = startShrinkFontSize - 1, 
                    actualFontSize <= 0) {
                        cc.logID(4003);
                        break;
                    }
                    for (_fontSize$2 = actualFontSize, _fontDesc = this._getFontDesc(), _context.font = _fontDesc, 
                    _splitedStrings = [], totalHeight = 0, i = 0; i < paragraphedStrings.length; ++i) {
                        var j = 0, allWidth = safeMeasureText(_context, paragraphedStrings[i]);
                        for (textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context)); j < textFragment.length; ) {
                            maxLength = safeMeasureText(_context, textFragment[j]), totalHeight += this._getLineHeight(), 
                            ++j;
                        }
                        _splitedStrings = _splitedStrings.concat(textFragment);
                    }
                    tryDivideByTwo && (totalHeight > canvasHeightNoMargin ? startShrinkFontSize = 0 | actualFontSize : (tryDivideByTwo = !1, 
                    totalHeight = canvasHeightNoMargin + 1));
                }
            } else {
                for (totalHeight = paragraphedStrings.length * this._getLineHeight(), i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
                var scaleX = (_canvasSize.width - 2 * _margin) / maxLength, scaleY = _canvasSize.height / totalHeight;
                _fontSize$2 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0, _fontDesc = this._getFontDesc(), 
                _context.font = _fontDesc;
            }
        }
    }
}, WHITE$3 = Color.WHITE.clone(), ttf = {
    createData: function createData(comp) {
        var renderData = comp.requestRenderData();
        renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6;
        var vData = renderData.vData = new Float32Array(36);
        vData[3] = vData[21] = vData[22] = vData[31] = 0, vData[4] = vData[12] = vData[13] = vData[30] = 1;
        for (var offset = 5, i = 0; i < 4; i++) Color.array(vData, WHITE$3, offset), offset += 9;
        return renderData;
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        var renderData = comp.renderData, datas = renderData.datas, node = comp.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request() || (buffer = renderer.currBufferBatch, indiceOffset = 0, vertexId = 0);
        var vbuf = buffer.vData, ibuf = buffer.iData, vData = renderData.vData, data0 = datas[0], data3 = datas[3];
        node.updateWorldTransform();
        var pos = node._pos, rot = node._rot, scale = node._scale, ax = data0.x * scale.x, bx = data3.x * scale.x, ay = data0.y * scale.y, by = data3.y * scale.y, qx = rot.x, qy = rot.y, qz = rot.z, qw = rot.w, qxy = qx * qy, qzw = qz * qw, qxy2 = qx * qx - qy * qy, qzw2 = qw * qw - qz * qz, cx1 = qzw2 + qxy2, cx2 = 2 * (qxy - qzw), cy1 = qzw2 - qxy2, cy2 = 2 * (qxy + qzw), x = pos.x, y = pos.y;
        vData[0] = cx1 * ax + cx2 * ay + x, vData[1] = cy1 * ay + cy2 * ax + y, vData[9] = cx1 * bx + cx2 * ay + x, 
        vData[10] = cy1 * ay + cy2 * bx + y, vData[18] = cx1 * ax + cx2 * by + x, vData[19] = cy1 * by + cy2 * ax + y, 
        vData[27] = cx1 * bx + cx2 * by + x, vData[28] = cy1 * by + cy2 * bx + y, vbuf.set(vData, vertexOffset), 
        ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
        ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3;
    },
    updateVerts: function updateVerts(comp) {
        var renderData = comp.renderData;
        if (renderData) {
            var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, datas = renderData.datas;
            datas[0].x = -appx, datas[0].y = -appy, datas[3].x = width - appx, datas[3].y = height - appy;
        }
    }
};

addon(ttf, ttfUtils);

var Stage, labelAssembler = {
    getAssembler: function getAssembler(comp) {
        var assembler = ttf;
        return comp.font instanceof BitmapFont ? assembler = bmfont : comp.cacheMode === LabelComponent.CacheMode.CHAR && (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB ? cc.warn("sorry, subdomain does not support CHAR mode currently!") : assembler = letter), 
        assembler;
    }
};

LabelComponent.Assembler = labelAssembler, function(Stage) {
    Stage[Stage.DISABLED = 0] = "DISABLED", Stage[Stage.CLEAR = 1] = "CLEAR", Stage[Stage.ENTER_LEVEL = 2] = "ENTER_LEVEL", 
    Stage[Stage.ENABLED = 3] = "ENABLED", Stage[Stage.EXIT_LEVEL = 4] = "EXIT_LEVEL";
}(Stage || (Stage = {}));

var StencilManager = function() {
    function StencilManager() {
        _classCallCheck(this, StencilManager), this.stage = Stage.DISABLED, this._maskStack = [], 
        this._stencilPattern = {
            stencilTest: !0,
            func: GFXComparisonFunc.ALWAYS,
            stencilMask: 4294967295,
            writeMask: 4294967295,
            failOp: GFXStencilOp.KEEP,
            zFailOp: GFXStencilOp.KEEP,
            passOp: GFXStencilOp.KEEP,
            ref: 1
        }, this._defaultPipelineState = {
            depthStencilState: {},
            rasterizerState: {},
            blendState: {}
        };
    }
    return _createClass(StencilManager, [ {
        key: "pushMask",
        value: function pushMask(mask) {
            this._maskStack.push(mask);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.stage = Stage.CLEAR;
        }
    }, {
        key: "enterLevel",
        value: function enterLevel() {
            this.stage = Stage.ENTER_LEVEL;
        }
    }, {
        key: "enableMask",
        value: function enableMask() {
            this.stage = Stage.ENABLED;
        }
    }, {
        key: "exitMask",
        value: function exitMask() {
            0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = Stage.DISABLED : this.stage = Stage.ENABLED);
        }
    }, {
        key: "handleMaterial",
        value: function handleMaterial(mat) {
            var pattern = this._stencilPattern;
            this.stage === Stage.DISABLED ? (pattern.stencilTest = !1, pattern.func = GFXComparisonFunc.ALWAYS, 
            pattern.failOp = GFXStencilOp.KEEP, pattern.stencilMask = pattern.writeMask = 4294967295, 
            pattern.ref = 1) : (pattern.stencilTest = !0, this.stage === Stage.ENABLED ? (pattern.func = GFXComparisonFunc.EQUAL, 
            pattern.failOp = GFXStencilOp.KEEP, pattern.stencilMask = pattern.ref = this.getStencilRef(), 
            pattern.writeMask = this.getWriteMask()) : this.stage === Stage.CLEAR ? (pattern.func = GFXComparisonFunc.NEVER, 
            pattern.failOp = GFXStencilOp.ZERO, pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask()) : this.stage === Stage.ENTER_LEVEL && (pattern.func = GFXComparisonFunc.NEVER, 
            pattern.failOp = GFXStencilOp.REPLACE, pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask()));
            var pass = mat.passes[0];
            if (this._changed(pass)) {
                var state = this._stencilPattern;
                return this._defaultPipelineState.depthStencilState = {
                    stencilTestFront: state.stencilTest,
                    stencilFuncFront: state.func,
                    stencilReadMaskFront: state.stencilMask,
                    stencilWriteMaskFront: state.writeMask,
                    stencilFailOpFront: state.failOp,
                    stencilZFailOpFront: state.zFailOp,
                    stencilPassOpFront: state.passOp,
                    stencilRefFront: state.ref,
                    stencilTestBack: state.stencilTest,
                    stencilFuncBack: state.func,
                    stencilReadMaskBack: state.stencilMask,
                    stencilWriteMaskBack: state.writeMask,
                    stencilFailOpBack: state.failOp,
                    stencilZFailOpBack: state.zFailOp,
                    stencilPassOpBack: state.passOp,
                    stencilRefBack: state.ref
                }, this._defaultPipelineState.blendState = pass.blendState, this._defaultPipelineState.rasterizerState = pass.rasterizerState, 
                mat.overridePipelineStates(this._defaultPipelineState), !0;
            }
            return !1;
        }
    }, {
        key: "getWriteMask",
        value: function getWriteMask() {
            return 1 << this._maskStack.length - 1;
        }
    }, {
        key: "getExitWriteMask",
        value: function getExitWriteMask() {
            return 1 << this._maskStack.length;
        }
    }, {
        key: "getStencilRef",
        value: function getStencilRef() {
            for (var result = 0, i = 0; i < this._maskStack.length; ++i) result += 1 << i;
            return result;
        }
    }, {
        key: "getInvertedRef",
        value: function getInvertedRef() {
            for (var result = 0, i = 0; i < this._maskStack.length - 1; ++i) result += 1 << i;
            return result;
        }
    }, {
        key: "reset",
        value: function reset() {
            this._maskStack.length = 0, this.stage = Stage.DISABLED;
        }
    }, {
        key: "_changed",
        value: function _changed(pass) {
            var stencilState = pass.depthStencilState, pattern = this._stencilPattern;
            return pattern.stencilTest !== stencilState.stencilTestFront || pattern.func !== stencilState.stencilFuncFront || pattern.failOp !== stencilState.stencilFailOpFront || pattern.zFailOp !== stencilState.stencilZFailOpFront || pattern.passOp !== stencilState.stencilPassOpFront || pattern.stencilMask !== stencilState.stencilReadMaskFront || pattern.writeMask !== stencilState.stencilWriteMaskFront || pattern.ref !== stencilState.stencilRefFront;
        }
    } ]), StencilManager;
}();

StencilManager.sharedManager = null, StencilManager.sharedManager = new StencilManager();

var _stencilManager = StencilManager.sharedManager, maskAssembler = {
    createData: function createData(mask) {
        var renderData = mask.requestRenderData();
        return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
        renderData;
    },
    updateRenderData: function updateRenderData(mask) {
        var renderData = mask.renderData;
        renderData && renderData.vertDirty && this.updateVerts && this.updateVerts(mask);
    },
    updateVerts: function updateVerts(mask) {
        var renderData = mask.renderData;
        if (renderData) {
            var l, b, r, t, node = mask.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch;
            l = -appx, b = -appy, r = cw - appx, t = ch - appy, datas[0].x = l, datas[0].y = b, 
            datas[3].x = r, datas[3].y = t, renderData.vertDirty = !1;
        }
    },
    fillBuffers: function fillBuffers(mask, renderer) {
        _stencilManager.pushMask(mask), _stencilManager.clear(), mask.clearGraphics.updateAssembler(renderer), 
        _stencilManager.enterLevel(), mask.graphics.updateAssembler(renderer), _stencilManager.enableMask();
    }
}, maskEndAssembler = {
    fillBuffers: function fillBuffers(mask, ui) {
        _stencilManager.exitMask();
    }
}, StartAssembler = {
    getAssembler: function getAssembler() {
        return maskAssembler;
    }
}, PostAssembler = {
    getAssembler: function getAssembler() {
        return maskEndAssembler;
    }
};

MaskComponent.Assembler = StartAssembler, MaskComponent.PostAssembler = PostAssembler;

var FillType$1 = SpriteComponent.FillType, matrix = new Mat4(), barFilled = {
    useModel: !1,
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        if (renderData && frame) {
            var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
            if (!uvDirty && !vertDirty) return;
            var fillStart = sprite.fillStart, fillRange = sprite.fillRange;
            fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange), fillRange = (fillRange = (fillRange = fillStart + fillRange) > 1 ? 1 : fillRange) < 0 ? 0 : fillRange;
            var fillEnd = (fillStart = (fillStart = fillStart > 1 ? 1 : fillStart) < 0 ? 0 : fillStart) + (fillRange = (fillRange -= fillStart) < 0 ? 0 : fillRange);
            fillEnd = fillEnd > 1 ? 1 : fillEnd, uvDirty && this.updateUVs(sprite, fillStart, fillEnd), 
            vertDirty && (this.updateVerts && this.updateVerts(sprite, fillStart, fillEnd), 
            this.updateWorldVerts(sprite));
        }
    },
    updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
        var spriteFrame = sprite.spriteFrame, renderData = sprite.renderData, datas = renderData.datas, atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), ul = 0, vb = 0, quadUV0 = 0, quadUV1 = 0, quadUV2 = 0, quadUV3 = 0, quadUV4 = 0, quadUV5 = 0, quadUV6 = 0, quadUV7 = 0;
        switch (spriteFrame.isRotated() ? (ul = textureRect.x / atlasWidth, vb = (textureRect.y + textureRect.width) / atlasHeight, 
        quadUV0 = quadUV2 = ul, quadUV4 = quadUV6 = (textureRect.x + textureRect.height) / atlasWidth, 
        quadUV3 = quadUV7 = vb, quadUV1 = quadUV5 = textureRect.y / atlasHeight) : (ul = textureRect.x / atlasWidth, 
        vb = (textureRect.y + textureRect.height) / atlasHeight, quadUV0 = quadUV4 = ul, 
        quadUV2 = quadUV6 = (textureRect.x + textureRect.width) / atlasWidth, quadUV1 = quadUV3 = vb, 
        quadUV5 = quadUV7 = textureRect.y / atlasHeight), sprite.fillType) {
          case FillType$1.HORIZONTAL:
            datas[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart, 
            datas[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd, datas[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd, 
            datas[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart, datas[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart, 
            datas[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd, datas[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
            break;

          case FillType$1.VERTICAL:
            datas[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart, 
            datas[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart, datas[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart, 
            datas[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd, datas[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd, 
            datas[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd, datas[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
            break;

          default:
            cc.errorID(2626);
        }
        renderData.uvDirty = !1;
    },
    updateVerts: function updateVerts(sprite, fillStart, fillEnd) {
        var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, progressEnd = 0;
        switch (sprite.fillType) {
          case FillType$1.HORIZONTAL:
            progressEnd = l + (r - l) * fillEnd, l = l + (r - l) * fillStart, r = progressEnd;
            break;

          case FillType$1.VERTICAL:
            progressEnd = b + (t - b) * fillEnd, b = b + (t - b) * fillStart, t = progressEnd;
            break;

          default:
            cc.errorID(2626);
        }
        datas[4].x = l, datas[4].y = b, datas[5].x = r, datas[5].y = b, datas[6].x = l, 
        datas[6].y = t, datas[7].x = r, datas[7].y = t, renderData.vertDirty = !1;
    },
    createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 8, renderData.vertexCount = 4, renderData.indiceCount = 6;
        var _iterator = renderData.datas, _isArray = Array.isArray(_iterator), _i = 0;
        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                if ((_i = _iterator.next()).done) break;
                _ref = _i.value;
            }
            _ref.z = 0;
        }
        return renderData;
    },
    updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, datas = sprite.renderData.datas;
        node.getWorldMatrix(matrix);
        for (var i = 0; i < 4; i++) {
            var local = datas[i + 4], world = datas[i];
            Vec3.transformMat4(world, local, matrix);
        }
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
        sprite.node;
        !function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
            var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexCount = 0, indiceOffset = 0, vertexId = 0);
            for (var vbuf = buffer.vData, i = 0; i < vertexCount; i++) {
                var vert = datas[i];
                vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.array(vbuf, color, vertexOffset), 
                vertexOffset += 4;
            }
            var ibuf = buffer.iData;
            ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
            ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2;
        }(0, renderer, sprite.renderData, sprite.color);
    }
}, PI_2 = 2 * Math.PI, EPSILON$2 = 1e-6, _vertPos = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _vertices = new Array(4), _uvs = new Array(8), _intersectPoint_1 = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _intersectPoint_2 = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ], _center = new Vec2(), _triangles = [ new Vec2(), new Vec2(), new Vec2(), new Vec2() ];

function _calcInsectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
    var sinAngle = Math.sin(angle);
    sinAngle = Math.abs(sinAngle) > EPSILON$2 ? sinAngle : 0;
    var cosAngle = Math.cos(angle), tanAngle = 0, cotAngle = 0;
    if (0 !== (cosAngle = Math.abs(cosAngle) > EPSILON$2 ? cosAngle : 0)) {
        if (tanAngle = sinAngle / cosAngle, (left - center.x) * cosAngle > 0) {
            var yleft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left, intersectPoints[0].y = yleft;
        }
        if ((right - center.x) * cosAngle > 0) {
            var yright = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right, intersectPoints[2].y = yright;
        }
    }
    if (0 !== sinAngle) {
        if (cotAngle = cosAngle / sinAngle, (top - center.y) * sinAngle > 0) {
            var xtop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xtop, intersectPoints[3].y = top;
        }
        if ((bottom - center.y) * sinAngle > 0) {
            var xbottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xbottom, intersectPoints[1].y = bottom;
        }
    }
}

function _getVertAngle(start, end) {
    var placementX = end.x - start.x, placementY = end.y - start.y;
    if (0 === placementX && 0 === placementY) return 0;
    if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
    var angle = Math.atan(placementY / placementX);
    return placementX < 0 && (angle += Math.PI), angle;
}

function _generateTriangle(datas, offset, vert0, vert1, vert2) {
    var vertices = _vertices, v0x = vertices[0], v0y = vertices[1], v1x = vertices[2], v1y = vertices[3];
    datas[offset].x = vert0.x, datas[offset].y = vert0.y, datas[offset + 1].x = vert1.x, 
    datas[offset + 1].y = vert1.y, datas[offset + 2].x = vert2.x, datas[offset + 2].y = vert2.y;
    _generateUV((vert0.x - v0x) / (v1x - v0x), (vert0.y - v0y) / (v1y - v0y), datas, offset), 
    _generateUV((vert1.x - v0x) / (v1x - v0x), (vert1.y - v0y) / (v1y - v0y), datas, offset + 1), 
    _generateUV((vert2.x - v0x) / (v1x - v0x), (vert2.y - v0y) / (v1y - v0y), datas, offset + 2);
}

function _generateUV(progressX, progressY, data, offset) {
    var uvs = _uvs, px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX, px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX, py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX, py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX, uv = data[offset];
    uv.u = px1 + (px2 - px1) * progressY, uv.v = py1 + (py2 - py1) * progressY;
}

for (var radialFilled = {
    useModel: !1,
    createData: function createData(sprite) {
        return sprite.requestRenderData();
    },
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        if (renderData && frame && (renderData.vertDirty || renderData.uvDirty)) {
            var datas = renderData.datas, fillStart = sprite.fillStart, fillRange = sprite.fillRange;
            for (fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange); fillStart >= 1; ) fillStart -= 1;
            for (;fillStart < 0; ) fillStart += 1;
            var fillEnd = (fillStart *= PI_2) + (fillRange *= PI_2);
            !function _calculateVertices(sprite) {
                var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, vertices = _vertices;
                vertices[0] = l, vertices[1] = b, vertices[2] = r, vertices[3] = t;
                var fillCenter = sprite.fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
                _vertPos[0].x = _vertPos[3].x = l, _vertPos[1].x = _vertPos[2].x = r, _vertPos[0].y = _vertPos[1].y = b, 
                _vertPos[2].y = _vertPos[3].y = t;
                for (var _i = 0, _triangles2 = _triangles; _i < _triangles2.length; _i++) {
                    var num = _triangles2[_i];
                    Vec2.set(num, 0, 0);
                }
                cx !== vertices[0] && Vec2.set(_triangles[0], 3, 0), cx !== vertices[2] && Vec2.set(_triangles[2], 1, 2), 
                cy !== vertices[1] && Vec2.set(_triangles[1], 0, 1), cy !== vertices[3] && Vec2.set(_triangles[3], 2, 3);
            }(sprite), function _calculateUVs(spriteFrame) {
                var atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), u0 = 0, u1 = 0, v0 = 0, v1 = 0, uvs = _uvs;
                spriteFrame.isRotated() ? (u0 = textureRect.x / atlasWidth, u1 = (textureRect.x + textureRect.height) / atlasWidth, 
                v0 = textureRect.y / atlasHeight, v1 = (textureRect.y + textureRect.width) / atlasHeight, 
                uvs[0] = uvs[2] = u0, uvs[4] = uvs[6] = u1, uvs[3] = uvs[7] = v1, uvs[1] = uvs[5] = v0) : (u0 = textureRect.x / atlasWidth, 
                u1 = (textureRect.x + textureRect.width) / atlasWidth, v0 = textureRect.y / atlasHeight, 
                v1 = (textureRect.y + textureRect.height) / atlasHeight, uvs[0] = uvs[4] = u0, uvs[2] = uvs[6] = u1, 
                uvs[1] = uvs[3] = v1, uvs[5] = uvs[7] = v0);
            }(frame), _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1), 
            _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
            for (var offset = 0, triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                var triangle = _triangles[triangleIndex];
                if (triangle) if (fillRange >= PI_2) renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]), 
                offset += 3; else {
                    var startAngle = _getVertAngle(_center, _vertPos[triangle.x]), endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
                    endAngle < startAngle && (endAngle += PI_2), startAngle -= PI_2, endAngle -= PI_2;
                    for (var testIndex = 0; testIndex < 3; ++testIndex) startAngle >= fillEnd || (startAngle >= fillStart ? (renderData.dataLength = offset + 3, 
                    _generateTriangle(datas, offset, _center, _vertPos[triangle.x], endAngle >= fillEnd ? _intersectPoint_2[triangleIndex] : _vertPos[triangle.y]), 
                    offset += 3) : endAngle <= fillStart || (endAngle <= fillEnd ? (renderData.dataLength = offset + 3, 
                    _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]), 
                    offset += 3) : (renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]), 
                    offset += 3))), startAngle += PI_2, endAngle += PI_2;
                }
            }
            renderData.indiceCount = renderData.vertexCount = offset, renderData.vertDirty = renderData.uvDirty = !1;
        }
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        !function fillVertices3D(node, renderer, renderData, color) {
            var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexCount = 0, indiceOffset = 0, vertexId = 0);
            var vbuf = buffer.vData;
            node.getWorldMatrix(_worldMatrix$1);
            for (var i = 0; i < vertexCount; i++) {
                var vert = datas[i];
                Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
                vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
                vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.array(vbuf, color, vertexOffset), 
                vertexOffset += 4;
            }
            for (var ibuf = buffer.iData, _i = 0; _i < renderData.dataLength; _i++) ibuf[indiceOffset + _i] = vertexId + _i;
        }(comp.node, renderer, comp.renderData, comp.color);
    }
}, vec3_temps$1 = [], i$3 = 0; i$3 < 4; i$3++) vec3_temps$1.push(new Vec3());

var simple = {
    createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
        renderData.vData = new Float32Array(36), renderData;
    },
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        renderData && frame && (renderData.vertDirty && this.updateVerts(sprite), renderData.uvDirty && this.updateUvs(sprite));
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        if (null !== sprite) {
            var datas = sprite.renderData.datas, node = sprite.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request() || (buffer = renderer.currBufferBatch, vertexOffset = 0, indiceOffset = 0, 
            vertexId = 0);
            var vbuf = buffer.vData, ibuf = buffer.iData, vData = sprite.renderData.vData, data0 = datas[0], data3 = datas[3];
            node.updateWorldTransform();
            var pos = node._pos, rot = node._rot, scale = node._scale, ax = data0.x * scale.x, bx = data3.x * scale.x, ay = data0.y * scale.y, by = data3.y * scale.y, qx = rot.x, qy = rot.y, qz = rot.z, qw = rot.w, qxy = qx * qy, qzw = qz * qw, qxy2 = qx * qx - qy * qy, qzw2 = qw * qw - qz * qz, cx1 = qzw2 + qxy2, cx2 = 2 * (qxy - qzw), cy1 = qzw2 - qxy2, cy2 = 2 * (qxy + qzw), x = pos.x, y = pos.y;
            vData[0] = cx1 * ax + cx2 * ay + x, vData[1] = cy1 * ay + cy2 * ax + y, vData[9] = cx1 * bx + cx2 * ay + x, 
            vData[10] = cy1 * ay + cy2 * bx + y, vData[18] = cx1 * ax + cx2 * by + x, vData[19] = cy1 * by + cy2 * ax + y, 
            vData[27] = cx1 * bx + cx2 * by + x, vData[28] = cy1 * by + cy2 * bx + y, vbuf.set(vData, vertexOffset), 
            ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
            ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3;
        }
    },
    updateVerts: function updateVerts(sprite) {
        var renderData = sprite.renderData;
        if (renderData) {
            var node = sprite.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = 0, b = 0, r = 0, t = 0;
            if (sprite.trim) l = -appx, b = -appy, r = cw - appx, t = ch - appy; else {
                var frame = sprite.spriteFrame, originSize = frame.getOriginalSize(), rect = frame.getRect(), ow = originSize.width, oh = originSize.height, rw = rect.width, rh = rect.height, offset = frame.getOffset(), scaleX = cw / ow, scaleY = ch / oh, trimLeft = offset.x + (ow - rw) / 2, trimRight = offset.x - (ow - rw) / 2;
                l = trimLeft * scaleX - appx, b = (offset.y + (oh - rh) / 2) * scaleY - appy, r = cw + trimRight * scaleX - appx, 
                t = ch + (offset.y - (oh - rh) / 2) * scaleY - appy;
            }
            datas[0].x = l, datas[0].y = b, datas[0].z = 0, datas[3].x = r, datas[3].y = t, 
            datas[3].z = 0, renderData.vertDirty = !1;
        }
    },
    updateUvs: function updateUvs(sprite) {
        var renderData = sprite.renderData, vData = renderData.vData, uv = sprite.spriteFrame.uv;
        vData[3] = uv[0], vData[4] = uv[1], vData[12] = uv[2], vData[13] = uv[3], vData[21] = uv[4], 
        vData[22] = uv[5], vData[30] = uv[6], vData[31] = uv[7], renderData.uvDirty = !1;
    },
    updateColor: function updateColor(sprite) {
        for (var vData = sprite.renderData.vData, colorOffset = 5, color = sprite.color, colorr = color.r / 255, colorg = color.g / 255, colorb = color.b / 255, colora = color.a / 255, _i = 0; _i < 4; _i++) vData[colorOffset] = colorr, 
        vData[colorOffset + 1] = colorg, vData[colorOffset + 2] = colorb, vData[colorOffset + 3] = colora, 
        colorOffset += 9;
    }
}, vec3_temp$1 = new Vec3(), matrix$1 = new Mat4(), sliced = {
    useModel: !1,
    createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        return renderData.dataLength = 20, renderData.vertexCount = 16, renderData.indiceCount = 54, 
        renderData;
    },
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        renderData && frame && (renderData.vertDirty && (this.updateVerts(sprite), this.updateWorldVerts(sprite)));
    },
    updateVerts: function updateVerts(sprite) {
        var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, frame = sprite.spriteFrame, leftWidth = frame.insetLeft, rightWidth = frame.insetRight, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, sizableWidth = width - leftWidth - rightWidth, sizableHeight = height - topHeight - bottomHeight, xScale = width / (leftWidth + rightWidth), yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale, yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale, 
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth, sizableHeight = sizableHeight < 0 ? 0 : sizableHeight, 
        datas[0].x = -appx, datas[0].y = -appy, datas[1].x = leftWidth * xScale - appx, 
        datas[1].y = bottomHeight * yScale - appy, datas[2].x = datas[1].x + sizableWidth, 
        datas[2].y = datas[1].y + sizableHeight, datas[3].x = width - appx, datas[3].y = height - appy, 
        renderData.vertDirty = !1;
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
        var buffer = renderer.currBufferBatch, renderData = sprite.renderData, datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset, uvSliced = sprite.spriteFrame.uvSliced;
        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexOffset = 0, indiceOffset = 0, vertexId = 0);
        for (var vbuf = buffer.vData, ibuf = buffer.iData, i = 4; i < 20; ++i) {
            var vert = datas[i], uvs = uvSliced[i - 4];
            vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
            vbuf[vertexOffset++] = uvs.u, vbuf[vertexOffset++] = uvs.v, Color.array(vbuf, sprite.color, vertexOffset), 
            vertexOffset += 4;
        }
        for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
            var start = vertexId + 4 * r + c;
            ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 4, 
            ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 5, ibuf[indiceOffset++] = start + 4;
        }
    },
    updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, datas = sprite.renderData.datas;
        node.getWorldMatrix(matrix$1);
        for (var row = 0; row < 4; ++row) for (var rowD = datas[row], col = 0; col < 4; ++col) {
            var colD = datas[col], world = datas[4 + 4 * row + col];
            Vec3.set(vec3_temp$1, colD.x, rowD.y, 0), Vec3.transformMat4(world, vec3_temp$1, matrix$1);
        }
    }
}, SpriteType$1 = SpriteComponent.Type, FillType$2 = SpriteComponent.FillType, spriteAssembler = {
    getAssembler: function getAssembler(spriteComp) {
        var util = simple, comp = spriteComp;
        switch (comp.type) {
          case SpriteType$1.SLICED:
            util = sliced;
            break;

          case SpriteType$1.FILLED:
            util = comp.fillType === FillType$2.RADIAL ? radialFilled : barFilled;
        }
        return util;
    }
};

SpriteComponent.Assembler = spriteAssembler;

var MeshBuffer = function() {
    function MeshBuffer(batcher) {
        _classCallCheck(this, MeshBuffer), this.batcher = void 0, this.vData = null, this.iData = null, 
        this.vb = null, this.ib = null, this.ia = null, this.byteStart = 0, this.byteOffset = 0, 
        this.indiceStart = 0, this.indiceOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, 
        this.dirty = !1, this._vertexFormatBytes = 9 * Float32Array.BYTES_PER_ELEMENT, this._initVDataCount = 256 * this._vertexFormatBytes, 
        this._initIDataCount = 1536, this._outofCallback = null, this.batcher = batcher;
    }
    return _createClass(MeshBuffer, [ {
        key: "initialize",
        value: function initialize(attrs, outofCallback) {
            this._outofCallback = outofCallback;
            var vbStride = 9 * Float32Array.BYTES_PER_ELEMENT;
            this.vb = this.vb || this.batcher.device.createBuffer({
                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 0,
                stride: vbStride
            });
            var ibStride = Uint16Array.BYTES_PER_ELEMENT;
            this.ib = this.ib || this.batcher.device.createBuffer({
                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: 0,
                stride: ibStride
            }), this.ia = this.ia || this.batcher.device.createInputAssembler({
                attributes: attrs,
                vertexBuffers: [ this.vb ],
                indexBuffer: this.ib
            }), this._reallocBuffer();
        }
    }, {
        key: "request",
        value: function request() {
            var vertexCount = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4, indiceCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 6, byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes, indiceOffset = this.indiceOffset + indiceCount;
            if (vertexCount + this.vertexOffset > 65535) return this.batcher.autoMergeBatches(), 
            this._outofCallback && this._outofCallback.call(this.batcher, vertexCount, indiceCount), 
            !1;
            var byteLength = this.vData.byteLength, indiceLength = this.iData.length;
            if (byteOffset > byteLength || indiceOffset > indiceLength) {
                for (;byteLength < byteOffset || indiceLength < indiceOffset; ) this._initVDataCount *= 2, 
                this._initIDataCount *= 2, byteLength = 4 * this._initVDataCount, indiceLength = this._initIDataCount;
                this._reallocBuffer();
            }
            return this.vertexOffset += vertexCount, this.indiceOffset += indiceCount, this.byteOffset = byteOffset, 
            this.dirty = !0, !0;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.byteStart = 0, this.byteOffset = 0, this.indiceStart = 0, this.indiceOffset = 0, 
            this.vertexStart = 0, this.vertexOffset = 0, this.dirty = !1;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.ib.destroy(), this.vb.destroy(), this.ia.destroy(), this.ib = null, this.vb = null, 
            this.ia = null;
        }
    }, {
        key: "uploadData",
        value: function uploadData() {
            if (0 !== this.byteOffset && this.dirty) {
                var vertexsData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2), indicesData = new Uint16Array(this.iData.buffer, 0, this.indiceOffset);
                this.byteOffset > this.vb.size && this.vb.resize(this.byteOffset), this.vb.update(vertexsData), 
                2 * this.indiceOffset > this.ib.size && this.ib.resize(2 * this.indiceOffset), this.ib.update(indicesData);
            }
        }
    }, {
        key: "_reallocBuffer",
        value: function _reallocBuffer() {
            this._reallocVData(!0), this._reallocIData(!0);
        }
    }, {
        key: "_reallocVData",
        value: function _reallocVData(copyOldData) {
            var oldVData;
            if (this.vData && (oldVData = new Uint8Array(this.vData.buffer)), this.vData = new Float32Array(this._initVDataCount), 
            oldVData && copyOldData) for (var newData = new Uint8Array(this.vData.buffer), i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
        }
    }, {
        key: "_reallocIData",
        value: function _reallocIData(copyOldData) {
            var oldIData = this.iData;
            if (this.iData = new Uint16Array(this._initIDataCount), oldIData && copyOldData) for (var iData = this.iData, i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
        }
    } ]), MeshBuffer;
}();

cc.UI = {
    MeshBuffer: MeshBuffer,
    UIVertexFormat: UIVertexFormat,
    barFilled: barFilled,
    radialFilled: radialFilled,
    simple: simple,
    sliced: sliced,
    ttf: ttf,
    bmfont: bmfont,
    letter: letter,
    mask: maskAssembler,
    maskEnd: maskEndAssembler,
    graphics: graphicsAssembler,
    spriteAssembler: spriteAssembler,
    graphicsAssembler: graphicsAssemblerManager,
    labelAssembler: labelAssembler
};

var UIBatchModel = function(_Model) {
    function UIBatchModel(scene) {
        var _this;
        return _classCallCheck(this, UIBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIBatchModel).call(this, scene, null)))._subModel = void 0, 
        _this._subModel = new UISubModel(), _this;
    }
    return _inherits(UIBatchModel, Model), _createClass(UIBatchModel, [ {
        key: "updateTransform",
        value: function updateTransform() {}
    }, {
        key: "updateUBOs",
        value: function updateUBOs() {
            return !1;
        }
    }, {
        key: "initialize",
        value: function initialize(ia, batch) {
            this._subModel.directInitialize(ia, batch.material, batch.pipelineState), this._subModels[0] = this._subModel;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._subModel.destroy();
        }
    } ]), UIBatchModel;
}(), UISubModel = function(_SubModel) {
    function UISubModel() {
        var _this2;
        return _classCallCheck(this, UISubModel), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(UISubModel).call(this))).psos = [], 
        _this2;
    }
    return _inherits(UISubModel, SubModel), _createClass(UISubModel, [ {
        key: "directInitialize",
        value: function directInitialize(ia, mat, pso) {
            this._inputAssembler = ia, this.psos[0] = pso, this.material = mat;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.commandBuffers.length > 0 && this.commandBuffers[0].destroy();
        }
    } ]), UISubModel;
}(), UIMaterial = function() {
    function UIMaterial() {
        _classCallCheck(this, UIMaterial), this._material = null, this._pass = null, this._psos = void 0, 
        this._psos = null;
    }
    return _createClass(UIMaterial, [ {
        key: "material",
        get: function get() {
            return this._material;
        }
    }, {
        key: "pass",
        get: function get() {
            return this._pass;
        }
    } ]), _createClass(UIMaterial, [ {
        key: "initialize",
        value: function initialize(info) {
            var _this = this;
            return !!info.material && (this._material = info.material, this._pass = this._material.passes[0], 
            this._psos = new Pool$1(function() {
                return _this._pass.createPipelineState();
            }, 1), !0);
        }
    }, {
        key: "getPipelineState",
        value: function getPipelineState() {
            return this._psos.alloc();
        }
    }, {
        key: "revertPipelineState",
        value: function revertPipelineState(pso) {
            this._psos.free(pso);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var _this2 = this;
            this._material = null, this._psos && this._psos.clear(function(obj) {
                _this2._pass.destroyPipelineState(obj);
            });
        }
    } ]), UIMaterial;
}(), UIDrawBatch = function() {
    function UIDrawBatch() {
        _classCallCheck(this, UIDrawBatch), this.camera = null, this.bufferBatch = null, 
        this.model = null, this.material = null, this.texView = null, this.firstIdx = 0, 
        this.idxCount = 0, this.pipelineState = null, this.bindingLayout = null, this.useLocalData = null;
    }
    return _createClass(UIDrawBatch, [ {
        key: "destroy",
        value: function destroy(ui) {
            this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
            this.pipelineState = null), this.bindingLayout && (this.bindingLayout = null);
        }
    }, {
        key: "clear",
        value: function clear(ui) {
            this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
            this.pipelineState = null), this.camera = null, this.bufferBatch = null, this.material = null, 
            this.texView = null, this.firstIdx = 0, this.idxCount = 0, this.model = null;
        }
    } ]), UIDrawBatch;
}(), UI = function() {
    function UI(_root) {
        var _this = this;
        _classCallCheck(this, UI), this._root = _root, this.device = void 0, this._screens = [], 
        this._debugScreen = null, this._bufferBatchPool = new RecyclePool(function() {
            return new MeshBuffer(_this);
        }, 128), this._drawBatchPool = new Pool$1(function() {
            return new UIDrawBatch();
        }, 128), this._cmdBuff = null, this._scene = void 0, this._attributes = [], this._meshBuffers = [], 
        this._meshBufferUseCount = 0, this._uiMaterials = new Map(), this._batches = void 0, 
        this._uiModelPool = null, this._modelInUse = void 0, this._emptyMaterial = Material.getInstantiatedMaterial(new Material(), new cc.RenderableComponent(), !1), 
        this._currMeshBuffer = null, this._currMaterial = this._emptyMaterial, this._currTexView = null, 
        this._currCanvas = -1, this.device = _root.device, this._scene = this._root.createScene({
            name: "GUIScene"
        }), this._uiModelPool = new Pool$1(function() {
            return _this._scene.createModel(UIBatchModel, null);
        }, 2), this._modelInUse = new CachedArray(10), this._batches = new CachedArray(64), 
        cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.update, this);
    }
    return _createClass(UI, [ {
        key: "renderScene",
        get: function get() {
            return this._scene;
        }
    }, {
        key: "currBufferBatch",
        get: function get() {
            return this._currMeshBuffer;
        }
    }, {
        key: "debugScreen",
        get: function get() {
            return this._debugScreen;
        },
        set: function set(value) {
            this._debugScreen = value, this._debugScreen && this._debugScreen.camera && (this._debugScreen.camera.view.visibility = this._screens.length + 1);
        }
    } ]), _createClass(UI, [ {
        key: "initialize",
        value: function initialize() {
            return this._attributes = vfmt, this._requireBufferBatch(), this._cmdBuff = this.device.createCommandBuffer({
                allocator: this.device.commandAllocator,
                type: GFXCommandBufferType.PRIMARY
            }), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._destroyUIMaterials();
            var _iterator = this._batches.array, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.destroy(this);
            }
            var _iterator2 = this._meshBuffers, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                _ref2.destroy();
            }
            this._meshBuffers.splice(0);
            for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                result.value.destroy(), result = matIter.next();
            }
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "getRenderSceneGetter",
        value: function getRenderSceneGetter() {
            return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "renderScene").get.bind(this);
        }
    }, {
        key: "_getUIMaterial",
        value: function _getUIMaterial(mat) {
            if (this._uiMaterials.has(mat.hash)) return this._uiMaterials.get(mat.hash);
            var uiMat = new UIMaterial();
            return uiMat.initialize({
                material: mat
            }), this._uiMaterials.set(mat.hash, uiMat), uiMat;
        }
    }, {
        key: "_removeUIMaterial",
        value: function _removeUIMaterial(hash) {
            this._uiMaterials.has(hash) && this._uiMaterials.delete(hash);
        }
    }, {
        key: "addScreen",
        value: function addScreen(comp) {
            this._screens.push(comp), comp.camera && (comp.camera.view.visibility = this._screens.length), 
            this._debugScreen && this._debugScreen.camera && (this._debugScreen.camera.view.visibility = this._screens.length + 1);
        }
    }, {
        key: "getScreen",
        value: function getScreen(visibility) {
            for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                var screen = screens[i];
                if (screen.camera && screen.camera.view.visibility === visibility) return screen;
            }
            return this._debugScreen && this._debugScreen.camera && this._debugScreen.camera.view.visibility === visibility ? this._debugScreen : null;
        }
    }, {
        key: "removeScreen",
        value: function removeScreen(comp) {
            var idx = this._screens.indexOf(comp);
            if (-1 !== idx) {
                var camera;
                this._screens.splice(idx, 1), this._debugScreen && this._debugScreen.camera && (this._debugScreen.camera.view.visibility = this._screens.length + 1);
                for (var i = idx; i < this._screens.length; i++) (camera = this._screens[i].camera) && (camera.view.visibility = i);
            }
        }
    }, {
        key: "update",
        value: function update(dt) {
            if (this._renderScreens(), this._batches.length > 0) for (var buffers = this._meshBuffers, i = 0; i < buffers.length; ++i) {
                var bufferBatch = buffers[i];
                bufferBatch.uploadData(), bufferBatch.reset();
            }
            this.render(), this._reset();
        }
    }, {
        key: "render",
        value: function render() {
            for (var batchPriority = 0, i = 0; i < this._modelInUse.length; i++) this._modelInUse.get(i).enabled = !1, 
            this._uiModelPool.free(this._modelInUse.get(i));
            if (this._modelInUse.clear(), this._batches.length) for (var _i3 = 0; _i3 < this._batches.length; ++_i3) {
                var batch = this._batches.array[_i3];
                if (batch.model) {
                    batch.camera && (batch.model.viewID = batch.camera.view.visibility);
                    for (var j = 0; j < batch.model.subModelNum; j++) batch.model.getSubModel(j).priority = batchPriority++;
                } else {
                    var bindingLayout = batch.bindingLayout;
                    bindingLayout.bindTextureView(UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT, batch.texView), 
                    bindingLayout.update();
                    var ia = batch.bufferBatch.ia;
                    ia.firstIndex = batch.firstIdx, ia.indexCount = batch.idxCount;
                    var uiModel = this._uiModelPool.alloc();
                    uiModel.initialize(ia, batch), uiModel.enabled = !0, uiModel.getSubModel(0).priority = batchPriority++, 
                    batch.camera && (uiModel.viewID = batch.camera.view.visibility), this._modelInUse.push(uiModel);
                }
            }
        }
    }, {
        key: "commitComp",
        value: function commitComp(comp) {
            var frame = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, assembler = arguments.length > 2 ? arguments[2] : void 0, renderComp = comp, texView = frame;
            this._currMaterial.hash === renderComp.material.hash && this._currTexView === texView && this._currCanvas === renderComp.visibility || (this.autoMergeBatches(), 
            this._currMaterial = renderComp.material, this._currTexView = texView, this._currCanvas = renderComp.visibility), 
            assembler && assembler.fillBuffers(renderComp, this);
        }
    }, {
        key: "commitModel",
        value: function commitModel(comp, model, mat) {
            if ((this._currMaterial !== this._emptyMaterial && this.autoMergeBatches(), mat) && (StencilManager.sharedManager.handleMaterial(mat) && model)) for (var i = 0; i < model.subModelNum; i++) model.setSubModelMaterial(i, mat);
            var uiCanvas = this.getScreen(comp.visibility), curDrawBatch = this._drawBatchPool.alloc();
            curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.model = model, curDrawBatch.bufferBatch = null, 
            curDrawBatch.material = mat, curDrawBatch.texView = null, curDrawBatch.firstIdx = 0, 
            curDrawBatch.idxCount = 0, curDrawBatch.pipelineState = null, curDrawBatch.bindingLayout = null, 
            this._currMaterial = this._emptyMaterial, this._currTexView = null, this._currCanvas = comp.visibility, 
            this._batches.push(curDrawBatch);
        }
    }, {
        key: "autoMergeBatches",
        value: function autoMergeBatches() {
            var mat = this._currMaterial, buffer = this._currMeshBuffer, indicsStart = buffer.indiceStart, vCount = buffer.indiceOffset - indicsStart;
            if (vCount && mat) {
                var uiCanvas = this.getScreen(this._currCanvas);
                StencilManager.sharedManager.handleMaterial(mat);
                var curDrawBatch = this._drawBatchPool.alloc();
                curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.bufferBatch = this._currMeshBuffer, 
                curDrawBatch.material = mat, curDrawBatch.texView = this._currTexView, curDrawBatch.firstIdx = indicsStart, 
                curDrawBatch.idxCount = vCount, curDrawBatch.pipelineState = this._getUIMaterial(mat).getPipelineState(), 
                curDrawBatch.bindingLayout = curDrawBatch.pipelineState.pipelineLayout.layouts[0], 
                this._batches.push(curDrawBatch), buffer.vertexStart = buffer.vertexOffset, buffer.indiceStart = buffer.indiceOffset, 
                buffer.byteStart = buffer.byteOffset;
            }
        }
    }, {
        key: "forceMergeBatches",
        value: function forceMergeBatches(material, sprite) {
            this._currMaterial = material, this._currTexView = sprite, this.autoMergeBatches();
        }
    }, {
        key: "_deleteUIMaterial",
        value: function _deleteUIMaterial(mat) {
            this._uiMaterials.has(mat.hash) && (this._uiMaterials.get(mat.hash).destroy(), this._uiMaterials.delete(mat.hash));
        }
    }, {
        key: "_destroyUIMaterials",
        value: function _destroyUIMaterials() {
            for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                console.log("111111111"), result.value.destroy(), result = matIter.next();
            }
            this._uiMaterials.clear();
        }
    }, {
        key: "_walk",
        value: function _walk(node) {
            var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, len = node.children.length;
            if (this._preprocess(node), len > 0) for (var children = node.children, i = 0; i < children.length; ++i) {
                var child = children[i];
                this._walk(child, level);
            }
            this._postprocess(node), level += 1;
        }
    }, {
        key: "_renderScreens",
        value: function _renderScreens() {
            for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                var screen = screens[i];
                screen.enabledInHierarchy && this._recursiveScreenNode(screen.node);
            }
            this._debugScreen && this._debugScreen.enabledInHierarchy && this._recursiveScreenNode(this._debugScreen.node);
        }
    }, {
        key: "_preprocess",
        value: function _preprocess(c) {
            var render = c._uiComp;
            render && render.enabledInHierarchy && render.updateAssembler(this);
        }
    }, {
        key: "_postprocess",
        value: function _postprocess(c) {
            var render = c._uiComp;
            render && render.enabledInHierarchy && render.postUpdateAssembler(this);
        }
    }, {
        key: "_recursiveScreenNode",
        value: function _recursiveScreenNode(screen) {
            this._walk(screen), this.autoMergeBatches();
        }
    }, {
        key: "_reset",
        value: function _reset() {
            for (var i = 0; i < this._batches.length; ++i) {
                var batch = this._batches.array[i];
                batch.clear(this), this._drawBatchPool.free(batch);
            }
            this._batches.clear(), this._currMaterial = this._emptyMaterial, this._currCanvas = -1, 
            this._currTexView = null, this._meshBufferUseCount = 0, this._requireBufferBatch(), 
            StencilManager.sharedManager.reset();
        }
    }, {
        key: "_createMeshBuffer",
        value: function _createMeshBuffer() {
            var batch = this._bufferBatchPool.add();
            return batch.initialize(this._attributes, this._requireBufferBatch.bind(this)), 
            this._meshBuffers.push(batch), batch;
        }
    }, {
        key: "_requireBufferBatch",
        value: function _requireBufferBatch() {
            this._meshBufferUseCount >= this._meshBuffers.length ? this._currMeshBuffer = this._createMeshBuffer() : this._currMeshBuffer = this._meshBuffers[this._meshBufferUseCount], 
            this._meshBufferUseCount++, 2 === arguments.length && this._currMeshBuffer.request(arguments[0], arguments[1]);
        }
    } ]), UI;
}(), Root = function() {
    function Root(device) {
        _classCallCheck(this, Root), this._createSceneFun = void 0, this._createViewFun = void 0, 
        this._device = void 0, this._windows = [], this._mainWindow = null, this._curWindow = null, 
        this._pipeline = null, this._ui = null, this._scenes = [], this._views = [], this._time = 0, 
        this._frameTime = 0, this._fpsTime = 0, this._frameCount = 0, this._fps = 0, this._device = device, 
        RenderScene.registerCreateFunc(this), RenderView.registerCreateFunc(this);
    }
    return _createClass(Root, [ {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "mainWindow",
        get: function get() {
            return this._mainWindow;
        }
    }, {
        key: "curWindow",
        get: function get() {
            return this._curWindow;
        }
    }, {
        key: "windows",
        get: function get() {
            return this._windows;
        }
    }, {
        key: "pipeline",
        get: function get() {
            return this._pipeline;
        }
    }, {
        key: "ui",
        get: function get() {
            return this._ui;
        }
    }, {
        key: "scenes",
        get: function get() {
            return this._scenes;
        }
    }, {
        key: "views",
        get: function get() {
            return this._views;
        }
    }, {
        key: "cumulativeTime",
        get: function get() {
            return this._time;
        }
    }, {
        key: "frameTime",
        get: function get() {
            return this._frameTime;
        }
    }, {
        key: "frameCount",
        get: function get() {
            return this._frameCount;
        }
    }, {
        key: "fps",
        get: function get() {
            return this._fps;
        }
    } ]), _createClass(Root, [ {
        key: "initialize",
        value: function initialize(info) {
            var _this = this;
            return !!this._device.mainWindow && (this._mainWindow = this._device.mainWindow, 
            this._curWindow = this._mainWindow, builtinResMgr.initBuiltinRes(this._device), 
            this._pipeline = new ForwardPipeline(this), this._pipeline.initialize(info) ? (this._ui = new UI(this), 
            this._ui.initialize() ? (cc.view.on("design-resolution-changed", function() {
                var width = cc.game.canvas.width, height = cc.game.canvas.height;
                _this.resize(width, height);
            }, this), !0) : (this.destroy(), !1)) : (this.destroy(), !1));
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyViews(), this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), 
            this._pipeline = null), this._ui && (this._ui.destroy(), this._ui = null), this._curWindow = null, 
            this._mainWindow = null;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._device.resize(width, height), this._mainWindow.resize(width, height);
            var _iterator = this._windows, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var window = _ref;
                window.isOffscreen || window.resize(width, height);
            }
            this._pipeline && this._pipeline.resize(width, height);
            var _iterator2 = this._views, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var view = _ref2;
                view.camera.isWindowSize && view.camera.resize(width, height);
            }
        }
    }, {
        key: "activeWindow",
        value: function activeWindow(window) {
            this._curWindow = window;
        }
    }, {
        key: "resetCumulativeTime",
        value: function resetCumulativeTime() {
            this._time = 0;
        }
    }, {
        key: "frameMove",
        value: function frameMove(deltaTime) {
            this._frameTime = deltaTime, ++this._frameCount, this._time += this._frameTime, 
            this._fpsTime += this._frameTime, this._fpsTime > 1 && (this._fps = this._frameCount, 
            this._frameCount = 0, this._fpsTime = 0);
            var _iterator3 = this._views, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var view = _ref3;
                view.isEnable && view.window && (view.window.isOffscreen || !view.window.isOffscreen && view.window === this._curWindow) && this._pipeline.render(view);
            }
        }
    }, {
        key: "createWindow",
        value: function createWindow(info) {
            if (this._device) {
                var window = this._device.createWindow(info);
                if (window) return this._windows.push(window), window;
            }
            return null;
        }
    }, {
        key: "destroyWindow",
        value: function destroyWindow(window) {
            for (var i = 0; i < this._windows.length; ++i) if (this._windows[i] === window) return window.destroy(), 
            void this._windows.splice(i, 1);
        }
    }, {
        key: "destroyWindows",
        value: function destroyWindows() {
            var _iterator4 = this._windows, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                _ref4.destroy();
            }
            this._windows = [];
        }
    }, {
        key: "createScene",
        value: function createScene(info) {
            var scene = this._createSceneFun(this);
            return scene.initialize(info), this._scenes.push(scene), scene;
        }
    }, {
        key: "destroyScene",
        value: function destroyScene(scene) {
            for (var i = 0; i < this._scenes.length; ++i) if (this._scenes[i] === scene) return scene.destroy(), 
            void this._scenes.splice(i, 1);
        }
    }, {
        key: "destroyScenes",
        value: function destroyScenes() {
            var _iterator5 = this._scenes, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                _ref5.destroy();
            }
            this._scenes = [];
        }
    }, {
        key: "createView",
        value: function createView(info) {
            var view = this._createViewFun(this, info.camera);
            return view.initialize(info), this._views.push(view), this._views.sort(function(a, b) {
                return a.priority - b.priority;
            }), view;
        }
    }, {
        key: "destroyView",
        value: function destroyView(view) {
            for (var i = 0; i < this._views.length; ++i) if (this._views[i] === view) return this._views.splice(i, 1), 
            void view.destroy();
        }
    }, {
        key: "destroyViews",
        value: function destroyViews() {
            var _iterator6 = this._views, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
            for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                var _ref6;
                if (_isArray6) {
                    if (_i6 >= _iterator6.length) break;
                    _ref6 = _iterator6[_i6++];
                } else {
                    if ((_i6 = _iterator6.next()).done) break;
                    _ref6 = _i6.value;
                }
                _ref6.destroy();
            }
            this._views = [];
        }
    } ]), Root;
}(), Director = function(_EventTarget) {
    function Director() {
        var _this;
        _classCallCheck(this, Director), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Director).call(this))).invalid = void 0, 
        _this._paused = void 0, _this._purgeDirectorInNextLoop = void 0, _this._root = void 0, 
        _this._loadingScene = void 0, _this._scene = void 0, _this._totalFrames = void 0, 
        _this._lastUpdate = void 0, _this._deltaTime = void 0, _this._scheduler = void 0, 
        _this._compScheduler = void 0, _this._nodeActivator = void 0, _this._physicsSystem = void 0, 
        _this._systems = void 0, _this._animationManager = void 0, _this.invalid = !1, _this._paused = !1, 
        _this._purgeDirectorInNextLoop = !1, _this._root = null, _this._loadingScene = "", 
        _this._scene = null, _this._totalFrames = 0, _this._lastUpdate = 0, _this._deltaTime = 0, 
        _this._scheduler = new Scheduler(), _this._compScheduler = new ComponentScheduler(), 
        _this._nodeActivator = new NodeActivator(), _this._physicsSystem = null, _this._systems = [];
        var self = _assertThisInitialized(_this);
        return cc.game.on(Game.EVENT_SHOW, function() {
            self._lastUpdate = performance.now();
        }), cc.game.once(Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(Director, EventTarget), _createClass(Director, [ {
        key: "init",
        value: function init() {
            this._totalFrames = 0, this._lastUpdate = performance.now(), this._paused = !1, 
            this._purgeDirectorInNextLoop = !1, this.sharedInit(), this._root = new Root(cc.game._gfxDevice);
            return !!this._root.initialize({});
        }
    }, {
        key: "sharedInit",
        value: function sharedInit() {
            eventManager && eventManager.setEnabled(!0), cc.AnimationManager ? (this._animationManager = new cc.AnimationManager(), 
            this._scheduler.scheduleUpdate(this._animationManager, Scheduler.PRIORITY_SYSTEM, !1)) : this._animationManager = null, 
            widgetManager && widgetManager.init(this), this._physicsSystem = new cc.PhysicsSystem(), 
            cc.loader.init(this);
        }
    }, {
        key: "calculateDeltaTime",
        value: function calculateDeltaTime() {
            var now = performance.now();
            this._deltaTime = (now - this._lastUpdate) / 1e3, this._lastUpdate = now;
        }
    }, {
        key: "convertToGL",
        value: function convertToGL(uiPoint) {
            var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, x = view._devicePixelRatio * (uiPoint.x - left), y = view._devicePixelRatio * (top + box.height - uiPoint.y);
            return view._isRotated ? cc.v2(view._viewportRect.width - y, x) : cc.v2(x, y);
        }
    }, {
        key: "convertToUI",
        value: function convertToUI(glPoint) {
            var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, uiPoint = cc.v2(0, 0);
            return view._isRotated ? (uiPoint.x = left + glPoint.y / view._devicePixelRatio, 
            uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio) : (uiPoint.x = left + glPoint.x * view._devicePixelRatio, 
            uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio), uiPoint;
        }
    }, {
        key: "end",
        value: function end() {
            this._purgeDirectorInNextLoop = !0;
        }
    }, {
        key: "getWinSize",
        value: function getWinSize() {
            return cc.size(cc.winSize);
        }
    }, {
        key: "getWinSizeInPixels",
        value: function getWinSizeInPixels() {
            return cc.size(cc.winSize);
        }
    }, {
        key: "pause",
        value: function pause() {
            this._paused || (this._paused = !0);
        }
    }, {
        key: "purgeCachedData",
        value: function purgeCachedData() {
            cc.loader.releaseAll();
        }
    }, {
        key: "purgeDirector",
        value: function purgeDirector() {
            this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), 
            eventManager && eventManager.setEnabled(!1), cc.isValid(this._scene) && this._scene.destroy(), 
            this._scene = null, this.stopAnimation(), null != this._root && this._root.destroy(), 
            this._root = null, cc.loader.releaseAll();
        }
    }, {
        key: "reset",
        value: function reset() {
            var _this2 = this;
            this.purgeDirector(), eventManager && eventManager.setEnabled(!0), this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, !1), 
            this._systems.forEach(function(sys) {
                _this2._scheduler.scheduleUpdate(sys, sys._priority, !1);
            }), this.startAnimation();
        }
    }, {
        key: "runSceneImmediate",
        value: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
            cc.assertID(scene instanceof cc.Scene, 1216);
            var uuid = cc.loader._getReferenceKey(scene.uuid);
            cc.loader.removeItem(uuid), scene._load();
            for (var persistNodeList = Object.keys(cc.game._persistRootNodes).map(function(x) {
                return cc.game._persistRootNodes[x];
            }), i = 0; i < persistNodeList.length; i++) {
                var node = persistNodeList[i];
                node.emit(cc.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                var existNode = scene.getChildByUuid(node.uuid);
                if (existNode) {
                    var index = existNode.getSiblingIndex();
                    existNode._destroyImmediate(), scene.insertChild(node, index);
                } else node.parent = scene;
            }
            var oldScene = this._scene;
            (function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
                var releaseSettings = cc.loader._autoReleaseSetting, excludeMap = createMap();
                if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = !0;
                for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
                if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
                    var key = oldSceneAssets[_i3];
                    !1 === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
                }
                for (var keys = Object.keys(releaseSettings), _i4 = 0; _i4 < keys.length; _i4++) {
                    var _key = keys[_i4];
                    !0 !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
                }
            })(oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets, scene.dependAssets, persistNodeList), 
            cc.isValid(oldScene) && oldScene.destroy(), this._scene = null, CCObject._deferredDestroy(), 
            onBeforeLoadScene && onBeforeLoadScene(), this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene), 
            this._scene = scene, scene._activate(), this._root && this._root.resetCumulativeTime(), 
            this.startAnimation(), onLaunched && onLaunched(null, scene), this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
        }
    }, {
        key: "runScene",
        value: function runScene(scene, onBeforeLoadScene, onLaunched) {
            var _this3 = this;
            cc.assertID(scene, 1205), cc.assertID(scene instanceof cc.Scene, 1216), scene._load(), 
            this.once(cc.Director.EVENT_AFTER_UPDATE, function() {
                _this3.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
            });
        }
    }, {
        key: "_getSceneUuid",
        value: function _getSceneUuid(key) {
            var scenes = cc.game._sceneInfos;
            if ("string" == typeof key) {
                key.endsWith(".scene") || (key += ".scene"), "/" === key[0] || key.startsWith("db://") || (key = "/" + key);
                for (var i = 0; i < scenes.length; i++) {
                    var info = scenes[i];
                    if (info.url.endsWith(key)) return info;
                }
            } else if ("number" == typeof key) {
                if (0 <= key && key < scenes.length) return scenes[key];
                cc.errorID(1206, key);
            } else cc.errorID(1207, key);
            return null;
        }
    }, {
        key: "loadScene",
        value: function loadScene(sceneName, onLaunched, _onUnloaded) {
            if (this._loadingScene) return cc.errorID(1208, sceneName, this._loadingScene), 
            !1;
            var info = this._getSceneUuid(sceneName);
            if (info) {
                var uuid = info.uuid;
                return this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), this._loadingScene = sceneName, 
                this._loadSceneByUuid(uuid, onLaunched, _onUnloaded), !0;
            }
            return cc.errorID(1209, sceneName), !1;
        }
    }, {
        key: "preloadScene",
        value: function preloadScene(sceneName, onProgress, onLoaded) {
            void 0 === onLoaded && (onLoaded = onProgress, onProgress = null);
            var info = this._getSceneUuid(sceneName);
            if (info) this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), cc.loader.load({
                uuid: info.uuid,
                type: "uuid"
            }, onProgress, function(error, asset) {
                error && cc.errorID(1210, sceneName, error.message), onLoaded && onLoaded(error, asset);
            }); else {
                var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
                onLoaded(new Error(error)), cc.error("preloadScene: " + error);
            }
        }
    }, {
        key: "_loadSceneByUuid",
        value: function _loadSceneByUuid(uuid) {
            var onLaunched = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, onUnloaded = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            arguments.length > 3 && arguments[3];
            console.time("LoadScene " + uuid), cc.AssetLibrary.loadAsset(uuid, function(error, sceneAsset) {
                console.timeEnd("LoadScene " + uuid);
                var self = cc.director;
                if (self._loadingScene = "", error) error = "Failed to load scene: " + error, cc.error(error); else {
                    if (sceneAsset instanceof cc.SceneAsset) {
                        var scene = sceneAsset.scene;
                        return scene._id = sceneAsset._uuid, scene._name = sceneAsset._name, void self.runSceneImmediate(scene, onUnloaded, onLaunched);
                    }
                    error = "The asset " + uuid + " is not a scene", cc.error(error);
                }
                onLaunched && onLaunched(error);
            });
        }
    }, {
        key: "resume",
        value: function resume() {
            this._paused && (this._lastUpdate = performance.now(), this._lastUpdate || cc.logID(1200), 
            this._paused = !1, this._deltaTime = 0);
        }
    }, {
        key: "setDepthTest",
        value: function setDepthTest(value) {
            cc.Camera.main && (cc.Camera.main.depth = !!value);
        }
    }, {
        key: "setClearColor",
        value: function setClearColor(clearColor) {
            cc.Camera.main && (cc.Camera.main.backgroundColor = clearColor);
        }
    }, {
        key: "getRunningScene",
        value: function getRunningScene() {
            return this._scene;
        }
    }, {
        key: "getScene",
        value: function getScene() {
            return this._scene;
        }
    }, {
        key: "getAnimationInterval",
        value: function getAnimationInterval() {
            return 1e3 / cc.game.getFrameRate();
        }
    }, {
        key: "setAnimationInterval",
        value: function setAnimationInterval(value) {
            cc.game.setFrameRate(Math.round(1e3 / value));
        }
    }, {
        key: "getDeltaTime",
        value: function getDeltaTime() {
            return this._deltaTime;
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._lastUpdate;
        }
    }, {
        key: "getTotalFrames",
        value: function getTotalFrames() {
            return this._totalFrames;
        }
    }, {
        key: "isPaused",
        value: function isPaused() {
            return this._paused;
        }
    }, {
        key: "getScheduler",
        value: function getScheduler() {
            return this._scheduler;
        }
    }, {
        key: "setScheduler",
        value: function setScheduler(scheduler) {
            this._scheduler !== scheduler && (this._scheduler = scheduler);
        }
    }, {
        key: "registerSystem",
        value: function registerSystem(name, cls, compClsNames, priority) {
            var sys = new cls();
            return sys._id = name, sys._priority = priority, compClsNames.forEach(function(compName) {
                getClassByName(compName).system = sys;
            }), this._scheduler.scheduleUpdate(sys, priority, !1), sys.init(), this._systems.push(sys), 
            sys;
        }
    }, {
        key: "getSystem",
        value: function getSystem(name) {
            return this._systems.find(function(sys) {
                return sys._id === name;
            });
        }
    }, {
        key: "getAnimationManager",
        value: function getAnimationManager() {
            return this._animationManager;
        }
    }, {
        key: "startAnimation",
        value: function startAnimation() {
            this.invalid = !1, this._lastUpdate = performance.now();
        }
    }, {
        key: "stopAnimation",
        value: function stopAnimation() {
            this.invalid = !0;
        }
    }, {
        key: "mainLoop",
        value: function mainLoop(time) {
            this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || (this.calculateDeltaTime(), 
            this._paused || (this.emit(Director.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), 
            this._compScheduler.updatePhase(this._deltaTime), this._scheduler.update(this._deltaTime), 
            this._compScheduler.lateUpdatePhase(this._deltaTime), this.emit(Director.EVENT_AFTER_UPDATE), 
            CCObject._deferredDestroy()), null != window.TWEEN && window.TWEEN.update(time), 
            this.emit(Director.EVENT_BEFORE_PHYSICS), this._physicsSystem.update(this._deltaTime), 
            this.emit(Director.EVENT_AFTER_PHYSICS), this.emit(Director.EVENT_BEFORE_DRAW), 
            this._root.frameMove(this._deltaTime), this._root.device.present(), this.emit(Director.EVENT_AFTER_DRAW), 
            eventManager.frameUpdateListeners(), this._scene && this._scene.resetHasChangedFlags(), 
            this._totalFrames++);
        }
    }, {
        key: "root",
        get: function get() {
            return this._root;
        }
    } ]), Director;
}();

Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", 
Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", Director.EVENT_BEFORE_UPDATE = "director_before_update", 
Director.EVENT_AFTER_UPDATE = "director_after_update", Director.EVENT_BEFORE_DRAW = "director_before_draw", 
Director.EVENT_AFTER_DRAW = "director_after_draw", Director.EVENT_BEFORE_PHYSICS = "director_before_physics", 
Director.EVENT_AFTER_PHYSICS = "director_after_physics";

var _dec$11, _dec2$I, _dec3$w, _dec4$q, _dec5$o, _class$12, _class2$T, _descriptor$Q, _descriptor2$H, _descriptor3$t, _class3$v, _temp$X, director = cc.director = new Director();

cc.Director = Director;

var _dec$12, _dec2$J, _dec3$x, _dec4$r, _dec5$p, _dec6$m, _dec7$f, _class$13, _class2$U, _descriptor$R, _descriptor2$I, _temp$Y, _dec$13, _dec2$K, _dec3$y, _dec4$s, _dec5$q, _dec6$n, _dec7$g, _class$14, _class2$V, _descriptor$S, _descriptor2$J, _descriptor3$u, _descriptor4$q, _descriptor5$l, _descriptor6$e, _dec8$a, _dec9$7, _dec10$6, _dec11$5, _dec12$5, _dec13$3, _dec14$3, _dec15$3, _class4$3, _class5$3, _descriptor7$d, _descriptor8$d, _descriptor9$c, _dec$14, _dec2$L, _dec3$z, _dec4$t, _dec5$r, _class$15, _class2$W, _descriptor$T, _descriptor2$K, _descriptor3$v, _descriptor4$r, _descriptor5$m, _dec6$o, _dec7$h, _dec8$b, _dec9$8, _dec10$7, _dec11$6, _dec12$6, _class4$4, _class5$4, _descriptor6$f, _descriptor7$e, _descriptor8$e, _dec$15, _dec2$M, _class$16, _class2$X, _descriptor$U, _descriptor2$L, _descriptor3$w, _class3$w, _temp$$, _dec$16, _dec2$N, _dec3$A, _class$17, _class2$Y, _descriptor$V, _class$18, _dec$18, _dec2$O, _dec3$B, _dec4$u, _class$19, _class2$Z, _descriptor$W, _descriptor2$M, _descriptor3$x, _descriptor4$s, _dec$19, _dec2$P, _dec3$C, _dec4$v, _dec5$s, _class$1a, _class2$_, _descriptor$X, _descriptor2$N, _descriptor3$y, _descriptor4$t, _descriptor5$n, _descriptor6$g, _descriptor7$f, _descriptor8$f, _class3$x, _temp$13, _class$1b, _class2$$, _descriptor$Y, _descriptor2$O, _class4$5, _class5$5, _descriptor3$z, _descriptor4$u, _class7$2, _class8$2, _descriptor5$o, _descriptor6$h, _descriptor7$g, _class9, _temp3$2, _dec$1b, _dec2$R, _dec3$E, _dec4$w, _dec5$t, _dec6$p, _class$1c, _class2$10, _descriptor$Z, _descriptor2$P, _descriptor3$A, _descriptor4$v, _descriptor5$p, _descriptor6$i, _descriptor7$h, _class3$y, _temp$15, _dec$1c, _dec2$S, _dec3$F, _dec4$x, _dec5$u, _dec6$q, _dec7$i, _dec8$c, _dec9$9, _dec10$8, _dec11$7, _dec12$7, _dec13$4, _class$1d, _class2$11, _descriptor$_, _descriptor2$Q, _descriptor3$B, _descriptor4$w, _descriptor5$q, _descriptor6$j, _descriptor7$i, _dec$1d, _dec2$T, _dec3$G, _class$1e, _class2$12, _descriptor$$, _descriptor2$R, _dec$1e, _dec2$U, _dec3$H, _dec4$y, _dec5$v, _dec6$r, _class$1f, _class2$13, _descriptor$10, _descriptor2$S, _descriptor3$C, _descriptor4$x, _descriptor5$r, ModelShadowCastingMode = Enum({
    OFF: 0,
    ON: 1
}), ModelComponent = (_dec$11 = ccclass("cc.ModelComponent"), _dec2$I = executionOrder(100), 
_dec3$w = menu("Components/ModelComponent"), _dec4$q = property({
    type: Mesh
}), _dec5$o = property({
    type: ModelShadowCastingMode
}), _dec$11(_class$12 = _dec2$I(_class$12 = _dec3$w(_class$12 = executeInEditMode((_temp$X = _class3$v = function(_RenderableComponent) {
    function ModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
        _initializerDefineProperty(_this, "_mesh", _descriptor$Q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor2$H, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_receiveShadows", _descriptor3$t, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ModelComponent, RenderableComponent), _createClass(ModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._model && (this._model.inited || this._updateModels(), this._model.enabled = !0);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._model && (this._model.enabled = !1);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._model && (this._getRenderScene().destroyModel(this._model), this._model = null);
        }
    }, {
        key: "_getModel",
        value: function _getModel() {
            return this._model;
        }
    }, {
        key: "recreateModel",
        value: function recreateModel() {
            this.isValid && (this._model && (this._model.destroy(), this._model.scene.destroyModel(this._model), 
            this._model = null), this._updateModels());
        }
    }, {
        key: "_updateModels",
        value: function _updateModels() {
            this.enabledInHierarchy && this._mesh && (this._model && this._model.inited ? this._model.destroy() : this._createModel(), 
            this._model.createBoundingShape(this._mesh.minPosition, this._mesh.maxPosition), 
            this._updateModelParams(), this._model && (this._model.enabled = !0));
        }
    }, {
        key: "_createModel",
        value: function _createModel() {
            if (this.node.scene) {
                var scene = this._getRenderScene();
                this._model = scene.createModel(this._getModelConstructor(), this.node), this._model.viewID = this.visibility;
            }
        }
    }, {
        key: "_getModelConstructor",
        value: function _getModelConstructor() {
            return Model;
        }
    }, {
        key: "_updateModelParams",
        value: function _updateModelParams() {
            if (this._mesh && this._model) {
                this.node._hasChangedFlags = this._model.transform._hasChangedFlags = !0;
                for (var meshCount = this._mesh ? this._mesh.subMeshCount : 0, i = 0; i < meshCount; ++i) {
                    var material = this.getSharedMaterial(i), renderingMesh = this._mesh.renderingMesh;
                    if (renderingMesh) {
                        var subMeshData = renderingMesh.getSubmesh(i);
                        subMeshData && this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                }
            }
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(idx, material) {
            null != this._model && this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(idx, material) {
            this._model && this._model.setSubModelMaterial(idx, material);
        }
    }, {
        key: "_onMeshChanged",
        value: function _onMeshChanged(old) {}
    }, {
        key: "_clearMaterials",
        value: function _clearMaterials() {
            if (null != this._model) for (var i = 0; i < this._model.subModelNum; ++i) this._onMaterialModified(i, null);
        }
    }, {
        key: "_getBuiltinMaterial",
        value: function _getBuiltinMaterial() {
            return builtinResMgr.get("missing-material");
        }
    }, {
        key: "_onVisiblityChange",
        value: function _onVisiblityChange(val) {
            this._model && (this._model.viewID = val);
        }
    }, {
        key: "_updateCastShadow",
        value: function _updateCastShadow() {
            this._model && (this._shadowCastingMode === ModelShadowCastingMode.OFF ? this._model.castShadow = !1 : this._shadowCastingMode === ModelShadowCastingMode.ON ? this._model.castShadow = !0 : console.warn("ShadowCastingMode ".concat(this._shadowCastingMode, " is not supported.")));
        }
    }, {
        key: "_updateReceiveShadow",
        value: function _updateReceiveShadow() {
            this.enabledInHierarchy && this._model;
        }
    }, {
        key: "mesh",
        get: function get() {
            return this._mesh;
        },
        set: function set(val) {
            var old = this._mesh;
            this._mesh = val, this._onMeshChanged(old), this._updateModels();
        }
    }, {
        key: "shadowCastingMode",
        get: function get() {
            return this._shadowCastingMode;
        },
        set: function set(val) {
            this._shadowCastingMode = val, this._updateCastShadow();
        }
    }, {
        key: "receiveShadows",
        get: function get() {
            return this._receiveShadows;
        },
        set: function set(val) {
            this._receiveShadows = val, this._updateReceiveShadow();
        }
    }, {
        key: "model",
        get: function get() {
            return this._model;
        }
    } ]), ModelComponent;
}(), _class3$v.ShadowCastingMode = ModelShadowCastingMode, _class2$T = _temp$X, 
_applyDecoratedDescriptor(_class2$T.prototype, "mesh", [ _dec4$q ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "mesh"), _class2$T.prototype), 
_applyDecoratedDescriptor(_class2$T.prototype, "shadowCastingMode", [ _dec5$o ], Object.getOwnPropertyDescriptor(_class2$T.prototype, "shadowCastingMode"), _class2$T.prototype), 
_descriptor$Q = _applyDecoratedDescriptor(_class2$T.prototype, "_mesh", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$H = _applyDecoratedDescriptor(_class2$T.prototype, "_shadowCastingMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ModelShadowCastingMode.OFF;
    }
}), _descriptor3$t = _applyDecoratedDescriptor(_class2$T.prototype, "_receiveShadows", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$12 = _class2$T)) || _class$12) || _class$12) || _class$12) || _class$12), SkinningModelComponent = (_dec$12 = ccclass("cc.SkinningModelComponent"), 
_dec2$J = executionOrder(100), _dec3$x = menu("Components/SkinningModelComponent"), 
_dec4$r = property(Skeleton), _dec5$p = property(Node$1), _dec6$m = property({
    type: Skeleton
}), _dec7$f = property({
    type: Node$1
}), _dec$12(_class$13 = _dec2$J(_class$13 = executeInEditMode(_class$13 = _dec3$x((_temp$Y = function(_ModelComponent) {
    function SkinningModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SkinningModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_skeleton", _descriptor$R, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$I, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SkinningModelComponent, ModelComponent), _createClass(SkinningModelComponent, [ {
        key: "uploadAnimation",
        value: function uploadAnimation(clip) {
            this._model && this._model.uploadAnimation(clip);
        }
    }, {
        key: "_updateModelParams",
        value: function _updateModelParams() {
            this._update(), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_updateModelParams", this).call(this);
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(index, material) {
            var type = selectJointsMediumType(cc.director.root && cc.director.root.device), mat = this.getMaterial(index) || this._getBuiltinMaterial();
            mat.recompileShaders({
                CC_USE_SKINNING: type
            }), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_onMaterialModified", this).call(this, index, mat);
        }
    }, {
        key: "_getModelConstructor",
        value: function _getModelConstructor() {
            return SkinningModel;
        }
    }, {
        key: "_getBuiltinMaterial",
        value: function _getBuiltinMaterial() {
            return builtinResMgr.get("missing-skinning-material");
        }
    }, {
        key: "_update",
        value: function _update() {
            var _this2 = this;
            this._model && this._model.bindSkeleton(this._skeleton, this._skinningRoot), this._materials.forEach(function(material, index) {
                return material && _this2._onMaterialModified(index, material);
            });
        }
    }, {
        key: "skeleton",
        get: function get() {
            return this._skeleton;
        },
        set: function set(val) {
            this._skeleton = val, this._update();
        }
    }, {
        key: "skinningRoot",
        get: function get() {
            return this._skinningRoot;
        },
        set: function set(value) {
            this._skinningRoot = value, this._update();
        }
    }, {
        key: "model",
        get: function get() {
            return this._model;
        }
    }, {
        key: "frameID",
        set: function set(val) {
            this._model && this._model.setFrameID(val);
        },
        get: function get() {
            return this._model ? this._model.getFrameID() : 0;
        }
    } ]), SkinningModelComponent;
}(), _class2$U = _temp$Y, _descriptor$R = _applyDecoratedDescriptor(_class2$U.prototype, "_skeleton", [ _dec4$r ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$I = _applyDecoratedDescriptor(_class2$U.prototype, "_skinningRoot", [ _dec5$p ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$U.prototype, "skeleton", [ _dec6$m ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "skeleton"), _class2$U.prototype), 
_applyDecoratedDescriptor(_class2$U.prototype, "skinningRoot", [ _dec7$f ], Object.getOwnPropertyDescriptor(_class2$U.prototype, "skinningRoot"), _class2$U.prototype), 
_class$13 = _class2$U)) || _class$13) || _class$13) || _class$13) || _class$13), _vec2$2 = new Vec2(), AvatarUnit = (_dec$13 = ccclass("cc.AvatarUnit"), 
_dec2$K = property(Mesh), _dec3$y = property(Skeleton), _dec4$s = property(Node$1), 
_dec5$q = property(Texture2D), _dec6$n = property({
    type: Texture2D
}), _dec7$g = property({
    type: SkinningModelComponent
}), _dec$13((_descriptor$S = _applyDecoratedDescriptor((_class2$V = function() {
    function AvatarUnit() {
        _classCallCheck(this, AvatarUnit), _initializerDefineProperty(this, "mesh", _descriptor$S, this), 
        _initializerDefineProperty(this, "skeleton", _descriptor2$J, this), _initializerDefineProperty(this, "skinningRoot", _descriptor3$u, this), 
        _initializerDefineProperty(this, "_offset", _descriptor4$q, this), _initializerDefineProperty(this, "_atlasSize", _descriptor5$l, this), 
        _initializerDefineProperty(this, "_albedoMap", _descriptor6$e, this);
    }
    return _createClass(AvatarUnit, [ {
        key: "atlasSize",
        set: function set(atlasSize) {
            Vec2.copy(this._atlasSize, atlasSize);
        },
        get: function get() {
            return this._atlasSize;
        }
    }, {
        key: "offset",
        set: function set(offset) {
            Vec2.copy(this._offset, offset);
        },
        get: function get() {
            return this._offset;
        }
    }, {
        key: "albedoMap",
        get: function get() {
            return this._albedoMap;
        },
        set: function set(albedoMap) {
            this._albedoMap !== albedoMap && (this._albedoMap = albedoMap, this._albedoMap && (_vec2$2.x = this._albedoMap.width, 
            _vec2$2.y = this._albedoMap.height, this.atlasSize = _vec2$2));
        }
    }, {
        key: "source",
        set: function set(comp) {
            comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.skinningRoot = comp.skinningRoot);
        },
        get: function get() {
            return null;
        }
    } ]), AvatarUnit;
}()).prototype, "mesh", [ _dec2$K ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$J = _applyDecoratedDescriptor(_class2$V.prototype, "skeleton", [ _dec3$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$u = _applyDecoratedDescriptor(_class2$V.prototype, "skinningRoot", [ _dec4$s ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$q = _applyDecoratedDescriptor(_class2$V.prototype, "_offset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(0, 0);
    }
}), _descriptor5$l = _applyDecoratedDescriptor(_class2$V.prototype, "_atlasSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(256, 256);
    }
}), _descriptor6$e = _applyDecoratedDescriptor(_class2$V.prototype, "_albedoMap", [ _dec5$q ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$V.prototype, "atlasSize", [ property ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "atlasSize"), _class2$V.prototype), 
_applyDecoratedDescriptor(_class2$V.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "offset"), _class2$V.prototype), 
_applyDecoratedDescriptor(_class2$V.prototype, "albedoMap", [ _dec6$n ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "albedoMap"), _class2$V.prototype), 
_applyDecoratedDescriptor(_class2$V.prototype, "source", [ _dec7$g ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "source"), _class2$V.prototype), 
_class$14 = _class2$V)) || _class$14), getPrefix = function getPrefix(lca, target) {
    for (var prefix = "", cur = target; cur && cur !== lca; ) prefix = "".concat(cur.name, "/") + prefix, 
    cur = cur.parent;
    return prefix;
}, concatPath = function concatPath(prefix, path) {
    return path ? prefix + path : prefix.slice(0, -1);
}, AvatarModelComponent = (_dec8$a = ccclass("cc.AvatarModelComponent"), _dec9$7 = executionOrder(100), 
_dec10$6 = property({
    override: !0,
    visible: !1
}), _dec11$5 = property({
    override: !0,
    visible: !1
}), _dec12$5 = property({
    override: !0,
    visible: !1
}), _dec13$3 = property({
    type: CCInteger
}), _dec14$3 = property({
    type: CCString
}), _dec15$3 = property({
    type: [ AvatarUnit ]
}), _dec8$a(_class4$3 = _dec9$7(_class4$3 = executeInEditMode((_descriptor7$d = _applyDecoratedDescriptor((_class5$3 = function(_SkinningModelCompone) {
    function AvatarModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AvatarModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AvatarModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_combinedTexSize", _descriptor7$d, _assertThisInitialized(_this)), 
        _this._combinedTex = null, _initializerDefineProperty(_this, "_albedoMapName", _descriptor8$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_avatarUnits", _descriptor9$c, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(AvatarModelComponent, SkinningModelComponent), _createClass(AvatarModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(AvatarModelComponent.prototype), "onLoad", this).call(this), 
            this._combinedTex = new Texture2D(), this._combinedTex.onLoaded(), this._combinedTex.setFilters(Filter.LINEAR, Filter.LINEAR), 
            this.resizeCombinedTexture(), this.combine();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._combinedTex && (this._combinedTex.destroy(), this._combinedTex = null), this._mesh && (this._mesh.destroy(), 
            this._mesh = null);
        }
    }, {
        key: "addAvatarUnit",
        value: function addAvatarUnit(unit) {
            this._avatarUnits.push(unit);
        }
    }, {
        key: "clear",
        value: function clear() {
            this._mesh && this._mesh.destroy();
        }
    }, {
        key: "bindTextures",
        value: function bindTextures() {
            if (this._albedoMapName.length > 0 && this._materials.length > 0) {
                var mtrl = this.material;
                mtrl && mtrl.setProperty(this._albedoMapName, this._combinedTex);
            }
        }
    }, {
        key: "combine",
        value: function combine() {
            this.combineTextures(), this.combineSkeletons(), this.combineMeshes(), this.bindTextures();
        }
    }, {
        key: "combineTextures",
        value: function combineTextures() {
            var isValid = !1, _iterator = this._avatarUnits, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                if (_ref.albedoMap) {
                    isValid = !0;
                    break;
                }
            }
            if (isValid) {
                var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], _iterator2 = this._avatarUnits, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _unit = _ref2;
                    if (_unit) {
                        var offset = _unit.offset;
                        if ((isValid = offset.x >= 0 && offset.y >= 0) && _unit.albedoMap && _unit.albedoMap.image && _unit.albedoMap.image.data) {
                            var region = new GFXBufferTextureCopy();
                            region.texOffset.x = offset.x, region.texOffset.y = offset.y, region.texExtent.width = _unit.albedoMap.image.width, 
                            region.texExtent.height = _unit.albedoMap.image.height;
                            var data = _unit.albedoMap.image.data;
                            data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                            texImageRegions.push(region)) : (texBuffers.push(data.buffer), texBufferRegions.push(region));
                        }
                    }
                }
                var gfxTex = this._combinedTex.getGFXTexture(), device = cc.director.root.device;
                texBuffers.length > 0 && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
                texImages.length > 0 && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
            }
        }
    }, {
        key: "combineSkeletons",
        value: function combineSkeletons() {
            var lca = null, _iterator3 = this._avatarUnits, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var unit = _ref3;
                if (unit && unit.skinningRoot) {
                    var cur = unit.skinningRoot;
                    lca = lca ? LCA(lca, cur) : cur;
                }
            }
            if (this._skinningRoot = lca, lca) {
                var skeleton = new Skeleton(), bindposes = [], _iterator4 = this._avatarUnits, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    var _unit2 = _ref4;
                    if (_unit2 && _unit2.skeleton && _unit2.skinningRoot) for (var partial = _unit2.skeleton, prefix = getPrefix(lca, _unit2.skinningRoot), _loop = function _loop(i) {
                        var path = concatPath(prefix, partial.joints[i]);
                        if (skeleton.joints.findIndex(function(p) {
                            return p === path;
                        }) >= 0) return "continue";
                        skeleton.joints.push(path), bindposes.push(partial.bindposes[i] || new Mat4());
                    }, i = 0; i < partial.joints.length; i++) _loop(i);
                }
                var idxMap = _toConsumableArray(Array(skeleton.joints.length).keys()).sort(function(a, b) {
                    return skeleton.joints[a] > skeleton.joints[b] ? 1 : skeleton.joints[a] < skeleton.joints[b] ? -1 : 0;
                });
                skeleton.joints = skeleton.joints.map(function(_, idx, arr) {
                    return arr[idxMap[idx]];
                }), skeleton.bindposes = bindposes.map(function(_, idx, arr) {
                    return arr[idxMap[idx]];
                }), _set(_getPrototypeOf(AvatarModelComponent.prototype), "skeleton", skeleton, this, !0);
            } else console.warn("illegal skinning roots");
        }
    }, {
        key: "combineMeshes",
        value: function combineMeshes() {
            var _this2 = this, isValid = !1, _iterator5 = this._avatarUnits, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                var _ref5;
                if (_isArray5) {
                    if (_i5 >= _iterator5.length) break;
                    _ref5 = _iterator5[_i5++];
                } else {
                    if ((_i5 = _iterator5.next()).done) break;
                    _ref5 = _i5.value;
                }
                if (_ref5.mesh) {
                    isValid = !0;
                    break;
                }
            }
            if (this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh(), isValid && this._skinningRoot) {
                for (var dataView, uvOffset = 0, uvFormat = GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = GFXFormat.UNKNOWN, jointIndexMap = new Array(this._avatarUnits.length), avatarLen = this._avatarUnits.length, _loop2 = function _loop2(i) {
                    var unit = _this2._avatarUnits[i];
                    if (!unit || !unit.skeleton || !unit.skinningRoot) return "continue";
                    var prefix = getPrefix(_this2._skinningRoot, unit.skinningRoot);
                    jointIndexMap[i] = unit.skeleton.joints.map(function(j) {
                        var path = concatPath(prefix, j);
                        return _this2._skeleton.joints.findIndex(function(ref) {
                            return path === ref;
                        });
                    });
                }, i = 0; i < avatarLen; i++) _loop2(i);
                var _loop3 = function _loop3(i) {
                    var unit = _this2._avatarUnits[i];
                    if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                    var offset = unit.offset, meshData = unit.mesh.data.slice(), newMesh = new Mesh();
                    newMesh.reset({
                        struct: unit.mesh.struct,
                        data: meshData
                    }), dataView = new DataView(meshData.buffer);
                    var _loop5 = function _loop5() {
                        if (_isArray6) {
                            if (_i6 >= _iterator6.length) return "break";
                            _ref6 = _iterator6[_i6++];
                        } else {
                            if ((_i6 = _iterator6.next()).done) return "break";
                            _ref6 = _i6.value;
                        }
                        var bundle = _ref6;
                        uvOffset = bundle.view.offset, uvFormat = GFXFormat.UNKNOWN;
                        var _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            if (_isArray7) {
                                if (_i7 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i7++];
                            } else {
                                if ((_i7 = _iterator7.next()).done) break;
                                _ref7 = _i7.value;
                            }
                            var attr = _ref7;
                            if (attr.name.indexOf(GFXAttributeName.ATTR_TEX_COORD) >= 0) {
                                uvFormat = attr.format;
                                break;
                            }
                            uvOffset += GFXFormatInfos[attr.format].size;
                        }
                        uvFormat && mapBuffer(dataView, function(cur, idx) {
                            var comp = 0 === idx ? "x" : "y";
                            return ((cur = function repeat(n) {
                                return n - Math.floor(n);
                            }(cur)) * unit.atlasSize[comp] + offset[comp]) / _this2._combinedTexSize;
                        }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                        var idxMap = jointIndexMap[i];
                        if (!idxMap) return "continue";
                        jointOffset = bundle.view.offset, jointFormat = GFXFormat.UNKNOWN;
                        var _iterator8 = bundle.attributes, _isArray8 = Array.isArray(_iterator8), _i8 = 0;
                        for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                            var _ref8;
                            if (_isArray8) {
                                if (_i8 >= _iterator8.length) break;
                                _ref8 = _iterator8[_i8++];
                            } else {
                                if ((_i8 = _iterator8.next()).done) break;
                                _ref8 = _i8.value;
                            }
                            var _attr = _ref8;
                            if (_attr.name === GFXAttributeName.ATTR_JOINTS) {
                                jointFormat = _attr.format;
                                break;
                            }
                            jointOffset += GFXFormatInfos[_attr.format].size;
                        }
                        jointFormat && mapBuffer(dataView, function(cur) {
                            return idxMap[cur];
                        }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    };
                    var _iterator6 = unit.mesh.struct.vertexBundles, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                    _loop4: for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        switch (_loop5()) {
                          case "break":
                            break _loop4;

                          case "continue":
                            continue;
                        }
                    }
                    _this2._mesh.merge(newMesh);
                };
                for (i = 0; i < avatarLen; i++) _loop3(i);
                this._onMeshChanged(this._mesh), this._updateModels();
            }
        }
    }, {
        key: "resizeCombinedTexture",
        value: function resizeCombinedTexture() {
            this._combinedTex && (this._combinedTex.destroy(), this._combinedTex.reset({
                width: this._combinedTexSize,
                height: this._combinedTexSize,
                format: PixelFormat.RGBA8888
            }));
        }
    }, {
        key: "mesh",
        get: function get() {
            return this._mesh;
        }
    }, {
        key: "skeleton",
        get: function get() {
            return this._skeleton;
        }
    }, {
        key: "skinningRoot",
        get: function get() {
            return this._skinningRoot;
        }
    }, {
        key: "combinedTexSize",
        get: function get() {
            return this._combinedTexSize;
        },
        set: function set(size) {
            this._combinedTexSize = size;
        }
    }, {
        key: "albedoMapName",
        get: function get() {
            return this._albedoMapName;
        },
        set: function set(name) {
            this._albedoMapName !== name && (this._albedoMapName = name);
        }
    }, {
        key: "avatarUnits",
        get: function get() {
            return this._avatarUnits;
        },
        set: function set(units) {
            this._avatarUnits = units;
        }
    } ]), AvatarModelComponent;
}()).prototype, "_combinedTexSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1024;
    }
}), _descriptor8$d = _applyDecoratedDescriptor(_class5$3.prototype, "_albedoMapName", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor9$c = _applyDecoratedDescriptor(_class5$3.prototype, "_avatarUnits", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class5$3.prototype, "mesh", [ _dec10$6 ], Object.getOwnPropertyDescriptor(_class5$3.prototype, "mesh"), _class5$3.prototype), 
_applyDecoratedDescriptor(_class5$3.prototype, "skeleton", [ _dec11$5 ], Object.getOwnPropertyDescriptor(_class5$3.prototype, "skeleton"), _class5$3.prototype), 
_applyDecoratedDescriptor(_class5$3.prototype, "skinningRoot", [ _dec12$5 ], Object.getOwnPropertyDescriptor(_class5$3.prototype, "skinningRoot"), _class5$3.prototype), 
_applyDecoratedDescriptor(_class5$3.prototype, "combinedTexSize", [ _dec13$3 ], Object.getOwnPropertyDescriptor(_class5$3.prototype, "combinedTexSize"), _class5$3.prototype), 
_applyDecoratedDescriptor(_class5$3.prototype, "albedoMapName", [ _dec14$3 ], Object.getOwnPropertyDescriptor(_class5$3.prototype, "albedoMapName"), _class5$3.prototype), 
_applyDecoratedDescriptor(_class5$3.prototype, "avatarUnits", [ _dec15$3 ], Object.getOwnPropertyDescriptor(_class5$3.prototype, "avatarUnits"), _class5$3.prototype), 
_class4$3 = _class5$3)) || _class4$3) || _class4$3) || _class4$3), batch_id = {
    name: GFXAttributeName.ATTR_BATCH_ID,
    format: GFXFormat.R32F,
    isNormalized: !1
}, batch_uv = {
    name: GFXAttributeName.ATTR_BATCH_UV,
    format: GFXFormat.RG32F,
    isNormalized: !1
}, batch_extras_size = GFXFormatInfos[batch_id.format].size + GFXFormatInfos[batch_uv.format].size, SkinningModelUnit = (_dec$14 = ccclass("cc.SkinningModelUnit"), 
_dec2$L = property(Mesh), _dec3$z = property(Skeleton), _dec4$t = property(Material), 
_dec5$r = property({
    type: SkinningModelComponent
}), _dec$14((_descriptor$T = _applyDecoratedDescriptor((_class2$W = function() {
    function SkinningModelUnit() {
        _classCallCheck(this, SkinningModelUnit), _initializerDefineProperty(this, "mesh", _descriptor$T, this), 
        _initializerDefineProperty(this, "skeleton", _descriptor2$K, this), _initializerDefineProperty(this, "material", _descriptor3$v, this), 
        _initializerDefineProperty(this, "_offset", _descriptor4$r, this), _initializerDefineProperty(this, "_size", _descriptor5$m, this);
    }
    return _createClass(SkinningModelUnit, [ {
        key: "offset",
        set: function set(offset) {
            Vec2.copy(this._offset, offset);
        },
        get: function get() {
            return this._offset;
        }
    }, {
        key: "size",
        set: function set(size) {
            Vec2.copy(this._size, size);
        },
        get: function get() {
            return this._size;
        }
    }, {
        key: "copyFrom",
        set: function set(comp) {
            comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.material = comp.getSharedMaterial(0));
        },
        get: function get() {
            return null;
        }
    } ]), SkinningModelUnit;
}()).prototype, "mesh", [ _dec2$L ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$K = _applyDecoratedDescriptor(_class2$W.prototype, "skeleton", [ _dec3$z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$v = _applyDecoratedDescriptor(_class2$W.prototype, "material", [ _dec4$t ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$r = _applyDecoratedDescriptor(_class2$W.prototype, "_offset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(0, 0);
    }
}), _descriptor5$m = _applyDecoratedDescriptor(_class2$W.prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(1, 1);
    }
}), _applyDecoratedDescriptor(_class2$W.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "offset"), _class2$W.prototype), 
_applyDecoratedDescriptor(_class2$W.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "size"), _class2$W.prototype), 
_applyDecoratedDescriptor(_class2$W.prototype, "copyFrom", [ _dec5$r ], Object.getOwnPropertyDescriptor(_class2$W.prototype, "copyFrom"), _class2$W.prototype), 
_class$15 = _class2$W)) || _class$15), BatchedSkinningModelComponent = (_dec6$o = ccclass("cc.BatchedSkinningModelComponent"), 
_dec7$h = executionOrder(100), _dec8$b = menu("Components/BatchedSkinningModelComponent"), 
_dec9$8 = property({
    type: [ CCString ]
}), _dec10$7 = property({
    type: [ SkinningModelUnit ]
}), _dec11$6 = property({
    override: !0,
    visible: !1
}), _dec12$6 = property({
    override: !0,
    visible: !1
}), _dec6$o(_class4$4 = _dec7$h(_class4$4 = executeInEditMode(_class4$4 = _dec8$b((_descriptor6$f = _applyDecoratedDescriptor((_class5$4 = function(_SkinningModelCompone) {
    function BatchedSkinningModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, BatchedSkinningModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BatchedSkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "atlasSize", _descriptor6$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "batchableTextureNames", _descriptor7$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "units", _descriptor8$e, _assertThisInitialized(_this)), 
        _this._textures = {}, _this._batchMaterial = null, _this;
    }
    return _inherits(BatchedSkinningModelComponent, SkinningModelComponent), _createClass(BatchedSkinningModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onLoad", this).call(this), 
            this._batchMaterial = this.getSharedMaterial(0), this.cook();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            for (var _i = 0, _Object$keys = Object.keys(this._textures); _i < _Object$keys.length; _i++) {
                var tex = _Object$keys[_i];
                this._textures[tex].destroy();
            }
            this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onDestroy", this).call(this);
        }
    }, {
        key: "cook",
        value: function cook() {
            this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
        }
    }, {
        key: "cookMaterials",
        value: function cookMaterials() {
            var _this2 = this, mat = this.getMaterial(0);
            if (mat && this._batchMaterial && this._batchMaterial.effectAsset) {
                mat.copy(this._batchMaterial), this.resizeAtlases();
                for (var tech = mat.effectAsset.techniques[mat.technique], _loop = function _loop(i) {
                    var pass = tech.passes[i];
                    if (!pass.properties) return "continue";
                    for (var _loop2 = function _loop2() {
                        var prop = _Object$keys2[_i2];
                        if (pass.properties[prop].type >= GFXType.SAMPLER1D) {
                            var tex = null;
                            _this2.batchableTextureNames.find(function(n) {
                                return n === prop;
                            }) ? ((tex = _this2._textures[prop]) || (tex = _this2.createTexture(prop)), _this2.cookTextures(tex, prop, i)) : _this2.units.some(function(u) {
                                return tex = u.material && u.material.getProperty(prop, i);
                            }), tex && mat.setProperty(prop, tex, i);
                        } else {
                            var value = [], _iterator = _this2.units, _isArray = Array.isArray(_iterator), _i3 = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i3 >= _iterator.length) break;
                                    _ref = _iterator[_i3++];
                                } else {
                                    if ((_i3 = _iterator.next()).done) break;
                                    _ref = _i3.value;
                                }
                                var unit = _ref;
                                unit.material && value.push(unit.material.getProperty(prop.slice(0, -3), i));
                            }
                            mat.setProperty(prop, value, i);
                        }
                    }, _i2 = 0, _Object$keys2 = Object.keys(pass.properties); _i2 < _Object$keys2.length; _i2++) _loop2();
                }, i = 0; i < tech.passes.length; i++) _loop(i);
            } else console.warn("incomplete batch material!");
        }
    }, {
        key: "cookSkeletons",
        value: function cookSkeletons() {
            if (this._skinningRoot) {
                var skeleton = new Skeleton(), bindposes = [], _iterator2 = this.units, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i4 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i4++];
                    } else {
                        if ((_i4 = _iterator2.next()).done) break;
                        _ref2 = _i4.value;
                    }
                    var unit = _ref2;
                    if (unit && unit.skeleton) for (var partial = unit.skeleton, _loop3 = function _loop3(i) {
                        var path = partial.joints[i];
                        if (skeleton.joints.findIndex(function(p) {
                            return p === path;
                        }) >= 0) return "continue";
                        skeleton.joints.push(path), bindposes.push(partial.bindposes[i] || new Mat4());
                    }, i = 0; i < partial.joints.length; i++) _loop3(i);
                }
                var idxMap = Array.from(Array(skeleton.joints.length).keys()).sort(function(a, b) {
                    return skeleton.joints[a] > skeleton.joints[b] ? 1 : skeleton.joints[a] < skeleton.joints[b] ? -1 : 0;
                });
                skeleton.joints = skeleton.joints.map(function(_, idx, arr) {
                    return arr[idxMap[idx]];
                }), skeleton.bindposes = bindposes.map(function(_, idx, arr) {
                    return arr[idxMap[idx]];
                }), this._skeleton && this._skeleton.destroy(), this.skeleton = skeleton;
            } else console.warn("no skinning root specified!");
        }
    }, {
        key: "cookMeshes",
        value: function cookMeshes() {
            var _this3 = this, isValid = !1, _iterator3 = this.units, _isArray3 = Array.isArray(_iterator3), _i5 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i5 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i5++];
                } else {
                    if ((_i5 = _iterator3.next()).done) break;
                    _ref3 = _i5.value;
                }
                if (_ref3.mesh) {
                    isValid = !0;
                    break;
                }
            }
            if (this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh(), isValid && this._skinningRoot) {
                for (var dataView, uvOffset = 0, uvFormat = GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = GFXFormat.UNKNOWN, jointIndexMap = new Array(this.units.length), unitLen = this.units.length, i = 0; i < unitLen; i++) {
                    var unit = this.units[i];
                    unit && unit.skeleton && (jointIndexMap[i] = unit.skeleton.joints.map(function(j) {
                        return _this3._skeleton.joints.findIndex(function(ref) {
                            return j === ref;
                        });
                    }));
                }
                for (var _loop4 = function _loop4(_i6) {
                    var unit = _this3.units[_i6];
                    if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                    var newMeshStruct = JSON.parse(JSON.stringify(unit.mesh.struct)), newOffset = 0, _iterator4 = newMeshStruct.vertexBundles, _isArray4 = Array.isArray(_iterator4), _i7 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref4;
                        if (_isArray4) {
                            if (_i7 >= _iterator4.length) break;
                            _ref4 = _iterator4[_i7++];
                        } else {
                            if ((_i7 = _iterator4.next()).done) break;
                            _ref4 = _i7.value;
                        }
                        var vb = _ref4;
                        vb.attributes.push(batch_id), vb.attributes.push(batch_uv), vb.view.offset = newOffset, 
                        vb.view.length += vb.view.count * batch_extras_size, vb.view.stride += batch_extras_size, 
                        newOffset += vb.view.length;
                    }
                    var _iterator5 = newMeshStruct.primitives, _isArray5 = Array.isArray(_iterator5), _i8 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i8 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i8++];
                        } else {
                            if ((_i8 = _iterator5.next()).done) break;
                            _ref5 = _i8.value;
                        }
                        var pm = _ref5;
                        pm.indexView && (pm.indexView.offset = newOffset, newOffset += pm.indexView.length), 
                        pm.geometricInfo && (newOffset = 4 * Math.ceil(newOffset / 4), pm.geometricInfo.view.offset = newOffset, 
                        newOffset += pm.geometricInfo.view.length);
                    }
                    var src = unit.mesh.data, oldOffset = 0, newMeshData = new Uint8Array(newOffset);
                    dataView = new DataView(newMeshData.buffer);
                    for (var k = 0; k < newMeshStruct.vertexBundles.length; k++) {
                        var uvs = unit.mesh.readAttribute(k, GFXAttributeName.ATTR_TEX_COORD), oldView = unit.mesh.struct.vertexBundles[k].view, newView = newMeshStruct.vertexBundles[k].view, oldStride = oldView.stride, newStride = newView.stride;
                        oldOffset = oldView.offset, newOffset = newView.offset;
                        for (var j = 0; j < newView.count; j++) {
                            var srcVertex = src.subarray(oldOffset, oldOffset + oldStride);
                            newMeshData.set(srcVertex, newOffset), dataView.setFloat32(newOffset + oldStride, _i6, cc.sys.isLittleEndian), 
                            dataView.setFloat32(newOffset + oldStride + 4, uvs[2 * j], cc.sys.isLittleEndian), 
                            dataView.setFloat32(newOffset + oldStride + 8, uvs[2 * j + 1], cc.sys.isLittleEndian), 
                            newOffset += newStride, oldOffset += oldStride;
                        }
                    }
                    for (var _k = 0; _k < newMeshStruct.primitives.length; _k++) {
                        var oldPrimitive = unit.mesh.struct.primitives[_k], newPrimitive = newMeshStruct.primitives[_k];
                        if (oldPrimitive.indexView && newPrimitive.indexView) {
                            var _oldStride = oldPrimitive.indexView.stride, _newStride = newPrimitive.indexView.stride;
                            oldOffset = oldPrimitive.indexView.offset, newOffset = newPrimitive.indexView.offset;
                            for (var _j = 0; _j < newPrimitive.indexView.count; _j++) {
                                var srcIndices = src.subarray(oldOffset, oldOffset + _oldStride);
                                newMeshData.set(srcIndices, newOffset), newOffset += _newStride, oldOffset += _oldStride;
                            }
                        }
                        if (oldPrimitive.geometricInfo && newPrimitive.geometricInfo) {
                            var _oldStride2 = oldPrimitive.geometricInfo.view.stride, _newStride2 = newPrimitive.geometricInfo.view.stride;
                            oldOffset = oldPrimitive.geometricInfo.view.offset, newOffset = newPrimitive.geometricInfo.view.offset;
                            for (var _j2 = 0; _j2 < newPrimitive.geometricInfo.view.count; _j2++) {
                                var srcPositions = src.subarray(oldOffset, oldOffset + _oldStride2);
                                newMeshData.set(srcPositions, newOffset), newOffset += _newStride2, oldOffset += _oldStride2;
                            }
                        }
                    }
                    var newMesh = new Mesh();
                    newMesh.reset({
                        struct: newMeshStruct,
                        data: newMeshData
                    });
                    var offset = unit.offset, size = unit.size, _loop6 = function _loop6() {
                        if (_isArray6) {
                            if (_i9 >= _iterator6.length) return "break";
                            _ref6 = _iterator6[_i9++];
                        } else {
                            if ((_i9 = _iterator6.next()).done) return "break";
                            _ref6 = _i9.value;
                        }
                        var bundle = _ref6;
                        uvOffset = bundle.view.offset, uvFormat = GFXFormat.UNKNOWN;
                        var _iterator7 = bundle.attributes, _isArray7 = Array.isArray(_iterator7), _i10 = 0;
                        for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                            var _ref7;
                            if (_isArray7) {
                                if (_i10 >= _iterator7.length) break;
                                _ref7 = _iterator7[_i10++];
                            } else {
                                if ((_i10 = _iterator7.next()).done) break;
                                _ref7 = _i10.value;
                            }
                            var attr = _ref7;
                            if (attr.name === GFXAttributeName.ATTR_BATCH_UV) {
                                uvFormat = attr.format;
                                break;
                            }
                            uvOffset += GFXFormatInfos[attr.format].size;
                        }
                        uvFormat && mapBuffer(dataView, function(cur, idx) {
                            var comp = 0 === idx ? "x" : "y";
                            return (cur = function repeat(n) {
                                return n - Math.floor(n);
                            }(cur)) * size[comp] + offset[comp];
                        }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                        var idxMap = jointIndexMap[_i6];
                        if (!idxMap) return "continue";
                        jointOffset = bundle.view.offset, jointFormat = GFXFormat.UNKNOWN;
                        var _iterator8 = bundle.attributes, _isArray8 = Array.isArray(_iterator8), _i11 = 0;
                        for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                            var _ref8;
                            if (_isArray8) {
                                if (_i11 >= _iterator8.length) break;
                                _ref8 = _iterator8[_i11++];
                            } else {
                                if ((_i11 = _iterator8.next()).done) break;
                                _ref8 = _i11.value;
                            }
                            var _attr = _ref8;
                            if (_attr.name === GFXAttributeName.ATTR_JOINTS) {
                                jointFormat = _attr.format;
                                break;
                            }
                            jointOffset += GFXFormatInfos[_attr.format].size;
                        }
                        jointFormat && mapBuffer(dataView, function(cur) {
                            return idxMap[cur];
                        }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    };
                    var _iterator6 = newMeshStruct.vertexBundles, _isArray6 = Array.isArray(_iterator6), _i9 = 0;
                    _loop5: for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                        var _ref6;
                        switch (_loop6()) {
                          case "break":
                            break _loop5;

                          case "continue":
                            continue;
                        }
                    }
                    _this3._mesh.merge(newMesh);
                }, _i6 = 0; _i6 < unitLen; _i6++) _loop4(_i6);
                this._onMeshChanged(this._mesh), this._updateModels();
            }
        }
    }, {
        key: "cookTextures",
        value: function cookTextures(target, prop, passIdx) {
            var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], _iterator9 = this.units, _isArray9 = Array.isArray(_iterator9), _i12 = 0;
            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                var _ref9;
                if (_isArray9) {
                    if (_i12 >= _iterator9.length) break;
                    _ref9 = _iterator9[_i12++];
                } else {
                    if ((_i12 = _iterator9.next()).done) break;
                    _ref9 = _i12.value;
                }
                var unit = _ref9;
                if (unit.material) {
                    var partial = unit.material.getProperty(prop, passIdx);
                    if (partial && partial.image && partial.image.data) {
                        var region = new GFXBufferTextureCopy();
                        region.texOffset.x = unit.offset.x * this.atlasSize, region.texOffset.y = unit.offset.y * this.atlasSize, 
                        region.texExtent.width = unit.size.x * this.atlasSize, region.texExtent.height = unit.size.y * this.atlasSize;
                        var data = partial.image.data;
                        data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                        texImageRegions.push(region)) : (texBuffers.push(data.buffer), texBufferRegions.push(region));
                    }
                }
            }
            var gfxTex = target.getGFXTexture(), device = cc.director.root.device;
            texBuffers.length > 0 && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
            texImages.length > 0 && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
        }
    }, {
        key: "createTexture",
        value: function createTexture(prop) {
            var tex = new Texture2D();
            return tex.setFilters(Filter.LINEAR, Filter.LINEAR), tex.reset({
                width: this.atlasSize,
                height: this.atlasSize,
                format: PixelFormat.RGBA8888
            }), tex.loaded = !0, this._textures[prop] = tex, tex;
        }
    }, {
        key: "resizeAtlases",
        value: function resizeAtlases() {
            for (var _i13 = 0, _Object$keys3 = Object.keys(this._textures); _i13 < _Object$keys3.length; _i13++) {
                var prop = _Object$keys3[_i13];
                this._textures[prop].reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: PixelFormat.RGBA8888
                });
            }
        }
    }, {
        key: "mesh",
        get: function get() {
            return this._mesh;
        },
        set: function set(val) {
            _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", val, this, !0);
        }
    }, {
        key: "skeleton",
        get: function get() {
            return this._skeleton;
        },
        set: function set(val) {
            _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", val, this, !0);
        }
    } ]), BatchedSkinningModelComponent;
}()).prototype, "atlasSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1024;
    }
}), _descriptor7$e = _applyDecoratedDescriptor(_class5$4.prototype, "batchableTextureNames", [ _dec9$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor8$e = _applyDecoratedDescriptor(_class5$4.prototype, "units", [ _dec10$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class5$4.prototype, "mesh", [ _dec11$6 ], Object.getOwnPropertyDescriptor(_class5$4.prototype, "mesh"), _class5$4.prototype), 
_applyDecoratedDescriptor(_class5$4.prototype, "skeleton", [ _dec12$6 ], Object.getOwnPropertyDescriptor(_class5$4.prototype, "skeleton"), _class5$4.prototype), 
_class4$4 = _class5$4)) || _class4$4) || _class4$4) || _class4$4) || _class4$4), PhotometricTerm = Enum({
    LUMINOUS_POWER: 0,
    LUMINANCE: 1
}), LightComponent = (_dec$15 = ccclass("cc.LightComponent"), _dec2$M = property({
    slide: !0,
    range: [ 1e3, 15e3, 1 ]
}), _dec$15((_temp$$ = _class3$w = function(_Component) {
    function LightComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, LightComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$U, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useColorTemperature", _descriptor2$L, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_colorTemperature", _descriptor3$w, _assertThisInitialized(_this)), 
        _this._type = LightType.UNKNOWN, _this._light = null, _this;
    }
    return _inherits(LightComponent, Component), _createClass(LightComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this._light ? this._light.enabled = !0 : this._createLight();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._light && (this._light.enabled = !1);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._destroyLight();
        }
    }, {
        key: "_createLight",
        value: function _createLight(scene) {
            this._light && (this.color = this._color, this.useColorTemperature = this._useColorTemperature, 
            this.colorTemperature = this._colorTemperature, this._light.node = this.node, this._light.enabled = this.enabledInHierarchy);
        }
    }, {
        key: "_destroyLight",
        value: function _destroyLight(scene) {
            this._light = null;
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            this._color = val, this._light && (this._light.color.x = val.r / 255, this._light.color.y = val.g / 255, 
            this._light.color.z = val.b / 255);
        }
    }, {
        key: "useColorTemperature",
        get: function get() {
            return this._useColorTemperature;
        },
        set: function set(enable) {
            this._useColorTemperature = enable, this._light && (this._light.useColorTemperature = enable);
        }
    }, {
        key: "colorTemperature",
        get: function get() {
            return this._colorTemperature;
        },
        set: function set(val) {
            this._colorTemperature = val, this._light && (this._light.colorTemperature = val);
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ]), LightComponent;
}(), _class3$w.Type = LightType, _class3$w.PhotometricTerm = PhotometricTerm, _descriptor$U = _applyDecoratedDescriptor((_class2$X = _temp$$).prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor2$L = _applyDecoratedDescriptor(_class2$X.prototype, "_useColorTemperature", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$w = _applyDecoratedDescriptor(_class2$X.prototype, "_colorTemperature", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 6550;
    }
}), _applyDecoratedDescriptor(_class2$X.prototype, "color", [ property ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "color"), _class2$X.prototype), 
_applyDecoratedDescriptor(_class2$X.prototype, "useColorTemperature", [ property ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "useColorTemperature"), _class2$X.prototype), 
_applyDecoratedDescriptor(_class2$X.prototype, "colorTemperature", [ _dec2$M ], Object.getOwnPropertyDescriptor(_class2$X.prototype, "colorTemperature"), _class2$X.prototype), 
_class$16 = _class2$X)) || _class$16), DirectionalLightComponent = (_dec$16 = ccclass("cc.DirectionalLightComponent"), 
_dec2$N = menu("Components/DirectionalLightComponent"), _dec3$A = property({
    unit: "lx"
}), _dec$16(_class$17 = _dec2$N(_class$17 = executeInEditMode((_descriptor$V = _applyDecoratedDescriptor((_class2$Y = function(_LightComponent) {
    function DirectionalLightComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, DirectionalLightComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(DirectionalLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_illuminance", _descriptor$V, _assertThisInitialized(_this)), 
        _this._type = LightType.DIRECTIONAL, _this._light = null, _this;
    }
    return _inherits(DirectionalLightComponent, LightComponent), _createClass(DirectionalLightComponent, [ {
        key: "_createLight",
        value: function _createLight(scene) {
            this.node.scene && ((scene = scene || this._getRenderScene()).mainLight.node.activeInHierarchy ? console.warn("there can be only one directional(main) light.") : (this._light = scene.mainLight, 
            this.illuminance = this._illuminance, _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_createLight", this).call(this, scene)));
        }
    }, {
        key: "_destroyLight",
        value: function _destroyLight(scene) {
            this.node.scene && this._light && (this._light.enabled = !1, scene = scene || this._getRenderScene(), 
            this._light.node = scene.defaultMainLightNode, _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_destroyLight", this).call(this, scene));
        }
    }, {
        key: "illuminance",
        get: function get() {
            return this._illuminance;
        },
        set: function set(val) {
            this._illuminance = val, this._light && (this._light.illuminance = this._illuminance);
        }
    } ]), DirectionalLightComponent;
}()).prototype, "_illuminance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 65e3;
    }
}), _applyDecoratedDescriptor(_class2$Y.prototype, "illuminance", [ _dec3$A ], Object.getOwnPropertyDescriptor(_class2$Y.prototype, "illuminance"), _class2$Y.prototype), 
_class$17 = _class2$Y)) || _class$17) || _class$17) || _class$17), EditorCameraComponent = ccclass("cc.EditorCameraComponent")(_class$18 = function(_CameraComponent) {
    function EditorCameraComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, EditorCameraComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditorCameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uiEditorCamera = null, 
        _this;
    }
    return _inherits(EditorCameraComponent, CameraComponent), _createClass(EditorCameraComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(EditorCameraComponent.prototype), "onLoad", this).call(this);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(EditorCameraComponent.prototype), "onEnable", this).call(this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDisable", this).call(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(EditorCameraComponent.prototype), "onDestroy", this).call(this), 
            this._uiEditorCamera && (cc.director.root.ui.renderScene.destroyCamera(this._uiEditorCamera), 
            this._uiEditorCamera = null);
        }
    }, {
        key: "_createCamera",
        value: function _createCamera() {
            var priorCamera = this._camera;
            if (_get(_getPrototypeOf(EditorCameraComponent.prototype), "_createCamera", this).call(this), 
            this._camera !== priorCamera && this._camera) {
                this._uiEditorCamera && (cc.director.root.ui.renderScene.destroyCamera(this._uiEditorCamera), 
                this._uiEditorCamera = null), this._uiEditorCamera = cc.director.root.ui.renderScene.createCamera({
                    name: "Editor UICamera",
                    node: this._camera.node,
                    projection: this._projection,
                    priority: this._priority,
                    isUI: !0,
                    flows: [ "UIFlow" ],
                    window: this._editorWindow
                }), this._uiEditorCamera.viewport = this._camera.viewport, this._uiEditorCamera.fov = this._camera.fov, 
                this._uiEditorCamera.nearClip = this._camera.nearClip, this._uiEditorCamera.farClip = this._camera.farClip;
                var r = this._camera.clearColor.r / 255, g = this._camera.clearColor.g / 255, b = this._camera.clearColor.b / 255, a = this._camera.clearColor.a / 255;
                this._uiEditorCamera.clearColor = {
                    r: r,
                    g: g,
                    b: b,
                    a: a
                }, this._uiEditorCamera.clearDepth = this._camera.clearDepth, this._uiEditorCamera.clearStencil = this._camera.clearStencil, 
                this._uiEditorCamera.clearFlag = this._camera.clearFlag;
            }
        }
    }, {
        key: "_getEditorWindow",
        value: function _getEditorWindow() {
            cc.director.root && (this._editorWindow = cc.director.root.mainWindow);
        }
    }, {
        key: "projection",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "projection", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.projectionType = val);
        }
    }, {
        key: "fov",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "fov", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.fov = toRadian(val));
        }
    }, {
        key: "orthoHeight",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "orthoHeight", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.orthoHeight = val);
        }
    }, {
        key: "near",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "near", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.nearClip = val);
        }
    }, {
        key: "far",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "far", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.farClip = val);
        }
    }, {
        key: "color",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "color", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.clearColor = val);
        }
    }, {
        key: "depth",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "depth", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.clearDepth = val);
        }
    }, {
        key: "stencil",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "stencil", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.clearStencil = val);
        }
    }, {
        key: "clearFlags",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "clearFlags", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.clearFlag = val);
        }
    }, {
        key: "rect",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "rect", val, this, !0), this._uiEditorCamera && (this._uiEditorCamera.viewport = val);
        }
    }, {
        key: "screenScale",
        set: function set(val) {
            _set(_getPrototypeOf(EditorCameraComponent.prototype), "screenScale", val, this, !0), 
            this._uiEditorCamera && (this._uiEditorCamera.screenScale = val);
        }
    } ]), EditorCameraComponent;
}()) || _class$18, BillboardComponent = (_dec$18 = ccclass("cc.BillboardComponent"), 
_dec2$O = menu("Components/BillboardComponent"), _dec3$B = property({
    type: Texture2D
}), _dec4$u = property({
    type: Texture2D
}), _dec$18(_class$19 = _dec2$O(_class$19 = executeInEditMode((_descriptor$W = _applyDecoratedDescriptor((_class2$Z = function(_Component) {
    function BillboardComponent() {
        var _this;
        return _classCallCheck(this, BillboardComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BillboardComponent).call(this)), "_texture", _descriptor$W, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_height", _descriptor2$M, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_width", _descriptor3$x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_rotation", _descriptor4$s, _assertThisInitialized(_this)), 
        _this._model = null, _this._mesh = null, _this._material = null, _this._uniform = cc.v4(1, 1, 0, 0), 
        _this;
    }
    return _inherits(BillboardComponent, Component), _createClass(BillboardComponent, [ {
        key: "texture",
        get: function get() {
            return this._texture;
        },
        set: function set(val) {
            this._texture = val, this._material && this._material.setProperty("mainTexture", val);
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(val) {
            this._height = val, this._material && (this._uniform.y = val, this._material.setProperty("cc_size_rotation", this._uniform));
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(val) {
            this._width = val, this._material && (this._uniform.x = val, this._material.setProperty("cc_size_rotation", this._uniform));
        }
    }, {
        key: "rotation",
        get: function get() {
            return Math.round(100 * toDegree(this._rotation)) / 100;
        },
        set: function set(val) {
            this._rotation = toRadian(val), this._material && (this._uniform.z = this._rotation, 
            this._material.setProperty("cc_size_rotation", this._uniform));
        }
    } ]), _createClass(BillboardComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this._model || this.createModel(), this._model.enabled = !0, this.width = this._width, 
            this.height = this._height, this.rotation = this.rotation, this.texture = this.texture;
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._model && (this._model.enabled = !1);
        }
    }, {
        key: "createModel",
        value: function createModel() {
            this._mesh = createMesh({
                primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST,
                positions: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
                uvs: [ 0, 0, 1, 0, 0, 1, 1, 1 ],
                colors: [ Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a ],
                attributes: [ {
                    name: GFXAttributeName.ATTR_POSITION,
                    format: GFXFormat.RGB32F
                }, {
                    name: GFXAttributeName.ATTR_TEX_COORD,
                    format: GFXFormat.RG32F
                }, {
                    name: GFXAttributeName.ATTR_COLOR,
                    format: GFXFormat.RGBA8UI,
                    isNormalized: !0
                } ],
                indices: [ 0, 1, 2, 1, 2, 3 ]
            }, void 0, {
                calculateBounds: !1
            }), this._model = this._getRenderScene().createModel(Model, this.node), null == this._material && (this._material = new Material(), 
            this._material.copy(builtinResMgr.get("default-billboard-material"))), this._model.initSubModel(0, this._mesh.getSubMesh(0), this._material);
        }
    } ]), BillboardComponent;
}()).prototype, "_texture", [ _dec3$B ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$Z.prototype, "texture", [ _dec4$u ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "texture"), _class2$Z.prototype), 
_descriptor2$M = _applyDecoratedDescriptor(_class2$Z.prototype, "_height", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$Z.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "height"), _class2$Z.prototype), 
_descriptor3$x = _applyDecoratedDescriptor(_class2$Z.prototype, "_width", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$Z.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "width"), _class2$Z.prototype), 
_descriptor4$s = _applyDecoratedDescriptor(_class2$Z.prototype, "_rotation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$Z.prototype, "rotation", [ property ], Object.getOwnPropertyDescriptor(_class2$Z.prototype, "rotation"), _class2$Z.prototype), 
_class$19 = _class2$Z)) || _class$19) || _class$19) || _class$19), _vertex_attrs = [ {
    name: GFXAttributeName.ATTR_POSITION,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD,
    format: GFXFormat.RGBA32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD1,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_COLOR,
    format: GFXFormat.RGBA8,
    isNormalized: !0
} ], _temp_v1 = cc.v3(), _temp_v2 = cc.v3(), LineModel = function(_Model) {
    function LineModel(scene, node) {
        var _this;
        return _classCallCheck(this, LineModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LineModel).call(this, scene, node)))._capacity = void 0, 
        _this._vertSize = 0, _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, 
        _this._vdataUint32 = null, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
        _this._subMeshData = null, _this._vertCount = 0, _this._indexCount = 0, _this._capacity = 100, 
        _this._iaInfo = {
            drawInfos: [ {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            } ]
        }, _this._iaInfoBuffer = _this._device.createBuffer({
            usage: GFXBufferUsageBit.INDIRECT,
            memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
            size: GFX_DRAW_INFO_SIZE,
            stride: 1
        }), _this;
    }
    return _inherits(LineModel, Model), _createClass(LineModel, [ {
        key: "setCapacity",
        value: function setCapacity(capacity) {
            this._capacity = capacity, this.createBuffer();
        }
    }, {
        key: "createBuffer",
        value: function createBuffer() {
            this._vertSize = 0;
            for (var _i = 0, _vertex_attrs2 = _vertex_attrs; _i < _vertex_attrs2.length; _i++) {
                var a = _vertex_attrs2[_i];
                a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
            }
            this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
            this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
        }
    }, {
        key: "_createSubMeshData",
        value: function _createSubMeshData() {
            this._subMeshData && this.destroySubMeshData(), this._vertCount = 2, this._indexCount = 6;
            var vertexBuffer = this._device.createBuffer({
                usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: this._vertSize * this._capacity * this._vertCount,
                stride: this._vertSize
            }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
            vertexBuffer.update(vBuffer);
            for (var indices = new Uint16Array((this._capacity - 1) * this._indexCount), dst = 0, i = 0; i < this._capacity - 1; ++i) {
                var baseIdx = 2 * i;
                indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
            }
            var indexBuffer = this._device.createBuffer({
                usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                size: (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                stride: Uint16Array.BYTES_PER_ELEMENT
            });
            return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
            this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount, 
            this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                vertexBuffers: [ vertexBuffer ],
                indexBuffer: indexBuffer,
                indirectBuffer: this._iaInfoBuffer,
                attributes: _vertex_attrs,
                primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST
            }, this.setSubModelMesh(0, this._subMeshData), vBuffer;
        }
    }, {
        key: "addLineVertexData",
        value: function addLineVertexData(positions, width, color) {
            if (positions.length > 1) {
                var offset = 0;
                Vec3.subtract(_temp_v1, positions[1], positions[0]), this._vdataF32[offset++] = positions[0].x, 
                this._vdataF32[offset++] = positions[0].y, this._vdataF32[offset++] = positions[0].z, 
                this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(0, 1), this._vdataF32[offset++] = 0, 
                this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val, 
                this._vdataF32[offset++] = positions[0].x, this._vdataF32[offset++] = positions[0].y, 
                this._vdataF32[offset++] = positions[0].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(0, 1), 
                this._vdataF32[offset++] = 0, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, 
                this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                for (var i = 1; i < positions.length - 1; i++) {
                    Vec3.subtract(_temp_v1, positions[i - 1], positions[i]), Vec3.subtract(_temp_v2, positions[i + 1], positions[i]), 
                    Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                    var seg = i / positions.length;
                    this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                    this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                    this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v2.x, 
                    this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val, 
                    this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                    this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                    this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v2.x, 
                    this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                }
                Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]), 
                this._vdataF32[offset++] = positions[positions.length - 1].x, this._vdataF32[offset++] = positions[positions.length - 1].y, 
                this._vdataF32[offset++] = positions[positions.length - 1].z, this._vdataF32[offset++] = 0, 
                this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, this._vdataF32[offset++] = 0, 
                this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, 
                this._vdataUint32[offset++] = color.evaluate(1, 1)._val, this._vdataF32[offset++] = positions[positions.length - 1].x, 
                this._vdataF32[offset++] = positions[positions.length - 1].y, this._vdataF32[offset++] = positions[positions.length - 1].z, 
                this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, 
                this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
            }
            this.updateIA(Math.max(0, positions.length - 1));
        }
    }, {
        key: "updateIA",
        value: function updateIA(count) {
            this.getSubModel(0).inputAssembler.vertexBuffers[0].update(this._vdataF32), this.getSubModel(0).inputAssembler.indexCount = this._indexCount * count, 
            this.getSubModel(0).inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), this._iaInfoBuffer.update(this._iaInfo);
        }
    }, {
        key: "destroySubMeshData",
        value: function destroySubMeshData() {
            var _iterator = this._subMeshData.vertexBuffers, _isArray = Array.isArray(_iterator), _i2 = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i2 >= _iterator.length) break;
                    _ref = _iterator[_i2++];
                } else {
                    if ((_i2 = _iterator.next()).done) break;
                    _ref = _i2.value;
                }
                _ref.destroy();
            }
            this._subMeshData.indexBuffer.destroy();
        }
    } ]), LineModel;
}(), Mode$1 = Enum({
    Constant: 0,
    Curve: 1,
    TwoCurves: 2,
    TwoConstants: 3
}), CurveRange = (_dec$19 = ccclass("cc.CurveRange"), _dec2$P = property({
    type: Mode$1
}), _dec3$C = property({
    type: AnimationCurve
}), _dec4$v = property({
    type: AnimationCurve
}), _dec5$s = property({
    type: AnimationCurve
}), _dec$19((_temp$13 = _class3$x = function() {
    function CurveRange() {
        _classCallCheck(this, CurveRange), _initializerDefineProperty(this, "mode", _descriptor$X, this), 
        _initializerDefineProperty(this, "curve", _descriptor2$N, this), _initializerDefineProperty(this, "curveMin", _descriptor3$y, this), 
        _initializerDefineProperty(this, "curveMax", _descriptor4$t, this), _initializerDefineProperty(this, "constant", _descriptor5$n, this), 
        _initializerDefineProperty(this, "constantMin", _descriptor6$g, this), _initializerDefineProperty(this, "constantMax", _descriptor7$f, this), 
        _initializerDefineProperty(this, "multiplier", _descriptor8$f, this);
    }
    return _createClass(CurveRange, [ {
        key: "evaluate",
        value: function evaluate(time, rndRatio) {
            switch (this.mode) {
              case Mode$1.Constant:
                return this.constant;

              case Mode$1.Curve:
                return this.curve.evaluate(time) * this.multiplier;

              case Mode$1.TwoCurves:
                return lerp(this.curveMin.evaluate(time), this.curveMax.evaluate(time), rndRatio) * this.multiplier;

              case Mode$1.TwoConstants:
                return lerp(this.constantMin, this.constantMax, rndRatio);
            }
        }
    }, {
        key: "getMax",
        value: function getMax() {
            switch (this.mode) {
              case Mode$1.Constant:
                return this.constant;

              case Mode$1.Curve:
                return this.multiplier;

              case Mode$1.TwoConstants:
                return this.constantMax;

              case Mode$1.TwoCurves:
                return this.multiplier;
            }
            return 0;
        }
    } ]), CurveRange;
}(), _class3$x.Mode = Mode$1, _descriptor$X = _applyDecoratedDescriptor((_class2$_ = _temp$13).prototype, "mode", [ _dec2$P ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$1.Constant;
    }
}), _descriptor2$N = _applyDecoratedDescriptor(_class2$_.prototype, "curve", [ _dec3$C ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AnimationCurve();
    }
}), _descriptor3$y = _applyDecoratedDescriptor(_class2$_.prototype, "curveMin", [ _dec4$v ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AnimationCurve();
    }
}), _descriptor4$t = _applyDecoratedDescriptor(_class2$_.prototype, "curveMax", [ _dec5$s ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AnimationCurve();
    }
}), _descriptor5$n = _applyDecoratedDescriptor(_class2$_.prototype, "constant", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$g = _applyDecoratedDescriptor(_class2$_.prototype, "constantMin", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$f = _applyDecoratedDescriptor(_class2$_.prototype, "constantMax", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$f = _applyDecoratedDescriptor(_class2$_.prototype, "multiplier", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class$1a = _class2$_)) || _class$1a), Mode$2 = Enum({
    Blend: 0,
    Fixed: 1
}), Gradient = (ccclass("cc.ColorKey")((_descriptor$Y = _applyDecoratedDescriptor((_class2$$ = function ColorKey() {
    _classCallCheck(this, ColorKey), _initializerDefineProperty(this, "color", _descriptor$Y, this), 
    _initializerDefineProperty(this, "time", _descriptor2$O, this);
}).prototype, "color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return cc.Color.WHITE.clone();
    }
}), _descriptor2$O = _applyDecoratedDescriptor(_class2$$.prototype, "time", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$1b = _class2$$)), ccclass("cc.AlphaKey")((_descriptor3$z = _applyDecoratedDescriptor((_class5$5 = function AlphaKey() {
    _classCallCheck(this, AlphaKey), _initializerDefineProperty(this, "alpha", _descriptor3$z, this), 
    _initializerDefineProperty(this, "time", _descriptor4$u, this);
}).prototype, "alpha", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$u = _applyDecoratedDescriptor(_class5$5.prototype, "time", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class4$5 = _class5$5)), ccclass("cc.Gradient")((_temp3$2 = _class9 = function() {
    function Gradient() {
        _classCallCheck(this, Gradient), _initializerDefineProperty(this, "colorKeys", _descriptor5$o, this), 
        _initializerDefineProperty(this, "alphaKeys", _descriptor6$h, this), _initializerDefineProperty(this, "mode", _descriptor7$g, this), 
        this._color = void 0, this._color = cc.Color.WHITE.clone();
    }
    return _createClass(Gradient, [ {
        key: "setKeys",
        value: function setKeys(colorKeys, alphaKeys) {
            this.colorKeys = colorKeys, this.alphaKeys = alphaKeys;
        }
    }, {
        key: "sortKeys",
        value: function sortKeys() {
            this.colorKeys.length > 1 && this.colorKeys.sort(function(a, b) {
                return a.time - b.time;
            }), this.alphaKeys.length > 1 && this.alphaKeys.sort(function(a, b) {
                return a.time - b.time;
            });
        }
    }, {
        key: "evaluate",
        value: function evaluate(time) {
            return this.getRGB(time), this._color._set_a_unsafe(this.getAlpha(time)), this._color;
        }
    }, {
        key: "randomColor",
        value: function randomColor() {
            var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)], a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
            return this._color.set(c.color), this._color._set_a_unsafe(a.alpha), this._color;
        }
    }, {
        key: "getRGB",
        value: function getRGB(time) {
            if (!(this.colorKeys.length > 1)) return 1 === this.colorKeys.length ? (this._color.set(this.colorKeys[0].color), 
            this._color) : (this._color.set(Color.WHITE), this._color);
            time = repeat(time, 1);
            for (var i = 1; i < this.colorKeys.length; ++i) {
                var preTime = this.colorKeys[i - 1].time, curTime = this.colorKeys[i].time;
                if (time >= preTime && time < curTime) {
                    if (this.mode === Mode$2.Fixed) return this.colorKeys[i].color;
                    var factor = (time - preTime) / (curTime - preTime);
                    return Color.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor), 
                    this._color;
                }
            }
            var lastIndex = this.colorKeys.length - 1;
            time < this.colorKeys[0].time ? Color.lerp(this._color, Color.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time) : time > this.colorKeys[lastIndex].time && Color.lerp(this._color, this.colorKeys[lastIndex].color, Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
        }
    }, {
        key: "getAlpha",
        value: function getAlpha(time) {
            if (!(this.alphaKeys.length > 1)) return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
            time = repeat(time, 1);
            for (var i = 1; i < this.alphaKeys.length; ++i) {
                var preTime = this.alphaKeys[i - 1].time, curTime = this.alphaKeys[i].time;
                if (time >= preTime && time < curTime) {
                    if (this.mode === Mode$2.Fixed) return this.alphaKeys[i].alpha;
                    var factor = (time - preTime) / (curTime - preTime);
                    return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                }
            }
            var lastIndex = this.alphaKeys.length - 1;
            return time < this.alphaKeys[0].time ? lerp(255, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time) : time > this.alphaKeys[lastIndex].time ? lerp(this.alphaKeys[lastIndex].alpha, 255, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time)) : void 0;
        }
    } ]), Gradient;
}(), _class9.Mode = Mode$2, _descriptor5$o = _applyDecoratedDescriptor((_class8$2 = _temp3$2).prototype, "colorKeys", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Array();
    }
}), _descriptor6$h = _applyDecoratedDescriptor(_class8$2.prototype, "alphaKeys", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Array();
    }
}), _descriptor7$g = _applyDecoratedDescriptor(_class8$2.prototype, "mode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$2.Blend;
    }
}), _class7$2 = _class8$2)) || _class7$2), Mode$3 = Enum({
    Color: 0,
    Gradient: 1,
    TwoColors: 2,
    TwoGradients: 3,
    RandomColor: 4
}), GradientRange = (_dec$1b = ccclass("cc.GradientRange"), _dec2$R = property({
    type: Mode$3
}), _dec3$E = property({
    type: Gradient
}), _dec4$w = property({
    type: Gradient
}), _dec5$t = property({
    type: Gradient
}), _dec6$p = property({
    type: Mode$3
}), _dec$1b((_temp$15 = _class3$y = function() {
    function GradientRange() {
        _classCallCheck(this, GradientRange), _initializerDefineProperty(this, "color", _descriptor$Z, this), 
        _initializerDefineProperty(this, "colorMin", _descriptor2$P, this), _initializerDefineProperty(this, "colorMax", _descriptor3$A, this), 
        _initializerDefineProperty(this, "gradient", _descriptor4$v, this), _initializerDefineProperty(this, "gradientMin", _descriptor5$p, this), 
        _initializerDefineProperty(this, "gradientMax", _descriptor6$i, this), _initializerDefineProperty(this, "_mode", _descriptor7$h, this), 
        this._color = cc.Color.WHITE.clone();
    }
    return _createClass(GradientRange, [ {
        key: "evaluate",
        value: function evaluate(time, rndRatio) {
            switch (this.mode) {
              case Mode$3.Color:
                return this.color;

              case Mode$3.TwoColors:
                return Color.lerp(this.color, this.colorMin, this.colorMax, rndRatio), this.color;

              case Mode$3.RandomColor:
                return this.gradient.randomColor();

              case Mode$3.Gradient:
                return this.gradient.evaluate(time);

              case Mode$3.TwoGradients:
                return this.colorMin = this.gradientMin.evaluate(time), this.colorMax = this.gradientMax.evaluate(time), 
                Color.lerp(this._color, this.colorMin, this.colorMax, rndRatio), this._color;
            }
        }
    }, {
        key: "mode",
        get: function get() {
            return this._mode;
        },
        set: function set(m) {
            this._mode = m;
        }
    } ]), GradientRange;
}(), _class3$y.Mode = Mode$3, _applyDecoratedDescriptor((_class2$10 = _temp$15).prototype, "mode", [ _dec2$R ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "mode"), _class2$10.prototype), 
_descriptor$Z = _applyDecoratedDescriptor(_class2$10.prototype, "color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return cc.Color.WHITE.clone();
    }
}), _descriptor2$P = _applyDecoratedDescriptor(_class2$10.prototype, "colorMin", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return cc.Color.WHITE.clone();
    }
}), _descriptor3$A = _applyDecoratedDescriptor(_class2$10.prototype, "colorMax", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return cc.Color.WHITE.clone();
    }
}), _descriptor4$v = _applyDecoratedDescriptor(_class2$10.prototype, "gradient", [ _dec3$E ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Gradient();
    }
}), _descriptor5$p = _applyDecoratedDescriptor(_class2$10.prototype, "gradientMin", [ _dec4$w ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Gradient();
    }
}), _descriptor6$i = _applyDecoratedDescriptor(_class2$10.prototype, "gradientMax", [ _dec5$t ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Gradient();
    }
}), _descriptor7$h = _applyDecoratedDescriptor(_class2$10.prototype, "_mode", [ _dec6$p ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$3.Color;
    }
}), _class$1c = _class2$10)) || _class$1c), define$1 = {
    CC_USE_WORLD_SPACE: !1
}, LineComponent = (_dec$1c = ccclass("cc.LineComponent"), _dec2$S = menu("Components/LineComponent"), 
_dec3$F = property({
    type: Texture2D
}), _dec4$x = property({
    type: Texture2D,
    displayOrder: 0
}), _dec5$u = property({
    displayOrder: 1
}), _dec6$q = property({
    type: [ Vec3 ]
}), _dec7$i = property({
    type: [ Vec3 ],
    displayOrder: 2
}), _dec8$c = property({
    type: CurveRange
}), _dec9$9 = property({
    type: CurveRange,
    displayOrder: 3
}), _dec10$8 = property({
    type: Vec2,
    displayOrder: 4
}), _dec11$7 = property({
    type: Vec2,
    displayOrder: 5
}), _dec12$7 = property({
    type: GradientRange
}), _dec13$4 = property({
    type: GradientRange,
    displayOrder: 6
}), _dec$1c(_class$1d = _dec2$S(_class$1d = executeInEditMode((_descriptor$_ = _applyDecoratedDescriptor((_class2$11 = function(_Component) {
    function LineComponent() {
        var _this;
        return _classCallCheck(this, LineComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LineComponent).call(this)), "_texture", _descriptor$_, _assertThisInitialized(_this)), 
        _this._material = null, _initializerDefineProperty(_this, "_worldSpace", _descriptor2$Q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_positions", _descriptor3$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_width", _descriptor4$w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_tile", _descriptor5$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_offset", _descriptor6$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor7$i, _assertThisInitialized(_this)), 
        _this._model = null, _this._tile_offset = cc.v4(), _this;
    }
    return _inherits(LineComponent, Component), _createClass(LineComponent, [ {
        key: "texture",
        get: function get() {
            return this._texture;
        },
        set: function set(val) {
            this._texture = val, this._material && this._material.setProperty("mainTexture", val);
        }
    }, {
        key: "worldSpace",
        get: function get() {
            return this._worldSpace;
        },
        set: function set(val) {
            this._worldSpace = val, this._material && (define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
            this._material.recompileShaders(define$1), this._model && this._model.setSubModelMaterial(0, this._material));
        }
    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(val) {
            this._width = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    }, {
        key: "tile",
        get: function get() {
            return this._tile;
        },
        set: function set(val) {
            this._tile.set(val), this._material && (this._tile_offset.x = this._tile.x, this._tile_offset.y = this._tile.y, 
            this._material.setProperty("mainTiling_Offset", this._tile_offset));
        }
    }, {
        key: "offset",
        get: function get() {
            return this._offset;
        },
        set: function set(val) {
            this._offset.set(val), this._material && (this._tile_offset.z = this._offset.x, 
            this._tile_offset.w = this._offset.y, this._material.setProperty("mainTiling_Offset", this._tile_offset));
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            this._color = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    } ]), _createClass(LineComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this._model || (this._model = this._getRenderScene().createModel(LineModel, this.node), 
            this._model.setCapacity(100), null == this._material && (this._material = new Material(), 
            this._material.copy(builtinResMgr.get("default-trail-material")), define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
            this._material.recompileShaders(define$1)), this._model.setSubModelMaterial(0, this._material)), 
            this._model.enabled = !0, this.texture = this.texture, this.tile = this._tile, this.offset = this._offset, 
            this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._model && (this._model.enabled = !1);
        }
    } ]), LineComponent;
}()).prototype, "_texture", [ _dec3$F ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "texture", [ _dec4$x ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "texture"), _class2$11.prototype), 
_descriptor2$Q = _applyDecoratedDescriptor(_class2$11.prototype, "_worldSpace", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "worldSpace", [ _dec5$u ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "worldSpace"), _class2$11.prototype), 
_descriptor3$B = _applyDecoratedDescriptor(_class2$11.prototype, "_positions", [ _dec6$q ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "positions", [ _dec7$i ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "positions"), _class2$11.prototype), 
_descriptor4$w = _applyDecoratedDescriptor(_class2$11.prototype, "_width", [ _dec8$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "width", [ _dec9$9 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "width"), _class2$11.prototype), 
_descriptor5$q = _applyDecoratedDescriptor(_class2$11.prototype, "_tile", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return cc.v2(1, 1);
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "tile", [ _dec10$8 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "tile"), _class2$11.prototype), 
_descriptor6$j = _applyDecoratedDescriptor(_class2$11.prototype, "_offset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return cc.v2(0, 0);
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "offset", [ _dec11$7 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "offset"), _class2$11.prototype), 
_descriptor7$i = _applyDecoratedDescriptor(_class2$11.prototype, "_color", [ _dec12$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange();
    }
}), _applyDecoratedDescriptor(_class2$11.prototype, "color", [ _dec13$4 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "color"), _class2$11.prototype), 
_class$1d = _class2$11)) || _class$1d) || _class$1d) || _class$1d), ColorOvertimeModule = (_dec$1d = ccclass("cc.ColorOvertimeModule"), 
_dec2$T = property({
    displayOrder: 0
}), _dec3$G = property({
    type: GradientRange,
    displayOrder: 1
}), _dec$1d((_descriptor$$ = _applyDecoratedDescriptor((_class2$12 = function() {
    function ColorOvertimeModule() {
        _classCallCheck(this, ColorOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$$, this), 
        _initializerDefineProperty(this, "color", _descriptor2$R, this);
    }
    return _createClass(ColorOvertimeModule, [ {
        key: "animate",
        value: function animate(particle) {
            this.enable && (particle.color.set(particle.startColor), particle.color.multiply(this.color.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 91041))));
        }
    } ]), ColorOvertimeModule;
}()).prototype, "enable", [ _dec2$T ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$R = _applyDecoratedDescriptor(_class2$12.prototype, "color", [ _dec3$G ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange();
    }
}), _class$1e = _class2$12)) || _class$1e), Space = Enum({
    World: 0,
    Local: 1,
    Custom: 2
}), RenderMode = Enum({
    Billboard: 0,
    StrecthedBillboard: 1,
    HorizontalBillboard: 2,
    VerticalBillboard: 3,
    Mesh: 4
}), ShapeType = Enum({
    Box: 0,
    Circle: 1,
    Cone: 2,
    Sphere: 3,
    Hemisphere: 4
}), EmitLocation = Enum({
    Base: 0,
    Edge: 1,
    Shell: 2,
    Volume: 3
}), ArcMode = Enum({
    Random: 0,
    Loop: 1,
    PingPong: 2
}), TrailMode = Enum({
    Particles: 0,
    Ribbon: 1
}), TextureMode = Enum({
    Stretch: 0,
    Repeat: 1
}), particleEmitZAxis = new Vec3(0, 0, -1);

function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
    return moduleSpace !== systemSpace ? (systemSpace === Space.World ? Mat4.getRotation(outQuat, worldTransform) : (Mat4.invert(worldTransform, worldTransform), 
    Mat4.getRotation(outQuat, worldTransform)), !0) : (Quat.set(outQuat, 0, 0, 0, 1), 
    !1);
}

function fixedAngleUnitVector2(out, theta) {
    Vec2.set(out, Math.cos(theta), Math.sin(theta));
}

function randomUnitVector(out) {
    var z = randomRange(-1, 1), a = randomRange(0, 2 * Math.PI), r = Math.sqrt(1 - z * z), x = r * Math.cos(a), y = r * Math.sin(a);
    Vec3.set(out, x, y, z);
}

function randomPointBetweenSphere(out, minRadius, maxRadius) {
    randomUnitVector(out), Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
}

function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
    fixedAngleUnitVector2(out, theta), out.z = 0, Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
}

function randomSortArray(arr) {
    for (var i = 0; i < arr.length; i++) {
        var transpose = i + randomRangeInt(0, arr.length - i), val = arr[transpose];
        arr[transpose] = arr[i], arr[i] = val;
    }
}

function randomSign() {
    var sgn = randomRange(-1, 1);
    return 0 === sgn && sgn++, sign(sgn);
}

var _dec$1f, _dec2$V, _dec3$I, _dec4$z, _dec5$w, _dec6$s, _dec7$j, _dec8$d, _dec9$a, _class$1g, _class2$14, _descriptor$11, _descriptor2$T, _descriptor3$D, _descriptor4$y, _descriptor5$s, _descriptor6$k, _descriptor7$j, _descriptor8$g, _dec$1g, _dec2$W, _dec3$J, _dec4$A, _dec5$x, _dec6$t, _class$1h, _class2$15, _descriptor$12, _descriptor2$U, _descriptor3$E, _descriptor4$z, _descriptor5$t, _temp_v3 = cc.v3(), ForceOvertimeModule = (_dec$1e = ccclass("cc.ForceOvertimeModule"), 
_dec2$U = property({
    displayOrder: 0
}), _dec3$H = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 2
}), _dec4$y = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 3
}), _dec5$v = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 4
}), _dec6$r = property({
    type: Space,
    displayOrder: 1
}), _dec$1e((_descriptor$10 = _applyDecoratedDescriptor((_class2$13 = function() {
    function ForceOvertimeModule() {
        _classCallCheck(this, ForceOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$10, this), 
        _initializerDefineProperty(this, "x", _descriptor2$S, this), _initializerDefineProperty(this, "y", _descriptor3$C, this), 
        _initializerDefineProperty(this, "z", _descriptor4$x, this), _initializerDefineProperty(this, "space", _descriptor5$r, this), 
        this.randomized = !1, this.rotation = void 0, this.needTransform = void 0, this.rotation = new Quat(), 
        this.needTransform = !1;
    }
    return _createClass(ForceOvertimeModule, [ {
        key: "update",
        value: function update(space, worldTransform) {
            this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
    }, {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 212165)));
            this.needTransform && Vec3.transformQuat(force, force, this.rotation), Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
        }
    } ]), ForceOvertimeModule;
}()).prototype, "enable", [ _dec2$U ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$S = _applyDecoratedDescriptor(_class2$13.prototype, "x", [ _dec3$H ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor3$C = _applyDecoratedDescriptor(_class2$13.prototype, "y", [ _dec4$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$x = _applyDecoratedDescriptor(_class2$13.prototype, "z", [ _dec5$v ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor5$r = _applyDecoratedDescriptor(_class2$13.prototype, "space", [ _dec6$r ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1f = _class2$13)) || _class$1f), _temp_v3$1 = cc.v3(), LimitVelocityOvertimeModule = (_dec$1f = ccclass("cc.LimitVelocityOvertimeModule"), 
_dec2$V = property({
    displayOrder: 0
}), _dec3$I = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 4
}), _dec4$z = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 5
}), _dec5$w = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 6
}), _dec6$s = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 3
}), _dec7$j = property({
    displayOrder: 7
}), _dec8$d = property({
    displayOrder: 2
}), _dec9$a = property({
    type: Space,
    displayOrder: 1
}), _dec$1f((_descriptor$11 = _applyDecoratedDescriptor((_class2$14 = function() {
    function LimitVelocityOvertimeModule() {
        _classCallCheck(this, LimitVelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$11, this), 
        _initializerDefineProperty(this, "limitX", _descriptor2$T, this), _initializerDefineProperty(this, "limitY", _descriptor3$D, this), 
        _initializerDefineProperty(this, "limitZ", _descriptor4$y, this), _initializerDefineProperty(this, "limit", _descriptor5$s, this), 
        _initializerDefineProperty(this, "dampen", _descriptor6$k, this), _initializerDefineProperty(this, "separateAxes", _descriptor7$j, this), 
        _initializerDefineProperty(this, "space", _descriptor8$g, this), this.drag = null, 
        this.multiplyDragByParticleSize = !1, this.multiplyDragByParticleVelocity = !1;
    }
    return _createClass(LimitVelocityOvertimeModule, [ {
        key: "animate",
        value: function animate(p) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, dampedVel = _temp_v3$1;
            this.separateAxes ? Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen)) : (Vec3.normalize(dampedVel, p.ultimateVelocity), 
            Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 23541)), this.dampen))), 
            Vec3.copy(p.ultimateVelocity, dampedVel);
        }
    } ]), LimitVelocityOvertimeModule;
}()).prototype, "enable", [ _dec2$V ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$T = _applyDecoratedDescriptor(_class2$14.prototype, "limitX", [ _dec3$I ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor3$D = _applyDecoratedDescriptor(_class2$14.prototype, "limitY", [ _dec4$z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$y = _applyDecoratedDescriptor(_class2$14.prototype, "limitZ", [ _dec5$w ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor5$s = _applyDecoratedDescriptor(_class2$14.prototype, "limit", [ _dec6$s ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor6$k = _applyDecoratedDescriptor(_class2$14.prototype, "dampen", [ _dec7$j ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 3;
    }
}), _descriptor7$j = _applyDecoratedDescriptor(_class2$14.prototype, "separateAxes", [ _dec8$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor8$g = _applyDecoratedDescriptor(_class2$14.prototype, "space", [ _dec9$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1g = _class2$14)) || _class$1g);

function dampenBeyondLimit(vel, limit, dampen) {
    var sgn = Math.sign(vel), abs = Math.abs(vel);
    return abs > limit && (abs = lerp(abs, limit, dampen)), abs * sgn;
}

var _dec$1h, _dec2$X, _dec3$K, _dec4$B, _dec5$y, _dec6$u, _dec7$k, _class$1i, _class2$16, _descriptor$13, _descriptor2$V, _descriptor3$F, _descriptor4$A, _descriptor5$u, _descriptor6$l, _dec$1i, _dec2$Y, _dec3$L, _dec4$C, _dec5$z, _dec6$v, _dec7$l, _dec8$e, _dec9$b, _dec10$9, _dec11$8, _dec12$8, _class$1j, _class2$17, _descriptor$14, _descriptor2$W, _descriptor3$G, _descriptor4$B, _descriptor5$v, _descriptor6$m, _descriptor7$k, _descriptor8$h, _descriptor9$d, _descriptor10$b, _descriptor11$a, _descriptor12$9, _descriptor13$7, _dec$1j, _dec2$Z, _dec3$M, _dec4$D, _dec5$A, _dec6$w, _dec7$m, _class$1k, _class2$18, _descriptor$15, _descriptor2$X, _descriptor3$H, _descriptor4$C, _descriptor5$w, _descriptor6$n, _dec$1k, _dec2$_, _class$1l, _class2$19, _descriptor$16, _descriptor2$Y, _descriptor3$I, _descriptor4$D, _descriptor5$x, _descriptor6$o, _dec$1l, _dec2$$, _dec3$N, _dec4$E, _dec5$B, _dec6$x, _dec7$n, _dec8$f, _dec9$c, _dec10$a, _dec11$9, _dec12$9, _dec13$5, _dec14$4, _dec15$4, _dec16$2, _dec17$2, _dec18$2, _dec19$1, _dec20, _class$1m, _class2$1a, _descriptor$17, _descriptor2$Z, _descriptor3$J, _descriptor4$E, _descriptor5$y, _descriptor6$p, _descriptor7$l, _descriptor8$i, _descriptor9$e, _descriptor10$c, _descriptor11$b, _descriptor12$a, _descriptor13$8, _descriptor14$7, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$1, _descriptor19$1, RotationOvertimeModule = (_dec$1g = ccclass("cc.RotationOvertimeModule"), 
_dec2$W = property({
    displayOrder: 0
}), _dec3$J = property({
    displayOrder: 1
}), _dec4$A = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 2
}), _dec5$x = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 3
}), _dec6$t = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 4
}), _dec$1g((_descriptor$12 = _applyDecoratedDescriptor((_class2$15 = function() {
    function RotationOvertimeModule() {
        _classCallCheck(this, RotationOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$12, this), 
        _initializerDefineProperty(this, "_separateAxes", _descriptor2$U, this), _initializerDefineProperty(this, "x", _descriptor3$E, this), 
        _initializerDefineProperty(this, "y", _descriptor4$z, this), _initializerDefineProperty(this, "z", _descriptor5$t, this);
    }
    return _createClass(RotationOvertimeModule, [ {
        key: "separateAxes",
        get: function get() {
            return this._separateAxes;
        },
        set: function set(val) {
            val ? console.error("rotation overtime separateAxes is not supported!") : this._separateAxes = val;
        }
    } ]), _createClass(RotationOvertimeModule, [ {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
            this._separateAxes || (p.rotation.x += this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 125292)) * dt);
        }
    } ]), RotationOvertimeModule;
}()).prototype, "enable", [ _dec2$W ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$U = _applyDecoratedDescriptor(_class2$15.prototype, "_separateAxes", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$15.prototype, "separateAxes", [ _dec3$J ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "separateAxes"), _class2$15.prototype), 
_descriptor3$E = _applyDecoratedDescriptor(_class2$15.prototype, "x", [ _dec4$A ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$z = _applyDecoratedDescriptor(_class2$15.prototype, "y", [ _dec5$x ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor5$t = _applyDecoratedDescriptor(_class2$15.prototype, "z", [ _dec6$t ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _class$1h = _class2$15)) || _class$1h), SizeOvertimeModule = (_dec$1h = ccclass("cc.SizeOvertimeModule"), 
_dec2$X = property({
    displayOrder: 0
}), _dec3$K = property({
    displayOrder: 1
}), _dec4$B = property({
    type: CurveRange,
    displayOrder: 2
}), _dec5$y = property({
    type: CurveRange,
    displayOrder: 3
}), _dec6$u = property({
    type: CurveRange,
    displayOrder: 4
}), _dec7$k = property({
    type: CurveRange,
    displayOrder: 5
}), _dec$1h((_descriptor$13 = _applyDecoratedDescriptor((_class2$16 = function() {
    function SizeOvertimeModule() {
        _classCallCheck(this, SizeOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$13, this), 
        _initializerDefineProperty(this, "separateAxes", _descriptor2$V, this), _initializerDefineProperty(this, "size", _descriptor3$F, this), 
        _initializerDefineProperty(this, "x", _descriptor4$A, this), _initializerDefineProperty(this, "y", _descriptor5$u, this), 
        _initializerDefineProperty(this, "z", _descriptor6$l, this);
    }
    return _createClass(SizeOvertimeModule, [ {
        key: "animate",
        value: function animate(particle) {
            this.separateAxes || Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + 39825)));
        }
    } ]), SizeOvertimeModule;
}()).prototype, "enable", [ _dec2$X ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$V = _applyDecoratedDescriptor(_class2$16.prototype, "separateAxes", [ _dec3$K ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$F = _applyDecoratedDescriptor(_class2$16.prototype, "size", [ _dec4$B ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$A = _applyDecoratedDescriptor(_class2$16.prototype, "x", [ _dec5$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor5$u = _applyDecoratedDescriptor(_class2$16.prototype, "y", [ _dec6$u ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor6$l = _applyDecoratedDescriptor(_class2$16.prototype, "z", [ _dec7$k ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _class$1i = _class2$16)) || _class$1i), Mode$4 = Enum({
    Grid: 0
}), Animation = Enum({
    WholeSheet: 0,
    SingleRow: 1
}), TextureAnimationModule = (_dec$1i = ccclass("cc.TextureAnimationModule"), _dec2$Y = property({
    displayOrder: 0
}), _dec3$L = property({
    type: Mode$4
}), _dec4$C = property({
    type: Mode$4,
    displayOrder: 1
}), _dec5$z = property({
    displayOrder: 2
}), _dec6$v = property({
    displayOrder: 3
}), _dec7$l = property({
    type: Animation,
    displayOrder: 4
}), _dec8$e = property({
    type: CurveRange,
    displayOrder: 7
}), _dec9$b = property({
    type: CurveRange,
    displayOrder: 8
}), _dec10$9 = property({
    displayOrder: 9
}), _dec11$8 = property({
    displayOrder: 5
}), _dec12$8 = property({
    displayOrder: 6
}), _dec$1i((_descriptor$14 = _applyDecoratedDescriptor((_class2$17 = function() {
    function TextureAnimationModule() {
        _classCallCheck(this, TextureAnimationModule), _initializerDefineProperty(this, "_enable", _descriptor$14, this), 
        _initializerDefineProperty(this, "_mode", _descriptor2$W, this), _initializerDefineProperty(this, "numTilesX", _descriptor3$G, this), 
        _initializerDefineProperty(this, "numTilesY", _descriptor4$B, this), _initializerDefineProperty(this, "animation", _descriptor5$v, this), 
        _initializerDefineProperty(this, "frameOverTime", _descriptor6$m, this), _initializerDefineProperty(this, "startFrame", _descriptor7$k, this), 
        _initializerDefineProperty(this, "cycleCount", _descriptor8$h, this), _initializerDefineProperty(this, "_flipU", _descriptor9$d, this), 
        _initializerDefineProperty(this, "_flipV", _descriptor10$b, this), _initializerDefineProperty(this, "_uvChannelMask", _descriptor11$a, this), 
        _initializerDefineProperty(this, "randomRow", _descriptor12$9, this), _initializerDefineProperty(this, "rowIndex", _descriptor13$7, this), 
        this.ps = null;
    }
    return _createClass(TextureAnimationModule, [ {
        key: "onInit",
        value: function onInit(ps) {
            this.ps = ps;
        }
    }, {
        key: "animate",
        value: function animate(p) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) / (this.numTilesX * this.numTilesY);
            if (this.animation === Animation.WholeSheet) p.frameIndex = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1); else if (this.animation === Animation.SingleRow) {
                var rowLength = 1 / this.numTilesY;
                if (this.randomRow) {
                    var f = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1), from = Math.floor(Math.random() * this.numTilesY) * rowLength, to = from + rowLength;
                    p.frameIndex = lerp(from, to, f);
                } else {
                    var _from = this.rowIndex * rowLength, _to = _from + rowLength;
                    p.frameIndex = lerp(_from, _to, repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 90794)) + startFrame), 1));
                }
            }
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable = val, this.ps && this.ps.renderer._updateMaterialParams();
        }
    }, {
        key: "mode",
        get: function get() {
            return this._mode;
        },
        set: function set(val) {
            val === Mode$4.Grid || console.error("particle texture animation's sprites is not supported!");
        }
    }, {
        key: "flipU",
        get: function get() {
            return this._flipU;
        },
        set: function set(val) {
            console.error("particle texture animation's flipU is not supported!");
        }
    }, {
        key: "flipV",
        get: function get() {
            return this._flipV;
        },
        set: function set(val) {
            console.error("particle texture animation's flipV is not supported!");
        }
    }, {
        key: "uvChannelMask",
        get: function get() {
            return this._uvChannelMask;
        },
        set: function set(val) {
            console.error("particle texture animation's uvChannelMask is not supported!");
        }
    } ]), TextureAnimationModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$17.prototype, "enable", [ _dec2$Y ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "enable"), _class2$17.prototype), 
_descriptor2$W = _applyDecoratedDescriptor(_class2$17.prototype, "_mode", [ _dec3$L ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$4.Grid;
    }
}), _applyDecoratedDescriptor(_class2$17.prototype, "mode", [ _dec4$C ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "mode"), _class2$17.prototype), 
_descriptor3$G = _applyDecoratedDescriptor(_class2$17.prototype, "numTilesX", [ _dec5$z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor4$B = _applyDecoratedDescriptor(_class2$17.prototype, "numTilesY", [ _dec6$v ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor5$v = _applyDecoratedDescriptor(_class2$17.prototype, "animation", [ _dec7$l ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Animation.WholeSheet;
    }
}), _descriptor6$m = _applyDecoratedDescriptor(_class2$17.prototype, "frameOverTime", [ _dec8$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor7$k = _applyDecoratedDescriptor(_class2$17.prototype, "startFrame", [ _dec9$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor8$h = _applyDecoratedDescriptor(_class2$17.prototype, "cycleCount", [ _dec10$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$d = _applyDecoratedDescriptor(_class2$17.prototype, "_flipU", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$b = _applyDecoratedDescriptor(_class2$17.prototype, "_flipV", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$a = _applyDecoratedDescriptor(_class2$17.prototype, "_uvChannelMask", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor12$9 = _applyDecoratedDescriptor(_class2$17.prototype, "randomRow", [ _dec11$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor13$7 = _applyDecoratedDescriptor(_class2$17.prototype, "rowIndex", [ _dec12$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$1j = _class2$17)) || _class$1j), _temp_v3$2 = cc.v3(), VelocityOvertimeModule = (_dec$1j = ccclass("cc.VelocityOvertimeModule"), 
_dec2$Z = property({
    displayOrder: 0
}), _dec3$M = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 2
}), _dec4$D = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 3
}), _dec5$A = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 4
}), _dec6$w = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 5
}), _dec7$m = property({
    type: Space,
    displayOrder: 1
}), _dec$1j((_descriptor$15 = _applyDecoratedDescriptor((_class2$18 = function() {
    function VelocityOvertimeModule() {
        _classCallCheck(this, VelocityOvertimeModule), _initializerDefineProperty(this, "enable", _descriptor$15, this), 
        _initializerDefineProperty(this, "x", _descriptor2$X, this), _initializerDefineProperty(this, "y", _descriptor3$H, this), 
        _initializerDefineProperty(this, "z", _descriptor4$C, this), _initializerDefineProperty(this, "speedModifier", _descriptor5$w, this), 
        _initializerDefineProperty(this, "space", _descriptor6$n, this), this.rotation = void 0, 
        this.needTransform = void 0, this.rotation = new Quat(), this.speedModifier.constant = 1, 
        this.needTransform = !1;
    }
    return _createClass(VelocityOvertimeModule, [ {
        key: "update",
        value: function update(space, worldTransform) {
            this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
    }, {
        key: "animate",
        value: function animate(p) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 197866)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 197866)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + 197866)));
            this.needTransform && Vec3.transformQuat(vel, vel, this.rotation), Vec3.add(p.animatedVelocity, p.animatedVelocity, vel), 
            Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity), Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + 197866)));
        }
    } ]), VelocityOvertimeModule;
}()).prototype, "enable", [ _dec2$Z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$X = _applyDecoratedDescriptor(_class2$18.prototype, "x", [ _dec3$M ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor3$H = _applyDecoratedDescriptor(_class2$18.prototype, "y", [ _dec4$D ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$C = _applyDecoratedDescriptor(_class2$18.prototype, "z", [ _dec5$A ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor5$w = _applyDecoratedDescriptor(_class2$18.prototype, "speedModifier", [ _dec6$w ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor6$n = _applyDecoratedDescriptor(_class2$18.prototype, "space", [ _dec7$m ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1k = _class2$18)) || _class$1k), Burst = (_dec$1k = ccclass("cc.Burst"), 
_dec2$_ = property({
    type: CurveRange
}), _dec$1k((_descriptor$16 = _applyDecoratedDescriptor((_class2$19 = function() {
    function Burst() {
        _classCallCheck(this, Burst), _initializerDefineProperty(this, "_time", _descriptor$16, this), 
        _initializerDefineProperty(this, "minCount", _descriptor2$Y, this), _initializerDefineProperty(this, "maxCount", _descriptor3$I, this), 
        _initializerDefineProperty(this, "_repeatCount", _descriptor4$D, this), _initializerDefineProperty(this, "repeatInterval", _descriptor5$x, this), 
        _initializerDefineProperty(this, "count", _descriptor6$o, this), this._remainingCount = void 0, 
        this._curTime = void 0, this._remainingCount = 1, this._curTime = 0;
    }
    return _createClass(Burst, [ {
        key: "time",
        get: function get() {
            return this._time;
        },
        set: function set(val) {
            this._time = val, this._curTime = val;
        }
    }, {
        key: "repeatCount",
        get: function get() {
            return this._repeatCount;
        },
        set: function set(val) {
            this._repeatCount = val, this._remainingCount = val;
        }
    } ]), _createClass(Burst, [ {
        key: "update",
        value: function update(psys, dt) {
            if (0 === this._remainingCount && (this._remainingCount = this._repeatCount, this._curTime = this._time), 
            this._remainingCount > 0) {
                var preFrameTime = repeat(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
                preFrameTime = preFrameTime > 0 ? preFrameTime : 0;
                var curFrameTime = repeat(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);
                this._curTime >= preFrameTime && this._curTime < curFrameTime && (psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime)), 
                this._curTime += this.repeatInterval, --this._remainingCount);
            }
        }
    }, {
        key: "getMaxCount",
        value: function getMaxCount(psys) {
            return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
        }
    } ]), Burst;
}()).prototype, "_time", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$19.prototype, "time", [ property ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "time"), _class2$19.prototype), 
_descriptor2$Y = _applyDecoratedDescriptor(_class2$19.prototype, "minCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 30;
    }
}), _descriptor3$I = _applyDecoratedDescriptor(_class2$19.prototype, "maxCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 30;
    }
}), _descriptor4$D = _applyDecoratedDescriptor(_class2$19.prototype, "_repeatCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$19.prototype, "repeatCount", [ property ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "repeatCount"), _class2$19.prototype), 
_descriptor5$x = _applyDecoratedDescriptor(_class2$19.prototype, "repeatInterval", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor6$o = _applyDecoratedDescriptor(_class2$19.prototype, "count", [ _dec2$_ ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _class$1l = _class2$19)) || _class$1l), _intermediVec = new Vec3(0, 0, 0), _intermediArr = new Array(), _unitBoxExtent = new Vec3(.5, .5, .5), ShapeModule = (_dec$1l = ccclass("cc.ShapeModule"), 
_dec2$$ = property({
    displayOrder: 13
}), _dec3$N = property({
    displayOrder: 14
}), _dec4$E = property({
    displayOrder: 15
}), _dec5$B = property({
    displayOrder: 6
}), _dec6$x = property({
    displayOrder: 5
}), _dec7$n = property({
    displayOrder: 0
}), _dec8$f = property({
    type: ShapeType,
    displayOrder: 1
}), _dec9$c = property({
    type: EmitLocation,
    displayOrder: 2
}), _dec10$a = property({
    displayOrder: 16
}), _dec11$9 = property({
    displayOrder: 17
}), _dec12$9 = property({
    displayOrder: 18
}), _dec13$5 = property({
    displayOrder: 19
}), _dec14$4 = property({
    displayOrder: 3
}), _dec15$4 = property({
    displayOrder: 4
}), _dec16$2 = property({
    type: ArcMode,
    displayOrder: 7
}), _dec17$2 = property({
    displayOrder: 9
}), _dec18$2 = property({
    type: CurveRange,
    displayOrder: 10
}), _dec19$1 = property({
    displayOrder: 11
}), _dec20 = property({
    displayOrder: 12
}), _dec$1l((_applyDecoratedDescriptor((_class2$1a = function() {
    function ShapeModule() {
        _classCallCheck(this, ShapeModule), _initializerDefineProperty(this, "enable", _descriptor$17, this), 
        _initializerDefineProperty(this, "shapeType", _descriptor2$Z, this), _initializerDefineProperty(this, "emitFrom", _descriptor3$J, this), 
        _initializerDefineProperty(this, "alignToDirection", _descriptor4$E, this), _initializerDefineProperty(this, "randomDirectionAmount", _descriptor5$y, this), 
        _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor6$p, this), 
        _initializerDefineProperty(this, "randomPositionAmount", _descriptor7$l, this), 
        _initializerDefineProperty(this, "radius", _descriptor8$i, this), _initializerDefineProperty(this, "radiusThickness", _descriptor9$e, this), 
        _initializerDefineProperty(this, "arcMode", _descriptor10$c, this), _initializerDefineProperty(this, "arcSpread", _descriptor11$b, this), 
        _initializerDefineProperty(this, "arcSpeed", _descriptor12$a, this), _initializerDefineProperty(this, "length", _descriptor13$8, this), 
        _initializerDefineProperty(this, "boxThickness", _descriptor14$7, this), _initializerDefineProperty(this, "_position", _descriptor15$3, this), 
        _initializerDefineProperty(this, "_rotation", _descriptor16$3, this), _initializerDefineProperty(this, "_scale", _descriptor17$2, this), 
        _initializerDefineProperty(this, "_arc", _descriptor18$1, this), _initializerDefineProperty(this, "_angle", _descriptor19$1, this), 
        this.mat = void 0, this.quat = void 0, this.particleSystem = void 0, this.lastTime = void 0, 
        this.totalAngle = void 0, this.mat = new Mat4(), this.quat = new Quat(), this.particleSystem = null, 
        this.lastTime = 0, this.totalAngle = 0;
    }
    return _createClass(ShapeModule, [ {
        key: "position",
        get: function get() {
            return this._position;
        },
        set: function set(val) {
            this._position = val, this.constructMat();
        }
    }, {
        key: "rotation",
        get: function get() {
            return this._rotation;
        },
        set: function set(val) {
            this._rotation = val, this.constructMat();
        }
    }, {
        key: "scale",
        get: function get() {
            return this._scale;
        },
        set: function set(val) {
            this._scale = val, this.constructMat();
        }
    }, {
        key: "arc",
        get: function get() {
            return toDegree(this._arc);
        },
        set: function set(val) {
            this._arc = toRadian(val);
        }
    }, {
        key: "angle",
        get: function get() {
            return Math.round(100 * toDegree(this._angle)) / 100;
        },
        set: function set(val) {
            this._angle = toRadian(val);
        }
    } ]), _createClass(ShapeModule, [ {
        key: "onInit",
        value: function onInit(ps) {
            this.particleSystem = ps, this.constructMat(), this.lastTime = this.particleSystem._time;
        }
    }, {
        key: "emit",
        value: function emit(p) {
            switch (this.shapeType) {
              case ShapeType.Box:
                !function boxEmit(emitFrom, boxThickness, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Volume:
                        !function randomPointInCube(out, extents) {
                            Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
                        }(pos, _unitBoxExtent);
                        break;

                      case EmitLocation.Shell:
                        _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                        _intermediArr.push(randomRange(-.5, .5)), _intermediArr.push(.5 * randomSign()), 
                        randomSortArray(_intermediArr), applyBoxThickness(_intermediArr, boxThickness), 
                        Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                        break;

                      case EmitLocation.Edge:
                        _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                        _intermediArr.push(.5 * randomSign()), _intermediArr.push(.5 * randomSign()), randomSortArray(_intermediArr), 
                        applyBoxThickness(_intermediArr, boxThickness), Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for box emitter.");
                    }
                    Vec3.copy(dir, particleEmitZAxis);
                }(this.emitFrom, this.boxThickness, p.position, p.velocity);
                break;

              case ShapeType.Circle:
                !function circleEmit(radius, radiusThickness, theta, pos, dir) {
                    randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                    Vec3.normalize(dir, pos);
                }(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                break;

              case ShapeType.Cone:
                !function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Base:
                        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                        Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                        Vec3.normalize(dir, dir), pos.z = 0;
                        break;

                      case EmitLocation.Shell:
                        fixedAngleUnitVector2(pos, theta), Vec2.multiplyScalar(dir, pos, Math.sin(angle)), 
                        dir.z = -Math.cos(angle), Vec3.normalize(dir, dir), Vec2.multiplyScalar(pos, pos, radius), 
                        pos.z = 0;
                        break;

                      case EmitLocation.Volume:
                        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                        Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                        Vec3.normalize(dir, dir), pos.z = 0, Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for cone emitter.");
                    }
                }(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                break;

              case ShapeType.Sphere:
                !function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Volume:
                        randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), Vec3.copy(dir, pos), 
                        Vec3.normalize(dir, dir);
                        break;

                      case EmitLocation.Shell:
                        randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), Vec3.copy(dir, pos);
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for sphere emitter.");
                    }
                }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                break;

              case ShapeType.Hemisphere:
                !function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Volume:
                        randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), pos.z > 0 && (pos.z *= -1), 
                        Vec3.copy(dir, pos), Vec3.normalize(dir, dir);
                        break;

                      case EmitLocation.Shell:
                        randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), pos.z > 0 && (pos.z *= -1), 
                        Vec3.copy(dir, pos);
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for hemisphere emitter.");
                    }
                }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                break;

              default:
                console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
            }
            if (this.randomPositionAmount > 0 && (p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
            p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
            p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount)), 
            Vec3.transformQuat(p.velocity, p.velocity, this.quat), Vec3.transformMat4(p.position, p.position, this.mat), 
            this.sphericalDirectionAmount > 0) {
                var sphericalVel = Vec3.normalize(_intermediVec, p.position);
                Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
            }
            this.lastTime = this.particleSystem._time;
        }
    }, {
        key: "constructMat",
        value: function constructMat() {
            Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z), 
            Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
        }
    }, {
        key: "generateArcAngle",
        value: function generateArcAngle() {
            if (this.arcMode === ArcMode.Random) return randomRange(0, this._arc);
            var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
            switch (this.totalAngle = angle, 0 !== this.arcSpread && (angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread), 
            this.arcMode) {
              case ArcMode.Loop:
                return repeat(angle, this._arc);

              case ArcMode.PingPong:
                return pingPong(angle, this._arc);
            }
        }
    } ]), ShapeModule;
}()).prototype, "position", [ _dec2$$ ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "position"), _class2$1a.prototype), 
_applyDecoratedDescriptor(_class2$1a.prototype, "rotation", [ _dec3$N ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "rotation"), _class2$1a.prototype), 
_applyDecoratedDescriptor(_class2$1a.prototype, "scale", [ _dec4$E ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "scale"), _class2$1a.prototype), 
_applyDecoratedDescriptor(_class2$1a.prototype, "arc", [ _dec5$B ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "arc"), _class2$1a.prototype), 
_applyDecoratedDescriptor(_class2$1a.prototype, "angle", [ _dec6$x ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "angle"), _class2$1a.prototype), 
_descriptor$17 = _applyDecoratedDescriptor(_class2$1a.prototype, "enable", [ _dec7$n ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$Z = _applyDecoratedDescriptor(_class2$1a.prototype, "shapeType", [ _dec8$f ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ShapeType.Box;
    }
}), _descriptor3$J = _applyDecoratedDescriptor(_class2$1a.prototype, "emitFrom", [ _dec9$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return EmitLocation.Volume;
    }
}), _descriptor4$E = _applyDecoratedDescriptor(_class2$1a.prototype, "alignToDirection", [ _dec10$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$y = _applyDecoratedDescriptor(_class2$1a.prototype, "randomDirectionAmount", [ _dec11$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$p = _applyDecoratedDescriptor(_class2$1a.prototype, "sphericalDirectionAmount", [ _dec12$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$l = _applyDecoratedDescriptor(_class2$1a.prototype, "randomPositionAmount", [ _dec13$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$i = _applyDecoratedDescriptor(_class2$1a.prototype, "radius", [ _dec14$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor9$e = _applyDecoratedDescriptor(_class2$1a.prototype, "radiusThickness", [ _dec15$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor10$c = _applyDecoratedDescriptor(_class2$1a.prototype, "arcMode", [ _dec16$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ArcMode.Random;
    }
}), _descriptor11$b = _applyDecoratedDescriptor(_class2$1a.prototype, "arcSpread", [ _dec17$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 8;
    }
}), _descriptor12$a = _applyDecoratedDescriptor(_class2$1a.prototype, "arcSpeed", [ _dec18$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor13$8 = _applyDecoratedDescriptor(_class2$1a.prototype, "length", [ _dec19$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor14$7 = _applyDecoratedDescriptor(_class2$1a.prototype, "boxThickness", [ _dec20 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _descriptor15$3 = _applyDecoratedDescriptor(_class2$1a.prototype, "_position", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _descriptor16$3 = _applyDecoratedDescriptor(_class2$1a.prototype, "_rotation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _descriptor17$2 = _applyDecoratedDescriptor(_class2$1a.prototype, "_scale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _descriptor18$1 = _applyDecoratedDescriptor(_class2$1a.prototype, "_arc", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return toRadian(360);
    }
}), _descriptor19$1 = _applyDecoratedDescriptor(_class2$1a.prototype, "_angle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return toRadian(25);
    }
}), _class$1m = _class2$1a)) || _class$1m);

function applyBoxThickness(pos, thickness) {
    thickness.x > 0 && (pos[0] += .5 * randomRange(-thickness.x, thickness.x), pos[0] = clamp(pos[0], -.5, .5)), 
    thickness.y > 0 && (pos[1] += .5 * randomRange(-thickness.y, thickness.y), pos[1] = clamp(pos[1], -.5, .5)), 
    thickness.z > 0 && (pos[2] += .5 * randomRange(-thickness.z, thickness.z), pos[2] = clamp(pos[2], -.5, .5));
}

var _dec$1m, _dec2$10, _dec3$O, _dec4$F, _dec5$C, _dec6$y, _dec7$o, _dec8$g, _dec9$d, _dec10$b, _dec11$a, _dec12$a, _class$1n, _class2$1b, _descriptor$18, _descriptor2$_, _descriptor3$K, _descriptor4$F, _descriptor5$z, _dec$1n, _dec2$11, _dec3$P, _dec4$G, _dec5$D, _dec6$z, _dec7$p, _dec8$h, _dec9$e, _dec10$c, _dec11$b, _dec12$b, _dec13$6, _dec14$5, _dec15$5, _class$1o, _class2$1c, _descriptor$19, _descriptor2$$, _descriptor3$L, _descriptor4$G, _descriptor5$A, _descriptor6$q, _descriptor7$m, _descriptor8$j, _descriptor9$f, _descriptor10$d, _descriptor11$c, _descriptor12$b, _descriptor13$9, Particle = function Particle(particleSystem) {
    _classCallCheck(this, Particle), this.particleSystem = void 0, this.position = void 0, 
    this.velocity = void 0, this.animatedVelocity = void 0, this.ultimateVelocity = void 0, 
    this.angularVelocity = void 0, this.axisOfRotation = void 0, this.rotation = void 0, 
    this.startSize = void 0, this.size = void 0, this.startColor = void 0, this.color = void 0, 
    this.randomSeed = void 0, this.remainingLifetime = void 0, this.startLifetime = void 0, 
    this.emitAccumulator0 = void 0, this.emitAccumulator1 = void 0, this.frameIndex = void 0, 
    this.particleSystem = particleSystem, this.position = new Vec3(0, 0, 0), this.velocity = new Vec3(0, 0, 0), 
    this.animatedVelocity = new Vec3(0, 0, 0), this.ultimateVelocity = new Vec3(0, 0, 0), 
    this.angularVelocity = new Vec3(0, 0, 0), this.axisOfRotation = new Vec3(0, 0, 0), 
    this.rotation = new Vec3(0, 0, 0), this.startSize = new Vec3(0, 0, 0), this.size = new Vec3(0, 0, 0), 
    this.startColor = cc.Color.WHITE.clone(), this.color = cc.Color.WHITE.clone(), this.randomSeed = 0, 
    this.remainingLifetime = 0, this.startLifetime = 0, this.emitAccumulator0 = 0, this.emitAccumulator1 = 0, 
    this.frameIndex = 0;
}, _tempAttribUV = new Vec3(), _tempAttribUV0 = new Vec2(), _tempWorldTrans = new Mat4(), _uvs$1 = [ 0, 0, 1, 0, 0, 1, 1, 1 ], _vertex_attrs$1 = [ {
    name: GFXAttributeName.ATTR_POSITION,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD1,
    format: GFXFormat.RG32F
}, {
    name: GFXAttributeName.ATTR_COLOR,
    format: GFXFormat.RGBA8,
    isNormalized: !0
} ], _vertex_attrs_stretch = [ {
    name: GFXAttributeName.ATTR_POSITION,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD1,
    format: GFXFormat.RG32F
}, {
    name: GFXAttributeName.ATTR_COLOR,
    format: GFXFormat.RGBA8,
    isNormalized: !0
}, {
    name: GFXAttributeName.ATTR_COLOR1,
    format: GFXFormat.RGB32F
} ], _vertex_attrs_mesh = [ {
    name: GFXAttributeName.ATTR_POSITION,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_TEX_COORD1,
    format: GFXFormat.RG32F
}, {
    name: GFXAttributeName.ATTR_COLOR,
    format: GFXFormat.RGBA8,
    isNormalized: !0
}, {
    name: GFXAttributeName.ATTR_TEX_COORD2,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_NORMAL,
    format: GFXFormat.RGB32F
}, {
    name: GFXAttributeName.ATTR_COLOR1,
    format: GFXFormat.RGBA8,
    isNormalized: !0
} ], ParticleSystemRenderer = (_dec$1m = ccclass("cc.ParticleSystemRenderer"), _dec2$10 = property({
    type: RenderMode,
    displayOrder: 0
}), _dec3$O = property({
    displayOrder: 1
}), _dec4$F = property({
    displayOrder: 2
}), _dec5$C = property({
    type: RenderMode,
    displayOrder: 3
}), _dec6$y = property({
    displayOrder: 4
}), _dec7$o = property({
    displayOrder: 5
}), _dec8$g = property({
    displayOrder: 6
}), _dec9$d = property({
    type: cc.ParticleSystemComponent,
    visible: !1
}), _dec10$b = property({
    type: Mesh,
    displayOrder: 7
}), _dec11$a = property({
    type: Material,
    displayOrder: 8
}), _dec12$a = property({
    type: Material,
    displayOrder: 9
}), _dec$1m((_applyDecoratedDescriptor((_class2$1b = function() {
    function ParticleSystemRenderer() {
        _classCallCheck(this, ParticleSystemRenderer), _initializerDefineProperty(this, "_renderMode", _descriptor$18, this), 
        _initializerDefineProperty(this, "_velocityScale", _descriptor2$_, this), _initializerDefineProperty(this, "_lengthScale", _descriptor3$K, this), 
        _initializerDefineProperty(this, "_mesh", _descriptor4$F, this), _initializerDefineProperty(this, "_particleSystem", _descriptor5$z, this), 
        this._defines = void 0, this._trailDefines = void 0, this._model = void 0, this.frameTile_velLenScale = void 0, 
        this._node_scale = void 0, this.attrs = void 0, this._vertAttrs = [], this._particles = null, 
        this._defaultMat = null, this._defaultTrailMat = null, this._model = null, this.frameTile_velLenScale = new Vec4(1, 1, 0, 0), 
        this._node_scale = new Vec4(), this.attrs = new Array(5), this._defines = {
            CC_USE_WORLD_SPACE: !0,
            CC_USE_BILLBOARD: !0,
            CC_USE_STRETCHED_BILLBOARD: !1,
            CC_USE_HORIZONTAL_BILLBOARD: !1,
            CC_USE_VERTICAL_BILLBOARD: !1
        }, this._trailDefines = {
            CC_USE_WORLD_SPACE: !0
        };
    }
    return _createClass(ParticleSystemRenderer, [ {
        key: "renderMode",
        get: function get() {
            return this._renderMode;
        },
        set: function set(val) {
            this._renderMode !== val && (this._renderMode = val, this._setVertexAttrib(), this._updateModel(), 
            this._updateMaterialParams());
        }
    }, {
        key: "velocityScale",
        get: function get() {
            return this._velocityScale;
        },
        set: function set(val) {
            this._velocityScale = val, this._updateMaterialParams();
        }
    }, {
        key: "lengthScale",
        get: function get() {
            return this._lengthScale;
        },
        set: function set(val) {
            this._lengthScale = val, this._updateMaterialParams();
        }
    }, {
        key: "mesh",
        get: function get() {
            return this._mesh;
        },
        set: function set(val) {
            this._mesh = val, this._model && this._model.setVertexAttributes(this._renderMode === RenderMode.Mesh ? this._mesh : null, this._vertAttrs);
        }
    }, {
        key: "particleMaterial",
        get: function get() {
            return this._particleSystem ? this._particleSystem.getMaterial(0) : null;
        },
        set: function set(val) {
            this._particleSystem.setMaterial(val, 0);
        }
    }, {
        key: "trailMaterial",
        get: function get() {
            return this._particleSystem ? this._particleSystem.getMaterial(1) : null;
        },
        set: function set(val) {
            this._particleSystem.setMaterial(val, 1);
        }
    } ]), _createClass(ParticleSystemRenderer, [ {
        key: "onInit",
        value: function onInit(ps) {
            var _this = this;
            this._particleSystem = ps, this._particles = new RecyclePool(function() {
                return new Particle(_this);
            }, 16), this._setVertexAttrib(), this.onEnable(), this._updateModel(), this._updateMaterialParams(), 
            this._updateTrailMaterial();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._particleSystem && (null == this._model && (this._model = this._particleSystem._getRenderScene().createModel(ParticleBatchModel, this._particleSystem.node), 
            this._model.viewID = this._particleSystem.visibility), this._model.inited || (this._model.setCapacity(this._particleSystem.capacity), 
            this._model.node = this._particleSystem.node), this._model.enabled = this._particleSystem.enabledInHierarchy);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._model && (this._model.enabled = this._particleSystem.enabledInHierarchy);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._particleSystem._getRenderScene().destroyModel(this._model), this._model = null;
        }
    }, {
        key: "clear",
        value: function clear() {
            this._particles.reset(), this._updateRenderData();
        }
    }, {
        key: "_getFreeParticle",
        value: function _getFreeParticle() {
            return this._particles.length >= this._particleSystem.capacity ? null : this._particles.add();
        }
    }, {
        key: "_setNewParticle",
        value: function _setNewParticle(p) {}
    }, {
        key: "_updateParticles",
        value: function _updateParticles(dt) {
            switch (this._particleSystem.node.getWorldMatrix(_tempWorldTrans), this._particleSystem.scaleSpace) {
              case Space.Local:
                this._particleSystem.node.getScale(this._node_scale);
                break;

              case Space.World:
                this._particleSystem.node.getWorldScale(this._node_scale);
            }
            (this._particleSystem.sharedMaterial ? this.particleMaterial : this._defaultMat).setProperty("scale", this._node_scale), 
            this._particleSystem.velocityOvertimeModule.enable && this._particleSystem.velocityOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
            this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans), 
            this._particleSystem.trailModule.enable && this._particleSystem.trailModule.update();
            for (var i = 0; i < this._particles.length; ++i) {
                var p = this._particles.data[i];
                p.remainingLifetime -= dt, Vec3.set(p.animatedVelocity, 0, 0, 0), p.remainingLifetime < 0 ? (this._particleSystem.trailModule.enable && this._particleSystem.trailModule.removeParticle(p), 
                this._particles.removeAt(i), --i) : (p.velocity.y -= 9.8 * this._particleSystem.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed) * dt, 
                this._particleSystem.sizeOvertimeModule.enable && this._particleSystem.sizeOvertimeModule.animate(p), 
                this._particleSystem.colorOverLifetimeModule.enable && this._particleSystem.colorOverLifetimeModule.animate(p), 
                this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.animate(p, dt), 
                this._particleSystem.velocityOvertimeModule.enable ? this._particleSystem.velocityOvertimeModule.animate(p) : Vec3.copy(p.ultimateVelocity, p.velocity), 
                this._particleSystem.limitVelocityOvertimeModule.enable && this._particleSystem.limitVelocityOvertimeModule.animate(p), 
                this._particleSystem.rotationOvertimeModule.enable && this._particleSystem.rotationOvertimeModule.animate(p, dt), 
                this._particleSystem.textureAnimationModule.enable && this._particleSystem.textureAnimationModule.animate(p), 
                Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt), this._particleSystem.trailModule.enable && this._particleSystem.trailModule.animate(p, dt));
            }
            return this._particles.length;
        }
    }, {
        key: "_updateRenderData",
        value: function _updateRenderData() {
            for (var idx = 0, uploadVel = this._renderMode === RenderMode.StrecthedBillboard, i = 0; i < this._particles.length; ++i) {
                var p = this._particles.data[i], fi = 0;
                this._particleSystem.textureAnimationModule.enable && (fi = p.frameIndex), idx = 4 * i;
                var attrNum = 0;
                if (this._renderMode !== RenderMode.Mesh) for (var j = 0; j < 4; ++j) attrNum = 0, 
                this.attrs[attrNum++] = p.position, _tempAttribUV.x = _uvs$1[2 * j], _tempAttribUV.y = _uvs$1[2 * j + 1], 
                _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, _tempAttribUV0.x = p.size.x, 
                _tempAttribUV0.y = p.rotation.x, this.attrs[attrNum++] = _tempAttribUV0, this.attrs[attrNum++] = p.color._val, 
                this.attrs[attrNum++] = uploadVel ? p.ultimateVelocity : null, this._model.addParticleVertexData(idx++, this.attrs); else attrNum = 0, 
                this.attrs[attrNum++] = p.position, _tempAttribUV.z = fi, this.attrs[attrNum++] = _tempAttribUV, 
                _tempAttribUV0.x = p.size.x, _tempAttribUV0.y = p.rotation.x, this.attrs[attrNum++] = _tempAttribUV0, 
                this.attrs[attrNum++] = p.color._val, this._model.addParticleVertexData(i, this.attrs);
            }
            this._model.updateIA(this._particles.length);
        }
    }, {
        key: "updateShaderUniform",
        value: function updateShaderUniform() {}
    }, {
        key: "getParticleCount",
        value: function getParticleCount() {
            return this._particles.length;
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(index, material) {
            0 === index ? (this._updateModel(), this._updateMaterialParams()) : this._updateTrailMaterial();
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(index, material) {
            this._model && 0 === index && this._model.setSubModelMaterial(0, material), this._particleSystem.trailModule._trailModel && 1 === index && this._particleSystem.trailModule._trailModel.setSubModelMaterial(0, material);
        }
    }, {
        key: "_setVertexAttrib",
        value: function _setVertexAttrib() {
            switch (this._renderMode) {
              case RenderMode.StrecthedBillboard:
                this._vertAttrs = _vertex_attrs_stretch.slice();
                break;

              case RenderMode.Mesh:
                this._vertAttrs = _vertex_attrs_mesh.slice();
                break;

              default:
                this._vertAttrs = _vertex_attrs$1.slice();
            }
        }
    }, {
        key: "_updateMaterialParams",
        value: function _updateMaterialParams() {
            if (this._particleSystem) {
                null != this._particleSystem.sharedMaterial && -1 === this._particleSystem.sharedMaterial._effectAsset._name.indexOf("particle") && this._particleSystem.setMaterial(null, 0, !1), 
                null == this._particleSystem.sharedMaterial && null == this._defaultMat && (this._defaultMat = Material.getInstantiatedMaterial(builtinResMgr.get("default-particle-material"), this._particleSystem, !0));
                var mat = this._particleSystem.sharedMaterial ? this.particleMaterial : this._defaultMat;
                this._particleSystem._simulationSpace === Space.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1, 
                this._renderMode === RenderMode.Billboard ? (this._defines.CC_USE_BILLBOARD = !0, 
                this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode.StrecthedBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                this._defines.CC_USE_STRETCHED_BILLBOARD = !0, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1, this.frameTile_velLenScale.z = this._velocityScale, 
                this.frameTile_velLenScale.w = this._lengthScale) : this._renderMode === RenderMode.HorizontalBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !0, 
                this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode.VerticalBillboard ? (this._defines.CC_USE_BILLBOARD = !1, 
                this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                this._defines.CC_USE_VERTICAL_BILLBOARD = !0, this._defines.CC_USE_MESH = !1) : this._renderMode === RenderMode.Mesh ? (this._defines.CC_USE_BILLBOARD = !1, 
                this._defines.CC_USE_STRETCHED_BILLBOARD = !1, this._defines.CC_USE_HORIZONTAL_BILLBOARD = !1, 
                this._defines.CC_USE_VERTICAL_BILLBOARD = !1, this._defines.CC_USE_MESH = !0) : console.warn("particle system renderMode ".concat(this._renderMode, " not support.")), 
                this._particleSystem.textureAnimationModule.enable ? (Vec2.set(this.frameTile_velLenScale, this._particleSystem.textureAnimationModule.numTilesX, this._particleSystem.textureAnimationModule.numTilesY), 
                mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale)) : mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale), 
                mat.recompileShaders(this._defines), this._model && this._model.setSubModelMaterial(0, this._particleSystem.sharedMaterial || this._defaultMat);
            }
        }
    }, {
        key: "_updateTrailMaterial",
        value: function _updateTrailMaterial() {
            if (this._particleSystem.trailModule.enable) {
                this._particleSystem._simulationSpace === Space.World || this._particleSystem.trailModule.space === Space.World ? this._trailDefines.CC_USE_WORLD_SPACE = !0 : this._trailDefines.CC_USE_WORLD_SPACE = !1;
                var mat = this.trailMaterial;
                null === mat && null === this._defaultTrailMat && (this._defaultTrailMat = Material.getInstantiatedMaterial(builtinResMgr.get("default-trail-material"), this._particleSystem, !0)), 
                null === mat && (mat = this._defaultTrailMat), mat.recompileShaders(this._trailDefines), 
                this._particleSystem.trailModule._updateMaterial();
            }
        }
    }, {
        key: "_updateModel",
        value: function _updateModel() {
            this._model && this._model.setVertexAttributes(this._renderMode === RenderMode.Mesh ? this._mesh : null, this._vertAttrs);
        }
    } ]), ParticleSystemRenderer;
}()).prototype, "renderMode", [ _dec2$10 ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "renderMode"), _class2$1b.prototype), 
_applyDecoratedDescriptor(_class2$1b.prototype, "velocityScale", [ _dec3$O ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "velocityScale"), _class2$1b.prototype), 
_applyDecoratedDescriptor(_class2$1b.prototype, "lengthScale", [ _dec4$F ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "lengthScale"), _class2$1b.prototype), 
_descriptor$18 = _applyDecoratedDescriptor(_class2$1b.prototype, "_renderMode", [ _dec5$C ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return RenderMode.Billboard;
    }
}), _descriptor2$_ = _applyDecoratedDescriptor(_class2$1b.prototype, "_velocityScale", [ _dec6$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor3$K = _applyDecoratedDescriptor(_class2$1b.prototype, "_lengthScale", [ _dec7$o ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$F = _applyDecoratedDescriptor(_class2$1b.prototype, "_mesh", [ _dec8$g ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor5$z = _applyDecoratedDescriptor(_class2$1b.prototype, "_particleSystem", [ _dec9$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1b.prototype, "mesh", [ _dec10$b ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "mesh"), _class2$1b.prototype), 
_applyDecoratedDescriptor(_class2$1b.prototype, "particleMaterial", [ _dec11$a ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "particleMaterial"), _class2$1b.prototype), 
_applyDecoratedDescriptor(_class2$1b.prototype, "trailMaterial", [ _dec12$a ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "trailMaterial"), _class2$1b.prototype), 
_class$1n = _class2$1b)) || _class$1n);

Object.assign(ParticleSystemRenderer, {
    uv: _uvs$1
});

var _dec$1o, _dec2$12, _dec3$Q, _dec4$H, _dec5$E, _dec6$A, _dec7$q, _dec8$i, _dec9$f, _dec10$d, _dec11$c, _dec12$c, _dec13$7, _dec14$6, _dec15$6, _dec16$3, _dec17$3, _dec18$3, _dec19$2, _dec20$1, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class$1p, _class2$1d, _descriptor$1a, _descriptor2$10, _descriptor3$M, _descriptor4$H, _descriptor5$B, _descriptor6$r, _descriptor7$n, _descriptor8$k, _descriptor9$g, _descriptor10$e, _descriptor11$d, _descriptor12$c, _descriptor13$a, _descriptor14$8, _descriptor15$4, _descriptor16$4, _descriptor17$3, _descriptor18$2, _descriptor19$2, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _dec$1p, _dec2$13, _dec3$R, _dec4$I, _dec5$F, _class$1q, _class2$1e, _descriptor$1b, _descriptor2$11, _descriptor3$N, _descriptor4$I, _temp_trailEle = {
    position: cc.v3(),
    velocity: cc.v3()
}, _temp_quat = cc.quat(), _temp_xform = cc.mat4(), _temp_vec3 = cc.v3(), _temp_vec3_1 = cc.v3(), _temp_color = cc.color(), TrailSegment = function() {
    function TrailSegment(maxTrailElementNum) {
        for (_classCallCheck(this, TrailSegment), this.start = void 0, this.end = void 0, 
        this.trailElements = void 0, this.start = -1, this.end = -1, this.trailElements = []; maxTrailElementNum--; ) this.trailElements.push({
            position: cc.v3(),
            lifetime: 0,
            width: 0,
            velocity: cc.v3(),
            color: cc.color()
        });
    }
    return _createClass(TrailSegment, [ {
        key: "getElement",
        value: function getElement(idx) {
            return -1 === this.start ? null : (idx < 0 && (idx = (idx + this.trailElements.length) % this.trailElements.length), 
            idx >= this.trailElements.length && (idx %= this.trailElements.length), this.trailElements[idx]);
        }
    }, {
        key: "addElement",
        value: function addElement() {
            if (0 === this.trailElements.length) return null;
            if (-1 === this.start) return this.start = 0, this.end = 1, this.trailElements[0];
            this.start === this.end && (this.start++, this.start %= this.trailElements.length);
            var newEleLoc = this.end++;
            return this.end %= this.trailElements.length, this.trailElements[newEleLoc];
        }
    }, {
        key: "iterateElement",
        value: function iterateElement(target, f, p, dt) {
            for (var end = this.start >= this.end ? this.end + this.trailElements.length : this.end, i = this.start; i < end; i++) f(target, this.trailElements[i % this.trailElements.length], p, dt) && (this.start++, 
            this.start %= this.trailElements.length);
            this.start === end && (this.start = -1, this.end = -1);
        }
    }, {
        key: "count",
        value: function count() {
            return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.start = -1, this.end = -1;
        }
    } ]), TrailSegment;
}(), TrailModule = (_dec$1n = ccclass("cc.TrailModule"), _dec2$11 = property({
    displayOrder: 0
}), _dec3$P = property({
    type: TrailMode,
    displayOrder: 1
}), _dec4$G = property({
    type: CurveRange,
    displayOrder: 3
}), _dec5$D = property({
    displayOrder: 5
}), _dec6$z = property({
    type: Space,
    displayOrder: 6
}), _dec7$p = property({
    displayOrder: 7
}), _dec8$h = property({
    type: TextureMode,
    displayOrder: 8
}), _dec9$e = property({
    displayOrder: 9
}), _dec10$c = property({
    type: CurveRange,
    displayOrder: 10
}), _dec11$b = property({
    displayOrder: 11
}), _dec12$b = property({
    type: GradientRange,
    displayOrder: 12
}), _dec13$6 = property({
    type: GradientRange,
    displayOrder: 13
}), _dec14$5 = property({
    type: Space
}), _dec15$5 = property({
    type: cc.ParticleSystemComponent,
    visible: !1
}), _dec$1n((_applyDecoratedDescriptor((_class2$1c = function() {
    function TrailModule() {
        _classCallCheck(this, TrailModule), _initializerDefineProperty(this, "_enable", _descriptor$19, this), 
        _initializerDefineProperty(this, "mode", _descriptor2$$, this), _initializerDefineProperty(this, "lifeTime", _descriptor3$L, this), 
        _initializerDefineProperty(this, "_minParticleDistance", _descriptor4$G, this), 
        _initializerDefineProperty(this, "existWithParticles", _descriptor5$A, this), _initializerDefineProperty(this, "textureMode", _descriptor6$q, this), 
        _initializerDefineProperty(this, "widthFromParticle", _descriptor7$m, this), _initializerDefineProperty(this, "widthRatio", _descriptor8$j, this), 
        _initializerDefineProperty(this, "colorFromParticle", _descriptor9$f, this), _initializerDefineProperty(this, "colorOverTrail", _descriptor10$d, this), 
        _initializerDefineProperty(this, "colorOvertime", _descriptor11$c, this), _initializerDefineProperty(this, "_space", _descriptor12$b, this), 
        _initializerDefineProperty(this, "_particleSystem", _descriptor13$9, this), this._minSquaredDistance = 0, 
        this._vertSize = void 0, this._trailNum = 0, this._trailLifetime = 0, this.vbOffset = 0, 
        this.ibOffset = 0, this._trailSegments = null, this._particleTrail = void 0, this._trailModel = null, 
        this._iaInfo = void 0, this._iaInfoBuffer = null, this._subMeshData = null, this._vertAttrs = void 0, 
        this._vbF32 = null, this._vbUint32 = null, this._iBuffer = null, this._needTransform = !1, 
        this._defaultMat = null, this._iaInfo = {
            drawInfos: [ {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            } ]
        }, this._vertAttrs = [ {
            name: GFXAttributeName.ATTR_POSITION,
            format: GFXFormat.RGB32F
        }, {
            name: GFXAttributeName.ATTR_TEX_COORD,
            format: GFXFormat.RGBA32F
        }, {
            name: GFXAttributeName.ATTR_TEX_COORD1,
            format: GFXFormat.RGB32F
        }, {
            name: GFXAttributeName.ATTR_COLOR,
            format: GFXFormat.RGBA8,
            isNormalized: !0
        } ], this._vertSize = 0;
        var _iterator = this._vertAttrs, _isArray = Array.isArray(_iterator), _i = 0;
        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
            var _ref;
            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                if ((_i = _iterator.next()).done) break;
                _ref = _i.value;
            }
            var a = _ref;
            this._vertSize += GFXFormatInfos[a.format].size;
        }
        this._particleTrail = new Map();
    }
    return _createClass(TrailModule, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            val && !this._trailModel && this._createModel(), val && !this._enable && (this._enable = val, 
            this._particleSystem.renderer._updateTrailMaterial()), this._enable = val, this._trailModel && (this._trailModel.enabled = val);
        }
    }, {
        key: "minParticleDistance",
        get: function get() {
            return this._minParticleDistance;
        },
        set: function set(val) {
            this._minParticleDistance = val, this._minSquaredDistance = val * val;
        }
    }, {
        key: "space",
        get: function get() {
            return this._space;
        },
        set: function set(val) {
            this._space = val, this._particleSystem && this._particleSystem.renderer._updateTrailMaterial();
        }
    } ]), _createClass(TrailModule, [ {
        key: "onInit",
        value: function onInit(ps) {
            var _this = this;
            this._particleSystem = ps;
            var burstCount = 0, _iterator2 = this._particleSystem.bursts, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                burstCount += _ref2.getMaxCount(this._particleSystem);
            }
            this._trailNum = Math.ceil(this._particleSystem.startLifetime.getMax() * this.lifeTime.getMax() * 60 * (this._particleSystem.rateOverTime.getMax() * this._particleSystem.duration + burstCount)), 
            this._trailSegments = new Pool$1(function() {
                return new TrailSegment(Math.ceil(_this._particleSystem.startLifetime.getMax() * _this.lifeTime.getMax() * 60));
            }, Math.ceil(this._particleSystem.rateOverTime.getMax() * this._particleSystem.duration)), 
            this._enable && (this.enable = this._enable, this._updateMaterial());
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._enable && this._trailModel && (this._trailModel.enabled = !0);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._enable && this._trailModel && (this._trailModel.enabled = !1);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._trailModel && (this._particleSystem._getRenderScene().destroyModel(this._trailModel), 
            this._trailModel = null);
        }
    }, {
        key: "clear",
        value: function clear() {
            if (this.enable) {
                for (var trailIter = this._particleTrail.values(), trail = trailIter.next(); !trail.done; ) trail.value.clear(), 
                trail = trailIter.next();
                this._particleTrail.clear(), this.updateRenderData();
            }
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial() {
            if (this._particleSystem && this._trailModel) {
                var mat = this._particleSystem.renderer.trailMaterial;
                mat ? this._trailModel.setSubModelMaterial(0, mat) : this._trailModel.setSubModelMaterial(0, this._particleSystem.renderer._defaultTrailMat);
            }
        }
    }, {
        key: "update",
        value: function update() {
            this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1), this.space === Space.World && this._particleSystem._simulationSpace === Space.Local ? (this._needTransform = !0, 
            this._particleSystem.node.getWorldMatrix(_temp_xform), this._particleSystem.node.getWorldRotation(_temp_quat)) : this._needTransform = !1;
        }
    }, {
        key: "animate",
        value: function animate(p, scaledDt) {
            if (this._trailSegments) {
                var trail = this._particleTrail.get(p);
                trail || (trail = this._trailSegments.alloc(), this._particleTrail.set(p, trail));
                var lastSeg = trail.getElement(trail.end - 1);
                if (this._needTransform ? Vec3.transformMat4(_temp_vec3, p.position, _temp_xform) : Vec3.copy(_temp_vec3, p.position), 
                !(lastSeg && (trail.iterateElement(this, this._updateTrailElement, p, scaledDt), 
                Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance)) && (lastSeg = trail.addElement())) {
                    Vec3.copy(lastSeg.position, _temp_vec3), lastSeg.lifetime = 0, this.widthFromParticle ? lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1) : lastSeg.width = this.widthRatio.evaluate(0, 1);
                    var trailNum = trail.count();
                    if (2 === trailNum) {
                        var lastSecondTrail = trail.getElement(trail.end - 2);
                        Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                    } else if (trailNum > 2) {
                        var _lastSecondTrail = trail.getElement(trail.end - 2), lastThirdTrail = trail.getElement(trail.end - 3);
                        Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position), Vec3.subtract(_temp_vec3_1, lastSeg.position, _lastSecondTrail.position), 
                        Vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1, _temp_vec3);
                    }
                    this.colorFromParticle ? lastSeg.color.set(p.color) : lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                }
            }
        }
    }, {
        key: "removeParticle",
        value: function removeParticle(p) {
            var trail = this._particleTrail.get(p);
            trail && this._trailSegments && (trail.clear(), this._trailSegments.free(trail), 
            this._particleTrail.delete(p));
        }
    }, {
        key: "updateRenderData",
        value: function updateRenderData() {
            this.vbOffset = 0, this.ibOffset = 0;
            var _iterator3 = this._particleTrail.keys(), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var p = _ref3, trailSeg = this._particleTrail.get(p);
                if (-1 !== trailSeg.start) {
                    var indexOffset = 4 * this.vbOffset / this._vertSize, end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end, trailNum = end - trailSeg.start, textCoordSeg = 1 / trailNum, startSegEle = trailSeg.trailElements[trailSeg.start];
                    this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, 4);
                    for (var i = trailSeg.start + 1; i < end; i++) {
                        var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length], j = i - trailSeg.start;
                        this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, 5);
                    }
                    if (this._needTransform ? Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform) : Vec3.copy(_temp_trailEle.position, p.position), 
                    1 === trailNum) {
                        var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                        Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x, 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y, 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z, 
                        this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x, this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y, 
                        this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z, Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);
                    } else if (trailNum > 2) {
                        var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1), lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                        Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position), 
                        Vec3.subtract(_temp_vec3_1, _temp_trailEle.position, _lastSecondTrail2.position), 
                        Vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1, _temp_vec3), this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = _lastSecondTrail2.velocity.x, 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = _lastSecondTrail2.velocity.y, 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = _lastSecondTrail2.velocity.z, 
                        this._vbF32[this.vbOffset - 4] = _lastSecondTrail2.velocity.x, this._vbF32[this.vbOffset - 3] = _lastSecondTrail2.velocity.y, 
                        this._vbF32[this.vbOffset - 2] = _lastSecondTrail2.velocity.z, Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position);
                    }
                    _temp_trailEle.width = p.size.x, _temp_trailEle.color = p.color, this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, 1);
                }
            }
            this.updateIA(this.ibOffset);
        }
    }, {
        key: "updateIA",
        value: function updateIA(count) {
            if (this._trailModel && this._trailModel.subModelNum > 0) {
                var subModel = this._trailModel.getSubModel(0);
                subModel.inputAssembler.vertexBuffers[0].update(this._vbF32), subModel.inputAssembler.indexBuffer.update(this._iBuffer), 
                subModel.inputAssembler.indexCount = count, subModel.inputAssembler.extractDrawInfo(this._iaInfo.drawInfos[0]), 
                this._iaInfoBuffer.update(this._iaInfo);
            }
        }
    }, {
        key: "_createModel",
        value: function _createModel() {
            if (!this._trailModel) {
                var device = cc.director.root.device, vertexBuffer = device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: this._vertSize * (this._trailNum + 1) * 2,
                    stride: this._vertSize
                }), vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                this._vbF32 = new Float32Array(vBuffer), this._vbUint32 = new Uint32Array(vBuffer), 
                vertexBuffer.update(vBuffer);
                var indexBuffer = device.createBuffer({
                    usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: 6 * this._trailNum * Uint16Array.BYTES_PER_ELEMENT,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                });
                this._iBuffer = new Uint16Array(6 * this._trailNum), indexBuffer.update(this._iBuffer), 
                this._iaInfoBuffer = device.createBuffer({
                    usage: GFXBufferUsageBit.INDIRECT,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: GFX_DRAW_INFO_SIZE,
                    stride: 1
                }), this._iaInfo.drawInfos[0].vertexCount = 2 * (this._trailNum + 1), this._iaInfo.drawInfos[0].indexCount = 6 * this._trailNum, 
                this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = {
                    vertexBuffers: [ vertexBuffer ],
                    indexBuffer: indexBuffer,
                    indirectBuffer: this._iaInfoBuffer,
                    attributes: this._vertAttrs,
                    primitiveMode: GFXPrimitiveMode.TRIANGLE_LIST
                }, this._trailModel = this._particleSystem._getRenderScene().createModel(Model, this._particleSystem.node), 
                this._trailModel.setSubModelMesh(0, this._subMeshData), this._trailModel.enabled = !0;
            }
        }
    }, {
        key: "_updateTrailElement",
        value: function _updateTrailElement(module, trailEle, p, dt) {
            return trailEle.lifetime += dt, module.colorFromParticle ? (trailEle.color.set(p.color), 
            trailEle.color.multiply(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1))) : trailEle.color.set(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1)), 
            module.widthFromParticle ? trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1) : trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1), 
            trailEle.lifetime > module._trailLifetime;
        }
    }, {
        key: "_fillVertexBuffer",
        value: function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
            this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
            this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 0, 
            this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
            this._vbF32[this.vbOffset++] = 0, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
            this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
            _temp_color.set(trailSeg.color), _temp_color.multiply(colorModifer), this._vbUint32[this.vbOffset++] = _temp_color._val, 
            this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
            this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 1, 
            this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
            this._vbF32[this.vbOffset++] = 1, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
            this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
            this._vbUint32[this.vbOffset++] = _temp_color._val, 1 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1), 
            4 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2);
        }
    } ]), TrailModule;
}()).prototype, "enable", [ _dec2$11 ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "enable"), _class2$1c.prototype), 
_descriptor$19 = _applyDecoratedDescriptor(_class2$1c.prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$$ = _applyDecoratedDescriptor(_class2$1c.prototype, "mode", [ _dec3$P ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return TrailMode.Particles;
    }
}), _descriptor3$L = _applyDecoratedDescriptor(_class2$1c.prototype, "lifeTime", [ _dec4$G ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$G = _applyDecoratedDescriptor(_class2$1c.prototype, "_minParticleDistance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _applyDecoratedDescriptor(_class2$1c.prototype, "minParticleDistance", [ _dec5$D ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "minParticleDistance"), _class2$1c.prototype), 
_applyDecoratedDescriptor(_class2$1c.prototype, "space", [ _dec6$z ], Object.getOwnPropertyDescriptor(_class2$1c.prototype, "space"), _class2$1c.prototype), 
_descriptor5$A = _applyDecoratedDescriptor(_class2$1c.prototype, "existWithParticles", [ _dec7$p ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor6$q = _applyDecoratedDescriptor(_class2$1c.prototype, "textureMode", [ _dec8$h ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return TextureMode.Stretch;
    }
}), _descriptor7$m = _applyDecoratedDescriptor(_class2$1c.prototype, "widthFromParticle", [ _dec9$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor8$j = _applyDecoratedDescriptor(_class2$1c.prototype, "widthRatio", [ _dec10$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor9$f = _applyDecoratedDescriptor(_class2$1c.prototype, "colorFromParticle", [ _dec11$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor10$d = _applyDecoratedDescriptor(_class2$1c.prototype, "colorOverTrail", [ _dec12$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange();
    }
}), _descriptor11$c = _applyDecoratedDescriptor(_class2$1c.prototype, "colorOvertime", [ _dec13$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange();
    }
}), _descriptor12$b = _applyDecoratedDescriptor(_class2$1c.prototype, "_space", [ _dec14$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.World;
    }
}), _descriptor13$9 = _applyDecoratedDescriptor(_class2$1c.prototype, "_particleSystem", [ _dec15$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1o = _class2$1c)) || _class$1o), _world_mat = new Mat4(), ParticleSystemComponent = (_dec$1o = ccclass("cc.ParticleSystemComponent"), 
_dec2$12 = menu("Components/ParticleSystemComponent"), _dec3$Q = executionOrder(99), 
_dec4$H = property({
    displayOrder: 1
}), _dec5$E = property({
    type: GradientRange,
    displayOrder: 8
}), _dec6$A = property({
    type: Space,
    displayOrder: 9
}), _dec7$q = property({
    type: CurveRange,
    displayOrder: 10
}), _dec8$i = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 11
}), _dec9$f = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 12
}), _dec10$d = property({
    type: CurveRange,
    displayOrder: 6
}), _dec11$c = property({
    type: CurveRange,
    displayOrder: 7
}), _dec12$c = property({
    displayOrder: 0
}), _dec13$7 = property({
    displayOrder: 2
}), _dec14$6 = property({
    displayOrder: 3
}), _dec15$6 = property({
    type: Space,
    displayOrder: 4
}), _dec16$3 = property({
    displayOrder: 5
}), _dec17$3 = property({
    displayOrder: 2
}), _dec18$3 = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 13
}), _dec19$2 = property({
    type: CurveRange,
    displayOrder: 14
}), _dec20$1 = property({
    type: CurveRange,
    displayOrder: 15
}), _dec21 = property({
    type: [ Burst ],
    displayOrder: 16
}), _dec22 = property({
    type: Material,
    displayName: "Materials",
    visible: !1,
    override: !0
}), _dec23 = property({
    type: ColorOvertimeModule,
    displayOrder: 23
}), _dec24 = property({
    type: ShapeModule,
    displayOrder: 17
}), _dec25 = property({
    type: SizeOvertimeModule,
    displayOrder: 21
}), _dec26 = property({
    type: VelocityOvertimeModule,
    displayOrder: 18
}), _dec27 = property({
    type: ForceOvertimeModule,
    displayOrder: 19
}), _dec28 = property({
    type: LimitVelocityOvertimeModule,
    displayOrder: 20
}), _dec29 = property({
    type: RotationOvertimeModule,
    displayOrder: 22
}), _dec30 = property({
    type: TextureAnimationModule,
    displayOrder: 24
}), _dec31 = property({
    type: TrailModule,
    displayOrder: 25
}), _dec32 = property({
    type: ParticleSystemRenderer,
    displayOrder: 26
}), _dec$1o(_class$1p = _dec2$12(_class$1p = _dec3$Q(_class$1p = executeInEditMode((_applyDecoratedDescriptor((_class2$1d = function(_RenderableComponent) {
    function ParticleSystemComponent() {
        var _this;
        return _classCallCheck(this, ParticleSystemComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemComponent).call(this)), "startColor", _descriptor$1a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "scaleSpace", _descriptor2$10, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSize", _descriptor3$M, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSpeed", _descriptor4$H, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startRotation", _descriptor5$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startDelay", _descriptor6$r, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startLifetime", _descriptor7$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "duration", _descriptor8$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "loop", _descriptor9$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "simulationSpeed", _descriptor10$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "playOnAwake", _descriptor11$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "gravityModifier", _descriptor12$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "rateOverTime", _descriptor13$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "rateOverDistance", _descriptor14$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "bursts", _descriptor15$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "colorOverLifetimeModule", _descriptor16$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "shapeModule", _descriptor17$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "sizeOvertimeModule", _descriptor18$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "velocityOvertimeModule", _descriptor19$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "forceOvertimeModule", _descriptor20, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "limitVelocityOvertimeModule", _descriptor21, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "rotationOvertimeModule", _descriptor22, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "textureAnimationModule", _descriptor23, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "trailModule", _descriptor24, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "renderer", _descriptor25, _assertThisInitialized(_this)), 
        _this._isPlaying = void 0, _this._isPaused = void 0, _this._isStopped = void 0, 
        _this._isEmitting = void 0, _this._time = void 0, _this._emitRateTimeCounter = void 0, 
        _this._emitRateDistanceCounter = void 0, _this._oldWPos = void 0, _this._curWPos = void 0, 
        _this._customData1 = void 0, _this._customData2 = void 0, _this._subEmitters = void 0, 
        _initializerDefineProperty(_this, "_prewarm", _descriptor26, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_capacity", _descriptor27, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_simulationSpace", _descriptor28, _assertThisInitialized(_this)), 
        _this.rateOverTime.constant = 10, _this.startLifetime.constant = 5, _this.startSize.constant = 1, 
        _this.startSpeed.constant = 1, _this._isPlaying = !1, _this._isPaused = !1, _this._isStopped = !0, 
        _this._isEmitting = !1, _this._time = 0, _this._emitRateTimeCounter = 0, _this._emitRateDistanceCounter = 0, 
        _this._oldWPos = new Vec3(), _this._curWPos = new Vec3(), _this._customData1 = new Vec2(), 
        _this._customData2 = new Vec2(), _this._subEmitters = [], _this;
    }
    return _inherits(ParticleSystemComponent, RenderableComponent), _createClass(ParticleSystemComponent, [ {
        key: "capacity",
        get: function get() {
            return this._capacity;
        },
        set: function set(val) {
            this._capacity = val, this.renderer && this.renderer._model && this.renderer._model.setCapacity(this._capacity);
        }
    }, {
        key: "prewarm",
        get: function get() {
            return this._prewarm;
        },
        set: function set(val) {
            !0 === val && this.loop, this._prewarm = val;
        }
    }, {
        key: "simulationSpace",
        get: function get() {
            return this._simulationSpace;
        },
        set: function set(val) {
            val !== this._simulationSpace && (this._simulationSpace = val, this.renderer._updateMaterialParams(), 
            this.renderer._updateTrailMaterial());
        }
    }, {
        key: "sharedMaterials",
        get: function get() {
            return _get(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", this);
        },
        set: function set(val) {
            _set(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", val, this, !0);
        }
    } ]), _createClass(ParticleSystemComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this.renderer.onInit(this), this.shapeModule.onInit(this), this.trailModule.onInit(this), 
            this.textureAnimationModule.onInit(this), this._resetPosition();
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(index, material) {
            this.renderer._onMaterialModified(index, material);
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(index, material) {
            this.renderer._onRebuildPSO(index, material);
        }
    }, {
        key: "_getModel",
        value: function _getModel() {
            return this.renderer._model;
        }
    }, {
        key: "recreateModel",
        value: function recreateModel() {
            if (this.isValid) {
                var r = this.renderer;
                r && r._model && (r._model.destroy(), r._model = null, r.onEnable(), r._updateModel(), 
                r._updateMaterialParams(), r._updateTrailMaterial());
            }
        }
    }, {
        key: "play",
        value: function play() {
            this._isPaused && (this._isPaused = !1), this._isStopped && (this._isStopped = !1), 
            this._isPlaying = !0, this._isEmitting = !0, this._resetPosition(), this._prewarm && this._prewarmSystem();
        }
    }, {
        key: "pause",
        value: function pause() {
            this._isStopped ? console.warn("pause(): particle system is already stopped.") : (this._isPlaying && (this._isPlaying = !1), 
            this._isPaused = !0);
        }
    }, {
        key: "stop",
        value: function stop() {
            (this._isPlaying || this._isPaused) && this.clear(), this._isPlaying && (this._isPlaying = !1), 
            this._isPaused && (this._isPaused = !1), this._time = 0, this._emitRateTimeCounter = 0, 
            this._emitRateDistanceCounter = 0, this._isStopped = !0;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.enabledInHierarchy && (this.renderer.clear(), this.trailModule.clear());
        }
    }, {
        key: "getParticleCount",
        value: function getParticleCount() {
            return this.renderer.getParticleCount();
        }
    }, {
        key: "setCustomData1",
        value: function setCustomData1(x, y) {
            Vec2.set(this._customData1, x, y);
        }
    }, {
        key: "setCustomData2",
        value: function setCustomData2(x, y) {
            Vec2.set(this._customData2, x, y);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.renderer.onDestroy(), this.trailModule.destroy();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.playOnAwake && this.play(), this.renderer.onEnable(), this.trailModule.onEnable();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.renderer.onDisable(), this.trailModule.onDisable();
        }
    }, {
        key: "update",
        value: function update(dt) {
            var scaledDeltaTime = dt * this.simulationSpeed;
            this._isPlaying && (this._time += scaledDeltaTime, this._emit(scaledDeltaTime), 
            0 !== this.renderer._updateParticles(scaledDeltaTime) || this._isEmitting || this.stop(), 
            this.renderer._updateRenderData(), this.trailModule.enable && this.trailModule.updateRenderData());
        }
    }, {
        key: "_onVisiblityChange",
        value: function _onVisiblityChange(val) {
            this.renderer._model && (this.renderer._model.viewID = val);
        }
    }, {
        key: "emit",
        value: function emit(count, dt) {
            for (var i = 0; i < count; ++i) {
                var particle = this.renderer._getFreeParticle();
                if (null === particle) return;
                var rand = pseudoRandom(randomRangeInt(0, 2147483647));
                switch (this.shapeModule.enable ? this.shapeModule.emit(particle) : (Vec3.set(particle.position, 0, 0, 0), 
                Vec3.copy(particle.velocity, particleEmitZAxis)), Vec3.multiplyScalar(particle.velocity, particle.velocity, this.startSpeed.evaluate(this._time / this.duration, rand)), 
                this._simulationSpace) {
                  case Space.Local:
                    break;

                  case Space.World:
                    this.node.getWorldMatrix(_world_mat), Vec3.transformMat4(particle.position, particle.position, _world_mat);
                    var worldRot = new Quat();
                    this.node.getWorldRotation(worldRot), Vec3.transformQuat(particle.velocity, particle.velocity, worldRot);
                    break;

                  case Space.Custom:
                }
                Vec3.copy(particle.ultimateVelocity, particle.velocity), Vec3.set(particle.rotation, this.startRotation.evaluate(this._time / this.duration, rand), 0, 0), 
                Vec3.set(particle.startSize, this.startSize.evaluate(this._time / this.duration, rand), 0, 0), 
                Vec3.copy(particle.size, particle.startSize), particle.startColor.set(this.startColor.evaluate(this._time / this.duration, rand)), 
                particle.color.set(particle.startColor), particle.startLifetime = this.startLifetime.evaluate(this._time / this.duration, rand) + dt, 
                particle.remainingLifetime = particle.startLifetime, particle.randomSeed = randomRangeInt(0, 233280), 
                this.renderer._setNewParticle(particle);
            }
        }
    }, {
        key: "_prewarmSystem",
        value: function _prewarmSystem() {
            this.startDelay.mode = Mode$1.Constant, this.startDelay.constant = 0;
            for (var cnt = this.duration / 1, i = 0; i < cnt; ++i) this._time += 1, this._emit(1), 
            this.renderer._updateParticles(1);
        }
    }, {
        key: "_emit",
        value: function _emit(dt) {
            var startDelay = this.startDelay.evaluate(0, 1);
            if (this._time > startDelay) {
                if (this._time > this.duration + startDelay && !this.loop) return void (this._isEmitting = !1);
                if (this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt, 
                this._emitRateTimeCounter > 1 && this._isEmitting) {
                    var emitNum = Math.floor(this._emitRateTimeCounter);
                    this._emitRateTimeCounter -= emitNum, this.emit(emitNum, dt);
                }
                this.node.getWorldPosition(this._curWPos);
                var distance = Vec3.distance(this._curWPos, this._oldWPos);
                if (Vec3.copy(this._oldWPos, this._curWPos), this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1), 
                this._emitRateDistanceCounter > 1 && this._isEmitting) {
                    var _emitNum = Math.floor(this._emitRateDistanceCounter);
                    this._emitRateDistanceCounter -= _emitNum, this.emit(_emitNum, dt);
                }
                var _iterator = this.bursts, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    _ref.update(this, dt);
                }
            }
        }
    }, {
        key: "_resetPosition",
        value: function _resetPosition() {
            this.node.getWorldPosition(this._oldWPos), Vec3.copy(this._curWPos, this._oldWPos);
        }
    }, {
        key: "addSubEmitter",
        value: function addSubEmitter(subEmitter) {
            this._subEmitters.push(subEmitter);
        }
    }, {
        key: "removeSubEmitter",
        value: function removeSubEmitter(idx) {
            this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
        }
    }, {
        key: "addBurst",
        value: function addBurst(burst) {
            this.bursts.push(burst);
        }
    }, {
        key: "removeBurst",
        value: function removeBurst(idx) {
            this.bursts.splice(this.bursts.indexOf(idx), 1);
        }
    }, {
        key: "isPlaying",
        get: function get() {
            return this._isPlaying;
        }
    }, {
        key: "isPaused",
        get: function get() {
            return this._isPaused;
        }
    }, {
        key: "isStopped",
        get: function get() {
            return this._isStopped;
        }
    }, {
        key: "isEmitting",
        get: function get() {
            return this._isEmitting;
        }
    }, {
        key: "time",
        get: function get() {
            return this._time;
        }
    } ]), ParticleSystemComponent;
}()).prototype, "capacity", [ _dec4$H ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "capacity"), _class2$1d.prototype), 
_descriptor$1a = _applyDecoratedDescriptor(_class2$1d.prototype, "startColor", [ _dec5$E ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange();
    }
}), _descriptor2$10 = _applyDecoratedDescriptor(_class2$1d.prototype, "scaleSpace", [ _dec6$A ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _descriptor3$M = _applyDecoratedDescriptor(_class2$1d.prototype, "startSize", [ _dec7$q ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor4$H = _applyDecoratedDescriptor(_class2$1d.prototype, "startSpeed", [ _dec8$i ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor5$B = _applyDecoratedDescriptor(_class2$1d.prototype, "startRotation", [ _dec9$f ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor6$r = _applyDecoratedDescriptor(_class2$1d.prototype, "startDelay", [ _dec10$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor7$n = _applyDecoratedDescriptor(_class2$1d.prototype, "startLifetime", [ _dec11$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor8$k = _applyDecoratedDescriptor(_class2$1d.prototype, "duration", [ _dec12$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 5;
    }
}), _descriptor9$g = _applyDecoratedDescriptor(_class2$1d.prototype, "loop", [ _dec13$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _applyDecoratedDescriptor(_class2$1d.prototype, "prewarm", [ _dec14$6 ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "prewarm"), _class2$1d.prototype), 
_applyDecoratedDescriptor(_class2$1d.prototype, "simulationSpace", [ _dec15$6 ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "simulationSpace"), _class2$1d.prototype), 
_descriptor10$e = _applyDecoratedDescriptor(_class2$1d.prototype, "simulationSpeed", [ _dec16$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor11$d = _applyDecoratedDescriptor(_class2$1d.prototype, "playOnAwake", [ _dec17$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor12$c = _applyDecoratedDescriptor(_class2$1d.prototype, "gravityModifier", [ _dec18$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor13$a = _applyDecoratedDescriptor(_class2$1d.prototype, "rateOverTime", [ _dec19$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor14$8 = _applyDecoratedDescriptor(_class2$1d.prototype, "rateOverDistance", [ _dec20$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange();
    }
}), _descriptor15$4 = _applyDecoratedDescriptor(_class2$1d.prototype, "bursts", [ _dec21 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Array();
    }
}), _applyDecoratedDescriptor(_class2$1d.prototype, "sharedMaterials", [ _dec22 ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "sharedMaterials"), _class2$1d.prototype), 
_descriptor16$4 = _applyDecoratedDescriptor(_class2$1d.prototype, "colorOverLifetimeModule", [ _dec23 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new ColorOvertimeModule();
    }
}), _descriptor17$3 = _applyDecoratedDescriptor(_class2$1d.prototype, "shapeModule", [ _dec24 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new ShapeModule();
    }
}), _descriptor18$2 = _applyDecoratedDescriptor(_class2$1d.prototype, "sizeOvertimeModule", [ _dec25 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new SizeOvertimeModule();
    }
}), _descriptor19$2 = _applyDecoratedDescriptor(_class2$1d.prototype, "velocityOvertimeModule", [ _dec26 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new VelocityOvertimeModule();
    }
}), _descriptor20 = _applyDecoratedDescriptor(_class2$1d.prototype, "forceOvertimeModule", [ _dec27 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new ForceOvertimeModule();
    }
}), _descriptor21 = _applyDecoratedDescriptor(_class2$1d.prototype, "limitVelocityOvertimeModule", [ _dec28 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new LimitVelocityOvertimeModule();
    }
}), _descriptor22 = _applyDecoratedDescriptor(_class2$1d.prototype, "rotationOvertimeModule", [ _dec29 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new RotationOvertimeModule();
    }
}), _descriptor23 = _applyDecoratedDescriptor(_class2$1d.prototype, "textureAnimationModule", [ _dec30 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new TextureAnimationModule();
    }
}), _descriptor24 = _applyDecoratedDescriptor(_class2$1d.prototype, "trailModule", [ _dec31 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new TrailModule();
    }
}), _descriptor25 = _applyDecoratedDescriptor(_class2$1d.prototype, "renderer", [ _dec32 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new ParticleSystemRenderer();
    }
}), _descriptor26 = _applyDecoratedDescriptor(_class2$1d.prototype, "_prewarm", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor27 = _applyDecoratedDescriptor(_class2$1d.prototype, "_capacity", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 100;
    }
}), _descriptor28 = _applyDecoratedDescriptor(_class2$1d.prototype, "_simulationSpace", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1p = _class2$1d)) || _class$1p) || _class$1p) || _class$1p) || _class$1p), ParticleUtils = function() {
    function ParticleUtils() {
        _classCallCheck(this, ParticleUtils);
    }
    return _createClass(ParticleUtils, null, [ {
        key: "instantiate",
        value: function instantiate(prefab) {
            return this.registeredSceneEvent || (cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this), 
            this.registeredSceneEvent = !0), this.particleSystemPool.has(prefab._uuid) || this.particleSystemPool.set(prefab._uuid, new Pool$1(function() {
                return cc.instantiate(prefab);
            }, 1)), this.particleSystemPool.get(prefab._uuid).alloc();
        }
    }, {
        key: "destroy",
        value: function destroy(prefab) {
            this.particleSystemPool.has(prefab._prefab.asset._uuid) && (this.stop(prefab), this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab));
        }
    }, {
        key: "onSceneUnload",
        value: function onSceneUnload() {
            this.particleSystemPool.forEach(function(value) {
                value.clear(function(prefab) {
                    prefab.destroy();
                });
            }), this.particleSystemPool.clear();
        }
    }, {
        key: "play",
        value: function play(rootNode) {
            var _iterator = rootNode.getComponentsInChildren(cc.ParticleSystemComponent), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.play();
            }
        }
    }, {
        key: "stop",
        value: function stop(rootNode) {
            var _iterator2 = rootNode.getComponentsInChildren(cc.ParticleSystemComponent), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                _ref2.stop();
            }
        }
    } ]), ParticleUtils;
}();

ParticleUtils.particleSystemPool = new Map(), ParticleUtils.registeredSceneEvent = !1;

var _dec$1q, _dec2$14, _dec3$S, _dec4$J, _dec5$G, _dec6$B, _class$1r, _class2$1f, _descriptor$1c, _descriptor2$12, _descriptor3$O, _descriptor4$J, _descriptor5$C, _class$1s, SphereLightComponent = (_dec$1p = ccclass("cc.SphereLightComponent"), 
_dec2$13 = menu("Components/SphereLightComponent"), _dec3$R = property({
    unit: "lm"
}), _dec4$I = property({
    unit: "cd/m"
}), _dec5$F = property({
    type: PhotometricTerm
}), _dec$1p(_class$1q = _dec2$13(_class$1q = executeInEditMode((_descriptor$1b = _applyDecoratedDescriptor((_class2$1e = function(_LightComponent) {
    function SphereLightComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SphereLightComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SphereLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_size", _descriptor$1b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_luminance", _descriptor2$11, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_term", _descriptor3$N, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_range", _descriptor4$I, _assertThisInitialized(_this)), 
        _this._type = LightType.SPHERE, _this._light = null, _this;
    }
    return _inherits(SphereLightComponent, LightComponent), _createClass(SphereLightComponent, [ {
        key: "_createLight",
        value: function _createLight(scene) {
            var _this2 = this;
            this.node.scene && (scene = scene || this._getRenderScene(), this._light && scene.sphereLights.find(function(c) {
                return c === _this2._light;
            }) || (this._light = scene.createSphereLight(this.name, this.node), this._light ? (this._light.luminance = this._luminance, 
            this.size = this._size, this.range = this._range, _get(_getPrototypeOf(SphereLightComponent.prototype), "_createLight", this).call(this, scene)) : console.warn("we don't support this many lights in forward pipeline.")));
        }
    }, {
        key: "_destroyLight",
        value: function _destroyLight(scene) {
            this.node.scene && this._light && (scene || (scene = this._getRenderScene()), scene.destroySphereLight(this._light), 
            _get(_getPrototypeOf(SphereLightComponent.prototype), "_destroyLight", this).call(this, scene));
        }
    }, {
        key: "luminousPower",
        get: function get() {
            return this._luminance * nt2lm(this._size);
        },
        set: function set(val) {
            this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
        }
    }, {
        key: "luminance",
        get: function get() {
            return this._luminance;
        },
        set: function set(val) {
            this._luminance = val, this._light && (this._light.luminance = val);
        }
    }, {
        key: "term",
        get: function get() {
            return this._term;
        },
        set: function set(val) {
            this._term = val;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        },
        set: function set(val) {
            this._size = val, this._light && (this._light.size = val);
        }
    }, {
        key: "range",
        get: function get() {
            return this._range;
        },
        set: function set(val) {
            this._range = val, this._light && (this._light.range = val);
        }
    } ]), SphereLightComponent;
}()).prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .15;
    }
}), _descriptor2$11 = _applyDecoratedDescriptor(_class2$1e.prototype, "_luminance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1700 / nt2lm(.15);
    }
}), _descriptor3$N = _applyDecoratedDescriptor(_class2$1e.prototype, "_term", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PhotometricTerm.LUMINOUS_POWER;
    }
}), _descriptor4$I = _applyDecoratedDescriptor(_class2$1e.prototype, "_range", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$1e.prototype, "luminousPower", [ _dec3$R ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "luminousPower"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "luminance", [ _dec4$I ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "luminance"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "term", [ _dec5$F ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "term"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "size"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "range", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "range"), _class2$1e.prototype), 
_class$1q = _class2$1e)) || _class$1q) || _class$1q) || _class$1q), SpotLightComponent = (_dec$1q = ccclass("cc.SpotLightComponent"), 
_dec2$14 = menu("Components/SpotLightComponent"), _dec3$S = property({
    unit: "lm"
}), _dec4$J = property({
    unit: "cd/m"
}), _dec5$G = property({
    type: PhotometricTerm
}), _dec6$B = property({
    slide: !0,
    range: [ 2, 180, 1 ]
}), _dec$1q(_class$1r = _dec2$14(_class$1r = executeInEditMode((_descriptor$1c = _applyDecoratedDescriptor((_class2$1f = function(_LightComponent) {
    function SpotLightComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SpotLightComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpotLightComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_size", _descriptor$1c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_luminance", _descriptor2$12, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_term", _descriptor3$O, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_range", _descriptor4$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spotAngle", _descriptor5$C, _assertThisInitialized(_this)), 
        _this._type = LightType.SPOT, _this._light = null, _this;
    }
    return _inherits(SpotLightComponent, LightComponent), _createClass(SpotLightComponent, [ {
        key: "_createLight",
        value: function _createLight(scene) {
            var _this2 = this;
            this.node.scene && (scene || (scene = this._getRenderScene()), this._light && scene.spotLights.find(function(c) {
                return c === _this2._light;
            }) || (this._light = scene.createSpotLight(this.name, this.node), this._light ? (this._light.luminance = this._luminance, 
            this.size = this._size, this.range = this._range, this.spotAngle = this._spotAngle, 
            _get(_getPrototypeOf(SpotLightComponent.prototype), "_createLight", this).call(this, scene)) : console.warn("we don't support this many lights in forward pipeline.")));
        }
    }, {
        key: "_destroyLight",
        value: function _destroyLight(scene) {
            this.node.scene && this._light && (scene || (scene = this._getRenderScene()), scene.destroySpotLight(this._light), 
            _get(_getPrototypeOf(SpotLightComponent.prototype), "_destroyLight", this).call(this, scene));
        }
    }, {
        key: "luminousPower",
        get: function get() {
            return this._luminance * nt2lm(this._size);
        },
        set: function set(val) {
            this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
        }
    }, {
        key: "luminance",
        get: function get() {
            return this._luminance;
        },
        set: function set(val) {
            this._luminance = val, this._light && (this._light.luminance = val);
        }
    }, {
        key: "term",
        get: function get() {
            return this._term;
        },
        set: function set(val) {
            this._term = val;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        },
        set: function set(val) {
            this._size = val, this._light && (this._light.size = val);
        }
    }, {
        key: "range",
        get: function get() {
            return this._range;
        },
        set: function set(val) {
            this._range = val, this._light && (this._light.range = val);
        }
    }, {
        key: "spotAngle",
        get: function get() {
            return this._spotAngle;
        },
        set: function set(val) {
            this._spotAngle = val, this._light && (this._light.spotAngle = toRadian(val));
        }
    } ]), SpotLightComponent;
}()).prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .15;
    }
}), _descriptor2$12 = _applyDecoratedDescriptor(_class2$1f.prototype, "_luminance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1700 / nt2lm(.15);
    }
}), _descriptor3$O = _applyDecoratedDescriptor(_class2$1f.prototype, "_term", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PhotometricTerm.LUMINOUS_POWER;
    }
}), _descriptor4$J = _applyDecoratedDescriptor(_class2$1f.prototype, "_range", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor5$C = _applyDecoratedDescriptor(_class2$1f.prototype, "_spotAngle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 60;
    }
}), _applyDecoratedDescriptor(_class2$1f.prototype, "luminousPower", [ _dec3$S ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "luminousPower"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "luminance", [ _dec4$J ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "luminance"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "term", [ _dec5$G ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "term"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "size"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "range", [ property ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "range"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "spotAngle", [ _dec6$B ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "spotAngle"), _class2$1f.prototype), 
_class$1r = _class2$1f)) || _class$1r) || _class$1r) || _class$1r);

cc.CameraComponent = CameraComponent, cc.EditorComponent = EditorCameraComponent, 
cc.RenderableComponent = RenderableComponent, cc.ModelComponent = ModelComponent, 
cc.SkinningModelComponent = SkinningModelComponent, cc.AvatarModelComponent = AvatarModelComponent, 
cc.AvatarUnit = AvatarUnit, cc.BatchedSkinningModelComponent = BatchedSkinningModelComponent, 
cc.SkinningModelUnit = SkinningModelUnit, cc.LightComponent = LightComponent, cc.DirectionalLightComponent = DirectionalLightComponent, 
cc.SphereLightComponent = SphereLightComponent, cc.SpotLightComponent = SpotLightComponent, 
cc.ParticleSystemComponent = ParticleSystemComponent, cc.BillboardComponent = BillboardComponent, 
cc.LineComponent = LineComponent, cc.ParticleUtils = ParticleUtils, cc.geometry = geometry, 
cc.utils = utils;

var _class$1t, Counter = ccclass("cc.Counter")(_class$1s = function() {
    function Counter(id, opts, now) {
        _classCallCheck(this, Counter), this._id = void 0, this._opts = void 0, this._accumStart = void 0, 
        this._total = 0, this._value = 0, this._averageValue = 0, this._accumValue = 0, 
        this._accumSamples = 0, this._id = id, this._opts = opts, this._accumStart = now;
    }
    return _createClass(Counter, [ {
        key: "value",
        get: function get() {
            return this._value;
        },
        set: function set(val) {
            this._value = val;
        }
    } ]), _createClass(Counter, [ {
        key: "sample",
        value: function sample(now) {
            this._average(this._value, now);
        }
    }, {
        key: "human",
        value: function human() {
            var isPoint = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], v = this._opts.average ? this._averageValue : this._value;
            return isPoint ? Math.round(100 * v) / 100 : Math.round(v);
        }
    }, {
        key: "alarm",
        value: function alarm() {
            return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
        }
    }, {
        key: "_average",
        value: function _average(v) {
            var now = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            if (this._opts.average) {
                this._accumValue += v, ++this._accumSamples;
                var t = now;
                t - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, 
                this._accumValue = 0, this._accumStart = t, this._accumSamples = 0);
            }
        }
    } ]), Counter;
}()) || _class$1s, PerfCounter = ccclass("cc.PerfCounter")(_class$1t = function(_Counter) {
    function PerfCounter(id, opts, now) {
        var _this;
        return _classCallCheck(this, PerfCounter), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PerfCounter).call(this, id, opts, now)))._time = void 0, 
        _this._time = now, _this;
    }
    return _inherits(PerfCounter, Counter), _createClass(PerfCounter, [ {
        key: "start",
        value: function start() {
            var now = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            this._time = now;
        }
    }, {
        key: "end",
        value: function end() {
            var now = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            this._value = now - this._time, this._average(this._value);
        }
    }, {
        key: "tick",
        value: function tick() {
            this.end(), this.start();
        }
    }, {
        key: "frame",
        value: function frame(now) {
            var t = now, e = t - this._time;
            this._total++, e > (this._opts.average || 1e3) && (this._value = 1e3 * this._total / e, 
            this._total = 0, this._time = t, this._average(this._value));
        }
    } ]), PerfCounter;
}()) || _class$1t, Profiler = function() {
    function Profiler() {
        _classCallCheck(this, Profiler), this._stats = null, this._showFPS = !1, this._fontSize = 22, 
        this._lineHeight = this._fontSize + 2, this._left = 10, this._right = 10, this._top = 10, 
        this._buttom = 10, this._rootNode = null, this._device = null, this._canvas = void 0, 
        this._ctx = void 0, this._texture = null, this._textureView = null, this._region = new GFXBufferTextureCopy(), 
        this._canvasArr = [ this._canvas ], this._regionArr = [ this._region ], this._canvasDone = !1, 
        this._statsDone = !1, this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), 
        this._region = new GFXBufferTextureCopy();
    }
    return _createClass(Profiler, [ {
        key: "isShowingStats",
        value: function isShowingStats() {
            return this._showFPS;
        }
    }, {
        key: "hideStats",
        value: function hideStats() {
            this._showFPS && (this._rootNode && (this._rootNode.active = !1), director.off(cc.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), 
            director.off(cc.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), director.off(cc.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), 
            director.off(cc.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), director.off(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), 
            director.off(cc.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !1);
        }
    }, {
        key: "showStats",
        value: function showStats() {
            this._showFPS || (this.initDevice(), this.generateCanvas(), this.generateStats(), 
            this._rootNode && (this._rootNode.active = !0), director.on(cc.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), 
            director.on(cc.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), director.on(cc.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), 
            director.on(cc.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), director.on(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), 
            director.on(cc.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !0, 
            this._canvasDone = !0, this._statsDone = !0);
        }
    }, {
        key: "initDevice",
        value: function initDevice() {
            this._device || (this._device = director.root.device);
        }
    }, {
        key: "generateCanvas",
        value: function generateCanvas() {
            if (!this._canvasDone) {
                this._canvas.width = 350, this._canvas.height = 200, this._canvas.style.width = "".concat(this._canvas.width), 
                this._canvas.style.height = "".concat(this._canvas.height), this._ctx && (this._ctx.font = "".concat(this._fontSize, "px Arial"), 
                this._ctx.textBaseline = "top", this._ctx.fillStyle = "#fff", this._texture = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED,
                    format: GFXFormat.RGBA8,
                    width: 350,
                    height: 200,
                    mipLevel: 1
                }), this._textureView = this._device.createTextureView({
                    texture: this._texture,
                    type: GFXTextureViewType.TV2D,
                    format: GFXFormat.RGBA8
                }), this._region.texExtent.width = 350, this._region.texExtent.height = 200);
            }
        }
    }, {
        key: "generateStats",
        value: function generateStats() {
            if (!this._statsDone) {
                this._stats = null;
                var now = director.getCurrentTime(), opts = {
                    frame: {
                        desc: "Frame time (ms)",
                        min: 0,
                        max: 50,
                        average: 500
                    },
                    fps: {
                        desc: "Framerate (FPS)",
                        below: 30,
                        average: 500
                    },
                    draws: {
                        desc: "Draw call"
                    },
                    tricount: {
                        desc: "Triangle"
                    },
                    logic: {
                        desc: "Game Logic (ms)",
                        min: 0,
                        max: 50,
                        average: 500,
                        color: "#080"
                    },
                    physics: {
                        desc: "Physics (ms)",
                        min: 0,
                        max: 50,
                        average: 500
                    },
                    render: {
                        desc: "Renderer (ms)",
                        min: 0,
                        max: 50,
                        average: 500,
                        color: "#f90"
                    },
                    textureMemory: {
                        desc: "GFX Texture Mem(M)"
                    },
                    bufferMemory: {
                        desc: "GFX Buffer Mem(M)"
                    }
                };
                this._ctx.textAlign = "left";
                for (var i = 0, _i = 0, _Object$keys = Object.keys(opts); _i < _Object$keys.length; _i++) {
                    var id = _Object$keys[_i];
                    this._ctx.fillText(opts[id].desc, this._left, this._top + i * this._lineHeight), 
                    opts[id].counter = new PerfCounter(id, opts[id], now), i++;
                }
                this._ctx.textAlign = "end", this._stats = opts;
            }
        }
    }, {
        key: "generateNode",
        value: function generateNode() {
            if (!this._rootNode || !this._rootNode.isValid) {
                this._rootNode = new Node$1("PROFILER_NODE"), cc.game.addPersistRootNode(this._rootNode);
                var cameraNode = new Node$1("Profiler_Camera");
                cameraNode.setPosition(0, 0, 1), cameraNode.parent = this._rootNode;
                var camera = cameraNode.addComponent("cc.CameraComponent");
                camera.projection = CameraComponent.ProjectionType.ORTHO, camera.near = 0, camera.far = 0, 
                camera.orthoHeight = this._device.height, camera.visibility = 3735928559, camera.clearFlags = GFXClearFlag.DEPTH | GFXClearFlag.STENCIL;
                var managerNode = new Node$1("Profiler_Root");
                managerNode.parent = this._rootNode;
                var modelCom = managerNode.addComponent("cc.ModelComponent");
                modelCom.mesh = createMesh({
                    positions: [ -.3, -.2, 0, -.3, .2, 0, .3, .2, 0, .3, -.2, 0 ],
                    indices: [ 0, 2, 1, 0, 3, 2 ],
                    uvs: [ 0, 1, 0, 0, 1, 0, 1, 1 ]
                });
                var _material = new Material();
                _material.initialize({
                    effectName: "builtin-screen-quad"
                }), _material.setProperty("offset", new Vec4(-.9, -.9, 0, 0));
                var pass = _material.passes[0], handle = pass.getBinding("mainTexture");
                pass.bindTextureView(handle, this._textureView), modelCom.material = _material, 
                modelCom.visibility = 3735928559;
            }
        }
    }, {
        key: "beforeUpdate",
        value: function beforeUpdate() {
            if (this._stats) {
                this.generateNode();
                var now = cc.director._lastUpdate;
                this.getCounter("frame").end(now), this.getCounter("frame").start(now), this.getCounter("logic").start(now);
            }
        }
    }, {
        key: "afterUpdate",
        value: function afterUpdate() {
            if (this._stats) {
                var now = director.getCurrentTime();
                director.isPaused() ? this.getCounter("frame").start(now) : this.getCounter("logic").end(now);
            }
        }
    }, {
        key: "beforePhysics",
        value: function beforePhysics() {
            if (this._stats) {
                var now = director.getCurrentTime();
                this.getCounter("physics").start(now);
            }
        }
    }, {
        key: "afterPhysics",
        value: function afterPhysics() {
            if (this._stats) {
                var now = director.getCurrentTime();
                this.getCounter("physics").end(now);
            }
        }
    }, {
        key: "beforeDraw",
        value: function beforeDraw() {
            if (this._stats) {
                var now = director.getCurrentTime();
                this.getCounter("render").start(now);
            }
        }
    }, {
        key: "afterDraw",
        value: function afterDraw() {
            if (this._stats) {
                var now = director.getCurrentTime();
                this.getCounter("fps").frame(now), this.getCounter("draws").value = this._device.numDrawCalls, 
                this.getCounter("bufferMemory").value = this._device.memoryStatus.bufferSize / 1048576, 
                this.getCounter("textureMemory").value = this._device.memoryStatus.textureSize / 1048576, 
                this.getCounter("tricount").value = this._device.numTris, this.getCounter("render").end(now);
                var x = this._left + this._ctx.measureText("GFX Texture Mem(M)").width;
                this._ctx.clearRect(x, 0, this._canvas.width - x, this._canvas.height);
                for (var i = 0, _i2 = 0, _Object$keys2 = Object.keys(this._stats); _i2 < _Object$keys2.length; _i2++) {
                    var id = _Object$keys2[_i2], stat = this._stats[id];
                    stat.counter.sample(now), this._ctx.fillText(stat.counter.human(!("Framerate (FPS)" === stat.desc)), this._canvas.width - this._right, this._top + i * this._lineHeight), 
                    i++;
                }
                this._canvasArr[0] = this._canvas, this.updateTexture();
            }
        }
    }, {
        key: "getCounter",
        value: function getCounter(s) {
            return this._stats[s].counter;
        }
    }, {
        key: "updateTexture",
        value: function updateTexture() {
            director.root.device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
        }
    } ]), Profiler;
}(), profiler = new Profiler();

cc.profiler = profiler, cc.math = math;

var _temp_vec3_1$1 = new Vec3();

cc.pipelineUtils = {
    WorldNode3DToLocalNodeUI: function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
        out || (out = new Vec3()), mainCamera.worldToScreen(wpos, _temp_vec3_1$1), _temp_vec3_1$1.x = _temp_vec3_1$1.x / cc.view.getScaleX(), 
        _temp_vec3_1$1.y = _temp_vec3_1$1.y / cc.view.getScaleY();
        var cmp = uiNode.getComponent(UITransformComponent);
        if (!cmp) return out;
        cmp.convertToNodeSpaceAR(_temp_vec3_1$1, out);
        var targetPos = uiNode.getPosition();
        return out.add(targetPos), out;
    },
    WorldNode3DToWorldNodeUI: function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
        return out || (out = new Vec3()), mainCamera.worldToScreen(wpos, out), out.x = out.x / cc.view.getScaleX(), 
        out.y = out.y / cc.view.getScaleY(), out;
    }
}, cc.RenderPassStage = RenderPassStage;

var NodePool = function() {
    function NodePool(poolHandlerComp) {
        _classCallCheck(this, NodePool), this.poolHandlerComp = void 0, this._pool = void 0, 
        this.poolHandlerComp = poolHandlerComp, this._pool = [];
    }
    return _createClass(NodePool, [ {
        key: "size",
        value: function size() {
            return this._pool.length;
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var count = this._pool.length, i = 0; i < count; ++i) this._pool[i].destroy();
            this._pool.length = 0;
        }
    }, {
        key: "put",
        value: function put(obj) {
            if (obj && -1 === this._pool.indexOf(obj)) {
                obj.removeFromParent();
                var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                handler && handler.unuse && handler.unuse(), this._pool.push(obj);
            }
        }
    }, {
        key: "get",
        value: function get() {
            var last = this._pool.length - 1;
            if (last < 0) return null;
            var obj = this._pool[last];
            this._pool.length = last;
            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
            if (handler && handler.reuse) {
                for (var _handler$reuse, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                (_handler$reuse = handler.reuse).apply.apply(_handler$reuse, [ handler ].concat(args));
            }
            return obj;
        }
    } ]), NodePool;
}();

cc.NodePool = NodePool;

var vmath = {};

function quadIn(k) {
    return k * k;
}

function quadOut(k) {
    return k * (2 - k);
}

function cubicIn(k) {
    return k * k * k;
}

function cubicOut(k) {
    return --k * k * k + 1;
}

function quartIn(k) {
    return k * k * k * k;
}

function quartOut(k) {
    return 1 - --k * k * k * k;
}

function quintIn(k) {
    return k * k * k * k * k;
}

function quintOut(k) {
    return --k * k * k * k * k + 1;
}

function sineIn(k) {
    return 1 - Math.cos(k * Math.PI / 2);
}

function sineOut(k) {
    return Math.sin(k * Math.PI / 2);
}

function expoIn(k) {
    return 0 === k ? 0 : Math.pow(1024, k - 1);
}

function expoOut(k) {
    return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
}

function circIn(k) {
    return 1 - Math.sqrt(1 - k * k);
}

function circOut(k) {
    return Math.sqrt(1 - --k * k);
}

function backIn(k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
}

function backOut(k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
}

function bounceIn(k) {
    return 1 - bounceOut(1 - k);
}

function bounceOut(k) {
    return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
}

replaceProperty(vmath, "vmath", [ {
    name: "vec2",
    newName: "Vec2",
    target: math,
    targetName: "math"
}, {
    name: "vec3",
    newName: "Vec3",
    target: math,
    targetName: "math"
}, {
    name: "vec4",
    newName: "Vec4",
    target: math,
    targetName: "math"
}, {
    name: "quat",
    newName: "Quat",
    target: math,
    targetName: "math"
}, {
    name: "mat3",
    newName: "Mat3",
    target: math,
    targetName: "math"
}, {
    name: "mat4",
    newName: "Mat4",
    target: math,
    targetName: "math"
}, {
    name: "color4",
    newName: "Color",
    target: math,
    targetName: "math"
}, {
    name: "rect",
    newName: "Rect",
    target: math,
    targetName: "math"
}, {
    name: "approx",
    newName: "approx",
    target: math,
    targetName: "math"
}, {
    name: "EPSILON",
    newName: "EPSILON",
    target: math,
    targetName: "math"
}, {
    name: "equals",
    newName: "equals",
    target: math,
    targetName: "math"
}, {
    name: "clamp",
    newName: "clamp",
    target: math,
    targetName: "math"
}, {
    name: "clamp01",
    newName: "clamp01",
    target: math,
    targetName: "math"
}, {
    name: "lerp",
    newName: "lerp",
    target: math,
    targetName: "math"
}, {
    name: "toRadian",
    newName: "toRadian",
    target: math,
    targetName: "math"
}, {
    name: "toDegree",
    newName: "toDegree",
    target: math,
    targetName: "math"
}, {
    name: "random",
    newName: "random",
    target: math,
    targetName: "math"
}, {
    name: "randomRange",
    newName: "randomRange",
    target: math,
    targetName: "math"
}, {
    name: "randomRangeInt",
    newName: "randomRangeInt",
    target: math,
    targetName: "math"
}, {
    name: "pseudoRandom",
    newName: "pseudoRandom",
    target: math,
    targetName: "math"
}, {
    name: "pseudoRandomRangeInt",
    newName: "pseudoRandomRangeInt",
    target: math,
    targetName: "math"
}, {
    name: "nextPow2",
    newName: "nextPow2",
    target: math,
    targetName: "math"
}, {
    name: "repeat",
    newName: "repeat",
    target: math,
    targetName: "math"
}, {
    name: "pingPong",
    newName: "pingPong",
    target: math,
    targetName: "math"
}, {
    name: "inverseLerp",
    newName: "inverseLerp",
    target: math,
    targetName: "math"
} ]), cc.vmath = vmath;

var quadOutIn = _makeOutIn(quadIn, quadOut), cubicOutIn = _makeOutIn(cubicIn, cubicOut), quartOutIn = _makeOutIn(quartIn, quartOut), quintOutIn = _makeOutIn(quintIn, quintOut), sineOutIn = _makeOutIn(sineIn, sineOut), expoOutIn = _makeOutIn(expoIn, expoOut), circOutIn = _makeOutIn(circIn, circOut), backOutIn = _makeOutIn(backIn, backOut), bounceOutIn = _makeOutIn(bounceIn, bounceOut);

function _makeOutIn(fnIn, fnOut) {
    return function(k) {
        return k < .5 ? fnOut(2 * k) / 2 : fnIn(2 * k - 1) / 2 + .5;
    };
}

var easing = Object.freeze({
    constant: function constant() {
        return 0;
    },
    linear: function linear(k) {
        return k;
    },
    quadIn: quadIn,
    quadOut: quadOut,
    quadInOut: function quadInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
    },
    cubicIn: cubicIn,
    cubicOut: cubicOut,
    cubicInOut: function cubicInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
    },
    quartIn: quartIn,
    quartOut: quartOut,
    quartInOut: function quartInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
    },
    quintIn: quintIn,
    quintOut: quintOut,
    quintInOut: function quintInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
    },
    sineIn: sineIn,
    sineOut: sineOut,
    sineInOut: function sineInOut(k) {
        return .5 * (1 - Math.cos(Math.PI * k));
    },
    expoIn: expoIn,
    expoOut: expoOut,
    expoInOut: function expoInOut(k) {
        return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
    },
    circIn: circIn,
    circOut: circOut,
    circInOut: function circInOut(k) {
        return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: function elasticIn(k) {
        var s, a = .1;
        return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
        -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
    },
    elasticOut: function elasticOut(k) {
        var s, a = .1;
        return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
        a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
    },
    elasticInOut: function elasticInOut(k) {
        var s, a = .1;
        return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
        (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4) * .5 + 1);
    },
    backIn: backIn,
    backOut: backOut,
    backInOut: function backInOut(k) {
        var s = 2.5949095;
        return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    bounceIn: bounceIn,
    bounceOut: bounceOut,
    bounceInOut: function bounceInOut(k) {
        return k < .5 ? .5 * bounceIn(2 * k) : .5 * bounceOut(2 * k - 1) + .5;
    },
    smooth: function smooth(k) {
        return k <= 0 ? 0 : k >= 1 ? 1 : k * k * (3 - 2 * k);
    },
    fade: function fade(k) {
        return k <= 0 ? 0 : k >= 1 ? 1 : k * k * k * (k * (6 * k - 15) + 10);
    },
    quadOutIn: quadOutIn,
    cubicOutIn: cubicOutIn,
    quartOutIn: quartOutIn,
    quintOutIn: quintOutIn,
    sineOutIn: sineOutIn,
    expoOutIn: expoOutIn,
    circOutIn: circOutIn,
    backOutIn: backOutIn,
    bounceOutIn: bounceOutIn
});

function bezier(C1, C2, C3, C4, t) {
    var t1 = 1 - t;
    return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
}

cc.bezier = bezier;

var cos$2 = Math.cos, acos$1 = Math.acos, max$4 = Math.max, tau = 2 * Math.PI, sqrt = Math.sqrt;

function crt(v) {
    return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
}

function bezierByTime(controlPoints, x) {
    var percent = function cardano(curve, x) {
        var u1, x1, x2, x3, pa = x - 0, pb = x - curve[0], pa3 = 3 * pa, pb3 = 3 * pb, pc3 = 3 * (x - curve[2]), rd = 1 / (-pa + pb3 - pc3 + (x - 1)), a = (pa3 - 6 * pb + pc3) * rd, a3 = a * (1 / 3), b = (-pa3 + pb3) * rd, p = 1 / 3 * (3 * b - a * a), p3 = p * (1 / 3), q = (2 * a * a * a - 9 * a * b + 27 * (pa * rd)) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
        if (discriminant < 0) {
            var mp3 = 1 / 3 * -p, r = sqrt(mp3 * mp3 * mp3), t = -q / (2 * r), phi = acos$1(t < -1 ? -1 : t > 1 ? 1 : t), t1 = 2 * crt(r);
            return x1 = t1 * cos$2(phi * (1 / 3)) - a3, x2 = t1 * cos$2((phi + tau) * (1 / 3)) - a3, 
            x3 = t1 * cos$2((phi + 2 * tau) * (1 / 3)) - a3, 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$4(x1, x2, x3) : max$4(x1, x2) : 0 <= x3 && x3 <= 1 ? max$4(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$4(x2, x3) : x2 : x3;
        }
        if (0 === discriminant) return x2 = -(u1 = q2 < 0 ? crt(-q2) : -crt(q2)) - a3, 0 <= (x1 = 2 * u1 - a3) && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max$4(x1, x2) : x1 : x2;
        var sd = sqrt(discriminant);
        return x1 = (u1 = crt(-q2 + sd)) - crt(q2 + sd) - a3;
    }(controlPoints, x), t1 = 1 - percent;
    return 0 * t1 * t1 * t1 + 3 * controlPoints[1] * percent * t1 * t1 + 3 * controlPoints[3] * percent * percent * t1 + 1 * percent * percent * percent;
}

cc.bezierByTime = bezierByTime;

var WrapModeMask, WrapMode$2, EPSILON$3 = 1e-6;

function binarySearchEpsilon(array, value) {
    for (var low = 0, high = array.length - 1, middle = high >>> 1; low <= high; middle = low + high >>> 1) {
        var middleValue = array[middle];
        if (middleValue > value + EPSILON$3) high = middle - 1; else {
            if (!(middleValue < value - EPSILON$3)) return middle;
            low = middle + 1;
        }
    }
    return ~low;
}

!function(WrapModeMask) {
    WrapModeMask[WrapModeMask.Loop = 2] = "Loop", WrapModeMask[WrapModeMask.ShouldWrap = 4] = "ShouldWrap", 
    WrapModeMask[WrapModeMask.PingPong = 22] = "PingPong", WrapModeMask[WrapModeMask.Reverse = 36] = "Reverse";
}(WrapModeMask || (WrapModeMask = {})), function(WrapMode) {
    WrapMode[WrapMode.Default = 0] = "Default", WrapMode[WrapMode.Normal = 1] = "Normal", 
    WrapMode[WrapMode.Reverse = WrapModeMask.Reverse] = "Reverse", WrapMode[WrapMode.Loop = WrapModeMask.Loop] = "Loop", 
    WrapMode[WrapMode.LoopReverse = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse", 
    WrapMode[WrapMode.PingPong = WrapModeMask.PingPong] = "PingPong", WrapMode[WrapMode.PingPongReverse = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
}(WrapMode$2 || (WrapMode$2 = {})), ccenum(WrapMode$2);

var _class$1u, WrappedInfo = function() {
    function WrappedInfo(info) {
        _classCallCheck(this, WrappedInfo), this.ratio = 0, this.time = 0, this.direction = 1, 
        this.stopped = !0, this.iterations = 0, this.frameIndex = void 0, info && this.set(info);
    }
    return _createClass(WrappedInfo, [ {
        key: "set",
        value: function set(info) {
            this.ratio = info.ratio, this.time = info.time, this.direction = info.direction, 
            this.stopped = info.stopped, this.iterations = info.iterations, this.frameIndex = info.frameIndex;
        }
    } ]), WrappedInfo;
}();

var RatioSampler = function() {
    function RatioSampler(ratios) {
        var currRatioDif, lastRatioDif;
        _classCallCheck(this, RatioSampler), this.ratios = void 0, this._findRatio = void 0, 
        this.ratios = ratios;
        for (var canOptimize = !0, i = 1, l = ratios.length; i < l; i++) if (currRatioDif = ratios[i] - ratios[i - 1], 
        1 === i) lastRatioDif = currRatioDif; else if (Math.abs(currRatioDif - lastRatioDif) > 1e-6) {
            canOptimize = !1;
            break;
        }
        this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon;
    }
    return _createClass(RatioSampler, [ {
        key: "sample",
        value: function sample(ratio) {
            return this._findRatio(this.ratios, ratio);
        }
    } ]), RatioSampler;
}();

cc.RatioSampler = RatioSampler;

var AnimCurve = function() {
    function AnimCurve(propertyCurveData, duration) {
        _classCallCheck(this, AnimCurve), this.types = void 0, this.type = null, this._values = [], 
        this._lerp = void 0, this._stepfiedValues = void 0, this._duration = void 0, this._duration = duration, 
        this._values = propertyCurveData.values;
        var getCurveType = function getCurveType(easingMethod) {
            return "string" == typeof easingMethod ? easingMethod : Array.isArray(easingMethod) ? easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3] ? AnimCurve.Linear : AnimCurve.Bezier(easingMethod) : AnimCurve.Linear;
        };
        void 0 !== propertyCurveData.easingMethod ? this.type = getCurveType(propertyCurveData.easingMethod) : void 0 !== propertyCurveData.easingMethods ? this.types = propertyCurveData.easingMethods.map(getCurveType) : this.type = null;
        var firstValue = propertyCurveData.values[0];
        (void 0 === propertyCurveData.interpolate || propertyCurveData.interpolate) && (this._lerp = selectLerpFx(firstValue));
    }
    return _createClass(AnimCurve, null, [ {
        key: "Bezier",
        value: function Bezier(controlPoints) {
            return controlPoints;
        }
    } ]), _createClass(AnimCurve, [ {
        key: "hasLerp",
        value: function hasLerp() {
            return !!this._lerp;
        }
    }, {
        key: "valueAt",
        value: function valueAt(index) {
            var value = this._values[index];
            return value && value.getNoLerp ? value.getNoLerp() : value;
        }
    }, {
        key: "valueBetween",
        value: function valueBetween(ratio, from, fromRatio, to, toRatio) {
            if (this._lerp) {
                var type = this.types ? this.types[from] : this.type, dRatio = toRatio - fromRatio, ratioBetweenFrames = (ratio - fromRatio) / dRatio;
                type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
                var fromVal = this._values[from], toVal = this._values[to];
                return this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
            }
            return this.valueAt(from);
        }
    }, {
        key: "empty",
        value: function empty() {
            return 0 === this._values.length;
        }
    } ]), AnimCurve;
}();

AnimCurve.Linear = null, cc.AnimCurve = AnimCurve;

var EventInfo = function() {
    function EventInfo() {
        _classCallCheck(this, EventInfo), this.events = [];
    }
    return _createClass(EventInfo, [ {
        key: "add",
        value: function add(func, params) {
            this.events.push({
                func: func || "",
                params: params || []
            });
        }
    } ]), EventInfo;
}(), CurveValueAdapter = ccclass("cc.CurveValueAdapter")(_class$1u = function() {
    function CurveValueAdapter() {
        _classCallCheck(this, CurveValueAdapter);
    }
    return _createClass(CurveValueAdapter, [ {
        key: "forTarget",
        value: function forTarget(target) {
            return {
                set: function set(value) {}
            };
        }
    } ]), CurveValueAdapter;
}()) || _class$1u;

function sampleAnimationCurve(curve, sampler, ratio) {
    var index = sampler.sample(ratio);
    if (index < 0) if ((index = ~index) <= 0) index = 0; else {
        if (!(index >= sampler.ratios.length)) return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
        index = sampler.ratios.length - 1;
    }
    return curve.valueAt(index);
}

function computeRatioByType(ratio, type) {
    if ("string" == typeof type) {
        var func = easing[type];
        func ? ratio = func(ratio) : errorID(3906, type);
    } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
    return ratio;
}

function quickFindIndex(ratios, ratio) {
    var length = ratios.length - 1;
    if (0 === length) return 0;
    var start = ratios[0];
    if (ratio < start) return 0;
    var end = ratios[length];
    if (ratio > end) return length;
    var index = (ratio = (ratio - start) / (end - start)) / (1 / length), floorIndex = 0 | index;
    return index - floorIndex < 1e-6 ? floorIndex : floorIndex + 1 - index < 1e-6 ? floorIndex + 1 : ~(floorIndex + 1);
}

cc.CurveValueAdapter = CurveValueAdapter, cc.sampleAnimationCurve = sampleAnimationCurve;

var _class$1v, _class2$1g, _descriptor$1d, _class4$6, _class5$6, _descriptor2$13, selectLerpFx = function() {
    function callLerpable(from, to, t, dt) {
        return from.lerp(to, t, dt);
    }
    return function(value) {
        if (null !== value) {
            if ("number" == typeof value) return lerp;
            if ("object" === _typeof(value) && value.constructor) {
                if (value instanceof ValueType) return function makeValueTypeLerpFx(constructor) {
                    var tempValue = new constructor();
                    return function(from, to, ratio) {
                        return constructor.lerp(tempValue, from, to, ratio), tempValue;
                    };
                }(value.constructor);
                if (value.constructor === Number) return lerp;
                if (function isLerpable(object) {
                    return "function" == typeof object.lerp;
                }(value)) return callLerpable;
            }
        }
    };
}(), EPSILON$4 = 1e-6;

function isPropertyModifier(modifier) {
    return "string" == typeof modifier;
}

function isElementModifier(modifier) {
    return "number" == typeof modifier;
}

function isCustomTargetModifier(modifier, constructor) {
    return modifier instanceof constructor;
}

cc.isPropertyModifier = isPropertyModifier, cc.isElementModifier = isElementModifier, 
cc.isCustomTargetModifier = isCustomTargetModifier;

var HierachyModifier = ccclass("cc.HierachyModifier")((_descriptor$1d = _applyDecoratedDescriptor((_class2$1g = function() {
    function HierachyModifier(path) {
        _classCallCheck(this, HierachyModifier), _initializerDefineProperty(this, "path", _descriptor$1d, this), 
        this.path = path || "";
    }
    return _createClass(HierachyModifier, [ {
        key: "get",
        value: function get(target) {
            if (!(target instanceof Node$1)) throw new Error("Target of hierachy modifier shall be Node.");
            var result = target.getChildByPath(this.path);
            if (!result) throw new Error('Node "'.concat(target.name, '" has no path "').concat(this.path, '"'));
            return result;
        }
    } ]), HierachyModifier;
}()).prototype, "path", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$1v = _class2$1g)) || _class$1v;

cc.HierachyModifier = HierachyModifier;

var ComponentModifier = ccclass("cc.ComponentModifier")((_descriptor2$13 = _applyDecoratedDescriptor((_class5$6 = function() {
    function ComponentModifier(component) {
        _classCallCheck(this, ComponentModifier), _initializerDefineProperty(this, "component", _descriptor2$13, this), 
        this.component = component || "";
    }
    return _createClass(ComponentModifier, [ {
        key: "get",
        value: function get(target) {
            if (!(target instanceof Node$1)) throw new Error("Target of hierachy modifier shall be Node.");
            var result = target.getComponent(this.component);
            if (!result) throw new Error('Node "'.concat(target.name, '" has no component "').concat(this.component, '"'));
            return result;
        }
    } ]), ComponentModifier;
}()).prototype, "component", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class4$6 = _class5$6)) || _class4$6;

cc.ComponentModifier = ComponentModifier;

var _dec$1v, _dec2$16, _class$1w, _class2$1h, _descriptor$1e, _descriptor2$14, _descriptor3$P, _descriptor4$K, _descriptor5$D, _descriptor6$s, _descriptor7$o, _descriptor8$l, _descriptor9$h, _class3$z, _temp$1o, BoundTarget = function() {
    function BoundTarget(target, modifiers, valueAdapter) {
        var assignmentModifier;
        _classCallCheck(this, BoundTarget), this._isProxy = void 0, this._assignmentOrProxy = void 0;
        for (var iModifier = 0; iModifier < modifiers.length; ++iModifier) {
            var modifier = modifiers[iModifier];
            if (isElementModifier(modifier) || isPropertyModifier(modifier)) if (iModifier !== modifiers.length - 1 || valueAdapter) {
                if (!(modifier in target)) throw new Error('Target object has no property "'.concat(modifier, '"'));
                target = target[modifier];
            } else assignmentModifier = modifier; else target = modifier.get(target);
        }
        if (void 0 !== assignmentModifier) this._assignmentOrProxy = {
            object: target,
            propertyOrElement: assignmentModifier
        }, this._isProxy = !1; else {
            if (!valueAdapter) throw new Error("Bad animation curve.");
            this._assignmentOrProxy = valueAdapter.forTarget(target), this._isProxy = !0;
        }
    }
    return _createClass(BoundTarget, [ {
        key: "setValue",
        value: function setValue(value) {
            this._isProxy ? this._assignmentOrProxy.set(value) : this._assignmentOrProxy.object[this._assignmentOrProxy.propertyOrElement] = value;
        }
    } ]), BoundTarget;
}();

cc.BoundTarget = BoundTarget;

var AnimationClip = (_dec$1v = ccclass("cc.AnimationClip"), _dec2$16 = property({
    visible: !1
}), _dec$1v((_temp$1o = _class3$z = function(_Asset) {
    function AnimationClip() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AnimationClip);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "sample", _descriptor$1e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "speed", _descriptor2$14, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "wrapMode", _descriptor3$P, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "curveDatas", _descriptor4$K, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_curves", _descriptor5$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "events", _descriptor6$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_duration", _descriptor7$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_keys", _descriptor8$l, _assertThisInitialized(_this)), 
        _this._ratioSamplers = [], _this._runtimeCurves = void 0, _this._runtimeEvents = void 0, 
        _this.frameRate = 0, _initializerDefineProperty(_this, "_stepness", _descriptor9$h, _assertThisInitialized(_this)), 
        _this._hash = 0, _this;
    }
    return _inherits(AnimationClip, Asset), _createClass(AnimationClip, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.frameRate = this.sample, this._migrateCurveDatas();
        }
    }, {
        key: "getPropertyCurves",
        value: function getPropertyCurves(root) {
            return this._runtimeCurves || this._createPropertyCurves(), this._runtimeCurves;
        }
    }, {
        key: "updateCurveDatas",
        value: function updateCurveDatas() {
            this._migrateCurveDatas(), delete this._runtimeCurves;
        }
    }, {
        key: "updateEventDatas",
        value: function updateEventDatas() {
            delete this._runtimeEvents;
        }
    }, {
        key: "getEventGroupIndexAtRatio",
        value: function getEventGroupIndexAtRatio(ratio) {
            return this._runtimeEvents || this._createRuntimeEvents(), function binarySearchEpsilon$1(array, value) {
                for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                    var test = array[m];
                    if (test > value + EPSILON$4) h = m - 1; else {
                        if (!(test < value - EPSILON$4)) return m;
                        l = m + 1;
                    }
                }
                return ~l;
            }(this._runtimeEvents.ratios, ratio);
        }
    }, {
        key: "hasEvents",
        value: function hasEvents() {
            return 0 !== this.events.length;
        }
    }, {
        key: "_createPropertyCurves",
        value: function _createPropertyCurves() {
            var _this2 = this;
            this._ratioSamplers = this._keys.map(function(keys) {
                return new RatioSampler(keys.map(function(key) {
                    return key / _this2._duration;
                }));
            }), this._runtimeCurves = this._curves.map(function(targetCurve) {
                return {
                    curve: new AnimCurve(targetCurve.data, _this2._duration),
                    modifiers: targetCurve.modifiers,
                    valueAdapter: targetCurve.valueAdapter,
                    sampler: _this2._ratioSamplers[targetCurve.data.keys]
                };
            }), this._applyStepness();
        }
    }, {
        key: "_createRuntimeEvents",
        value: function _createRuntimeEvents() {
            var _this3 = this;
            var ratios = [], eventGroups = [], _loop = function _loop() {
                if (_isArray) {
                    if (_i >= _iterator.length) return "break";
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) return "break";
                    _ref = _i.value;
                }
                var eventData = _ref, ratio = eventData.frame / _this3._duration, i = ratios.findIndex(function(r) {
                    return r === ratio;
                });
                i < 0 && (i = ratios.length, ratios.push(ratio), eventGroups.push({
                    events: []
                })), eventGroups[i].events.push({
                    functionName: eventData.func,
                    parameters: eventData.params
                });
            }, _iterator = this.events.sort(function(a, b) {
                return a.frame - b.frame;
            }), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if ("break" === _loop()) break;
            }
            this._runtimeEvents = {
                ratios: ratios,
                eventGroups: eventGroups
            };
        }
    }, {
        key: "_applyStepness",
        value: function _applyStepness() {
            this._runtimeCurves;
        }
    }, {
        key: "_migrateCurveDatas",
        value: function _migrateCurveDatas() {
            var _this4 = this;
            if (this.curveDatas) {
                for (var _i2 = 0, _Object$keys = Object.keys(this.curveDatas); _i2 < _Object$keys.length; _i2++) {
                    var curveTargetPath = _Object$keys[_i2], hierachyModifier = new HierachyModifier();
                    hierachyModifier.path = curveTargetPath;
                    var nodeData = this.curveDatas[curveTargetPath];
                    if (nodeData.props) for (var _i4 = 0, _Object$keys2 = Object.keys(nodeData.props); _i4 < _Object$keys2.length; _i4++) {
                        var nodePropertyName = _Object$keys2[_i4], propertyCurveData = nodeData.props[nodePropertyName];
                        this._curves.push({
                            modifiers: [ hierachyModifier, nodePropertyName ],
                            data: propertyCurveData
                        });
                    }
                    if (nodeData.comps) for (var _i5 = 0, _Object$keys3 = Object.keys(nodeData.comps); _i5 < _Object$keys3.length; _i5++) {
                        var _componentName2 = _Object$keys3[_i5], componentModifier = new ComponentModifier();
                        componentModifier.component = _componentName2;
                        for (var componentData = nodeData.comps[_componentName2], _i6 = 0, _Object$keys4 = Object.keys(componentData); _i6 < _Object$keys4.length; _i6++) {
                            var componentPropertyName = _Object$keys4[_i6], _propertyCurveData = componentData[componentPropertyName];
                            this._curves.push({
                                modifiers: [ hierachyModifier, componentModifier, componentPropertyName ],
                                data: _propertyCurveData
                            });
                        }
                    }
                }
                delete this.curveDatas, Object.defineProperty(this, "curveDatas", {
                    get: function get() {
                        var result = {}, _iterator2 = _this4._curves, _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray2) {
                                if (_i3 >= _iterator2.length) break;
                                _ref2 = _iterator2[_i3++];
                            } else {
                                if ((_i3 = _iterator2.next()).done) break;
                                _ref2 = _i3.value;
                            }
                            var curve = _ref2;
                            if (0 !== curve.modifiers.length && isCustomTargetModifier(curve.modifiers[0], HierachyModifier)) {
                                var _componentName = null, _propertyName = void 0;
                                if (2 === curve.modifiers.length && isPropertyModifier(curve.modifiers[1])) _propertyName = curve.modifiers[1]; else {
                                    if (3 !== curve.modifiers.length || !isCustomTargetModifier(curve.modifiers[1], ComponentModifier) || !isPropertyModifier(curve.modifiers[2])) continue;
                                    _componentName = curve.modifiers[1].component, _propertyName = curve.modifiers[2];
                                }
                                var _path = curve.modifiers[0].path;
                                _path in result || (result[_path] = {});
                                var nodeCurveData = result[_path], objectCurveData = void 0;
                                if (_componentName) {
                                    "comps" in nodeCurveData || (nodeCurveData.comps = {});
                                    var componentCurveData = nodeCurveData.comps;
                                    _componentName in componentCurveData || (componentCurveData[_componentName] = {}), 
                                    objectCurveData = componentCurveData[_componentName];
                                } else "props" in nodeCurveData || (nodeCurveData.props = {}), objectCurveData = nodeCurveData.props;
                                objectCurveData[_propertyName] = curve.data;
                            }
                        }
                        return result;
                    }
                });
            }
        }
    }, {
        key: "duration",
        get: function get() {
            return this._duration;
        },
        set: function set(value) {
            this._duration = value;
        }
    }, {
        key: "keys",
        get: function get() {
            return this._keys;
        },
        set: function set(value) {
            this._keys = value;
        }
    }, {
        key: "eventGroups",
        get: function get() {
            return this._runtimeEvents || this._createRuntimeEvents(), this._runtimeEvents.eventGroups;
        }
    }, {
        key: "stepness",
        get: function get() {
            return this._stepness;
        },
        set: function set(value) {
            this._stepness = value, this._applyStepness();
        }
    }, {
        key: "hash",
        get: function get() {
            return this._hash || (this._hash = murmurhash2_32_gc(JSON.stringify(this.curveDatas), 666)), 
            this._hash;
        }
    }, {
        key: "curves",
        get: function get() {
            return this._curves;
        },
        set: function set(value) {
            this._curves = value, delete this._runtimeCurves;
        }
    } ], [ {
        key: "createWithSpriteFrames",
        value: function createWithSpriteFrames(spriteFrames, sample) {
            if (!Array.isArray(spriteFrames)) return errorID(3905), null;
            var clip = new AnimationClip();
            clip.sample = sample || clip.sample, clip.duration = spriteFrames.length / clip.sample;
            for (var step = 1 / clip.sample, keys = new Array(spriteFrames.length), values = new Array(keys.length), i = 0; i < spriteFrames.length; i++) keys[i] = i * step, 
            values[i] = spriteFrames[i];
            return clip.keys = [ keys ], clip.curveDatas = {
                "/": {
                    comps: {
                        "cc.SpriteComponent": {
                            spriteFrame: {
                                keys: 0,
                                values: values
                            }
                        }
                    }
                }
            }, clip;
        }
    } ]), AnimationClip;
}(), _class3$z.WrapMode = WrapMode$2, _descriptor$1e = _applyDecoratedDescriptor((_class2$1h = _temp$1o).prototype, "sample", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 60;
    }
}), _descriptor2$14 = _applyDecoratedDescriptor(_class2$1h.prototype, "speed", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor3$P = _applyDecoratedDescriptor(_class2$1h.prototype, "wrapMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode$2.Normal;
    }
}), _descriptor4$K = _applyDecoratedDescriptor(_class2$1h.prototype, "curveDatas", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return {};
    }
}), _descriptor5$D = _applyDecoratedDescriptor(_class2$1h.prototype, "_curves", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor6$s = _applyDecoratedDescriptor(_class2$1h.prototype, "events", [ _dec2$16 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor7$o = _applyDecoratedDescriptor(_class2$1h.prototype, "_duration", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$l = _applyDecoratedDescriptor(_class2$1h.prototype, "_keys", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor9$h = _applyDecoratedDescriptor(_class2$1h.prototype, "_stepness", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$1w = _class2$1h)) || _class$1w);

cc.AnimationClip = AnimationClip;

var _class$1x, AnimationBlendState = function() {
    function AnimationBlendState() {
        _classCallCheck(this, AnimationBlendState), this._blendTargets = [];
    }
    return _createClass(AnimationBlendState, [ {
        key: "refPropertyBlendTarget",
        value: function refPropertyBlendTarget(target, property) {
            var targetState = this._blendTargets.find(function(x) {
                return x.target === target;
            });
            targetState || (targetState = {
                target: target,
                properties: []
            }, this._blendTargets.push(targetState));
            var propertyStates = targetState.properties, propertyState = propertyStates.find(function(p) {
                return p.name === property;
            });
            return propertyState || (propertyState = {
                name: property,
                weight: 0,
                value: void 0,
                refCount: 0
            }, propertyStates.push(propertyState)), ++propertyState.refCount, propertyState;
        }
    }, {
        key: "derefPropertyBlendTarget",
        value: function derefPropertyBlendTarget(target, property) {
            var iTargetState = this._blendTargets.findIndex(function(x) {
                return x.target === target;
            });
            if (!(iTargetState < 0)) {
                var propertyStates = this._blendTargets[iTargetState].properties, iPropertyState = propertyStates.findIndex(function(p) {
                    return p.name === property;
                });
                if (!(iPropertyState < 0)) {
                    var propertyState = propertyStates[iPropertyState];
                    --propertyState.refCount, propertyState.refCount > 0 || (propertyStates.length >= 2 ? propertyStates.splice(iPropertyState, 1) : this._blendTargets.splice(iTargetState, 1));
                }
            }
        }
    }, {
        key: "apply",
        value: function apply() {
            var _iterator = this._blendTargets, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var targetState = _ref, target = targetState.target, _iterator2 = targetState.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var p = _ref2;
                    0 !== p.weight && (target instanceof Node$1 ? "position" === p.name ? target.setPosition(p.value) : "rotation" === p.name ? target.setRotation(p.value) : target.setScale(p.value) : target[p.name] = p.value);
                }
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            var _iterator3 = this._blendTargets, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var _iterator4 = _ref3.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.weight = 0;
                }
            }
        }
    } ]), AnimationBlendState;
}(), AnimationManager = ccclass(_class$1x = function() {
    function AnimationManager() {
        _classCallCheck(this, AnimationManager), this._anims = new MutableForwardIterator([]), 
        this._delayEvents = [], this._blendState = new AnimationBlendState(), this._crossFades = [], 
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
    }
    return _createClass(AnimationManager, [ {
        key: "addCrossFade",
        value: function addCrossFade(crossFade) {
            this._crossFades.push(crossFade);
        }
    }, {
        key: "removeCrossFade",
        value: function removeCrossFade(crossFade) {
            remove(this._crossFades, crossFade);
        }
    }, {
        key: "update",
        value: function update(dt) {
            var _iterator = this._crossFades, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.update(dt);
            }
            this._blendState.clear();
            var iterator = this._anims, array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var anim = array[iterator.i];
                anim.isPlaying && !anim.isPaused && anim.update(dt);
            }
            this._blendState.apply();
            for (var events = this._delayEvents, i = 0, l = events.length; i < l; i++) {
                var event = events[i];
                event.target[event.func].apply(event.target, event.args);
            }
            events.length = 0;
        }
    }, {
        key: "destruct",
        value: function destruct() {}
    }, {
        key: "addAnimation",
        value: function addAnimation(anim) {
            -1 === this._anims.array.indexOf(anim) && (anim.attachToBlendState(this._blendState), 
            this._anims.push(anim));
        }
    }, {
        key: "removeAnimation",
        value: function removeAnimation(anim) {
            var index = this._anims.array.indexOf(anim);
            index >= 0 ? (anim.detachFromBlendState(this._blendState), this._anims.fastRemoveAt(index)) : errorID(3907);
        }
    }, {
        key: "pushDelayEvent",
        value: function pushDelayEvent(target, func, args) {
            this._delayEvents.push({
                target: target,
                func: func,
                args: args
            });
        }
    }, {
        key: "blendState",
        get: function get() {
            return this._blendState;
        }
    } ]), AnimationManager;
}()) || _class$1x;

cc.AnimationManager = AnimationManager;

var PropertySpecialization, Playable = function() {
    function Playable() {
        _classCallCheck(this, Playable), this._isPlaying = !1, this._isPaused = !1, this._stepOnce = !1;
    }
    return _createClass(Playable, [ {
        key: "play",
        value: function play() {
            this._isPlaying ? this._isPaused ? (this._isPaused = !1, this.onResume()) : this.onError(getError(3912)) : (this._isPlaying = !0, 
            this.onPlay());
        }
    }, {
        key: "stop",
        value: function stop() {
            this._isPlaying && (this._isPlaying = !1, this.onStop(), this._isPaused = !1);
        }
    }, {
        key: "pause",
        value: function pause() {
            this._isPlaying && !this._isPaused && (this._isPaused = !0, this.onPause());
        }
    }, {
        key: "resume",
        value: function resume() {
            this._isPlaying && this._isPaused && (this._isPaused = !1, this.onResume());
        }
    }, {
        key: "step",
        value: function step() {
            this.pause(), this._stepOnce = !0, this._isPlaying || this.play();
        }
    }, {
        key: "update",
        value: function update(deltaTime) {}
    }, {
        key: "onPlay",
        value: function onPlay() {}
    }, {
        key: "onPause",
        value: function onPause() {}
    }, {
        key: "onResume",
        value: function onResume() {}
    }, {
        key: "onStop",
        value: function onStop() {}
    }, {
        key: "onError",
        value: function onError(message) {}
    }, {
        key: "isPlaying",
        get: function get() {
            return this._isPlaying;
        }
    }, {
        key: "isPaused",
        get: function get() {
            return this._isPaused;
        }
    } ]), Playable;
}();

function additive3D(value, weight, propertyBlendState) {
    return propertyBlendState.value || (propertyBlendState.value = new Vec3()), 0 === propertyBlendState.weight && Vec3.zero(propertyBlendState.value), 
    0 === weight ? propertyBlendState.value : 1 === weight ? Vec3.copy(propertyBlendState.value, value) : Vec3.scaleAndAdd(propertyBlendState.value, propertyBlendState.value, value, weight);
}

function additiveQuat(value, weight, propertyBlendState) {
    if (propertyBlendState.value || (propertyBlendState.value = new Quat()), 0 === propertyBlendState.weight && Quat.identity(propertyBlendState.value), 
    0 === weight) return propertyBlendState.value;
    if (1 === weight) return Quat.copy(propertyBlendState.value, value);
    var t = weight / (propertyBlendState.weight + weight);
    return Quat.slerp(propertyBlendState.value, propertyBlendState.value, value, t);
}

!function(PropertySpecialization) {
    PropertySpecialization[PropertySpecialization.NodePosition = 0] = "NodePosition", 
    PropertySpecialization[PropertySpecialization.NodeScale = 1] = "NodeScale", PropertySpecialization[PropertySpecialization.NodeRotation = 2] = "NodeRotation", 
    PropertySpecialization[PropertySpecialization.None = 3] = "None";
}(PropertySpecialization || (PropertySpecialization = {}));

var ICurveInstance = function() {
    function ICurveInstance(runtimeCurve, target) {
        var blendTarget = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        if (_classCallCheck(this, ICurveInstance), this._curve = void 0, this._boundTarget = void 0, 
        this._curveValueProxy = void 0, this._rootTarget = void 0, this._rootTargetProperty = void 0, 
        this._isNodeTarget = void 0, this._propertySpecialization = void 0, this._blendTarget = void 0, 
        this._blendFunction = void 0, this._cached = void 0, this._curveDetail = void 0, 
        this._curve = runtimeCurve.curve, this._curveDetail = runtimeCurve, this._boundTarget = new BoundTarget(target, runtimeCurve.modifiers, runtimeCurve.valueAdapter), 
        this._rootTarget = target, this._isNodeTarget = target instanceof Node$1, this._propertySpecialization = PropertySpecialization.None, 
        this._blendFunction = null, this._isNodeTarget && 1 === runtimeCurve.modifiers.length) switch (runtimeCurve.modifiers[0]) {
          case "position":
            this._propertySpecialization = PropertySpecialization.NodePosition, this._blendFunction = additive3D;
            break;

          case "rotation":
            this._propertySpecialization = PropertySpecialization.NodeRotation, this._blendFunction = additiveQuat;
            break;

          case "scale":
            this._propertySpecialization = PropertySpecialization.NodeScale, this._blendFunction = additive3D;
        }
        this._blendTarget = blendTarget;
    }
    return _createClass(ICurveInstance, [ {
        key: "attachToBlendState",
        value: function attachToBlendState(blendState) {
            this._rootTargetProperty && (this._blendTarget = blendState.refPropertyBlendTarget(this._rootTarget, this._rootTargetProperty));
        }
    }, {
        key: "dettachFromBlendState",
        value: function dettachFromBlendState(blendState) {
            this._rootTargetProperty && (this._blendTarget = null, blendState.derefPropertyBlendTarget(this._rootTarget, this._rootTargetProperty));
        }
    }, {
        key: "applySample",
        value: function applySample(ratio, index, lerpRequired, samplerResultCache, weight) {
            var value;
            this._curve.empty() || (value = lerpRequired ? this._curve.valueBetween(ratio, samplerResultCache.from, samplerResultCache.fromRatio, samplerResultCache.to, samplerResultCache.toRatio) : this._curve.valueAt(index), 
            this._setValue(value, weight));
        }
    }, {
        key: "_setValue",
        value: function _setValue(value, weight) {
            if (!this._blendFunction || !this._blendTarget || this._blendTarget.refCount <= 1) switch (this._propertySpecialization) {
              case PropertySpecialization.NodePosition:
                this._rootTarget.setPosition(value);
                break;

              case PropertySpecialization.NodeRotation:
                this._rootTarget.setRotation(value);
                break;

              case PropertySpecialization.NodeScale:
                this._rootTarget.setScale(value);
                break;

              default:
                this._boundTarget.setValue(value);
            } else this._blendTarget.value = this._blendFunction(value, weight, this._blendTarget), 
            this._blendTarget.weight += weight;
        }
    }, {
        key: "propertyName",
        get: function get() {
            return this._rootTargetProperty || "";
        }
    }, {
        key: "curveDetail",
        get: function get() {
            return this._curveDetail;
        }
    } ]), ICurveInstance;
}();

var _class4$7, _class5$7, _descriptor4$L, _descriptor5$E, _descriptor6$t, InvalidIndex = -1, AnimationState = function(_Playable) {
    function AnimationState(clip, name) {
        var _this;
        return _classCallCheck(this, AnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationState).call(this))).duration = 1, 
        _this.speed = 1, _this.time = 0, _this.weight = 0, _this.frameRate = 0, _this._lastframeEventOn = !1, 
        _this._wrapMode = WrapMode$2.Normal, _this._repeatCount = 1, _this._currentFramePlayed = !1, 
        _this._delay = 0, _this._delayTime = 0, _this._wrappedInfo = new WrappedInfo(), 
        _this._lastWrapInfo = null, _this._lastWrapInfoEvent = null, _this._process = _this.process, 
        _this._target = null, _this._targetNode = null, _this._clip = void 0, _this._name = void 0, 
        _this._lastIterations = void 0, _this._samplerSharedGroups = [], _this._curveLoaded = !1, 
        _this._ignoreIndex = InvalidIndex, _this._clip = clip, _this._name = name || clip && clip.name, 
        _this;
    }
    return _inherits(AnimationState, Playable), _createClass(AnimationState, [ {
        key: "clip",
        get: function get() {
            return this._clip;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "length",
        get: function get() {
            return this.duration;
        }
    }, {
        key: "wrapMode",
        get: function get() {
            return this._wrapMode;
        },
        set: function set(value) {
            this._wrapMode = value, this.time = 0, value & WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
        }
    }, {
        key: "repeatCount",
        get: function get() {
            return this._repeatCount;
        },
        set: function set(value) {
            this._repeatCount = value;
            var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap, reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
            this._process = value !== 1 / 0 || shouldWrap || reverse ? this.process : this.simpleProcess;
        }
    }, {
        key: "delay",
        get: function get() {
            return this._delay;
        },
        set: function set(value) {
            this._delayTime = this._delay = value;
        }
    } ]), _createClass(AnimationState, [ {
        key: "initialize",
        value: function initialize(root) {
            var _this2 = this;
            if (!this._curveLoaded) {
                this._curveLoaded = !0, this._samplerSharedGroups.length = 0, this._targetNode = root;
                var clip = this._clip;
                this.duration = clip.duration, this.speed = clip.speed, this.wrapMode = clip.wrapMode, 
                this.frameRate = clip.sample, (this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
                for (var propertyCurves = clip.getPropertyCurves(root), _loop = function _loop(iPropertyCurve) {
                    var propertyCurve = propertyCurves[iPropertyCurve], samplerSharedGroup = _this2._samplerSharedGroups.find(function(value) {
                        return value.sampler === propertyCurve.sampler;
                    });
                    samplerSharedGroup || (samplerSharedGroup = function makeSamplerSharedGroup(sampler) {
                        return {
                            sampler: sampler,
                            curves: [],
                            samplerResultCache: {
                                from: 0,
                                fromRatio: 0,
                                to: 0,
                                toRatio: 0
                            }
                        };
                    }(propertyCurve.sampler), _this2._samplerSharedGroups.push(samplerSharedGroup));
                    try {
                        samplerSharedGroup.curves.push(new ICurveInstance(propertyCurve, root));
                    } catch (err) {}
                }, iPropertyCurve = 0; iPropertyCurve < propertyCurves.length; ++iPropertyCurve) _loop(iPropertyCurve);
            }
        }
    }, {
        key: "_emit",
        value: function _emit(type, state) {
            this._target && this._target.isValid && this._target.emit(type, type, state);
        }
    }, {
        key: "emit",
        value: function emit() {
            for (var args = new Array(arguments.length), i = 0, l = args.length; i < l; i++) args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
            cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
        }
    }, {
        key: "on",
        value: function on(type, callback, target) {
            return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
            this._target.on(type, callback, target)) : null;
        }
    }, {
        key: "once",
        value: function once(type, callback, target) {
            var _this3 = this;
            return this._target && this._target.isValid ? ("lastframe" === type && (this._lastframeEventOn = !0), 
            this._target.once(type, function(event) {
                callback.call(target, event), _this3._lastframeEventOn = !1;
            })) : null;
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            this._target && this._target.isValid && ("lastframe" === type && (this._target.hasEventListener(type) || (this._lastframeEventOn = !1)), 
            this._target.off(type, callback, target));
        }
    }, {
        key: "_setEventTarget",
        value: function _setEventTarget(target) {
            this._target = target;
        }
    }, {
        key: "setTime",
        value: function setTime(time) {
            this._currentFramePlayed = !1, this.time = time || 0, this._lastWrapInfoEvent = null, 
            this._ignoreIndex = InvalidIndex;
            var info = this.getWrappedInfo(time, this._wrappedInfo), direction = info.direction, frameIndex = this._clip.getEventGroupIndexAtRatio(info.ratio);
            frameIndex < 0 && (frameIndex = ~frameIndex - 1, direction < 0 && (frameIndex += 1), 
            this._ignoreIndex = frameIndex);
        }
    }, {
        key: "update",
        value: function update(delta) {
            this._delayTime > 0 && (this._delayTime -= delta, this._delayTime > 0) || (this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = !0, 
            this._process());
        }
    }, {
        key: "_needReverse",
        value: function _needReverse(currentIterations) {
            var wrapMode = this.wrapMode, needReverse = !1;
            (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong && (currentIterations - (0 | currentIterations) == 0 && currentIterations > 0 && (currentIterations -= 1), 
            1 & currentIterations && (needReverse = !needReverse));
            return (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needReverse = !needReverse), 
            needReverse;
        }
    }, {
        key: "getWrappedInfo",
        value: function getWrappedInfo(time, info) {
            info = info || new WrappedInfo();
            var stopped = !1, duration = this.duration, repeatCount = this.repeatCount, currentIterations = time > 0 ? time / duration : -time / duration;
            if (currentIterations >= repeatCount) {
                currentIterations = repeatCount, stopped = !0;
                var tempRatio = repeatCount - (0 | repeatCount);
                0 === tempRatio && (tempRatio = 1), time = tempRatio * duration * (time > 0 ? 1 : -1);
            }
            if (time > duration) {
                var tempTime = time % duration;
                time = 0 === tempTime ? duration : tempTime;
            } else time < 0 && 0 !== (time %= duration) && (time += duration);
            var needReverse = !1, shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
            shouldWrap && (needReverse = this._needReverse(currentIterations));
            var direction = needReverse ? -1 : 1;
            return this.speed < 0 && (direction *= -1), shouldWrap && needReverse && (time = duration - time), 
            info.ratio = time / duration, info.time = time, info.direction = direction, info.stopped = stopped, 
            info.iterations = currentIterations, info;
        }
    }, {
        key: "sample",
        value: function sample() {
            var info = this.getWrappedInfo(this.time, this._wrappedInfo);
            return this._sampleCurves(info.ratio), this._sampleEvents(info), info;
        }
    }, {
        key: "process",
        value: function process() {
            var lastInfo, info = this.sample();
            this._lastframeEventOn && (lastInfo = this._lastWrapInfo ? this._lastWrapInfo : this._lastWrapInfo = new WrappedInfo(info), 
            this.repeatCount > 1 && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit("lastframe", this), 
            lastInfo.set(info));
            info.stopped && (this.stop(), this.emit("finished", this));
        }
    }, {
        key: "simpleProcess",
        value: function simpleProcess() {
            var time = this.time, duration = this.duration;
            time > duration ? 0 === (time %= duration) && (time = duration) : time < 0 && 0 !== (time %= duration) && (time += duration);
            var ratio = time / duration;
            this._sampleCurves(ratio), this._clip.hasEvents() && this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo)), 
            this._lastframeEventOn && (void 0 === this._lastIterations && (this._lastIterations = ratio), 
            (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit("lastframe", this), 
            this._lastIterations = ratio);
        }
    }, {
        key: "attachToBlendState",
        value: function attachToBlendState(blendState) {
            var _iterator = this._samplerSharedGroups, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var _iterator2 = _ref.curves, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    _ref2.attachToBlendState(blendState);
                }
            }
        }
    }, {
        key: "detachFromBlendState",
        value: function detachFromBlendState(blendState) {
            var _iterator3 = this._samplerSharedGroups, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var _iterator4 = _ref3.curves, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref4 = _i4.value;
                    }
                    _ref4.dettachFromBlendState(blendState);
                }
            }
        }
    }, {
        key: "cache",
        value: function cache(frames) {}
    }, {
        key: "onPlay",
        value: function onPlay() {
            this.setTime(0), this._delayTime = this._delay, cc.director.getAnimationManager().addAnimation(this), 
            this.emit("play", this);
        }
    }, {
        key: "onStop",
        value: function onStop() {
            this.isPaused || cc.director.getAnimationManager().removeAnimation(this), this.emit("stop", this);
        }
    }, {
        key: "onResume",
        value: function onResume() {
            cc.director.getAnimationManager().addAnimation(this), this.emit("resume", this);
        }
    }, {
        key: "onPause",
        value: function onPause() {
            cc.director.getAnimationManager().removeAnimation(this), this.emit("pause", this);
        }
    }, {
        key: "_sampleCurves",
        value: function _sampleCurves(ratio) {
            for (var iSamplerSharedGroup = 0, szSamplerSharedGroup = this._samplerSharedGroups.length; iSamplerSharedGroup < szSamplerSharedGroup; ++iSamplerSharedGroup) {
                var samplerSharedGroup = this._samplerSharedGroups[iSamplerSharedGroup], sampler = samplerSharedGroup.sampler, samplerResultCache = samplerSharedGroup.samplerResultCache, index = 0, lerpRequired = !1;
                sampler ? (index = sampler.sample(ratio)) < 0 && ((index = ~index) <= 0 ? index = 0 : index >= sampler.ratios.length ? index = sampler.ratios.length - 1 : (lerpRequired = !0, 
                samplerResultCache.from = index - 1, samplerResultCache.fromRatio = sampler.ratios[samplerResultCache.from], 
                samplerResultCache.to = index, samplerResultCache.toRatio = sampler.ratios[samplerResultCache.to])) : index = 0;
                for (var iCurveInstance = 0, szCurves = samplerSharedGroup.curves.length; iCurveInstance < szCurves; ++iCurveInstance) {
                    samplerSharedGroup.curves[iCurveInstance].applySample(ratio, index, lerpRequired, samplerResultCache, this.weight);
                }
            }
        }
    }, {
        key: "_sampleEvents",
        value: function _sampleEvents(wrapInfo) {
            var length = this._clip.eventGroups.length, direction = wrapInfo.direction, eventIndex = this._clip.getEventGroupIndexAtRatio(wrapInfo.ratio);
            if (eventIndex < 0 && (eventIndex = ~eventIndex - 1, direction < 0 && (eventIndex += 1)), 
            this._ignoreIndex !== eventIndex && (this._ignoreIndex = InvalidIndex), wrapInfo.frameIndex = eventIndex, 
            !this._lastWrapInfoEvent) return this._fireEvent(eventIndex), void (this._lastWrapInfoEvent = new WrappedInfo(wrapInfo));
            var wrapMode = this.wrapMode, currentIterations = wrapIterations(wrapInfo.iterations), lastWrappedInfo = this._lastWrapInfoEvent, lastIterations = wrapIterations(lastWrappedInfo.iterations), lastIndex = lastWrappedInfo.frameIndex, lastDirection = lastWrappedInfo.direction, interationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
            if (lastIndex === eventIndex && interationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== eventIndex || interationsChanged) {
                direction = lastDirection;
                do {
                    if (lastIndex !== eventIndex) {
                        if (-1 === direction && 0 === lastIndex && eventIndex > 0 ? ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length, 
                        lastIterations++) : 1 === direction && lastIndex === length - 1 && eventIndex < length - 1 && ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1, 
                        lastIterations++), lastIndex === eventIndex) break;
                        if (lastIterations > currentIterations) break;
                    }
                    lastIndex += direction, cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
                } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
            }
            this._lastWrapInfoEvent.set(wrapInfo);
        }
    }, {
        key: "_fireEvent",
        value: function _fireEvent(index) {
            if (this._targetNode && this._targetNode.isValid) {
                var eventGroups = this._clip.eventGroups;
                if (!(index < 0 || index >= eventGroups.length || this._ignoreIndex === index)) {
                    var eventGroup = eventGroups[index], components = this._targetNode.components, _iterator5 = eventGroup.events, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                    for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray5) {
                            if (_i5 >= _iterator5.length) break;
                            _ref5 = _iterator5[_i5++];
                        } else {
                            if ((_i5 = _iterator5.next()).done) break;
                            _ref5 = _i5.value;
                        }
                        var event = _ref5, functionName = event.functionName, _iterator6 = components, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                            var _ref6;
                            if (_isArray6) {
                                if (_i6 >= _iterator6.length) break;
                                _ref6 = _iterator6[_i6++];
                            } else {
                                if ((_i6 = _iterator6.next()).done) break;
                                _ref6 = _i6.value;
                            }
                            var component = _ref6, fx = component[functionName];
                            "function" == typeof fx && fx.apply(component, event.parameters);
                        }
                    }
                }
            }
        }
    }, {
        key: "curveLoaded",
        get: function get() {
            return this._curveLoaded;
        }
    } ]), AnimationState;
}();

function wrapIterations(iterations) {
    return iterations - (0 | iterations) == 0 && (iterations -= 1), 0 | iterations;
}

function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
    var _class, _class2, _descriptor, _descriptor2, _descriptor3, tempValue = new constructorX(), m0 = new constructorX(), m1 = new constructorX();
    return ccclass(name)((_descriptor = _applyDecoratedDescriptor((_class2 = function() {
        function CubicSplineValueClass(dataPoint, inTangent, outTangent) {
            _classCallCheck(this, CubicSplineValueClass), _initializerDefineProperty(this, "dataPoint", _descriptor, this), 
            _initializerDefineProperty(this, "inTangent", _descriptor2, this), _initializerDefineProperty(this, "outTangent", _descriptor3, this), 
            this.dataPoint = dataPoint || new constructorX(), this.inTangent = inTangent || new constructorX(), 
            this.outTangent = outTangent || new constructorX();
        }
        return _createClass(CubicSplineValueClass, [ {
            key: "lerp",
            value: function lerp(to, t, dt) {
                var p0 = this.dataPoint, p1 = to.dataPoint;
                m0 = scaleFx(m0, this.outTangent, dt), m1 = scaleFx(m1, to.inTangent, dt);
                var t_3 = t * t * t, t_2 = t * t, f_1 = t_3 - 2 * t_2 + t, f_2 = -2 * t_3 + 3 * t_2, f_3 = t_3 - t_2;
                return tempValue = scaleFx(tempValue, p0, 2 * t_3 - 3 * t_2 + 1), tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1), 
                tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2), tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
            }
        }, {
            key: "getNoLerp",
            value: function getNoLerp() {
                return this.dataPoint;
            }
        } ]), CubicSplineValueClass;
    }()).prototype, "dataPoint", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new constructorX();
        }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new constructorX();
        }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new constructorX();
        }
    }), _class = _class2)) || _class;
}

cc.AnimationState = AnimationState;

var CubicSplineVec2Value = makeCubicSplineValueConstructor("cc.CubicSplineVec2Value", Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd);

cc.CubicSplineVec2Value = CubicSplineVec2Value;

var CubicSplineVec3Value = makeCubicSplineValueConstructor("cc.CubicSplineVec3Value", Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd);

cc.CubicSplineVec3Value = CubicSplineVec3Value;

var CubicSplineVec4Value = makeCubicSplineValueConstructor("cc.CubicSplineVec4Value", Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd);

cc.CubicSplineVec4Value = CubicSplineVec4Value;

var CubicSplineQuatValue = makeCubicSplineValueConstructor("cc.CubicSplineQuatValue", Quat, Quat.multiplyScalar, Quat.scaleAndAdd);

cc.CubicSplineQuatValue = CubicSplineQuatValue;

var CubicSplineNumberValue = ccclass("cc.CubicSplineNumberValue")((_descriptor4$L = _applyDecoratedDescriptor((_class5$7 = function() {
    function CubicSplineNumberValue(dataPoint, inTangent, outTangent) {
        _classCallCheck(this, CubicSplineNumberValue), _initializerDefineProperty(this, "dataPoint", _descriptor4$L, this), 
        _initializerDefineProperty(this, "inTangent", _descriptor5$E, this), _initializerDefineProperty(this, "outTangent", _descriptor6$t, this), 
        this.dataPoint = dataPoint, this.inTangent = inTangent, this.outTangent = outTangent;
    }
    return _createClass(CubicSplineNumberValue, [ {
        key: "lerp",
        value: function lerp(to, t, dt) {
            var p0 = this.dataPoint, p1 = to.dataPoint, t_3 = t * t * t, t_2 = t * t;
            return p0 * (2 * t_3 - 3 * t_2 + 1) + this.outTangent * dt * (t_3 - 2 * t_2 + t) + p1 * (-2 * t_3 + 3 * t_2) + to.inTangent * dt * (t_3 - t_2);
        }
    }, {
        key: "getNoLerp",
        value: function getNoLerp() {
            return this.dataPoint;
        }
    } ]), CubicSplineNumberValue;
}()).prototype, "dataPoint", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor5$E = _applyDecoratedDescriptor(_class5$7.prototype, "inTangent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$t = _applyDecoratedDescriptor(_class5$7.prototype, "outTangent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class4$7 = _class5$7)) || _class4$7;

cc.CubicSplineNumberValue = CubicSplineNumberValue;

var _dec$1w, _dec2$18, _dec3$T, _dec4$K, _dec5$H, _dec6$C, _class$1y, _class2$1i, _descriptor$1f, _descriptor2$15, _descriptor3$Q, _class3$A, _temp$1q, EventType$1, CrossFade = function(_Playable) {
    function CrossFade() {
        var _this;
        return _classCallCheck(this, CrossFade), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this)))._fadings = [], 
        _this._unshiftDefault(), _this;
    }
    return _inherits(CrossFade, Playable), _createClass(CrossFade, [ {
        key: "update",
        value: function update(deltaTime) {
            if (this.isPlaying && !this.isPaused) for (var absoluteWeight = 1, i = 0; i < this._fadings.length; ++i) {
                if (0 === absoluteWeight) {
                    for (var j = i; j < this._fadings.length; ++j) {
                        var follingFading = this._fadings[j];
                        follingFading.state && this._directStopState(follingFading.state);
                    }
                    this._fadings.splice(i);
                    break;
                }
                var fading = this._fadings[i];
                fading.easeTime += deltaTime;
                var relativeWeight = clamp01(fading.easeTime / fading.easeDuration), weight = relativeWeight * absoluteWeight;
                absoluteWeight *= 1 - relativeWeight, fading.state && (fading.state.weight = weight);
            }
        }
    }, {
        key: "crossFade",
        value: function crossFade(state, duration) {
            var es = removeIf(this._fadings, function(animation) {
                return animation.state === state;
            });
            void 0 === es && (es = {
                easeDuration: duration,
                easeTime: 0,
                state: state
            }), this._fadings.unshift(es), state && this._directPlayState(state);
        }
    }, {
        key: "onPause",
        value: function onPause() {
            _get(_getPrototypeOf(CrossFade.prototype), "onPause", this).call(this);
            var _iterator = this._fadings, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var fading = _ref;
                fading.state && fading.state.pause();
            }
        }
    }, {
        key: "onResume",
        value: function onResume() {
            _get(_getPrototypeOf(CrossFade.prototype), "onResume", this).call(this);
            var _iterator2 = this._fadings, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var fading = _ref2;
                fading.state && fading.state.resume();
            }
        }
    }, {
        key: "onStop",
        value: function onStop() {
            _get(_getPrototypeOf(CrossFade.prototype), "onStop", this).call(this);
            var currentFading = this._fadings[0];
            currentFading.state && (currentFading.state.weight = 1);
            var _iterator3 = this._fadings, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var fading = _ref3;
                fading.state && this._directStopState(fading.state);
            }
            this._fadings.splice(1, this._fadings.length - 1);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.stop(), this._fadings.length = 0, this._unshiftDefault();
        }
    }, {
        key: "_unshiftDefault",
        value: function _unshiftDefault() {
            this._fadings.unshift({
                state: null,
                easeDuration: Number.POSITIVE_INFINITY,
                easeTime: 0
            });
        }
    }, {
        key: "_directStopState",
        value: function _directStopState(state) {
            state.stop();
        }
    }, {
        key: "_directPlayState",
        value: function _directPlayState(state) {
            state.weight = 1, state.play();
        }
    } ]), CrossFade;
}();

!function(EventType) {
    EventType.PLAY = "play", EventType.STOP = "stop", EventType.PAUSE = "pause", EventType.RESUME = "resume", 
    EventType.LASTFRAME = "lastframe", EventType.FINISHED = "finished";
}(EventType$1 || (EventType$1 = {})), ccenum(EventType$1);

var AnimationComponent = (_dec$1w = ccclass("cc.AnimationComponent"), _dec2$18 = executionOrder(99), 
_dec3$T = menu("Components/AnimationComponent"), _dec4$K = property({
    type: [ AnimationClip ]
}), _dec5$H = property({
    type: AnimationClip
}), _dec6$C = property({
    type: [ AnimationClip ]
}), _dec$1w(_class$1y = _dec2$18(_class$1y = executeInEditMode(_class$1y = _dec3$T((_temp$1q = _class3$A = function(_Component) {
    function AnimationComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AnimationComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "playOnLoad", _descriptor$1f, _assertThisInitialized(_this)), 
        _this._callbackTable = createMap(!0), _this._crossFade = new CrossFade(), _this._nameToState = createMap(!0), 
        _initializerDefineProperty(_this, "_clips", _descriptor2$15, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_defaultClip", _descriptor3$Q, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(AnimationComponent, Component), _createClass(AnimationComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this.clips = this._clips;
            for (var _i = 0, _Object$keys = Object.keys(this._nameToState); _i < _Object$keys.length; _i++) {
                var stateName = _Object$keys[_i];
                this._nameToState[stateName].initialize(this.node);
            }
        }
    }, {
        key: "start",
        value: function start() {
            cc.director.getAnimationManager().addCrossFade(this._crossFade), this._crossFade.play(), 
            this.playOnLoad && this._defaultClip && this.crossFade(this._defaultClip.name, 0);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._crossFade && this._crossFade.resume();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._crossFade && this._crossFade.pause();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._crossFade && (this._crossFade.stop(), cc.director.getAnimationManager().removeCrossFade(this._crossFade), 
            this._crossFade.stop());
            for (var _i2 = 0, _Object$keys2 = Object.keys(this._nameToState); _i2 < _Object$keys2.length; _i2++) {
                var _name = _Object$keys2[_i2];
                this._nameToState[_name].stop();
            }
            this._nameToState = null;
        }
    }, {
        key: "play",
        value: function play(name) {
            if (!name) {
                if (!this._defaultClip) return;
                name = this._defaultClip.name;
            }
            this.crossFade(name, 0);
        }
    }, {
        key: "crossFade",
        value: function crossFade(name) {
            var duration = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3, state = this._nameToState[name];
            state && this._crossFade.crossFade(state, duration);
        }
    }, {
        key: "pause",
        value: function pause() {
            this._crossFade.pause();
        }
    }, {
        key: "resume",
        value: function resume() {
            this._crossFade.resume();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._crossFade.stop();
        }
    }, {
        key: "getAnimationState",
        value: function getAnimationState(name) {
            return this.getState(name);
        }
    }, {
        key: "getState",
        value: function getState(name) {
            var state = this._nameToState[name];
            return state && !state.curveLoaded && state.initialize(this.node), state || null;
        }
    }, {
        key: "createState",
        value: function createState(clip, name) {
            return name = name || clip.name, this.removeState(name), this._doCreateState(clip, name);
        }
    }, {
        key: "removeState",
        value: function removeState(name) {
            var state = this._nameToState[name];
            state && (state.stop(), delete this._nameToState[name]);
        }
    }, {
        key: "addClip",
        value: function addClip(clip, name) {
            return contains(this._clips, clip) || this._clips.push(clip), this.createState(clip, name);
        }
    }, {
        key: "removeClip",
        value: function removeClip(clip, force) {
            for (var state, _i3 = 0, _Object$keys3 = Object.keys(this._nameToState); _i3 < _Object$keys3.length; _i3++) {
                var _name2 = _Object$keys3[_i3];
                if ((state = this._nameToState[_name2]).clip === clip) break;
            }
            if (clip === this._defaultClip) {
                if (!force) return void warnID(3902);
                this._defaultClip = null;
            }
            if (state && state.isPlaying) {
                if (!force) return void warnID(3903);
                state.stop();
            }
            this._clips = this._clips.filter(function(item) {
                return item !== clip;
            }), state && delete this._nameToState[state.name];
        }
    }, {
        key: "on",
        value: function on(type, callback, target) {
            var ret = EventTarget.prototype.on.call(this, type, callback, target);
            if ("lastframe" === type) for (var _i4 = 0, _Object$keys4 = Object.keys(this._nameToState); _i4 < _Object$keys4.length; _i4++) {
                var stateName = _Object$keys4[_i4];
                this._nameToState[stateName]._lastframeEventOn = !0;
            }
            return ret;
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            if ("lastframe" === type) for (var nameToState = this._nameToState, _i5 = 0, _Object$keys5 = Object.keys(nameToState); _i5 < _Object$keys5.length; _i5++) {
                nameToState[_Object$keys5[_i5]]._lastframeEventOn = !1;
            }
            EventTarget.prototype.off.call(this, type, callback, target);
        }
    }, {
        key: "targetOff",
        value: function targetOff(keyOrTarget) {}
    }, {
        key: "once",
        value: function once(type, callback, target) {}
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {}
    }, {
        key: "hasEventListener",
        value: function hasEventListener(key, callback, target) {
            return !1;
        }
    }, {
        key: "removeAll",
        value: function removeAll(keyOrTarget) {}
    }, {
        key: "emit",
        value: function emit(key) {}
    }, {
        key: "_createState",
        value: function _createState(clip, name) {
            return new AnimationState(clip, name);
        }
    }, {
        key: "_doCreateState",
        value: function _doCreateState(clip, name) {
            var state = this._createState(clip, name);
            return state._setEventTarget(this), this.node && state.initialize(this.node), this._nameToState[state.name] = state, 
            state;
        }
    }, {
        key: "_getStateByNameOrDefaultClip",
        value: function _getStateByNameOrDefaultClip(name) {
            if (!name) {
                if (!this._defaultClip) return null;
                name = this._defaultClip.name;
            }
            var state = this._nameToState[name];
            return state || null;
        }
    }, {
        key: "_removeStateOfAutomaticClip",
        value: function _removeStateOfAutomaticClip(clip) {
            for (var _name4 in this._nameToState) {
                var _state4 = this._nameToState[_name4];
                equalClips(clip, _state4.clip) && (_state4.stop(), delete this._nameToState[_name4]);
            }
        }
    }, {
        key: "clips",
        get: function get() {
            return this._clips;
        },
        set: function set(value) {
            var _this2 = this;
            this._crossFade && this._crossFade.clear();
            var _iterator = this._clips, _isArray = Array.isArray(_iterator), _i6 = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i6 >= _iterator.length) break;
                    _ref = _iterator[_i6++];
                } else {
                    if ((_i6 = _iterator.next()).done) break;
                    _ref = _i6.value;
                }
                var clip = _ref;
                clip && this._removeStateOfAutomaticClip(clip);
            }
            var _iterator2 = value, _isArray2 = Array.isArray(_iterator2), _i7 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i7 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i7++];
                } else {
                    if ((_i7 = _iterator2.next()).done) break;
                    _ref2 = _i7.value;
                }
                var _clip = _ref2;
                _clip && this.createState(_clip);
            }
            var newDefaultClip = value.find(function(clip) {
                return equalClips(clip, _this2._defaultClip);
            });
            this._defaultClip = newDefaultClip || null, this._clips = value;
        }
    }, {
        key: "defaultClip",
        get: function get() {
            return this._defaultClip;
        },
        set: function set(value) {
            (this._defaultClip = value, value) && (this._clips.findIndex(function(clip) {
                return equalClips(clip, value);
            }) >= 0 || (this._clips.push(value), this.createState(value)));
        }
    } ]), AnimationComponent;
}(), _class3$A.EventType = EventType$1, _applyDecoratedDescriptor((_class2$1i = _temp$1q).prototype, "clips", [ _dec4$K ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "clips"), _class2$1i.prototype), 
_applyDecoratedDescriptor(_class2$1i.prototype, "defaultClip", [ _dec5$H ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "defaultClip"), _class2$1i.prototype), 
_descriptor$1f = _applyDecoratedDescriptor(_class2$1i.prototype, "playOnLoad", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1i.prototype, "_clips", [ _dec6$C ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$Q = _applyDecoratedDescriptor(_class2$1i.prototype, "_defaultClip", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1y = _class2$1i)) || _class$1y) || _class$1y) || _class$1y) || _class$1y), _AnimationComponent$p = AnimationComponent.prototype, on = _AnimationComponent$p.on, off = _AnimationComponent$p.off;

function equalClips(clip1, clip2) {
    return clip1 === clip2 || !(!clip1 || !clip2 || clip1.name !== clip2.name && clip1._uuid !== clip2._uuid);
}

applyMixins(AnimationComponent, [ CallbacksInvoker, EventTarget ]), AnimationComponent.prototype.on = on, 
AnimationComponent.prototype.off = off, cc.AnimationComponent = AnimationComponent;

var _class$1z, m4_1$3 = new Mat4();

function getPathFromRoot(target, root) {
    for (var node = target, path = ""; null !== node && node !== root; ) path = "".concat(node.name, "/").concat(path), 
    node = node.parent;
    return path.slice(0, -1);
}

function getWorldTransformUntilRoot(target, root, outMatrix) {
    for (Mat4.identity(outMatrix); target !== root; ) Mat4.fromRTS(m4_1$3, target.rotation, target.position, target.scale), 
    Mat4.multiply(outMatrix, m4_1$3, outMatrix), target = target.parent;
}

function isTargetSkinningModel(comp, root) {
    if (!(comp instanceof SkinningModelComponent)) return !1;
    var curRoot = comp.skinningRoot;
    if (curRoot === root) return !0;
    if (curRoot && curRoot.getComponent(AnimationComponent)) return !1;
    for (var node = comp.node; node && !node.getComponent(AnimationComponent); ) node = node.parent;
    return node === root;
}

var FrameIDValueAdapter = function(_CurveValueAdapter) {
    function FrameIDValueAdapter(path, component) {
        var _this;
        return _classCallCheck(this, FrameIDValueAdapter), (_this = _possibleConstructorReturn(this, _getPrototypeOf(FrameIDValueAdapter).call(this))).path = void 0, 
        _this.component = void 0, _this.path = path, _this.component = component, _this;
    }
    return _inherits(FrameIDValueAdapter, CurveValueAdapter), _createClass(FrameIDValueAdapter, [ {
        key: "forTarget",
        value: function forTarget(target) {
            var node = new HierachyModifier(this.path).get(target), component = new ComponentModifier(this.component).get(node);
            return {
                set: function set(value) {
                    component.frameID = value;
                }
            };
        }
    } ]), FrameIDValueAdapter;
}(), SkeletalAnimationClip = ccclass("cc.SkeletalAnimationClip")(_class$1z = function(_AnimationClip) {
    function SkeletalAnimationClip() {
        var _getPrototypeOf2, _this2;
        _classCallCheck(this, SkeletalAnimationClip);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkeletalAnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).convertedData = {}, 
        _this2._converted = !1, _this2;
    }
    return _inherits(SkeletalAnimationClip, AnimationClip), _createClass(SkeletalAnimationClip, [ {
        key: "getPropertyCurves",
        value: function getPropertyCurves(root) {
            return this.hash, this._convertToSkeletalCurves(root), _get(_getPrototypeOf(SkeletalAnimationClip.prototype), "getPropertyCurves", this).call(this, root);
        }
    }, {
        key: "_convertToSkeletalCurves",
        value: function _convertToSkeletalCurves(root) {
            var _this3 = this;
            if (!this._converted) {
                var convertedData = {};
                this.curves.forEach(function(curve) {
                    if (!curve.valueAdapter && isCustomTargetModifier(curve.modifiers[0], HierachyModifier) && isPropertyModifier(curve.modifiers[1])) {
                        var path = curve.modifiers[0].path, cs = convertedData[path];
                        cs || (cs = convertedData[path] = {
                            props: {}
                        });
                        var property = curve.modifiers[1];
                        cs.props[property] = curve.data;
                    }
                }), this.convertedData = convertedData, this.curves = [];
                for (var values = new Array(Math.ceil(this.sample * this._duration / this.speed) + 1), i = 0; i < values.length; i++) values[i] = i;
                var _iterator = Object.keys(this.convertedData).sort(), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var path = _ref, nodeData = this.convertedData[path];
                    if (nodeData.props) {
                        var _nodeData$props = nodeData.props, position = _nodeData$props.position, rotation = _nodeData$props.rotation, scale = _nodeData$props.scale;
                        this._convertToUniformSample(position, values), this._convertToUniformSample(rotation, values), 
                        this._convertToUniformSample(scale, values), this._convertToWorldSpace(path, nodeData.props);
                    }
                }
                var _iterator2 = root.getComponentsInChildren(RenderableComponent), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var comp = _ref2;
                    isTargetSkinningModel(comp, root) && function() {
                        var path = getPathFromRoot(comp.node, root), compName = getClassName(comp), curves = _this3.curves, dstcurve = curves.find(function(curve) {
                            return curve.valueAdapter && curve.valueAdapter instanceof FrameIDValueAdapter && curve.valueAdapter.path === path && curve.valueAdapter.component === compName;
                        });
                        dstcurve ? dstcurve.data = {
                            keys: 0,
                            values: values,
                            interpolate: !1
                        } : curves.push({
                            modifiers: [],
                            data: {
                                keys: 0,
                                values: values,
                                interpolate: !1
                            },
                            valueAdapter: new FrameIDValueAdapter(path, compName)
                        }), _this3.curves = curves;
                    }();
                }
                this._keys = [ values.map(function(_, i) {
                    return i * _this3.speed / _this3.sample;
                }) ], this._duration = this._keys[0][values.length - 1], this._converted = !0;
            }
        }
    }, {
        key: "_convertToUniformSample",
        value: function _convertToUniformSample(curve, counts) {
            var _this4 = this, keys = this._keys[curve.keys];
            curve.keys = 0, curve.values = counts.map(function(_, i) {
                if (!keys || 1 === keys.length) return curve.values[0].clone();
                var time = i * _this4.speed / _this4.sample, idx = keys.findIndex(function(k) {
                    return k > time;
                });
                idx < 0 ? (idx = keys.length - 1, time = keys[idx]) : 0 === idx && (idx = 1);
                var from = curve.values[idx - 1].clone();
                return from.lerp(curve.values[idx], (time - keys[idx - 1]) / (keys[idx] - keys[idx - 1])), 
                from;
            });
        }
    }, {
        key: "_convertToWorldSpace",
        value: function _convertToWorldSpace(path, props) {
            var oPos = props.position.values, oRot = props.rotation.values, oScale = props.scale.values, matrix = oPos.map(function() {
                return new Mat4();
            }), idx = path.lastIndexOf("/"), pMatrix = null;
            if (idx > 0) {
                var name = path.substring(0, idx), data = this.convertedData[name];
                if (!data || !data.props) return void console.warn("no data for parent bone?");
                pMatrix = data.props.worldMatrix.values;
            }
            for (var i = 0; i < oPos.length; i++) {
                var oT = oPos[i], oR = oRot[i], oS = oScale[i], m = matrix[i];
                Mat4.fromRTS(m, oR, oT, oS), pMatrix && Mat4.multiply(m, pMatrix[i], m);
            }
            Object.keys(props).forEach(function(k) {
                return delete props[k];
            }), props.worldMatrix = {
                keys: 0,
                interpolate: !1,
                values: matrix
            };
        }
    } ]), SkeletalAnimationClip;
}()) || _class$1z;

cc.SkeletalAnimationClip = SkeletalAnimationClip;

var _dec$1y, _dec2$19, _class$1A, _class2$1j, _descriptor$1g, _descriptor2$16, _dec3$U, _dec4$L, _dec5$I, _dec6$D, _dec7$r, _class4$8, _class5$8, _descriptor3$R, _class6, _temp2$8, m4_1$4 = new Mat4(), SkeletalAnimationState = function(_AnimationState) {
    function SkeletalAnimationState() {
        return _classCallCheck(this, SkeletalAnimationState), _possibleConstructorReturn(this, _getPrototypeOf(SkeletalAnimationState).apply(this, arguments));
    }
    return _inherits(SkeletalAnimationState, AnimationState), _createClass(SkeletalAnimationState, [ {
        key: "onPlay",
        value: function onPlay() {
            _get(_getPrototypeOf(SkeletalAnimationState.prototype), "onPlay", this).call(this);
            var _iterator = this._targetNode.getComponentsInChildren(SkinningModelComponent), _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var comp = _ref;
                comp.skinningRoot === this._targetNode && comp.uploadAnimation(this.clip);
            }
        }
    }, {
        key: "rebuildSocketCurves",
        value: function rebuildSocketCurves(sockets) {
            if (this._samplerSharedGroups.length) {
                for (var curves = this._samplerSharedGroups[0].curves, iCurve = 0; iCurve < curves.length; iCurve++) {
                    var curveDetail = curves[iCurve].curveDetail;
                    curveDetail.valueAdapter && curveDetail.valueAdapter instanceof FrameIDValueAdapter || curves.splice(iCurve--, 1);
                }
                for (var iSocket = 0; iSocket < sockets.length; ++iSocket) {
                    var curve = this._buildSocketData(sockets[iSocket]);
                    curve && curves.push(curve);
                }
            }
        }
    }, {
        key: "_buildSocketData",
        value: function _buildSocketData(socket) {
            if (!this._targetNode) return null;
            var root = this._targetNode, targetNode = root.getChildByPath(socket.path);
            if (!targetNode || !socket.target) return null;
            for (var targetPath = socket.path, sourceData = this.clip.convertedData, animPath = targetPath, source = sourceData[animPath], animNode = targetNode; !source || !source.props; ) {
                var idx = animPath.lastIndexOf("/");
                if (source = sourceData[animPath = animPath.substring(0, idx)], animNode = animNode.parent, 
                idx < 0) return null;
            }
            var data = {
                matrix: {
                    keys: 0,
                    interpolate: !1,
                    values: source.props.worldMatrix.values.map(function(v) {
                        return v.clone();
                    })
                }
            }, matrix = data.matrix.values;
            getWorldTransformUntilRoot(targetNode, animNode, m4_1$4);
            for (var i = 0; i < matrix.length; i++) {
                var m = matrix[i];
                Mat4.multiply(m, m, m4_1$4);
            }
            var duration = this.clip.duration, hierachyModifier = new HierachyModifier();
            return new ICurveInstance({
                curve: new AnimCurve(data.matrix, duration),
                modifiers: [ hierachyModifier, "matrix" ]
            }, socket.target);
        }
    } ]), SkeletalAnimationState;
}();

cc.SkeletalAnimationState = SkeletalAnimationState;

var Socket = (_dec$1y = ccclass("cc.SkeletalAnimationComponent.Socket"), _dec2$19 = property(Node$1), 
_dec$1y((_descriptor$1g = _applyDecoratedDescriptor((_class2$1j = function Socket() {
    var path = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", target = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    _classCallCheck(this, Socket), _initializerDefineProperty(this, "path", _descriptor$1g, this), 
    _initializerDefineProperty(this, "target", _descriptor2$16, this), this.path = path, 
    this.target = target;
}).prototype, "path", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor2$16 = _applyDecoratedDescriptor(_class2$1j.prototype, "target", [ _dec2$19 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1A = _class2$1j)) || _class$1A), m4_1$5 = new Mat4();

function collectRecursively(node) {
    for (var prefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", out = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        if (child) {
            var path = prefix ? "".concat(prefix, "/").concat(child.name) : child.name;
            out.push(path), collectRecursively(child, path, out);
        }
    }
    return out;
}

var _class$1B, _class2$1k, _descriptor$1h, _descriptor2$17, SkeletalAnimationComponent = (_dec3$U = ccclass("cc.SkeletalAnimationComponent"), 
_dec4$L = executionOrder(99), _dec5$I = menu("Components/SkeletalAnimationComponent"), 
_dec6$D = property({
    type: [ Socket ]
}), _dec7$r = property({
    type: [ Socket ]
}), _dec3$U(_class4$8 = _dec4$L(_class4$8 = executeInEditMode(_class4$8 = _dec5$I((_temp2$8 = _class6 = function(_AnimationComponent) {
    function SkeletalAnimationComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SkeletalAnimationComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkeletalAnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_sockets", _descriptor3$R, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SkeletalAnimationComponent, AnimationComponent), _createClass(SkeletalAnimationComponent, [ {
        key: "start",
        value: function start() {
            _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "start", this).call(this), 
            this.sockets = this._sockets;
        }
    }, {
        key: "querySockets",
        value: function querySockets() {
            var out = [];
            if (!this._defaultClip) return out;
            for (var animPaths = Object.keys(this._defaultClip.convertedData).sort().reduce(function(acc, cur) {
                return cur.startsWith(acc[acc.length - 1]) ? acc : (acc.push(cur), acc);
            }, []), i = 0; i < animPaths.length; i++) {
                var path = animPaths[i], node = this.node.getChildByPath(path);
                node && (out.push(path), collectRecursively(node, path, out));
            }
            return out;
        }
    }, {
        key: "rebuildSocketAnimations",
        value: function rebuildSocketAnimations() {
            var _iterator = this._sockets, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var socket = _ref, joint = this.node.getChildByPath(socket.path), target = socket.target;
                joint && target && (target.name = "".concat(socket.path.substring(socket.path.lastIndexOf("/") + 1), " Socket"), 
                target.parent = this.node, getWorldTransformUntilRoot(joint, this.node, m4_1$5), 
                target.matrix = m4_1$5);
            }
            for (var _i2 = 0, _Object$keys = Object.keys(this._nameToState); _i2 < _Object$keys.length; _i2++) {
                var stateName = _Object$keys[_i2];
                this._nameToState[stateName].rebuildSocketCurves(this._sockets);
            }
        }
    }, {
        key: "createSocket",
        value: function createSocket(path) {
            var socket = this._sockets.find(function(s) {
                return s.path === path;
            });
            if (socket) return socket.target;
            if (!this.node.getChildByPath(path)) return console.warn("illegal socket path"), 
            null;
            var target = new cc.Node();
            return target.parent = this.node, this._sockets.push(new Socket(path, target)), 
            this.rebuildSocketAnimations(), target;
        }
    }, {
        key: "_createState",
        value: function _createState(clip, name) {
            return new SkeletalAnimationState(clip, name);
        }
    }, {
        key: "_doCreateState",
        value: function _doCreateState(clip, name) {
            clip instanceof SkeletalAnimationClip || console.warn("non-skeletal clip bound to skeletal component");
            var state = _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "_doCreateState", this).call(this, clip, name);
            return state.rebuildSocketCurves(this._sockets), state;
        }
    }, {
        key: "sockets",
        get: function get() {
            return this._sockets;
        },
        set: function set(val) {
            this._sockets = val, this.rebuildSocketAnimations();
        }
    } ]), SkeletalAnimationComponent;
}(), _class6.Socket = Socket, _descriptor3$R = _applyDecoratedDescriptor((_class5$8 = _temp2$8).prototype, "_sockets", [ _dec6$D ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class5$8.prototype, "sockets", [ _dec7$r ], Object.getOwnPropertyDescriptor(_class5$8.prototype, "sockets"), _class5$8.prototype), 
_class4$8 = _class5$8)) || _class4$8) || _class4$8) || _class4$8) || _class4$8);

cc.SkeletalAnimationComponent = SkeletalAnimationComponent;

var UniformCurveValueAdapter = ccclass("cc.UniformCurveValueAdapter")((_descriptor$1h = _applyDecoratedDescriptor((_class2$1k = function(_CurveValueAdapter) {
    function UniformCurveValueAdapter() {
        var _this;
        return _classCallCheck(this, UniformCurveValueAdapter), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(UniformCurveValueAdapter).call(this)), "passIndex", _descriptor$1h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "uniformName", _descriptor2$17, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(UniformCurveValueAdapter, CurveValueAdapter), _createClass(UniformCurveValueAdapter, [ {
        key: "forTarget",
        value: function forTarget(target) {
            var pass = target.passes[this.passIndex], uniformHandle = pass.getHandle(this.uniformName);
            if (void 0 === uniformHandle) throw new Error('Material "'.concat(target.name, '" has no uniform "').concat(this.uniformName, '"'));
            return {
                set: function set(value) {
                    pass.setUniform(uniformHandle, value);
                }
            };
        }
    } ]), UniformCurveValueAdapter;
}()).prototype, "passIndex", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$17 = _applyDecoratedDescriptor(_class2$1k.prototype, "uniformName", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$1B = _class2$1k)) || _class$1B;

cc.UniformCurveValueAdapter = UniformCurveValueAdapter, replaceProperty(AnimationComponent.prototype, "AnimationComponent", [ {
    name: "getAnimationState",
    newName: "getState"
}, {
    name: "removeClip",
    newName: "removeState",
    customFunction: function customFunction() {
        var arg0 = arguments.length <= 0 ? void 0 : arguments[0];
        return AnimationComponent.prototype.removeState.call(this, arg0.name);
    }
} ]), cc.easing = easing, cc.renderer = renderer;

var cclegacy = cc;

cc.primitives = primitives;

var WebGLEXT, GFXBindingLayout = function(_GFXObject) {
    function GFXBindingLayout(device) {
        var _this;
        return _classCallCheck(this, GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBindingLayout).call(this, GFXObjectType.BINDING_LAYOUT)))._device = void 0, 
        _this._bindingUnits = [], _this._isDirty = !1, _this._device = device, _this;
    }
    return _inherits(GFXBindingLayout, GFXObject), _createClass(GFXBindingLayout, [ {
        key: "bindBuffer",
        value: function bindBuffer(binding, buffer) {
            var _iterator = this._bindingUnits, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                var bindingUnit = _ref;
                if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.UNIFORM_BUFFER ? bindingUnit.buffer !== buffer && (bindingUnit.buffer = buffer, 
                this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.UNIFORM_BUFFER."));
            }
        }
    }, {
        key: "bindSampler",
        value: function bindSampler(binding, sampler) {
            var _iterator2 = this._bindingUnits, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var bindingUnit = _ref2;
                if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.SAMPLER ? bindingUnit.sampler !== sampler && (bindingUnit.sampler = sampler, 
                this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
            }
        }
    }, {
        key: "bindTextureView",
        value: function bindTextureView(binding, texView) {
            var _iterator3 = this._bindingUnits, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                var _ref3;
                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    if ((_i3 = _iterator3.next()).done) break;
                    _ref3 = _i3.value;
                }
                var bindingUnit = _ref3;
                if (bindingUnit.binding === binding) return void (bindingUnit.type === GFXBindingType.SAMPLER ? bindingUnit.texView !== texView && (bindingUnit.texView = texView, 
                this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
            }
        }
    }, {
        key: "getBindingUnit",
        value: function getBindingUnit(binding) {
            var _iterator4 = this._bindingUnits, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
            for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                var _ref4;
                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    if ((_i4 = _iterator4.next()).done) break;
                    _ref4 = _i4.value;
                }
                var unit = _ref4;
                if (unit.binding === binding) return unit;
            }
            return null;
        }
    } ]), GFXBindingLayout;
}(), WebGLGFXBindingLayout = function(_GFXBindingLayout) {
    function WebGLGFXBindingLayout(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
        _this;
    }
    return _inherits(WebGLGFXBindingLayout, GFXBindingLayout), _createClass(WebGLGFXBindingLayout, [ {
        key: "gpuBindingLayout",
        get: function get() {
            return this._gpuBindingLayout;
        }
    } ]), _createClass(WebGLGFXBindingLayout, [ {
        key: "initialize",
        value: function initialize(info) {
            this._bindingUnits = new Array(info.bindings.length);
            for (var i = 0; i < info.bindings.length; ++i) {
                var binding = info.bindings[i];
                this._bindingUnits[i] = {
                    binding: binding.binding,
                    type: binding.type,
                    name: binding.name,
                    buffer: null,
                    texView: null,
                    sampler: null
                };
            }
            this._gpuBindingLayout = {
                gpuBindings: new Array(info.bindings.length)
            };
            for (var _i = 0; _i < info.bindings.length; ++_i) {
                var _binding = info.bindings[_i];
                this._gpuBindingLayout.gpuBindings[_i] = {
                    binding: _binding.binding,
                    type: _binding.type,
                    name: _binding.name,
                    gpuBuffer: null,
                    gpuTexView: null,
                    gpuSampler: null
                };
            }
            return this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuBindingLayout = null, this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "update",
        value: function update() {
            if (this._isDirty && this._gpuBindingLayout) {
                for (var i = 0; i < this._bindingUnits.length; ++i) {
                    var bindingUnit = this._bindingUnits[i];
                    switch (bindingUnit.type) {
                      case GFXBindingType.UNIFORM_BUFFER:
                        bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                        break;

                      case GFXBindingType.SAMPLER:
                        bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                        bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                    }
                }
                this._isDirty = !1;
            }
        }
    } ]), WebGLGFXBindingLayout;
}();

function GFXFormatToWebGLType(format, gl) {
    switch (format) {
      case GFXFormat.R8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.R8SN:
        return gl.BYTE;

      case GFXFormat.R8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.R8I:
        return gl.BYTE;

      case GFXFormat.R16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case GFXFormat.R16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.R16I:
        return gl.SHORT;

      case GFXFormat.R32F:
        return gl.FLOAT;

      case GFXFormat.R32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.R32I:
        return gl.INT;

      case GFXFormat.RG8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RG8SN:
        return gl.BYTE;

      case GFXFormat.RG8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RG8I:
        return gl.BYTE;

      case GFXFormat.RG16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case GFXFormat.RG16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.RG16I:
        return gl.SHORT;

      case GFXFormat.RG32F:
        return gl.FLOAT;

      case GFXFormat.RG32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RG32I:
        return gl.INT;

      case GFXFormat.RGB8:
      case GFXFormat.SRGB8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGB8SN:
        return gl.BYTE;

      case GFXFormat.RGB8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGB8I:
        return gl.BYTE;

      case GFXFormat.RGB16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case GFXFormat.RGB16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.RGB16I:
        return gl.SHORT;

      case GFXFormat.RGB32F:
        return gl.FLOAT;

      case GFXFormat.RGB32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RGB32I:
        return gl.INT;

      case GFXFormat.RGBA8:
      case GFXFormat.SRGB8_A8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGBA8SN:
        return gl.BYTE;

      case GFXFormat.RGBA8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGBA8I:
        return gl.BYTE;

      case GFXFormat.RGBA16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case GFXFormat.RGBA16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.RGBA16I:
        return gl.SHORT;

      case GFXFormat.RGBA32F:
        return gl.FLOAT;

      case GFXFormat.RGBA32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RGBA32I:
        return gl.INT;

      case GFXFormat.R5G6B5:
        return gl.UNSIGNED_SHORT_5_6_5;

      case GFXFormat.R11G11B10F:
        return gl.FLOAT;

      case GFXFormat.RGB5A1:
        return gl.UNSIGNED_SHORT_5_5_5_1;

      case GFXFormat.RGBA4:
        return gl.UNSIGNED_SHORT_4_4_4_4;

      case GFXFormat.RGB10A2:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGB10A2UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RGB9E5:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.D16:
      case GFXFormat.D16S8:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.D24:
        return gl.UNSIGNED_INT;

      case GFXFormat.D24S8:
        return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

      case GFXFormat.D32F:
      case GFXFormat.D32F_S8:
        return gl.FLOAT;

      case GFXFormat.BC1:
      case GFXFormat.BC1_SRGB:
      case GFXFormat.BC2:
      case GFXFormat.BC2_SRGB:
      case GFXFormat.BC3:
      case GFXFormat.BC3_SRGB:
      case GFXFormat.BC4:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.BC4_SNORM:
        return gl.BYTE;

      case GFXFormat.BC5:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.BC5_SNORM:
        return gl.BYTE;

      case GFXFormat.BC6H_SF16:
      case GFXFormat.BC6H_UF16:
        return gl.FLOAT;

      case GFXFormat.BC7:
      case GFXFormat.BC7_SRGB:
      case GFXFormat.ETC_RGB8:
      case GFXFormat.ETC2_RGB8:
      case GFXFormat.ETC2_SRGB8:
      case GFXFormat.ETC2_RGB8_A1:
      case GFXFormat.ETC2_SRGB8_A1:
      case GFXFormat.ETC2_RGB8:
      case GFXFormat.ETC2_SRGB8:
      case GFXFormat.EAC_R11:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.EAC_R11SN:
        return gl.BYTE;

      case GFXFormat.EAC_RG11:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.EAC_RG11SN:
        return gl.BYTE;

      case GFXFormat.PVRTC_RGB2:
      case GFXFormat.PVRTC_RGBA2:
      case GFXFormat.PVRTC_RGB4:
      case GFXFormat.PVRTC_RGBA4:
      case GFXFormat.PVRTC2_2BPP:
      case GFXFormat.PVRTC2_4BPP:
      default:
        return gl.UNSIGNED_BYTE;
    }
}

function GFXFormatToWebGLInternalFormat(format, gl) {
    switch (format) {
      case GFXFormat.A8:
        return gl.ALPHA;

      case GFXFormat.L8:
        return gl.LUMINANCE;

      case GFXFormat.LA8:
        return gl.LUMINANCE_ALPHA;

      case GFXFormat.RGB8:
      case GFXFormat.RGB16F:
      case GFXFormat.RGB32F:
        return gl.RGB;

      case GFXFormat.RGBA8:
      case GFXFormat.RGBA16F:
      case GFXFormat.RGBA32F:
        return gl.RGBA;

      case GFXFormat.R5G6B5:
        return gl.RGB565;

      case GFXFormat.RGB5A1:
        return gl.RGB5_A1;

      case GFXFormat.RGBA4:
        return gl.RGBA4;

      case GFXFormat.D16:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D16S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D24:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D24S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D32F:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D32F_S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.BC1:
        return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_ALPHA:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB_ALPHA:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

      case GFXFormat.BC2:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

      case GFXFormat.BC2_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

      case GFXFormat.BC3:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

      case GFXFormat.BC3_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

      case GFXFormat.ETC_RGB8:
        return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

      case GFXFormat.PVRTC_RGB2:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA2:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGB4:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA4:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

      default:
        return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
        gl.RGBA;
    }
}

function GFXFormatToWebGLFormat(format, gl) {
    switch (format) {
      case GFXFormat.A8:
        return gl.ALPHA;

      case GFXFormat.L8:
        return gl.LUMINANCE;

      case GFXFormat.LA8:
        return gl.LUMINANCE_ALPHA;

      case GFXFormat.RGB8:
      case GFXFormat.RGB16F:
      case GFXFormat.RGB32F:
        return gl.RGB;

      case GFXFormat.RGBA8:
      case GFXFormat.RGBA16F:
      case GFXFormat.RGBA32F:
        return gl.RGBA;

      case GFXFormat.R5G6B5:
        return gl.RGB;

      case GFXFormat.RGB5A1:
      case GFXFormat.RGBA4:
        return gl.RGBA;

      case GFXFormat.D16:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D16S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D24:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D24S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D32F:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D32F_S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.BC1:
        return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_ALPHA:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB_ALPHA:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

      case GFXFormat.BC2:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

      case GFXFormat.BC2_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

      case GFXFormat.BC3:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

      case GFXFormat.BC3_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

      case GFXFormat.ETC_RGB8:
        return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

      case GFXFormat.ETC2_RGB8:
        return WebGLEXT.COMPRESSED_RGB8_ETC2;

      case GFXFormat.ETC2_SRGB8:
        return WebGLEXT.COMPRESSED_SRGB8_ETC2;

      case GFXFormat.ETC2_RGB8_A1:
        return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case GFXFormat.ETC2_SRGB8_A1:
        return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case GFXFormat.ETC2_RGBA8:
        return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

      case GFXFormat.ETC2_SRGB8_A8:
        return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

      case GFXFormat.EAC_R11:
        return WebGLEXT.COMPRESSED_R11_EAC;

      case GFXFormat.EAC_R11SN:
        return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

      case GFXFormat.EAC_RG11:
        return WebGLEXT.COMPRESSED_RG11_EAC;

      case GFXFormat.EAC_RG11SN:
        return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

      case GFXFormat.PVRTC_RGB2:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA2:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGB4:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA4:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

      default:
        return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
        gl.RGBA;
    }
}

function GFXTypeToWebGLType(type, gl) {
    switch (type) {
      case GFXType.BOOL:
        return gl.BOOL;

      case GFXType.BOOL2:
        return gl.BOOL_VEC2;

      case GFXType.BOOL3:
        return gl.BOOL_VEC3;

      case GFXType.BOOL4:
        return gl.BOOL_VEC4;

      case GFXType.INT:
        return gl.INT;

      case GFXType.INT2:
        return gl.INT_VEC2;

      case GFXType.INT3:
        return gl.INT_VEC3;

      case GFXType.INT4:
        return gl.INT_VEC4;

      case GFXType.UINT:
        return gl.UNSIGNED_INT;

      case GFXType.FLOAT:
        return gl.FLOAT;

      case GFXType.FLOAT2:
        return gl.FLOAT_VEC2;

      case GFXType.FLOAT3:
        return gl.FLOAT_VEC3;

      case GFXType.FLOAT4:
        return gl.FLOAT_VEC4;

      case GFXType.MAT2:
        return gl.FLOAT_MAT2;

      case GFXType.MAT3:
        return gl.FLOAT_MAT3;

      case GFXType.MAT4:
        return gl.FLOAT_MAT4;

      case GFXType.SAMPLER2D:
        return gl.SAMPLER_2D;

      case GFXType.SAMPLER_CUBE:
        return gl.SAMPLER_CUBE;

      default:
        return console.error("Unsupported GLType, convert to GL type failed."), GFXType.UNKNOWN;
    }
}

function WebGLTypeToGFXType(glType, gl) {
    switch (glType) {
      case gl.BOOL:
        return GFXType.BOOL;

      case gl.BOOL_VEC2:
        return GFXType.BOOL2;

      case gl.BOOL_VEC3:
        return GFXType.BOOL3;

      case gl.BOOL_VEC4:
        return GFXType.BOOL4;

      case gl.INT:
        return GFXType.INT;

      case gl.INT_VEC2:
        return GFXType.INT2;

      case gl.INT_VEC3:
        return GFXType.INT3;

      case gl.INT_VEC4:
        return GFXType.INT4;

      case gl.UNSIGNED_INT:
        return GFXType.UINT;

      case gl.FLOAT:
        return GFXType.FLOAT;

      case gl.FLOAT_VEC2:
        return GFXType.FLOAT2;

      case gl.FLOAT_VEC3:
        return GFXType.FLOAT3;

      case gl.FLOAT_VEC4:
        return GFXType.FLOAT4;

      case gl.FLOAT_MAT2:
        return GFXType.MAT2;

      case gl.FLOAT_MAT3:
        return GFXType.MAT3;

      case gl.FLOAT_MAT4:
        return GFXType.MAT4;

      case gl.SAMPLER_2D:
        return GFXType.SAMPLER2D;

      case gl.SAMPLER_CUBE:
        return GFXType.SAMPLER_CUBE;

      default:
        return console.error("Unsupported GLType, convert to GFXType failed."), GFXType.UNKNOWN;
    }
}

function WebGLGetTypeSize(glType, gl) {
    switch (glType) {
      case gl.BOOL:
        return 4;

      case gl.BOOL_VEC2:
        return 8;

      case gl.BOOL_VEC3:
        return 12;

      case gl.BOOL_VEC4:
        return 16;

      case gl.INT:
        return 4;

      case gl.INT_VEC2:
        return 8;

      case gl.INT_VEC3:
        return 12;

      case gl.INT_VEC4:
        return 16;

      case gl.UNSIGNED_INT:
      case gl.FLOAT:
        return 4;

      case gl.FLOAT_VEC2:
        return 8;

      case gl.FLOAT_VEC3:
        return 12;

      case gl.FLOAT_VEC4:
      case gl.FLOAT_MAT2:
        return 16;

      case gl.FLOAT_MAT3:
        return 36;

      case gl.FLOAT_MAT4:
        return 64;

      case gl.SAMPLER_2D:
      case gl.SAMPLER_CUBE:
        return 4;

      default:
        return console.error("Unsupported GLType, get type failed."), 0;
    }
}

function WebGLGetComponentCount(glType, gl) {
    switch (glType) {
      case gl.FLOAT_MAT2:
        return 2;

      case gl.FLOAT_MAT3:
        return 3;

      case gl.FLOAT_MAT4:
        return 4;

      default:
        return 1;
    }
}

!function(WebGLEXT) {
    WebGLEXT[WebGLEXT.RGBA16F_EXT = 34842] = "RGBA16F_EXT", WebGLEXT[WebGLEXT.RGB16F_EXT = 34843] = "RGB16F_EXT", 
    WebGLEXT[WebGLEXT.RGBA32F_EXT = 34836] = "RGBA32F_EXT", WebGLEXT[WebGLEXT.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", 
    WebGLEXT[WebGLEXT.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", 
    WebGLEXT[WebGLEXT.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", 
    WebGLEXT[WebGLEXT.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", WebGLEXT[WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", 
    WebGLEXT[WebGLEXT.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", 
    WebGLEXT[WebGLEXT.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
}(WebGLEXT || (WebGLEXT = {}));

var WebGLCmd, WebGLCmpFuncs = [ 512, 513, 514, 515, 516, 517, 518, 519 ], WebGLStencilOps = [ 0, 7680, 7681, 7682, 7683, 5386, 34055, 34056 ], WebGLBlendOps = [ 32774, 32778, 32779, 32774, 32774 ], WebGLBlendFactors = [ 0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772 ];

!function(WebGLCmd) {
    WebGLCmd[WebGLCmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGLCmd[WebGLCmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
    WebGLCmd[WebGLCmd.BIND_STATES = 2] = "BIND_STATES", WebGLCmd[WebGLCmd.DRAW = 3] = "DRAW", 
    WebGLCmd[WebGLCmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGLCmd[WebGLCmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
    WebGLCmd[WebGLCmd.COUNT = 6] = "COUNT";
}(WebGLCmd || (WebGLCmd = {}));

var WebGLCmdObject = function WebGLCmdObject(type) {
    _classCallCheck(this, WebGLCmdObject), this.cmdType = void 0, this.refCount = 0, 
    this.cmdType = type;
}, WebGLCmdBeginRenderPass = function(_WebGLCmdObject) {
    function WebGLCmdBeginRenderPass() {
        var _this;
        return _classCallCheck(this, WebGLCmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBeginRenderPass).call(this, WebGLCmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
        _this.renderArea = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }, _this.clearFlag = GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
        _this.clearStencil = 0, _this;
    }
    return _inherits(WebGLCmdBeginRenderPass, WebGLCmdObject), _createClass(WebGLCmdBeginRenderPass, [ {
        key: "clear",
        value: function clear() {
            this.gpuFramebuffer = null, this.clearColors = [];
        }
    } ]), WebGLCmdBeginRenderPass;
}(), WebGLCmdBindStates = function(_WebGLCmdObject2) {
    function WebGLCmdBindStates() {
        var _this2;
        return _classCallCheck(this, WebGLCmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBindStates).call(this, WebGLCmd.BIND_STATES))).gpuPipelineState = null, 
        _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
        _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
        _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
        _this2;
    }
    return _inherits(WebGLCmdBindStates, WebGLCmdObject), _createClass(WebGLCmdBindStates, [ {
        key: "clear",
        value: function clear() {
            this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
            this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
            this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
            this.stencilCompareMask = null;
        }
    } ]), WebGLCmdBindStates;
}(), WebGLCmdDraw = function(_WebGLCmdObject3) {
    function WebGLCmdDraw() {
        var _this3;
        return _classCallCheck(this, WebGLCmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdDraw).call(this, WebGLCmd.DRAW))).drawInfo = {
            vertexCount: 0,
            firstVertex: 0,
            indexCount: 0,
            firstIndex: 0,
            vertexOffset: 0,
            instanceCount: 0,
            firstInstance: 0
        }, _this3;
    }
    return _inherits(WebGLCmdDraw, WebGLCmdObject), _createClass(WebGLCmdDraw, [ {
        key: "clear",
        value: function clear() {}
    } ]), WebGLCmdDraw;
}(), WebGLCmdUpdateBuffer = function(_WebGLCmdObject4) {
    function WebGLCmdUpdateBuffer() {
        var _this4;
        return _classCallCheck(this, WebGLCmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdUpdateBuffer).call(this, WebGLCmd.UPDATE_BUFFER))).gpuBuffer = null, 
        _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
    }
    return _inherits(WebGLCmdUpdateBuffer, WebGLCmdObject), _createClass(WebGLCmdUpdateBuffer, [ {
        key: "clear",
        value: function clear() {
            this.gpuBuffer = null, this.buffer = null;
        }
    } ]), WebGLCmdUpdateBuffer;
}(), WebGLCmdCopyBufferToTexture = function(_WebGLCmdObject5) {
    function WebGLCmdCopyBufferToTexture() {
        var _this5;
        return _classCallCheck(this, WebGLCmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdCopyBufferToTexture).call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
        _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
    }
    return _inherits(WebGLCmdCopyBufferToTexture, WebGLCmdObject), _createClass(WebGLCmdCopyBufferToTexture, [ {
        key: "clear",
        value: function clear() {
            this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions = [];
        }
    } ]), WebGLCmdCopyBufferToTexture;
}(), WebGLCmdPackage = function() {
    function WebGLCmdPackage() {
        _classCallCheck(this, WebGLCmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
        this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
        this.copyBufferToTextureCmds = new CachedArray(1);
    }
    return _createClass(WebGLCmdPackage, [ {
        key: "clearCmds",
        value: function clearCmds(allocator) {
            this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
            this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
            this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
            this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
            this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
            this.copyBufferToTextureCmds.clear()), this.cmds.clear();
        }
    } ]), WebGLCmdPackage;
}();

function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
    if (gpuBuffer.usage & GFXBufferUsageBit.UNIFORM) buffer instanceof Float32Array ? gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT) : gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT); else if (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
        var buff = buffer, gl = device.gl, cache = device.stateCache;
        switch (gpuBuffer.glTarget) {
          case gl.ARRAY_BUFFER:
            device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
            cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
            device.stateCache.glArrayBuffer = gpuBuffer.glBuffer);
            break;

          case gl.ELEMENT_ARRAY_BUFFER:
            device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
            cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
            device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer);
            break;

          default:
            return void console.error("Unsupported GFXBufferType, update buffer failed.");
        }
        size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
    }
}

var cmdIds = new Array(WebGLCmd.COUNT);

function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
    for (var gl = device.gl, cache = device.stateCache, i = 0; i < WebGLCmd.COUNT; ++i) cmdIds[i] = 0;
    for (var glWrapS, glWrapT, glMinFilter, gpuPipelineState = null, gpuShader = null, isShaderChanged = !1, gpuInputAssembler = null, glPrimitive = gl.TRIANGLES, _i19 = 0; _i19 < cmdPackage.cmds.length; ++_i19) {
        var cmd = cmdPackage.cmds.array[_i19], cmdId = cmdIds[cmd]++;
        switch (cmd) {
          case WebGLCmd.BEGIN_RENDER_PASS:
            var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
            if (cmd0.gpuFramebuffer) {
                cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, clearCount = cmd0.clearColors.length;
                device.WEBGL_draw_buffers || (clearCount = 1);
                for (var j = 0; j < clearCount; ++j) {
                    var colorAttachment = curGPURenderPass.colorAttachments[j];
                    if (colorAttachment.format !== GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                      case GFXLoadOp.LOAD:
                        break;

                      case GFXLoadOp.CLEAR:
                        if (cmd0.clearFlag & GFXClearFlag.COLOR) {
                            cache.bs.targets[0].blendColorMask !== GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0);
                            var clearColor = cmd0.clearColors[0];
                            gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= gl.COLOR_BUFFER_BIT;
                        }
                        break;

                      case GFXLoadOp.DISCARD:
                    }
                }
                if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== GFXFormat.UNKNOWN) {
                    switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                      case GFXLoadOp.LOAD:
                        break;

                      case GFXLoadOp.CLEAR:
                        cmd0.clearFlag & GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                        gl.clearDepth(cmd0.clearDepth), clears |= gl.DEPTH_BUFFER_BIT);
                        break;

                      case GFXLoadOp.DISCARD:
                    }
                    if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                      case GFXLoadOp.LOAD:
                        break;

                      case GFXLoadOp.CLEAR:
                        cmd0.clearFlag & GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                        cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.clearStencil(cmd0.clearStencil), 
                        clears |= gl.STENCIL_BUFFER_BIT);
                        break;

                      case GFXLoadOp.DISCARD:
                    }
                }
                if (clears && gl.clear(clears), clears & gl.COLOR_BUFFER_BIT) {
                    var colorMask = cache.bs.targets[0].blendColorMask;
                    if (colorMask !== GFXColorMask.ALL) {
                        var r = (colorMask & GFXColorMask.R) !== GFXColorMask.NONE, g = (colorMask & GFXColorMask.G) !== GFXColorMask.NONE, b = (colorMask & GFXColorMask.B) !== GFXColorMask.NONE, a = (colorMask & GFXColorMask.A) !== GFXColorMask.NONE;
                        gl.colorMask(r, g, b, a);
                    }
                }
                clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), clears & gl.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 0), 
                cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 0));
            }
            break;

          case WebGLCmd.BIND_STATES:
            var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
            if (isShaderChanged = !1, cmd2.gpuPipelineState) {
                if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                cmd2.gpuPipelineState.gpuShader) {
                    var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                    cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram, 
                    isShaderChanged = !0), gpuShader = cmd2.gpuPipelineState.gpuShader;
                }
                var rs = cmd2.gpuPipelineState.rs;
                if (rs) {
                    if (cache.rs.cullMode !== rs.cullMode) {
                        switch (rs.cullMode) {
                          case GFXCullMode.NONE:
                            gl.disable(gl.CULL_FACE);
                            break;

                          case GFXCullMode.FRONT:
                            gl.enable(gl.CULL_FACE), gl.cullFace(gl.FRONT);
                            break;

                          case GFXCullMode.BACK:
                            gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK);
                        }
                        cache.rs.cullMode = rs.cullMode;
                    }
                    cache.rs.isFrontFaceCCW !== rs.isFrontFaceCCW && (gl.frontFace(rs.isFrontFaceCCW ? gl.CCW : gl.CW), 
                    cache.rs.isFrontFaceCCW = rs.isFrontFaceCCW), cache.rs.depthBias === rs.depthBias && cache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                    cache.rs.depthBias = rs.depthBias, cache.rs.depthBiasSlop = rs.depthBiasSlop), cache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                    cache.rs.lineWidth = rs.lineWidth);
                }
                var dss = cmd2.gpuPipelineState.dss;
                dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), 
                cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]), 
                cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST), 
                cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]), 
                cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront), 
                cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]), 
                cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack), 
                cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                var bs = cmd2.gpuPipelineState.bs;
                if (bs) {
                    cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                    cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                    cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                    cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                    var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                    target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND), 
                    target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]), 
                    target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                    target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]), 
                    target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                    target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & GFXColorMask.R) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.G) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.B) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.A) !== GFXColorMask.NONE), 
                    target0Cache.blendColorMask = target0.blendColorMask);
                }
            }
            if (cmd2.gpuBindingLayout && gpuShader) {
                var _iterator9 = cmd2.gpuBindingLayout.gpuBindings, _isArray9 = Array.isArray(_iterator9), _i20 = 0;
                for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                    var _ref9;
                    if (_isArray9) {
                        if (_i20 >= _iterator9.length) break;
                        _ref9 = _iterator9[_i20++];
                    } else {
                        if ((_i20 = _iterator9.next()).done) break;
                        _ref9 = _i20.value;
                    }
                    var gpuBinding = _ref9;
                    switch (gpuBinding.type) {
                      case GFXBindingType.UNIFORM_BUFFER:
                        if (gpuBinding.gpuBuffer && gpuBinding.gpuBuffer.buffer) {
                            var glBlock = null, _iterator10 = gpuShader.glBlocks, _isArray10 = Array.isArray(_iterator10), _i21 = 0;
                            for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                var _ref10;
                                if (_isArray10) {
                                    if (_i21 >= _iterator10.length) break;
                                    _ref10 = _iterator10[_i21++];
                                } else {
                                    if ((_i21 = _iterator10.next()).done) break;
                                    _ref10 = _i21.value;
                                }
                                var block = _ref10;
                                if (block.binding === gpuBinding.binding) {
                                    glBlock = block;
                                    break;
                                }
                            }
                            if (glBlock && gpuBinding.gpuBuffer.vf32) {
                                var _iterator11 = glBlock.glActiveUniforms, _isArray11 = Array.isArray(_iterator11), _i22 = 0;
                                for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                                    var _ref11;
                                    if (_isArray11) {
                                        if (_i22 >= _iterator11.length) break;
                                        _ref11 = _iterator11[_i22++];
                                    } else {
                                        if ((_i22 = _iterator11.next()).done) break;
                                        _ref11 = _i22.value;
                                    }
                                    var glUniform = _ref11;
                                    switch (glUniform.glType) {
                                      case gl.BOOL:
                                      case gl.INT:
                                        for (var u = 0; u < glUniform.array.length; ++u) {
                                            var idx = glUniform.begin + u;
                                            if (gpuBinding.gpuBuffer.vf32[idx] !== glUniform.array[u]) {
                                                for (var n = u, m = glUniform.begin + u; n < glUniform.array.length; ++n, ++m) glUniform.array[n] = gpuBinding.gpuBuffer.vf32[m];
                                                gl.uniform1iv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.BOOL_VEC2:
                                      case gl.INT_VEC2:
                                        for (var _u = 0; _u < glUniform.array.length; ++_u) {
                                            var _idx = glUniform.begin + _u;
                                            if (gpuBinding.gpuBuffer.vf32[_idx] !== glUniform.array[_u]) {
                                                for (var _n = _u, _m = glUniform.begin + _u; _n < glUniform.array.length; ++_n, 
                                                ++_m) glUniform.array[_n] = gpuBinding.gpuBuffer.vf32[_m];
                                                gl.uniform2iv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.BOOL_VEC3:
                                      case gl.INT_VEC3:
                                        for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                                            var _idx2 = glUniform.begin + _u2;
                                            if (gpuBinding.gpuBuffer.vf32[_idx2] !== glUniform.array[_u2]) {
                                                for (var _n2 = _u2, _m2 = glUniform.begin + _u2; _n2 < glUniform.array.length; ++_n2, 
                                                ++_m2) glUniform.array[_n2] = gpuBinding.gpuBuffer.vf32[_m2];
                                                gl.uniform3iv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.BOOL_VEC4:
                                      case gl.INT_VEC4:
                                        for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                                            var _idx3 = glUniform.begin + _u3;
                                            if (gpuBinding.gpuBuffer.vf32[_idx3] !== glUniform.array[_u3]) {
                                                for (var _n3 = _u3, _m3 = glUniform.begin + _u3; _n3 < glUniform.array.length; ++_n3, 
                                                ++_m3) glUniform.array[_n3] = gpuBinding.gpuBuffer.vf32[_m3];
                                                gl.uniform4iv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT:
                                        for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                                            var _idx4 = glUniform.begin + _u4;
                                            if (gpuBinding.gpuBuffer.vf32[_idx4] !== glUniform.array[_u4]) {
                                                for (var _n4 = _u4, _m4 = glUniform.begin + _u4; _n4 < glUniform.array.length; ++_n4, 
                                                ++_m4) glUniform.array[_n4] = gpuBinding.gpuBuffer.vf32[_m4];
                                                gl.uniform1fv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT_VEC2:
                                        for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                                            var _idx5 = glUniform.begin + _u5;
                                            if (gpuBinding.gpuBuffer.vf32[_idx5] !== glUniform.array[_u5]) {
                                                for (var _n5 = _u5, _m5 = glUniform.begin + _u5; _n5 < glUniform.array.length; ++_n5, 
                                                ++_m5) glUniform.array[_n5] = gpuBinding.gpuBuffer.vf32[_m5];
                                                gl.uniform2fv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT_VEC3:
                                        for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                                            var _idx6 = glUniform.begin + _u6;
                                            if (gpuBinding.gpuBuffer.vf32[_idx6] !== glUniform.array[_u6]) {
                                                for (var _n6 = _u6, _m6 = glUniform.begin + _u6; _n6 < glUniform.array.length; ++_n6, 
                                                ++_m6) glUniform.array[_n6] = gpuBinding.gpuBuffer.vf32[_m6];
                                                gl.uniform3fv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT_VEC4:
                                        for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                                            var _idx7 = glUniform.begin + _u7;
                                            if (gpuBinding.gpuBuffer.vf32[_idx7] !== glUniform.array[_u7]) {
                                                for (var _n7 = _u7, _m7 = glUniform.begin + _u7; _n7 < glUniform.array.length; ++_n7, 
                                                ++_m7) glUniform.array[_n7] = gpuBinding.gpuBuffer.vf32[_m7];
                                                gl.uniform4fv(glUniform.glLoc, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT_MAT2:
                                        for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                                            var _idx8 = glUniform.begin + _u8;
                                            if (gpuBinding.gpuBuffer.vf32[_idx8] !== glUniform.array[_u8]) {
                                                for (var _n8 = _u8, _m8 = glUniform.begin + _u8; _n8 < glUniform.array.length; ++_n8, 
                                                ++_m8) glUniform.array[_n8] = gpuBinding.gpuBuffer.vf32[_m8];
                                                gl.uniformMatrix2fv(glUniform.glLoc, !1, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT_MAT3:
                                        for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                                            var _idx9 = glUniform.begin + _u9;
                                            if (gpuBinding.gpuBuffer.vf32[_idx9] !== glUniform.array[_u9]) {
                                                for (var _n9 = _u9, _m9 = glUniform.begin + _u9; _n9 < glUniform.array.length; ++_n9, 
                                                ++_m9) glUniform.array[_n9] = gpuBinding.gpuBuffer.vf32[_m9];
                                                gl.uniformMatrix3fv(glUniform.glLoc, !1, glUniform.array);
                                                break;
                                            }
                                        }
                                        break;

                                      case gl.FLOAT_MAT4:
                                        for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                                            var _idx10 = glUniform.begin + _u10;
                                            if (gpuBinding.gpuBuffer.vf32[_idx10] !== glUniform.array[_u10]) {
                                                for (var _n10 = _u10, _m10 = glUniform.begin + _u10; _n10 < glUniform.array.length; ++_n10, 
                                                ++_m10) glUniform.array[_n10] = gpuBinding.gpuBuffer.vf32[_m10];
                                                gl.uniformMatrix4fv(glUniform.glLoc, !1, glUniform.array);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;

                      case GFXBindingType.SAMPLER:
                        if (gpuBinding.gpuSampler) {
                            var glSampler = null, _iterator12 = gpuShader.glSamplers, _isArray12 = Array.isArray(_iterator12), _i23 = 0;
                            for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                                var _ref12;
                                if (_isArray12) {
                                    if (_i23 >= _iterator12.length) break;
                                    _ref12 = _iterator12[_i23++];
                                } else {
                                    if ((_i23 = _iterator12.next()).done) break;
                                    _ref12 = _i23.value;
                                }
                                var sampler = _ref12;
                                if (sampler.binding === gpuBinding.binding) {
                                    glSampler = sampler;
                                    break;
                                }
                            }
                            if (glSampler) {
                                var _iterator13 = glSampler.units, _isArray13 = Array.isArray(_iterator13), _i24 = 0;
                                for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                                    var _ref13;
                                    if (_isArray13) {
                                        if (_i24 >= _iterator13.length) break;
                                        _ref13 = _iterator13[_i24++];
                                    } else {
                                        if ((_i24 = _iterator13.next()).done) break;
                                        _ref13 = _i24.value;
                                    }
                                    var texUnit = _ref13, glTexUnit = null;
                                    if (gpuBinding.gpuTexView && gpuBinding.gpuTexView.gpuTexture.size > 0) {
                                        cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), cache.texUnit = texUnit);
                                        var gpuTexture = gpuBinding.gpuTexView.gpuTexture;
                                        switch (glSampler.glType) {
                                          case gl.SAMPLER_2D:
                                            (glTexUnit = cache.glTex2DUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_2D, device.nullTex2D.gpuTexture.glTexture), 
                                            glTexUnit.glTexture = gpuTexture.glTexture);
                                            break;

                                          case gl.SAMPLER_CUBE:
                                            (glTexUnit = cache.glTexCubeUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_CUBE_MAP, device.nullTexCube.gpuTexture.glTexture), 
                                            glTexUnit.glTexture = gpuTexture.glTexture);
                                            break;

                                          default:
                                            console.error("Unsupported GL Texture type.");
                                        }
                                        if (glTexUnit) {
                                            var gpuSampler = gpuBinding.gpuSampler;
                                            gpuTexture.isPowerOf2 ? (glWrapS = gpuSampler.glWrapS, glWrapT = gpuSampler.glWrapT) : (glWrapS = gl.CLAMP_TO_EDGE, 
                                            glWrapT = gl.CLAMP_TO_EDGE), glMinFilter = gpuTexture.isPowerOf2 ? gpuSampler.glMinFilter : gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR ? gl.LINEAR : gl.NEAREST, 
                                            gpuTexture.glWrapS !== glWrapS && (gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS), 
                                            gpuTexture.glWrapS = glWrapS), gpuTexture.glWrapT !== glWrapT && (gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT), 
                                            gpuTexture.glWrapT = glWrapT), gpuTexture.glMinFilter !== glMinFilter && (gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter), 
                                            gpuTexture.glMinFilter = glMinFilter), gpuTexture.glMagFilter !== gpuSampler.glMagFilter && (gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                                            gpuTexture.glMagFilter = gpuSampler.glMagFilter);
                                        }
                                    }
                                }
                            }
                        } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                    }
                }
            }
            if (cmd2.gpuInputAssembler && gpuShader && (isShaderChanged || gpuInputAssembler !== cmd2.gpuInputAssembler)) if (gpuInputAssembler = cmd2.gpuInputAssembler, 
            device.useVAO) {
                var vao = device.OES_vertex_array_object, glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                if (!glVAO) {
                    glVAO = vao.createVertexArrayOES(), gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO), 
                    vao.bindVertexArrayOES(glVAO), gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    var glAttrib = void 0, _iterator14 = gpuShader.glInputs, _isArray14 = Array.isArray(_iterator14), _i25 = 0;
                    for (_iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ;) {
                        var _ref14;
                        if (_isArray14) {
                            if (_i25 >= _iterator14.length) break;
                            _ref14 = _iterator14[_i25++];
                        } else {
                            if ((_i25 = _iterator14.next()).done) break;
                            _ref14 = _i25.value;
                        }
                        var glInput = _ref14;
                        glAttrib = null;
                        var _iterator15 = gpuInputAssembler.glAttribs, _isArray15 = Array.isArray(_iterator15), _i26 = 0;
                        for (_iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ;) {
                            var _ref15;
                            if (_isArray15) {
                                if (_i26 >= _iterator15.length) break;
                                _ref15 = _iterator15[_i26++];
                            } else {
                                if ((_i26 = _iterator15.next()).done) break;
                                _ref15 = _i26.value;
                            }
                            var attrib = _ref15;
                            if (attrib.name === glInput.name) {
                                glAttrib = attrib;
                                break;
                            }
                        }
                        if (glAttrib) {
                            cache.glArrayBuffer !== glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer), 
                            cache.glArrayBuffer = glAttrib.glBuffer);
                            for (var c = 0; c < glAttrib.componentCount; ++c) {
                                var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                            }
                        }
                    }
                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    gpuBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), vao.bindVertexArrayOES(null), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                    cache.glArrayBuffer = null, cache.glElementArrayBuffer = null;
                }
                cache.glVAO !== glVAO && (vao.bindVertexArrayOES(glVAO), cache.glVAO = glVAO);
            } else {
                for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glCurrentAttribLocs[_a] = !1;
                var _iterator16 = gpuShader.glInputs, _isArray16 = Array.isArray(_iterator16), _i27 = 0;
                for (_iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ;) {
                    var _ref16;
                    if (_isArray16) {
                        if (_i27 >= _iterator16.length) break;
                        _ref16 = _iterator16[_i27++];
                    } else {
                        if ((_i27 = _iterator16.next()).done) break;
                        _ref16 = _i27.value;
                    }
                    var _glInput = _ref16, _glAttrib = null, _iterator17 = gpuInputAssembler.glAttribs, _isArray17 = Array.isArray(_iterator17), _i28 = 0;
                    for (_iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator](); ;) {
                        var _ref17;
                        if (_isArray17) {
                            if (_i28 >= _iterator17.length) break;
                            _ref17 = _iterator17[_i28++];
                        } else {
                            if ((_i28 = _iterator17.next()).done) break;
                            _ref17 = _i28.value;
                        }
                        var _attrib = _ref17;
                        if (_attrib.name === _glInput.name) {
                            _glAttrib = _attrib;
                            break;
                        }
                    }
                    if (_glAttrib) {
                        cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer), 
                        cache.glArrayBuffer = _glAttrib.glBuffer);
                        for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                            var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                            !cache.glEnabledAttribLocs[_glLoc2] && _glLoc2 >= 0 && (gl.enableVertexAttribArray(_glLoc2), 
                            cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                            gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                        }
                    }
                }
                var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
                cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
                for (var _a2 = 0; _a2 < device.maxVertexAttributes; ++_a2) cache.glEnabledAttribLocs[_a2] !== cache.glCurrentAttribLocs[_a2] && (gl.disableVertexAttribArray(_a2), 
                cache.glEnabledAttribLocs[_a2] = !1);
            }
            if (gpuPipelineState) {
                var _iterator18 = gpuPipelineState.dynamicStates, _isArray18 = Array.isArray(_iterator18), _i29 = 0;
                for (_iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator](); ;) {
                    var _ref18;
                    if (_isArray18) {
                        if (_i29 >= _iterator18.length) break;
                        _ref18 = _iterator18[_i29++];
                    } else {
                        if ((_i29 = _iterator18.next()).done) break;
                        _ref18 = _i29.value;
                    }
                    switch (_ref18) {
                      case GFXDynamicState.VIEWPORT:
                        cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                        cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                        cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                        break;

                      case GFXDynamicState.SCISSOR:
                        cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                        cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                        cache.scissorRect.height = cmd2.scissor.height));
                        break;

                      case GFXDynamicState.LINE_WIDTH:
                        cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                        cache.rs.lineWidth = cmd2.lineWidth);
                        break;

                      case GFXDynamicState.DEPTH_BIAS:
                        cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                        cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                        break;

                      case GFXDynamicState.BLEND_CONSTANTS:
                        cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                        cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                        cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                        break;

                      case GFXDynamicState.STENCIL_WRITE_MASK:
                        if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                          case GFXStencilFace.FRONT:
                            cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.FRONT, cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                            break;

                          case GFXStencilFace.BACK:
                            cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.BACK, cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                            break;

                          case GFXStencilFace.ALL:
                            cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                        }
                        break;

                      case GFXDynamicState.STENCIL_COMPARE_MASK:
                        if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                          case GFXStencilFace.FRONT:
                            cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                            break;

                          case GFXStencilFace.BACK:
                            cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                            break;

                          case GFXStencilFace.ALL:
                            cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                            cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                        }
                    }
                }
            }
            break;

          case WebGLCmd.DRAW:
            var cmd3 = cmdPackage.drawCmds.array[cmdId];
            if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) {
                if (gpuInputAssembler.gpuIndirectBuffer) {
                    var _iterator19 = gpuInputAssembler.gpuIndirectBuffer.indirects, _isArray19 = Array.isArray(_iterator19), _i30 = 0;
                    for (_iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator](); ;) {
                        var _ref19;
                        if (_isArray19) {
                            if (_i30 >= _iterator19.length) break;
                            _ref19 = _iterator19[_i30++];
                        } else {
                            if ((_i30 = _iterator19.next()).done) break;
                            _ref19 = _i30.value;
                        }
                        var drawInfo = _ref19, _gpuBuffer3 = gpuInputAssembler.gpuIndexBuffer;
                        if (_gpuBuffer3 && drawInfo.indexCount > -1) {
                            var _offset = drawInfo.firstIndex * _gpuBuffer3.stride;
                            gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                        } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                    }
                }
            } else {
                var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                if (_gpuBuffer2 && cmd3.drawInfo.indexCount > -1) {
                    var offset = cmd3.drawInfo.firstIndex * _gpuBuffer2.stride;
                    gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
                } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
            }
            break;

          case WebGLCmd.UPDATE_BUFFER:
            var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
            WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
            break;

          case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
            var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
            WebGLCmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
        }
    }
}

function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
    var gl = device.gl, m = 0, n = 0, w = 1, h = 1, f = 0, fmtInfo = GFXFormatInfos[gpuTexture.format], isCompressed = fmtInfo.isCompressed;
    switch (gpuTexture.glTarget) {
      case gl.TEXTURE_2D:
        var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
        glTexUnit.glTexture = gpuTexture.glTexture);
        var _iterator22 = regions, _isArray22 = Array.isArray(_iterator22), _i33 = 0;
        for (_iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator](); ;) {
            var _ref22;
            if (_isArray22) {
                if (_i33 >= _iterator22.length) break;
                _ref22 = _iterator22[_i33++];
            } else {
                if ((_i33 = _iterator22.next()).done) break;
                _ref22 = _i33.value;
            }
            var region = _ref22;
            for (w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                var pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
            }
        }
        break;

      case gl.TEXTURE_CUBE_MAP:
        var _glTexUnit4 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
        _glTexUnit4.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
        _glTexUnit4.glTexture = gpuTexture.glTexture);
        var _iterator23 = regions, _isArray23 = Array.isArray(_iterator23), _i34 = 0;
        for (_iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator](); ;) {
            var _ref23;
            if (_isArray23) {
                if (_i34 >= _iterator23.length) break;
                _ref23 = _iterator23[_i34++];
            } else {
                if ((_i34 = _iterator23.next()).done) break;
                _ref23 = _i34.value;
            }
            var _region2 = _ref23;
            n = 0;
            var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
            for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                w = _region2.texExtent.width, h = _region2.texExtent.height;
                var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                    var _pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                    isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                    w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                }
            }
        }
        break;

      default:
        console.error("Unsupported GL texture type, copy buffer to texture failed.");
    }
    gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
}

var WebGLGFXBuffer = function(_GFXBuffer) {
    function WebGLGFXBuffer(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXBuffer).call(this, device)))._gpuBuffer = null, 
        _this._uniformBuffer = null, _this._indirectBuffer = null, _this;
    }
    return _inherits(WebGLGFXBuffer, GFXBuffer), _createClass(WebGLGFXBuffer, [ {
        key: "gpuBuffer",
        get: function get() {
            return this._gpuBuffer;
        }
    } ]), _createClass(WebGLGFXBuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
            this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
            this._usage & GFXBufferUsageBit.INDIRECT ? this._indirectBuffer = {
                drawInfos: []
            } : this._usage & GFXBufferUsageBit.UNIFORM && this._size > 0 && (this._uniformBuffer = new ArrayBuffer(this._size)), 
            this._gpuBuffer = {
                usage: info.usage,
                memUsage: info.memUsage,
                size: info.size,
                stride: this._stride,
                buffer: null,
                vf32: null,
                indirects: [],
                glTarget: 0,
                glBuffer: null
            }, info.usage & GFXBufferUsageBit.INDIRECT ? this._gpuBuffer.indirects = this._indirectBuffer.drawInfos : this._usage & GFXBufferUsageBit.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer), 
            function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
                var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                if (gpuBuffer.usage & GFXBufferUsageBit.VERTEX) {
                    gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                    var glBuffer = gl.createBuffer();
                    glBuffer && (gpuBuffer.glBuffer = glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                } else if (gpuBuffer.usage & GFXBufferUsageBit.INDEX) {
                    gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                    var _glBuffer = gl.createBuffer();
                    _glBuffer && (gpuBuffer.glBuffer = _glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                } else gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? (gpuBuffer.glTarget = gl.NONE, 
                gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer))) : gpuBuffer.usage & GFXBufferUsageBit.INDIRECT ? gpuBuffer.glTarget = gl.NONE : gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST ? gpuBuffer.glTarget = gl.NONE : gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC ? gpuBuffer.glTarget = gl.NONE : (console.error("Unsupported GFXBufferType, create buffer failed."), 
                gpuBuffer.glTarget = gl.NONE);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size, 
            this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuBuffer && (!function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
                gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size, 
            this._gpuBuffer = null), this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(size) {
            var oldSize = this._size;
            this._size = size, this._count = this._size / this._stride, this._uniformBuffer && (this._uniformBuffer = new ArrayBuffer(this._size)), 
            this._gpuBuffer && (this._uniformBuffer && (this._gpuBuffer.buffer = this._uniformBuffer), 
            this._gpuBuffer.size = this._size, this._size > 0 && (!function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
                var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                gpuBuffer.usage & GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(gl.ARRAY_BUFFER, null), 
                device.stateCache.glArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer)) : gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC ? gpuBuffer.glTarget = gl.NONE : (console.error("Unsupported GFXBufferType, create buffer failed."), 
                gpuBuffer.glTarget = gl.NONE);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= oldSize, 
            this._device.memoryStatus.bufferSize += this._size));
        }
    }, {
        key: "update",
        value: function update(buffer, offset, size) {
            var buffSize;
            buffSize = void 0 !== size ? size : this._usage & GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
            WebGLCmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
        }
    } ]), WebGLGFXBuffer;
}(), GFXCommandAllocator = function(_GFXObject) {
    function GFXCommandAllocator(device) {
        var _this;
        return _classCallCheck(this, GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandAllocator).call(this, GFXObjectType.COMMAND_ALLOCATOR)))._device = void 0, 
        _this._device = device, _this;
    }
    return _inherits(GFXCommandAllocator, GFXObject), GFXCommandAllocator;
}(), WebGLGFXCommandPool = function() {
    function WebGLGFXCommandPool(clazz, count) {
        _classCallCheck(this, WebGLGFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
        this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
        for (var i = 0; i < count; ++i) this._frees[i] = new clazz();
        this._freeIdx = count - 1;
    }
    return _createClass(WebGLGFXCommandPool, [ {
        key: "alloc",
        value: function alloc(clazz) {
            return new clazz();
        }
    }, {
        key: "free",
        value: function free(cmd) {
            0 == --cmd.refCount && this._freeCmds.push(cmd);
        }
    }, {
        key: "freeCmds",
        value: function freeCmds(cmds) {}
    }, {
        key: "release",
        value: function release() {
            for (var i = 0; i < this._freeCmds.length; ++i) {
                var cmd = this._freeCmds.array[i];
                cmd.clear(), this._frees[++this._freeIdx] = cmd;
            }
            this._freeCmds.clear();
        }
    } ]), WebGLGFXCommandPool;
}(), WebGLGFXCommandAllocator = function(_GFXCommandAllocator) {
    function WebGLGFXCommandAllocator(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
        _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
        _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGLGFXCommandPool(WebGLCmdBeginRenderPass, 16), 
        _this.bindStatesCmdPool = new WebGLGFXCommandPool(WebGLCmdBindStates, 16), _this.drawCmdPool = new WebGLGFXCommandPool(WebGLCmdDraw, 16), 
        _this.updateBufferCmdPool = new WebGLGFXCommandPool(WebGLCmdUpdateBuffer, 16), _this.copyBufferToTextureCmdPool = new WebGLGFXCommandPool(WebGLCmdCopyBufferToTexture, 16), 
        _this;
    }
    return _inherits(WebGLGFXCommandAllocator, GFXCommandAllocator), _createClass(WebGLGFXCommandAllocator, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "clearCmds",
        value: function clearCmds(cmdPackage) {
            cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
            cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
            cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
            cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
            cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
            cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
        }
    }, {
        key: "releaseCmds",
        value: function releaseCmds() {
            this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
            this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
        }
    } ]), WebGLGFXCommandAllocator;
}(), WebGLGFXCommandBuffer = function(_GFXCommandBuffer) {
    function WebGLGFXCommandBuffer(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandBuffer).call(this, device))).cmdPackage = new WebGLCmdPackage(), 
        _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
        _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
        _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
        _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
        _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
    }
    return _inherits(WebGLGFXCommandBuffer, GFXCommandBuffer), _createClass(WebGLGFXCommandBuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
            this._type = info.type, this._status = GFXStatus.SUCCESS, !0);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
            this._webGLAllocator = null), this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "begin",
        value: function begin() {
            this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
            this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
            this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
            this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
            this._numDrawCalls = 0, this._numTris = 0;
        }
    }, {
        key: "end",
        value: function end() {
            this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
        }
    }, {
        key: "beginRenderPass",
        value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
            var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);
            cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag, 
            cmd.clearColors.length = clearColors.length;
            for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
            cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
            this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
        }
    }, {
        key: "endRenderPass",
        value: function endRenderPass() {
            this._isInRenderPass = !1;
        }
    }, {
        key: "bindPipelineState",
        value: function bindPipelineState(pipelineState) {
            var gpuPipelineState = pipelineState.gpuPipelineState;
            this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
        }
    }, {
        key: "bindBindingLayout",
        value: function bindBindingLayout(bindingLayout) {
            var gpuBindingLayout = bindingLayout.gpuBindingLayout;
            this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
        }
    }, {
        key: "bindInputAssembler",
        value: function bindInputAssembler(inputAssembler) {
            var gpuInputAssembler = inputAssembler.gpuInputAssembler;
            this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
        }
    }, {
        key: "setViewport",
        value: function setViewport(viewport) {
            this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
            this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
            this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
            this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                left: viewport.left,
                top: viewport.top,
                width: viewport.width,
                height: viewport.height,
                minDepth: viewport.minDepth,
                maxDepth: viewport.maxDepth
            }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
        }
    }, {
        key: "setScissor",
        value: function setScissor(scissor) {
            this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
            this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
            this._isStateInvalied = !0) : this._curScissor = {
                x: scissor.x,
                y: scissor.y,
                width: scissor.width,
                height: scissor.height
            };
        }
    }, {
        key: "setLineWidth",
        value: function setLineWidth(lineWidth) {
            this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
        }
    }, {
        key: "setDepthBias",
        value: function setDepthBias(depthBiasConstantFacotr, depthBiasClamp, depthBiasSlopeFactor) {
            this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFacotr && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFacotr, 
            this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
            this._isStateInvalied = !0) : (this._curDepthBias = {
                constantFactor: depthBiasConstantFacotr,
                clamp: depthBiasClamp,
                slopeFactor: depthBiasSlopeFactor
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setBlendConstants",
        value: function setBlendConstants(blendConstants) {
            (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
            this._isStateInvalied = !0);
        }
    }, {
        key: "setDepthBound",
        value: function setDepthBound(minDepthBounds, maxDepthBounds) {
            this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                minBounds: minDepthBounds,
                maxBounds: maxDepthBounds
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setStencilWriteMask",
        value: function setStencilWriteMask(face, writeMask) {
            this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
            this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                face: face,
                writeMask: writeMask
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setStencilCompareMask",
        value: function setStencilCompareMask(face, reference, compareMask) {
            this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
            this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
            this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                face: face,
                reference: reference,
                compareMask: compareMask
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "draw",
        value: function draw(inputAssembler) {
            if (this._type === GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                this._isStateInvalied && this.bindStates();
                var cmd = this._allocator.drawCmdPool.alloc(WebGLCmdDraw);
                if (inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.DRAW), 
                ++this._numDrawCalls, this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                  case 4:
                    this._numTris += inputAssembler.indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                    break;

                  case 5:
                  case 6:
                    this._numTris += (inputAssembler.indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                }
            } else console.error("Command 'draw' must be recorded inside a render pass.");
        }
    }, {
        key: "updateBuffer",
        value: function updateBuffer(buffer, data, offset, size) {
            if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                var gpuBuffer = buffer.gpuBuffer;
                if (gpuBuffer) {
                    var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);
                    if (cmd) {
                        var buffSize;
                        buffSize = void 0 !== size ? size : buffer.usage & GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                        var buff = data;
                        cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                        cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                    }
                }
            } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
        }
    }, {
        key: "copyBufferToTexture",
        value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
            if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                if (gpuBuffer && gpuTexture) {
                    var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);
                    cmd && (cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                    cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE));
                }
            } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
        }
    }, {
        key: "execute",
        value: function execute(cmdBuffs, count) {
            for (var i = 0; i < count; ++i) {
                for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                }
                for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                }
                for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                }
                for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                }
                for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                }
                this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                this._numTris += webGLCmdBuff._numTris;
            }
        }
    }, {
        key: "bindStates",
        value: function bindStates() {
            var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);
            bindStatesCmd && (bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
            bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
            bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
            bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
            bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
            bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
            this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES), this._isStateInvalied = !1);
        }
    }, {
        key: "webGLDevice",
        get: function get() {
            return this._device;
        }
    } ]), WebGLGFXCommandBuffer;
}(), WebGLGFXFramebuffer = function(_GFXFramebuffer) {
    function WebGLGFXFramebuffer(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
        _this;
    }
    return _inherits(WebGLGFXFramebuffer, GFXFramebuffer), _createClass(WebGLGFXFramebuffer, [ {
        key: "gpuFramebuffer",
        get: function get() {
            return this._gpuFramebuffer;
        }
    } ]), _createClass(WebGLGFXFramebuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
            this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
            this._isOffscreen) {
                var gpuColorViews = [];
                if (void 0 !== info.colorViews) {
                    var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var colorView = _ref;
                        gpuColorViews.push(colorView.gpuTextureView);
                    }
                }
                var gpuDepthStencilView = null;
                info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                this._gpuFramebuffer = {
                    gpuRenderPass: info.renderPass.gpuRenderPass,
                    gpuColorViews: gpuColorViews,
                    gpuDepthStencilView: gpuDepthStencilView,
                    isOffscreen: this._isOffscreen,
                    glFramebuffer: null
                }, function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                    if (gpuFramebuffer.isOffscreen) {
                        var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                        if (glFramebuffer) {
                            gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                            device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                            for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                var cv = gpuFramebuffer.gpuColorViews[i];
                                cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                attachments.push(gl.COLOR_ATTACHMENT0 + i));
                            }
                            var dsv = gpuFramebuffer.gpuDepthStencilView;
                            if (dsv) {
                                var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                            }
                            device.WEBGL_draw_buffers && device.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                            if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                break;

                              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                break;

                              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                break;

                              case gl.FRAMEBUFFER_UNSUPPORTED:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                            }
                        }
                    }
                }(this._device, this._gpuFramebuffer);
            } else this._gpuFramebuffer = {
                gpuRenderPass: info.renderPass.gpuRenderPass,
                gpuColorViews: [],
                gpuDepthStencilView: null,
                isOffscreen: info.isOffscreen,
                glFramebuffer: null
            };
            return this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._isOffscreen && this._gpuFramebuffer && function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                gpuFramebuffer.glFramebuffer = null);
            }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXFramebuffer;
}(), WebGLGFXInputAssembler = function(_GFXInputAssembler) {
    function WebGLGFXInputAssembler(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
        _this;
    }
    return _inherits(WebGLGFXInputAssembler, GFXInputAssembler), _createClass(WebGLGFXInputAssembler, [ {
        key: "gpuInputAssembler",
        get: function get() {
            return this._gpuInputAssembler;
        }
    } ]), _createClass(WebGLGFXInputAssembler, [ {
        key: "initialize",
        value: function initialize(info) {
            if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
            !1;
            if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
            void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                var vertBuff = this._vertexBuffers[0];
                this._vertexCount = vertBuff.size / vertBuff.stride;
            }
            this._indirectBuffer = info.indirectBuffer || null;
            for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                var vb = info.vertexBuffers[i];
                vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
            }
            var gpuIndexBuffer = null, glIndexType = 0;
            if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
              case 1:
                glIndexType = 5121;
                break;

              case 2:
                glIndexType = 5123;
                break;

              case 4:
                glIndexType = 5125;
                break;

              default:
                console.error("Error index buffer stride.");
            }
            var gpuIndirectBuffer = null;
            return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
            this._gpuInputAssembler = {
                attributes: info.attributes,
                gpuVertexBuffers: gpuVertexBuffers,
                gpuIndexBuffer: gpuIndexBuffer,
                gpuIndirectBuffer: gpuIndirectBuffer,
                glAttribs: [],
                glIndexType: glIndexType,
                glVAOs: new Map()
            }, function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
                var gl = device.gl;
                gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                    var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType(attrib.format, gl), size = GFXFormatInfos[attrib.format].size;
                    gpuInputAssembler.glAttribs[i] = {
                        name: attrib.name,
                        glBuffer: gpuBuffer.glBuffer,
                        glType: glType,
                        size: size,
                        count: GFXFormatInfos[attrib.format].count,
                        stride: gpuBuffer.stride,
                        componentCount: WebGLGetComponentCount(glType, gl),
                        isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                        isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                        offset: offsets[stream]
                    }, offsets[stream] += size;
                }
            }(this._device, this._gpuInputAssembler), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var webglDev = this._device;
            this._gpuInputAssembler && webglDev.useVAO && function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                var _iterator8 = gpuInputAssembler.glVAOs, _isArray8 = Array.isArray(_iterator8), _i18 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i18 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i18++];
                    } else {
                        if ((_i18 = _iterator8.next()).done) break;
                        _ref8 = _i18.value;
                    }
                    var vao = _ref8;
                    device.OES_vertex_array_object.deleteVertexArrayOES(vao[1]);
                }
                gpuInputAssembler.glVAOs.clear();
            }(webglDev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "extractCmdDraw",
        value: function extractCmdDraw(cmd) {
            cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
            cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
            cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
            cmd.drawInfo.firstInstance = this._firstInstance;
        }
    } ]), WebGLGFXInputAssembler;
}(), WebGLGFXPipelineLayout = function(_GFXPipelineLayout) {
    function WebGLGFXPipelineLayout(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
        _this;
    }
    return _inherits(WebGLGFXPipelineLayout, GFXPipelineLayout), _createClass(WebGLGFXPipelineLayout, [ {
        key: "gpuPipelineLayout",
        get: function get() {
            return this._gpuPipelineLayout;
        }
    } ]), _createClass(WebGLGFXPipelineLayout, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
            this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXPipelineLayout;
}(), WebGLPrimitives = [ 0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0 ], WebGLGFXPipelineState = function(_GFXPipelineState) {
    function WebGLGFXPipelineState(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPipelineState).call(this, device)))._gpuPipelineState = null, 
        _this;
    }
    return _inherits(WebGLGFXPipelineState, GFXPipelineState), _createClass(WebGLGFXPipelineState, [ {
        key: "gpuPipelineState",
        get: function get() {
            return this._gpuPipelineState;
        }
    } ]), _createClass(WebGLGFXPipelineState, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._primitive = info.primitive, this._shader = info.shader, this._is = info.is, 
            this._rs = info.rs, this._dss = info.dss, this._bs = info.bs, this._dynamicStates = info.dynamicStates || [], 
            this._layout = info.layout, this._renderPass = info.renderPass, this._gpuPipelineState = {
                glPrimitive: WebGLPrimitives[info.primitive],
                gpuShader: info.shader.gpuShader,
                rs: info.rs,
                dss: info.dss,
                bs: info.bs,
                dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                gpuLayout: info.layout.gpuPipelineLayout,
                gpuRenderPass: info.renderPass.gpuRenderPass
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuPipelineState = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXPipelineState;
}(), WebGLGFXQueue = function(_GFXQueue) {
    function WebGLGFXQueue(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXQueue).call(this, device))).numDrawCalls = 0, 
        _this.numTris = 0, _this._isAsync = !1, _this;
    }
    return _inherits(WebGLGFXQueue, GFXQueue), _createClass(WebGLGFXQueue, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._type = info.type, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "submit",
        value: function submit(cmdBuffs, fence) {
            if (!this._isAsync) {
                var _iterator = cmdBuffs, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var cmdBuff = _ref;
                    WebGLCmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                    this.numTris += cmdBuff.numTris;
                }
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            this.numDrawCalls = 0, this.numTris = 0;
        }
    } ]), WebGLGFXQueue;
}(), WebGLGFXRenderPass = function(_GFXRenderPass) {
    function WebGLGFXRenderPass(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXRenderPass).call(this, device)))._gpuRenderPass = null, 
        _this;
    }
    return _inherits(WebGLGFXRenderPass, GFXRenderPass), _createClass(WebGLGFXRenderPass, [ {
        key: "gpuRenderPass",
        get: function get() {
            return this._gpuRenderPass;
        }
    } ]), _createClass(WebGLGFXRenderPass, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
            this._gpuRenderPass = {
                colorAttachments: this._colorInfos,
                depthStencilAttachment: this._depthStencilInfo
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuRenderPass = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXRenderPass;
}(), WebGLWraps = [ 10497, 33648, 33071, 33071 ], WebGLGFXSampler = function(_GFXSampler) {
    function WebGLGFXSampler(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXSampler).call(this, device)))._gpuSampler = null, 
        _this._state = new GFXSamplerState(), _this;
    }
    return _inherits(WebGLGFXSampler, GFXSampler), _createClass(WebGLGFXSampler, [ {
        key: "gpuSampler",
        get: function get() {
            return this._gpuSampler;
        }
    } ]), _createClass(WebGLGFXSampler, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
            void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
            void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
            void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
            void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
            void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
            void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias);
            var glMinFilter = 0, glMagFilter = 0, minFilter = this._state.minFilter, magFilter = this._state.magFilter, mipFilter = this._state.mipFilter;
            glMinFilter = minFilter === GFXFilter.LINEAR || minFilter === GFXFilter.ANISOTROPIC ? mipFilter === GFXFilter.LINEAR || mipFilter === GFXFilter.ANISOTROPIC ? 9987 : mipFilter === GFXFilter.POINT ? 9985 : 9729 : mipFilter === GFXFilter.LINEAR || mipFilter === GFXFilter.ANISOTROPIC ? 9986 : mipFilter === GFXFilter.POINT ? 9984 : 9728, 
            glMagFilter = magFilter === GFXFilter.LINEAR || magFilter === GFXFilter.ANISOTROPIC ? 9729 : 9728;
            var glWrapS = WebGLWraps[this._state.addressU], glWrapT = WebGLWraps[this._state.addressV], glWrapR = WebGLWraps[this._state.addressW];
            return this._gpuSampler = {
                glMinFilter: glMinFilter,
                glMagFilter: glMagFilter,
                glWrapS: glWrapS,
                glWrapT: glWrapT,
                glWrapR: glWrapR
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuSampler = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXSampler;
}(), WebGLGFXShader = function(_GFXShader) {
    function WebGLGFXShader(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXShader).call(this, device)))._gpuShader = null, 
        _this;
    }
    return _inherits(WebGLGFXShader, GFXShader), _createClass(WebGLGFXShader, [ {
        key: "gpuShader",
        get: function get() {
            return this._gpuShader;
        }
    } ]), _createClass(WebGLGFXShader, [ {
        key: "initialize",
        value: function initialize(info) {
            this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
            void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                name: info.name ? info.name : "",
                blocks: void 0 !== info.blocks ? info.blocks : [],
                samplers: void 0 !== info.samplers ? info.samplers : [],
                gpuStages: new Array(info.stages.length),
                glProgram: null,
                glInputs: [],
                glUniforms: [],
                glBlocks: [],
                glSamplers: []
            };
            for (var i = 0; i < info.stages.length; ++i) {
                var stage = info.stages[i];
                this._gpuShader.gpuStages[i] = {
                    type: stage.type,
                    source: stage.source,
                    macros: stage.macros ? stage.macros : [],
                    glShader: null
                };
            }
            return function WebGLCmdFuncCreateShader(device, gpuShader) {
                var gl = device.gl, _loop2 = function _loop2() {
                    if (_isArray) {
                        if (_i7 >= _iterator.length) return "break";
                        _ref = _iterator[_i7++];
                    } else {
                        if ((_i7 = _iterator.next()).done) return "break";
                        _ref = _i7.value;
                    }
                    var gpuStage = _ref, glShaderType = 0, shaderTypeStr = "", lineNumber = 1;
                    switch (gpuStage.type) {
                      case GFXShaderType.VERTEX:
                        shaderTypeStr = "VertexShader", glShaderType = gl.VERTEX_SHADER;
                        break;

                      case GFXShaderType.FRAGMENT:
                        shaderTypeStr = "FragmentShader", glShaderType = gl.FRAGMENT_SHADER;
                        break;

                      default:
                        return console.error("Unsupported GFXShaderType."), {
                            v: void 0
                        };
                    }
                    var glShader = gl.createShader(glShaderType);
                    if (glShader && (gpuStage.glShader = glShader, gl.shaderSource(gpuStage.glShader, gpuStage.source), 
                    gl.compileShader(gpuStage.glShader), !gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS))) return console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                    console.error("Shader source dump:", gpuStage.source.replace(/^|\n/g, function() {
                        return "\n".concat(lineNumber++, " ");
                    })), console.error(gl.getShaderInfoLog(gpuStage.glShader)), gl.deleteShader(gpuStage.glShader), 
                    gpuStage.glShader = null, {
                        v: void 0
                    };
                }, _iterator = gpuShader.gpuStages, _isArray = Array.isArray(_iterator), _i7 = 0;
                _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref, _ret = _loop2();
                    switch (_ret) {
                      case "break":
                        break _loop;

                      default:
                        if ("object" === _typeof(_ret)) return _ret.v;
                    }
                }
                var glProgram = gl.createProgram();
                if (glProgram) {
                    gpuShader.glProgram = glProgram;
                    var _iterator2 = gpuShader.gpuStages, _isArray2 = Array.isArray(_iterator2), _i8 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i8 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i8++];
                        } else {
                            if ((_i8 = _iterator2.next()).done) break;
                            _ref2 = _i8.value;
                        }
                        var _gpuStage = _ref2;
                        gl.attachShader(gpuShader.glProgram, _gpuStage.glShader);
                    }
                    if (gl.linkProgram(gpuShader.glProgram), gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                        console.info("Shader '" + gpuShader.name + "' compilation successed.");
                        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                        gpuShader.glInputs = new Array(activeAttribCount);
                        for (var i = 0; i < activeAttribCount; ++i) {
                            var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                            if (attribInfo) {
                                var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType(attribInfo.type, gl), stride = WebGLGetTypeSize(attribInfo.type, gl);
                                gpuShader.glInputs[i] = {
                                    binding: glLoc,
                                    name: varName,
                                    type: type,
                                    stride: stride,
                                    count: attribInfo.size,
                                    size: stride * attribInfo.size,
                                    glType: attribInfo.type,
                                    glLoc: glLoc
                                };
                            }
                        }
                        if (gpuShader.blocks.length > 0) {
                            gpuShader.glBlocks = new Array(gpuShader.blocks.length);
                            for (var _i10 = 0; _i10 < gpuShader.blocks.length; ++_i10) {
                                var block = gpuShader.blocks[_i10], glBlock = {
                                    binding: block.binding,
                                    name: block.name,
                                    size: 0,
                                    glUniforms: new Array(block.members.length),
                                    glActiveUniforms: [],
                                    isUniformPackage: !0
                                };
                                gpuShader.glBlocks[_i10] = glBlock;
                                for (var u = 0; u < block.members.length; ++u) {
                                    var uniform = block.members[u], glType = GFXTypeToWebGLType(uniform.type, gl), _stride = WebGLGetTypeSize(glType, gl), size = _stride * uniform.count, begin = glBlock.size / 4, array = new Array(size / 4);
                                    array.fill(0), glBlock.glUniforms[u] = {
                                        binding: -1,
                                        name: uniform.name,
                                        type: uniform.type,
                                        stride: _stride,
                                        count: uniform.count,
                                        size: size,
                                        offset: glBlock.size,
                                        glType: glType,
                                        glLoc: -1,
                                        array: array,
                                        begin: begin
                                    }, glBlock.size += size;
                                }
                            }
                        }
                        if (gpuShader.samplers.length > 0) {
                            gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                            for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                                var sampler = gpuShader.samplers[_i11];
                                gpuShader.glSamplers[_i11] = {
                                    binding: sampler.binding,
                                    name: sampler.name,
                                    type: sampler.type,
                                    units: [],
                                    glType: GFXTypeToWebGLType(sampler.type, gl),
                                    glLoc: -1
                                };
                            }
                        }
                        for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i12 = 0; _i12 < activeUniformCount; ++_i12) {
                            var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i12);
                            if (uniformInfo) {
                                var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                if (_glLoc) {
                                    var _varName = void 0, _nameOffset = uniformInfo.name.indexOf("[");
                                    if (_varName = -1 !== _nameOffset ? uniformInfo.name.substr(0, _nameOffset) : uniformInfo.name, 
                                    uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE) {
                                        var _iterator6 = gpuShader.glSamplers, _isArray6 = Array.isArray(_iterator6), _i15 = 0;
                                        for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                                            var _ref6;
                                            if (_isArray6) {
                                                if (_i15 >= _iterator6.length) break;
                                                _ref6 = _iterator6[_i15++];
                                            } else {
                                                if ((_i15 = _iterator6.next()).done) break;
                                                _ref6 = _i15.value;
                                            }
                                            var glSampler = _ref6;
                                            if (glSampler.name === _varName) {
                                                for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                                glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                                break;
                                            }
                                        }
                                    } else {
                                        var _iterator4 = gpuShader.glBlocks, _isArray4 = Array.isArray(_iterator4), _i13 = 0;
                                        for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                            var _ref4;
                                            if (_isArray4) {
                                                if (_i13 >= _iterator4.length) break;
                                                _ref4 = _iterator4[_i13++];
                                            } else {
                                                if ((_i13 = _iterator4.next()).done) break;
                                                _ref4 = _i13.value;
                                            }
                                            var _glBlock = _ref4, _iterator5 = _glBlock.glUniforms, _isArray5 = Array.isArray(_iterator5), _i14 = 0;
                                            for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                                var _ref5;
                                                if (_isArray5) {
                                                    if (_i14 >= _iterator5.length) break;
                                                    _ref5 = _iterator5[_i14++];
                                                } else {
                                                    if ((_i14 = _iterator5.next()).done) break;
                                                    _ref5 = _i14.value;
                                                }
                                                var glUniform = _ref5;
                                                if (glUniform.name === _varName) {
                                                    glUniform.glLoc = _glLoc, _glBlock.glActiveUniforms.push(glUniform);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (glActiveSamplers.length) {
                            device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                            device.stateCache.glProgram = gpuShader.glProgram);
                            for (var _i16 = 0, _glActiveSamplers = glActiveSamplers; _i16 < _glActiveSamplers.length; _i16++) {
                                var _glSampler = _glActiveSamplers[_i16];
                                gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                            }
                        }
                    } else {
                        console.error("Failed to link shader '" + gpuShader.name + "'."), console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                        var _iterator3 = gpuShader.gpuStages, _isArray3 = Array.isArray(_iterator3), _i9 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i9 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i9++];
                            } else {
                                if ((_i9 = _iterator3.next()).done) break;
                                _ref3 = _i9.value;
                            }
                            var gpuStage = _ref3;
                            gpuStage.glShader && (gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                        }
                    }
                }
            }(this._device, this._gpuShader), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuShader && (!function WebGLCmdFuncDestroyShader(device, gpuShader) {
                var _iterator7 = gpuShader.gpuStages, _isArray7 = Array.isArray(_iterator7), _i17 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i17 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i17++];
                    } else {
                        if ((_i17 = _iterator7.next()).done) break;
                        _ref7 = _i17.value;
                    }
                    var gpuStage = _ref7;
                    gpuStage.glShader && (device.gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                }
                gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
            }(this._device, this._gpuShader), this._gpuShader = null), this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXShader;
}(), WebGLStateCache = function WebGLStateCache() {
    _classCallCheck(this, WebGLStateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
    this.glVAO = null, this.texUnit = 0, this.glTex2DUnits = void 0, this.glTexCubeUnits = void 0, 
    this.glRenderbuffer = null, this.glFramebuffer = null, this.viewport = void 0, this.scissorRect = void 0, 
    this.rs = void 0, this.dss = void 0, this.bs = void 0, this.glProgram = null, this.glEnabledAttribLocs = void 0, 
    this.glCurrentAttribLocs = void 0, this.glTex2DUnits = new Array(16), this.glTexCubeUnits = new Array(16), 
    this.viewport = {
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        minDepth: 0,
        maxDepth: 0
    }, this.scissorRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }, this.rs = new GFXRasterizerState(), this.dss = new GFXDepthStencilState(), this.bs = new GFXBlendState(), 
    this.glEnabledAttribLocs = new Array(16), this.glCurrentAttribLocs = new Array(16), 
    this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
    for (var i = 0; i < 16; ++i) this.glTex2DUnits[i] = {
        glTexture: null
    }, this.glTexCubeUnits[i] = {
        glTexture: null
    };
};

function IsPowerOf2(x) {
    return x > 0 && 0 == (x & x - 1);
}

var WebGLGFXTexture = function(_GFXTexture) {
    function WebGLGFXTexture(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTexture).call(this, device)))._gpuTexture = null, 
        _this;
    }
    return _inherits(WebGLGFXTexture, GFXTexture), _createClass(WebGLGFXTexture, [ {
        key: "gpuTexture",
        get: function get() {
            return this._gpuTexture;
        }
    } ]), _createClass(WebGLGFXTexture, [ {
        key: "initialize",
        value: function initialize(info) {
            var viewType;
            switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
            this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
            void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
            void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
            this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
            this._flags & GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
            info.type) {
              case GFXTextureType.TEX1D:
                viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV1D : GFXTextureViewType.TV1D_ARRAY : GFXTextureViewType.TV1D;
                break;

              case GFXTextureType.TEX2D:
                var flags = GFXTextureFlagBit.NONE;
                info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV2D : flags & GFXTextureFlagBit.CUBEMAP ? GFXTextureViewType.CUBE : GFXTextureViewType.TV2D_ARRAY : GFXTextureViewType.TV2D;
                break;

              case GFXTextureType.TEX3D:
                viewType = GFXTextureViewType.TV3D;
                break;

              default:
                viewType = GFXTextureViewType.TV2D;
            }
            return this._gpuTexture = {
                type: this._type,
                viewType: viewType,
                format: this._format,
                usage: this._usage,
                width: this._width,
                height: this._height,
                depth: this._depth,
                size: this._size,
                arrayLayer: this._arrayLayer,
                mipLevel: this._mipLevel,
                samples: this._samples,
                flags: this._flags,
                isPowerOf2: this._isPowerOf2,
                glTarget: 0,
                glInternelFmt: 0,
                glFormat: 0,
                glType: 0,
                glUsage: 0,
                glTexture: null,
                glRenderbuffer: null,
                glWrapS: 0,
                glWrapT: 0,
                glMinFilter: 0,
                glMagFilter: 0
            }, function WebGLCmdFuncCreateTexture(device, gpuTexture) {
                var gl = device.gl;
                switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl), 
                gpuTexture.viewType) {
                  case GFXTextureViewType.TV2D:
                    if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D, 
                    gpuTexture.samples === GFXSampleCount.X1) {
                        var glTexture = gl.createTexture();
                        if (glTexture && gpuTexture.size > 0) {
                            gpuTexture.glTexture = glTexture;
                            var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            if (GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            } else {
                                var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                            } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                            gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                        }
                    }
                    break;

                  case GFXTextureViewType.CUBE:
                    gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    var _glTexture = gl.createTexture();
                    if (_glTexture && gpuTexture.size > 0) {
                        gpuTexture.glTexture = _glTexture;
                        var _glTexUnit = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                        if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) for (var _w2 = gpuTexture.width, _h2 = gpuTexture.height, _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                            var _imgSize2 = GFXFormatSize(gpuTexture.format, _w2, _h2, 1), _view2 = new Uint8Array(_imgSize2);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, _w2, _h2, 0, _view2), 
                            _w2 = Math.max(1, _w2 >> 1), _h2 = Math.max(1, _h2 >> 1);
                        } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                            var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                        } else for (var f = 0; f < 6; ++f) for (var _w = gpuTexture.width, _h = gpuTexture.height, _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, _w, _h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        _w = Math.max(1, _w >> 1), _h = Math.max(1, _h >> 1);
                        gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                        gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                    }
                    break;

                  default:
                    console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                }
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, 
            this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuTexture && (!function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
                gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                gpuTexture.glRenderbuffer = null);
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= this._size, 
            this._gpuTexture = null), this._status = GFXStatus.UNREADY, this._buffer = null;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            var oldSize = this._size;
            this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
            this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
            this._gpuTexture.size = this._size, function WebGLCmdFuncResizeTexture(device, gpuTexture) {
                var gl = device.gl;
                switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl), 
                gpuTexture.viewType) {
                  case GFXTextureViewType.TV2D:
                    if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D, 
                    gpuTexture.samples === GFXSampleCount.X1) {
                        var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                        glTexUnit.glTexture = gpuTexture.glTexture);
                        var w = gpuTexture.width, h = gpuTexture.height;
                        if (GFXFormatInfos[gpuTexture.format].isCompressed) {
                            if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                        } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                    }
                    break;

                  case GFXTextureViewType.CUBE:
                    gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    var _glTexUnit2 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                    _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                        if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) for (var _w4 = gpuTexture.width, _h4 = gpuTexture.height, _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                            var _imgSize4 = GFXFormatSize(gpuTexture.format, _w4, _h4, 1), _view4 = new Uint8Array(_imgSize4);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, _w4, _h4, 0, _view4), 
                            _w4 = Math.max(1, _w4 >> 1), _h4 = Math.max(1, _h4 >> 1);
                        }
                    } else for (var f = 0; f < 6; ++f) for (var _w3 = gpuTexture.width, _h3 = gpuTexture.height, _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, _w3, _h3, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                    _w3 = Math.max(1, _w3 >> 1), _h3 = Math.max(1, _h3 >> 1);
                    break;

                  default:
                    console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                }
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= oldSize, 
            this._device.memoryStatus.textureSize += this._size), this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXTexture;
}(), WebGLGFXTextureView = function(_GFXTextureView) {
    function WebGLGFXTextureView(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXTextureView).call(this, device)))._gpuTextureView = null, 
        _this;
    }
    return _inherits(WebGLGFXTextureView, GFXTextureView), _createClass(WebGLGFXTextureView, [ {
        key: "gpuTextureView",
        get: function get() {
            return this._gpuTextureView;
        }
    } ]), _createClass(WebGLGFXTextureView, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._texture = info.texture, this._type = info.type, this._format = info.format, 
            this._format = info.format, void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), 
            void 0 !== info.levelCount && (this._levelCount = info.levelCount), void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), 
            void 0 !== info.layerCount && (this._layerCount = info.layerCount), this._gpuTextureView = {
                gpuTexture: info.texture.gpuTexture,
                type: info.type,
                format: info.format,
                baseLevel: info.baseLevel ? info.baseLevel : 0,
                levelCount: info.levelCount ? info.levelCount : 1
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuTextureView = null, this._texture = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGLGFXTextureView;
}(), GFXWindow = function(_GFXObject) {
    function GFXWindow(device) {
        var _this;
        return _classCallCheck(this, GFXWindow), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXWindow).call(this, GFXObjectType.WINDOW)))._device = void 0, 
        _this._title = "", _this._left = 0, _this._top = 0, _this._width = 0, _this._height = 0, 
        _this._nativeWidth = 0, _this._nativeHeight = 0, _this._colorFmt = GFXFormat.UNKNOWN, 
        _this._depthStencilFmt = GFXFormat.UNKNOWN, _this._isOffscreen = !1, _this._renderPass = null, 
        _this._colorTex = null, _this._colorTexView = null, _this._depthStencilTex = null, 
        _this._depthStencilTexView = null, _this._framebuffer = null, _this._device = device, 
        _this;
    }
    return _inherits(GFXWindow, GFXObject), _createClass(GFXWindow, [ {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "colorFormat",
        get: function get() {
            return this._colorFmt;
        }
    }, {
        key: "detphStencilFormat",
        get: function get() {
            return this._depthStencilFmt;
        }
    }, {
        key: "isOffscreen",
        get: function get() {
            return this._isOffscreen;
        }
    }, {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    }, {
        key: "colorTexView",
        get: function get() {
            return this._colorTexView;
        }
    }, {
        key: "depthStencilTexView",
        get: function get() {
            return this._depthStencilTexView;
        }
    }, {
        key: "framebuffer",
        get: function get() {
            return this._framebuffer;
        }
    } ]), GFXWindow;
}(), WebGLGFXWindow = function(_GFXWindow) {
    function WebGLGFXWindow(device) {
        return _classCallCheck(this, WebGLGFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXWindow).call(this, device));
    }
    return _inherits(WebGLGFXWindow, GFXWindow), _createClass(WebGLGFXWindow, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
            void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
            this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
            this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
            this._renderPass = this._device.createRenderPass({
                colorAttachments: [ {
                    format: this._colorFmt,
                    loadOp: GFXLoadOp.CLEAR,
                    storeOp: GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                    endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                } ],
                depthStencilAttachment: {
                    format: this._depthStencilFmt,
                    depthLoadOp: GFXLoadOp.CLEAR,
                    depthStoreOp: GFXStoreOp.STORE,
                    stencilLoadOp: GFXLoadOp.CLEAR,
                    stencilStoreOp: GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                    endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                }
            });
            var colorViews = [];
            return this._isOffscreen && (this._colorFmt !== GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                format: this._colorFmt,
                width: this._width,
                height: this._height,
                depth: 1,
                arrayLayer: 1,
                mipLevel: 1,
                flags: GFXTextureFlagBit.NONE
            }), this._colorTexView = this._device.createTextureView({
                texture: this._colorTex,
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt,
                baseLevel: 0,
                levelCount: 1,
                baseLayer: 0,
                layerCount: 1
            }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                format: this._depthStencilFmt,
                width: this._width,
                height: this._height,
                depth: 1,
                arrayLayer: 1,
                mipLevel: 1,
                flags: GFXTextureFlagBit.NONE
            }), this._depthStencilTexView = this._device.createTextureView({
                texture: this._depthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt,
                baseLevel: 0,
                levelCount: 1,
                baseLayer: 0,
                layerCount: 1
            }))), this._framebuffer = this._device.createFramebuffer({
                renderPass: this._renderPass,
                colorViews: colorViews,
                depthStencilView: this._depthStencilTexView,
                isOffscreen: this._isOffscreen
            }), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
            this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
            this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
            this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
            this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
            this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
            this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
            this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                texture: this._depthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt
            })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
            this._colorTexView.initialize({
                texture: this._colorTex,
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt
            })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
            this._framebuffer.initialize({
                renderPass: this._renderPass,
                colorViews: [ this._colorTexView ],
                depthStencilView: this._depthStencilTexView
            })));
        }
    } ]), WebGLGFXWindow;
}(), WebGLGFXDevice = function(_GFXDevice) {
    function WebGLGFXDevice() {
        var _this;
        return _classCallCheck(this, WebGLGFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXDevice).call(this))).stateCache = new WebGLStateCache(), 
        _this.nullTex2D = null, _this.nullTexCube = null, _this._webGLRC = null, _this._isAntialias = !0, 
        _this._isPremultipliedAlpha = !0, _this._useVAO = !1, _this._extensions = null, 
        _this._EXT_texture_filter_anisotropic = null, _this._EXT_frag_depth = null, _this._EXT_shader_texture_lod = null, 
        _this._EXT_sRGB = null, _this._OES_vertex_array_object = null, _this._EXT_color_buffer_half_float = null, 
        _this._WEBGL_color_buffer_float = null, _this._WEBGL_compressed_texture_etc1 = null, 
        _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
        _this._WEBGL_compressed_texture_astc = null, _this._WEBGL_compressed_texture_s3tc = null, 
        _this._WEBGL_compressed_texture_s3tc_srgb = null, _this._WEBGL_debug_shaders = null, 
        _this._WEBGL_draw_buffers = null, _this._WEBGL_lose_context = null, _this._WEBGL_depth_texture = null, 
        _this._WEBGL_debug_renderer_info = null, _this._OES_texture_half_float = null, _this._OES_texture_half_float_linear = null, 
        _this._OES_texture_float = null, _this._OES_texture_float_linear = null, _this._OES_standard_derivatives = null, 
        _this._OES_element_index_uint = null, _this._ANGLE_instanced_arrays = null, _this;
    }
    return _inherits(WebGLGFXDevice, GFXDevice), _createClass(WebGLGFXDevice, [ {
        key: "gl",
        get: function get() {
            return this._webGLRC;
        }
    }, {
        key: "webGLQueue",
        get: function get() {
            return this._queue;
        }
    }, {
        key: "isAntialias",
        get: function get() {
            return this._isAntialias;
        }
    }, {
        key: "isPremultipliedAlpha",
        get: function get() {
            return this._isPremultipliedAlpha;
        }
    }, {
        key: "useVAO",
        get: function get() {
            return this._useVAO;
        }
    }, {
        key: "EXT_texture_filter_anisotropic",
        get: function get() {
            return this._EXT_texture_filter_anisotropic;
        }
    }, {
        key: "EXT_frag_depth",
        get: function get() {
            return this._EXT_frag_depth;
        }
    }, {
        key: "EXT_shader_texture_lod",
        get: function get() {
            return this._EXT_shader_texture_lod;
        }
    }, {
        key: "EXT_sRGB",
        get: function get() {
            return this._EXT_sRGB;
        }
    }, {
        key: "OES_vertex_array_object",
        get: function get() {
            return this._OES_vertex_array_object;
        }
    }, {
        key: "WEBGL_color_buffer_float",
        get: function get() {
            return this._WEBGL_color_buffer_float;
        }
    }, {
        key: "WEBGL_compressed_texture_etc1",
        get: function get() {
            return this._WEBGL_compressed_texture_etc1;
        }
    }, {
        key: "WEBGL_compressed_texture_pvrtc",
        get: function get() {
            return this._WEBGL_compressed_texture_pvrtc;
        }
    }, {
        key: "WEBGL_compressed_texture_astc",
        get: function get() {
            return this._WEBGL_compressed_texture_astc;
        }
    }, {
        key: "WEBGL_compressed_texture_s3tc",
        get: function get() {
            return this._WEBGL_compressed_texture_s3tc;
        }
    }, {
        key: "WEBGL_compressed_texture_s3tc_srgb",
        get: function get() {
            return this._WEBGL_compressed_texture_s3tc_srgb;
        }
    }, {
        key: "WEBGL_debug_shaders",
        get: function get() {
            return this._WEBGL_debug_shaders;
        }
    }, {
        key: "WEBGL_draw_buffers",
        get: function get() {
            return this._WEBGL_draw_buffers;
        }
    }, {
        key: "WEBGL_lose_context",
        get: function get() {
            return this._WEBGL_lose_context;
        }
    }, {
        key: "WEBGL_depth_texture",
        get: function get() {
            return this._WEBGL_depth_texture;
        }
    }, {
        key: "WEBGL_debug_renderer_info",
        get: function get() {
            return this._WEBGL_debug_renderer_info;
        }
    }, {
        key: "OES_texture_half_float",
        get: function get() {
            return this._OES_texture_half_float;
        }
    }, {
        key: "OES_texture_half_float_linear",
        get: function get() {
            return this._OES_texture_half_float_linear;
        }
    }, {
        key: "OES_texture_float",
        get: function get() {
            return this._OES_texture_float;
        }
    }, {
        key: "OES_standard_derivatives",
        get: function get() {
            return this._OES_standard_derivatives;
        }
    }, {
        key: "OES_element_index_uint",
        get: function get() {
            return this._OES_element_index_uint;
        }
    }, {
        key: "ANGLE_instanced_arrays",
        get: function get() {
            return this._ANGLE_instanced_arrays;
        }
    } ]), _createClass(WebGLGFXDevice, [ {
        key: "initialize",
        value: function initialize(info) {
            this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
            this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
            try {
                var webGLCtxAttribs = {
                    alpha: !1,
                    antialias: this._isAntialias,
                    depth: !0,
                    stencil: !0,
                    premultipliedAlpha: this._isPremultipliedAlpha,
                    preserveDrawingBuffer: !1,
                    powerPreference: "default",
                    failIfMajorPerformanceCaveat: !1
                };
                this._webGLRC = this._canvas.getContext("webgl", webGLCtxAttribs);
            } catch (err) {
                return console.error(err), !1;
            }
            if (!this._webGLRC) return console.error("This device does not support WebGL."), 
            !1;
            this._canvas2D = document.createElement("canvas"), console.info("WebGL device initialized."), 
            this._gfxAPI = GFXAPI.WEBGL, this._deviceName = "WebGL";
            var gl = this._webGLRC;
            this._WEBGL_debug_renderer_info = gl.getExtension("WEBGL_debug_renderer_info"), 
            this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
            this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(gl.RENDERER), 
            this._vendor = gl.getParameter(gl.VENDOR)), this._version = gl.getParameter(gl.VERSION), 
            this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), 
            this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), 
            this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
            this._depthBits = gl.getParameter(gl.DEPTH_BITS), this._stencilBits = gl.getParameter(gl.STENCIL_BITS), 
            this._devicePixelRatio = info.devicePixelRatio || 1, this._width = this._canvas.width, 
            this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
            this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = GFXFormat.RGBA8, 
            24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D24S8 : this._depthStencilFmt = GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D16S8 : this._depthStencilFmt = GFXFormat.D16, 
            this._extensions = gl.getSupportedExtensions();
            var extensions = "";
            if (this._extensions) {
                var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    extensions += _ref + " ";
                }
                console.debug("EXTENSIONS: " + extensions);
            }
            this._EXT_texture_filter_anisotropic = gl.getExtension("EXT_texture_filter_anisotropic"), 
            this._EXT_frag_depth = gl.getExtension("EXT_frag_depth"), this._EXT_shader_texture_lod = gl.getExtension("EXT_shader_texture_lod"), 
            this._EXT_sRGB = gl.getExtension("EXT_sRGB"), this._OES_vertex_array_object = gl.getExtension("OES_vertex_array_object"), 
            this._EXT_color_buffer_half_float = gl.getExtension("EXT_color_buffer_half_float"), 
            this._WEBGL_color_buffer_float = gl.getExtension("WEBGL_color_buffer_float"), this._WEBGL_compressed_texture_etc1 = gl.getExtension("WEBGL_compressed_texture_etc1"), 
            this._WEBGL_compressed_texture_etc = gl.getExtension("WEBGL_compressed_texture_etc"), 
            this._WEBGL_compressed_texture_pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc"), 
            this._WEBGL_compressed_texture_astc = gl.getExtension("WEBGL_compressed_texture_astc"), 
            this._WEBGL_compressed_texture_s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc"), 
            this._WEBGL_compressed_texture_s3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
            this._WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders"), this._WEBGL_draw_buffers = gl.getExtension("WEBGL_draw_buffers"), 
            this._WEBGL_lose_context = gl.getExtension("WEBGL_lose_context"), this._WEBGL_depth_texture = gl.getExtension("WEBGL_depth_texture"), 
            this._OES_texture_half_float = gl.getExtension("OES_texture_half_float"), this._OES_texture_half_float_linear = gl.getExtension("OES_texture_half_float_linear"), 
            this._OES_texture_float = gl.getExtension("OES_texture_float"), this._OES_texture_float_linear = gl.getExtension("OES_texture_float_linear"), 
            this._OES_standard_derivatives = gl.getExtension("OES_standard_derivatives"), this._OES_element_index_uint = gl.getExtension("OES_element_index_uint"), 
            this._ANGLE_instanced_arrays = gl.getExtension("ANGLE_instanced_arrays"), this._features.fill(!1), 
            this._WEBGL_color_buffer_float && (this._features[GFXFeature.COLOR_FLOAT] = !0), 
            this._EXT_color_buffer_half_float && (this._features[GFXFeature.COLOR_HALF_FLOAT] = !0), 
            this._OES_texture_float && (this._features[GFXFeature.TEXTURE_FLOAT] = !0), this._OES_texture_half_float && (this._features[GFXFeature.TEXTURE_HALF_FLOAT] = !0), 
            this._OES_texture_float_linear && (this._features[GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
            this._OES_texture_half_float_linear && (this._features[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0), 
            this._WEBGL_depth_texture && (this._features[GFXFeature.FORMAT_D24S8] = !0);
            var compressedFormat = "";
            this._WEBGL_compressed_texture_etc1 && (this._features[GFXFeature.FORMAT_ETC1] = !0, 
            compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[GFXFeature.FORMAT_ETC2] = !0, 
            compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[GFXFeature.FORMAT_DXT] = !0, 
            compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[GFXFeature.FORMAT_PVRTC] = !0, 
            compressedFormat += "pvrtc "), this._features[GFXFeature.MSAA] = !1, this._OES_vertex_array_object && (this._useVAO = !1), 
            console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
            console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
            console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
            console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("DEPTH_BITS: " + this._depthBits), 
            console.info("STENCIL_BITS: " + this._stencilBits), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
            console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
            this.initStates(gl), this._queue = this.createQueue({
                type: GFXQueueType.GRAPHICS
            }), this._mainWindow = this.createWindow({
                title: this._webGLRC.canvas.title,
                left: this._webGLRC.canvas.offsetLeft,
                top: this._webGLRC.canvas.offsetTop,
                width: this._webGLRC.drawingBufferWidth,
                height: this._webGLRC.drawingBufferHeight,
                colorFmt: this._colorFmt,
                depthStencilFmt: this._depthStencilFmt
            }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGLGFXTexture(this), 
            this.nullTex2D.initialize({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.SAMPLED,
                format: GFXFormat.RGBA8,
                width: 2,
                height: 2,
                flags: GFXTextureFlagBit.GEN_MIPMAP
            }), this.nullTexCube = new WebGLGFXTexture(this), this.nullTexCube.initialize({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.SAMPLED,
                format: GFXFormat.RGBA8,
                width: 2,
                height: 2,
                arrayLayer: 6,
                flags: GFXTextureFlagBit.CUBEMAP | GFXTextureFlagBit.GEN_MIPMAP
            });
            var nullTexRegion = {
                buffOffset: 0,
                buffStride: 0,
                buffTexHeight: 0,
                texOffset: {
                    x: 0,
                    y: 0,
                    z: 0
                },
                texExtent: {
                    width: 2,
                    height: 2,
                    depth: 1
                },
                texSubres: {
                    baseMipLevel: 0,
                    levelCount: 1,
                    baseArrayLayer: 0,
                    layerCount: 1
                }
            }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
            return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
            nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
            this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
            this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
            this._queue && (this._queue.destroy(), this._queue = null), this._webGLRC = null;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
            this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
        }
    }, {
        key: "createBuffer",
        value: function createBuffer(info) {
            var buffer = new WebGLGFXBuffer(this);
            return buffer.initialize(info), buffer;
        }
    }, {
        key: "createTexture",
        value: function createTexture(info) {
            var texture = new WebGLGFXTexture(this);
            return texture.initialize(info), texture;
        }
    }, {
        key: "createTextureView",
        value: function createTextureView(info) {
            var texView = new WebGLGFXTextureView(this);
            return texView.initialize(info), texView;
        }
    }, {
        key: "createSampler",
        value: function createSampler(info) {
            var sampler = new WebGLGFXSampler(this);
            return sampler.initialize(info), sampler;
        }
    }, {
        key: "createBindingLayout",
        value: function createBindingLayout(info) {
            var bindingLayout = new WebGLGFXBindingLayout(this);
            return bindingLayout.initialize(info), bindingLayout;
        }
    }, {
        key: "createShader",
        value: function createShader(info) {
            var shader = new WebGLGFXShader(this);
            return shader.initialize(info), shader;
        }
    }, {
        key: "createInputAssembler",
        value: function createInputAssembler(info) {
            var inputAssembler = new WebGLGFXInputAssembler(this);
            return inputAssembler.initialize(info), inputAssembler;
        }
    }, {
        key: "createRenderPass",
        value: function createRenderPass(info) {
            var renderPass = new WebGLGFXRenderPass(this);
            return renderPass.initialize(info), renderPass;
        }
    }, {
        key: "createFramebuffer",
        value: function createFramebuffer(info) {
            var framebuffer = new WebGLGFXFramebuffer(this);
            return framebuffer.initialize(info), framebuffer;
        }
    }, {
        key: "createPipelineLayout",
        value: function createPipelineLayout(info) {
            var pipelineLayout = new WebGLGFXPipelineLayout(this);
            return pipelineLayout.initialize(info), pipelineLayout;
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(info) {
            var pipelineState = new WebGLGFXPipelineState(this);
            return pipelineState.initialize(info), pipelineState;
        }
    }, {
        key: "createCommandAllocator",
        value: function createCommandAllocator(info) {
            var cmdAllocator = new WebGLGFXCommandAllocator(this);
            return cmdAllocator.initialize(info), cmdAllocator;
        }
    }, {
        key: "createCommandBuffer",
        value: function createCommandBuffer(info) {
            var cmdBuff = new WebGLGFXCommandBuffer(this);
            return cmdBuff.initialize(info), cmdBuff;
        }
    }, {
        key: "createQueue",
        value: function createQueue(info) {
            var queue = new WebGLGFXQueue(this);
            return queue.initialize(info), queue;
        }
    }, {
        key: "createWindow",
        value: function createWindow(info) {
            var window = new WebGLGFXWindow(this);
            return window.initialize(info), window;
        }
    }, {
        key: "present",
        value: function present() {
            this._cmdAllocator.releaseCmds();
            var queue = this._queue;
            this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
        }
    }, {
        key: "copyBuffersToTexture",
        value: function copyBuffersToTexture(buffers, texture, regions) {
            WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        }
    }, {
        key: "copyTexImagesToTexture",
        value: function copyTexImagesToTexture(texImages, texture, regions) {
            !function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                var gl = device.gl, m = 0, n = 0, f = 0;
                switch (gpuTexture.glTarget) {
                  case gl.TEXTURE_2D:
                    var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                    glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                    glTexUnit.glTexture = gpuTexture.glTexture);
                    var _iterator20 = regions, _isArray20 = Array.isArray(_iterator20), _i31 = 0;
                    for (_iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator](); ;) {
                        var _ref20;
                        if (_isArray20) {
                            if (_i31 >= _iterator20.length) break;
                            _ref20 = _iterator20[_i31++];
                        } else {
                            if ((_i31 = _iterator20.next()).done) break;
                            _ref20 = _i31.value;
                        }
                        var region = _ref20;
                        for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }
                    break;

                  case gl.TEXTURE_CUBE_MAP:
                    var _glTexUnit3 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                    _glTexUnit3.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                    _glTexUnit3.glTexture = gpuTexture.glTexture);
                    var _iterator21 = regions, _isArray21 = Array.isArray(_iterator21), _i32 = 0;
                    for (_iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator](); ;) {
                        var _ref21;
                        if (_isArray21) {
                            if (_i32 >= _iterator21.length) break;
                            _ref21 = _iterator21[_i32++];
                        } else {
                            if ((_i32 = _iterator21.next()).done) break;
                            _ref21 = _i32.value;
                        }
                        var _region = _ref21, fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                        for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                            var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                            for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                        }
                    }
                    break;

                  default:
                    console.error("Unsupported GL texture type, copy buffer to texture failed.");
                }
                gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2 && gl.generateMipmap(gpuTexture.glTarget);
            }(this, texImages, texture.gpuTexture, regions);
        }
    }, {
        key: "copyFramebufferToBuffer",
        value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
            var gl = this._webGLRC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
            this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
            this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
            var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO), 
            this.stateCache.glFramebuffer = curFBO);
        }
    }, {
        key: "blitFramebuffer",
        value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {}
    }, {
        key: "initStates",
        value: function initStates(gl) {
            gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
            gl.disable(gl.SCISSOR_TEST), gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), 
            gl.disable(gl.POLYGON_OFFSET_FILL), gl.polygonOffset(0, 0), gl.enable(gl.DEPTH_TEST), 
            gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.depthRange(0, 1), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 4294967295), 
            gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
            gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 4294967295), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
            gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
            gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
            gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
        }
    } ]), WebGLGFXDevice;
}();

cc.WebGLGFXDevice = WebGLGFXDevice;

var WebGL2GFXBindingLayout = function(_GFXBindingLayout) {
    function WebGL2GFXBindingLayout(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXBindingLayout).call(this, device)))._gpuBindingLayout = null, 
        _this;
    }
    return _inherits(WebGL2GFXBindingLayout, GFXBindingLayout), _createClass(WebGL2GFXBindingLayout, [ {
        key: "gpuBindingLayout",
        get: function get() {
            return this._gpuBindingLayout;
        }
    } ]), _createClass(WebGL2GFXBindingLayout, [ {
        key: "initialize",
        value: function initialize(info) {
            this._bindingUnits = new Array(info.bindings.length);
            for (var i = 0; i < info.bindings.length; ++i) {
                var binding = info.bindings[i];
                this._bindingUnits[i] = {
                    binding: binding.binding,
                    type: binding.type,
                    name: binding.name,
                    buffer: null,
                    texView: null,
                    sampler: null
                };
            }
            this._gpuBindingLayout = {
                gpuBindings: new Array(info.bindings.length)
            };
            for (var _i = 0; _i < info.bindings.length; ++_i) {
                var _binding = info.bindings[_i];
                this._gpuBindingLayout.gpuBindings[_i] = {
                    binding: _binding.binding,
                    type: _binding.type,
                    name: _binding.name,
                    gpuBuffer: null,
                    gpuTexView: null,
                    gpuSampler: null
                };
            }
            return this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuBindingLayout = null, this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "update",
        value: function update() {
            if (this._isDirty && this._gpuBindingLayout) {
                for (var i = 0; i < this._bindingUnits.length; ++i) {
                    var bindingUnit = this._bindingUnits[i];
                    switch (bindingUnit.type) {
                      case GFXBindingType.UNIFORM_BUFFER:
                        bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                        break;

                      case GFXBindingType.SAMPLER:
                        bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                        bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                    }
                }
                this._isDirty = !1;
            }
        }
    } ]), WebGL2GFXBindingLayout;
}(), WebGLWraps$1 = [ WebGLRenderingContext.REPEAT, WebGLRenderingContext.MIRRORED_REPEAT, WebGLRenderingContext.CLAMP_TO_EDGE, WebGLRenderingContext.CLAMP_TO_EDGE ], SAMPLES = [ 1, 2, 4, 8, 16, 32, 64 ], _f32v4 = new Float32Array(4);

function GFXFormatToWebGLType$1(format, gl) {
    switch (format) {
      case GFXFormat.R8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.R8SN:
        return gl.BYTE;

      case GFXFormat.R8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.R8I:
        return gl.BYTE;

      case GFXFormat.R16F:
        return gl.HALF_FLOAT;

      case GFXFormat.R16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.R16I:
        return gl.SHORT;

      case GFXFormat.R32F:
        return gl.FLOAT;

      case GFXFormat.R32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.R32I:
        return gl.INT;

      case GFXFormat.RG8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RG8SN:
        return gl.BYTE;

      case GFXFormat.RG8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RG8I:
        return gl.BYTE;

      case GFXFormat.RG16F:
        return gl.HALF_FLOAT;

      case GFXFormat.RG16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.RG16I:
        return gl.SHORT;

      case GFXFormat.RG32F:
        return gl.FLOAT;

      case GFXFormat.RG32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RG32I:
        return gl.INT;

      case GFXFormat.RGB8:
      case GFXFormat.SRGB8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGB8SN:
        return gl.BYTE;

      case GFXFormat.RGB8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGB8I:
        return gl.BYTE;

      case GFXFormat.RGB16F:
        return gl.HALF_FLOAT;

      case GFXFormat.RGB16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.RGB16I:
        return gl.SHORT;

      case GFXFormat.RGB32F:
        return gl.FLOAT;

      case GFXFormat.RGB32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RGB32I:
        return gl.INT;

      case GFXFormat.RGBA8:
      case GFXFormat.SRGB8_A8:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGBA8SN:
        return gl.BYTE;

      case GFXFormat.RGBA8UI:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.RGBA8I:
        return gl.BYTE;

      case GFXFormat.RGBA16F:
        return gl.HALF_FLOAT;

      case GFXFormat.RGBA16UI:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.RGBA16I:
        return gl.SHORT;

      case GFXFormat.RGBA32F:
        return gl.FLOAT;

      case GFXFormat.RGBA32UI:
        return gl.UNSIGNED_INT;

      case GFXFormat.RGBA32I:
        return gl.INT;

      case GFXFormat.R5G6B5:
        return gl.UNSIGNED_SHORT_5_6_5;

      case GFXFormat.R11G11B10F:
        return gl.UNSIGNED_INT_10F_11F_11F_REV;

      case GFXFormat.RGB5A1:
        return gl.UNSIGNED_SHORT_5_5_5_1;

      case GFXFormat.RGBA4:
        return gl.UNSIGNED_SHORT_4_4_4_4;

      case GFXFormat.RGB10A2:
      case GFXFormat.RGB10A2UI:
        return gl.UNSIGNED_INT_2_10_10_10_REV;

      case GFXFormat.RGB9E5:
        return gl.FLOAT;

      case GFXFormat.D16:
      case GFXFormat.D16S8:
        return gl.UNSIGNED_SHORT;

      case GFXFormat.D24:
        return gl.UNSIGNED_INT;

      case GFXFormat.D24S8:
        return gl.UNSIGNED_INT_24_8;

      case GFXFormat.D32F:
        return gl.FLOAT;

      case GFXFormat.D32F_S8:
        return gl.FLOAT_32_UNSIGNED_INT_24_8_REV;

      case GFXFormat.BC1:
      case GFXFormat.BC1_SRGB:
      case GFXFormat.BC2:
      case GFXFormat.BC2_SRGB:
      case GFXFormat.BC3:
      case GFXFormat.BC3_SRGB:
      case GFXFormat.BC4:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.BC4_SNORM:
        return gl.BYTE;

      case GFXFormat.BC5:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.BC5_SNORM:
        return gl.BYTE;

      case GFXFormat.BC6H_SF16:
      case GFXFormat.BC6H_UF16:
        return gl.FLOAT;

      case GFXFormat.BC7:
      case GFXFormat.BC7_SRGB:
      case GFXFormat.ETC_RGB8:
      case GFXFormat.ETC2_RGB8:
      case GFXFormat.ETC2_SRGB8:
      case GFXFormat.ETC2_RGB8_A1:
      case GFXFormat.ETC2_SRGB8_A1:
      case GFXFormat.ETC2_RGB8:
      case GFXFormat.ETC2_SRGB8:
      case GFXFormat.EAC_R11:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.EAC_R11SN:
        return gl.BYTE;

      case GFXFormat.EAC_RG11:
        return gl.UNSIGNED_BYTE;

      case GFXFormat.EAC_RG11SN:
        return gl.BYTE;

      case GFXFormat.PVRTC_RGB2:
      case GFXFormat.PVRTC_RGBA2:
      case GFXFormat.PVRTC_RGB4:
      case GFXFormat.PVRTC_RGBA4:
      case GFXFormat.PVRTC2_2BPP:
      case GFXFormat.PVRTC2_4BPP:
      default:
        return gl.UNSIGNED_BYTE;
    }
}

function GFXFormatToWebGLInternalFormat$1(format, gl) {
    switch (format) {
      case GFXFormat.A8:
        return gl.ALPHA;

      case GFXFormat.L8:
        return gl.LUMINANCE;

      case GFXFormat.LA8:
        return gl.LUMINANCE_ALPHA;

      case GFXFormat.R8:
        return gl.R8;

      case GFXFormat.R8SN:
        return gl.R8_SNORM;

      case GFXFormat.R8UI:
        return gl.R8UI;

      case GFXFormat.R8I:
        return gl.R8I;

      case GFXFormat.RG8:
        return gl.RG8;

      case GFXFormat.RG8SN:
        return gl.RG8_SNORM;

      case GFXFormat.RG8UI:
        return gl.RG8UI;

      case GFXFormat.RG8I:
        return gl.RG8I;

      case GFXFormat.RGB8:
        return gl.RGB8;

      case GFXFormat.RGB8SN:
        return gl.RGB8_SNORM;

      case GFXFormat.RGB8UI:
        return gl.RGB8UI;

      case GFXFormat.RGB8I:
        return gl.RGB8I;

      case GFXFormat.RGBA8:
        return gl.RGBA8;

      case GFXFormat.RGBA8SN:
        return gl.RGBA8_SNORM;

      case GFXFormat.RGBA8UI:
        return gl.RGBA8UI;

      case GFXFormat.RGBA8I:
        return gl.RGBA8I;

      case GFXFormat.R16I:
        return gl.R16I;

      case GFXFormat.R16UI:
        return gl.R16UI;

      case GFXFormat.R16F:
        return gl.R16F;

      case GFXFormat.RG16I:
        return gl.RG16I;

      case GFXFormat.RG16UI:
        return gl.RG16UI;

      case GFXFormat.RG16F:
        return gl.RG16F;

      case GFXFormat.RGB16I:
        return gl.RGB16I;

      case GFXFormat.RGB16UI:
        return gl.RGB16UI;

      case GFXFormat.RGB16F:
        return gl.RGB16F;

      case GFXFormat.RGBA16I:
        return gl.RGBA16I;

      case GFXFormat.RGBA16UI:
        return gl.RGBA16UI;

      case GFXFormat.RGBA16F:
        return gl.RGBA16F;

      case GFXFormat.R32I:
        return gl.R32I;

      case GFXFormat.R32UI:
        return gl.R32UI;

      case GFXFormat.R32F:
        return gl.R32F;

      case GFXFormat.RG32I:
        return gl.RG32I;

      case GFXFormat.RG32UI:
        return gl.RG32UI;

      case GFXFormat.RG32F:
        return gl.RG32F;

      case GFXFormat.RGB32I:
        return gl.RGB32I;

      case GFXFormat.RGB32UI:
        return gl.RGB32UI;

      case GFXFormat.RGB32F:
        return gl.RGB32F;

      case GFXFormat.RGBA32I:
        return gl.RGBA32I;

      case GFXFormat.RGBA32UI:
        return gl.RGBA32UI;

      case GFXFormat.RGBA32F:
        return gl.RGBA32F;

      case GFXFormat.R5G6B5:
        return gl.RGB565;

      case GFXFormat.RGB5A1:
        return gl.RGB5_A1;

      case GFXFormat.RGBA4:
        return gl.RGBA4;

      case GFXFormat.RGB10A2:
        return gl.RGB10_A2;

      case GFXFormat.RGB10A2UI:
        return gl.RGB10_A2UI;

      case GFXFormat.R11G11B10F:
        return gl.R11F_G11F_B10F;

      case GFXFormat.D16:
        return gl.DEPTH_COMPONENT16;

      case GFXFormat.D16S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D24:
        return gl.DEPTH_COMPONENT24;

      case GFXFormat.D24S8:
        return gl.DEPTH24_STENCIL8;

      case GFXFormat.D32F:
        return gl.DEPTH_COMPONENT32F;

      case GFXFormat.D32F_S8:
        return gl.DEPTH32F_STENCIL8;

      case GFXFormat.BC1:
        return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_ALPHA:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB_ALPHA:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

      case GFXFormat.BC2:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

      case GFXFormat.BC2_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

      case GFXFormat.BC3:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

      case GFXFormat.BC3_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

      case GFXFormat.ETC_RGB8:
        return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

      case GFXFormat.ETC2_RGB8:
        return WebGLEXT.COMPRESSED_RGB8_ETC2;

      case GFXFormat.ETC2_SRGB8:
        return WebGLEXT.COMPRESSED_SRGB8_ETC2;

      case GFXFormat.ETC2_RGB8_A1:
        return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case GFXFormat.ETC2_SRGB8_A1:
        return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case GFXFormat.ETC2_RGBA8:
        return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

      case GFXFormat.ETC2_SRGB8_A8:
        return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

      case GFXFormat.EAC_R11:
        return WebGLEXT.COMPRESSED_R11_EAC;

      case GFXFormat.EAC_R11SN:
        return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

      case GFXFormat.EAC_RG11:
        return WebGLEXT.COMPRESSED_RG11_EAC;

      case GFXFormat.EAC_RG11SN:
        return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

      case GFXFormat.PVRTC_RGB2:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA2:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGB4:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA4:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

      default:
        return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
        gl.RGBA;
    }
}

function GFXFormatToWebGLFormat$1(format, gl) {
    switch (format) {
      case GFXFormat.A8:
        return gl.ALPHA;

      case GFXFormat.L8:
        return gl.LUMINANCE;

      case GFXFormat.LA8:
        return gl.LUMINANCE_ALPHA;

      case GFXFormat.R8:
      case GFXFormat.R8SN:
        return gl.RED;

      case GFXFormat.R8UI:
      case GFXFormat.R8I:
        return gl.RED;

      case GFXFormat.RG8:
      case GFXFormat.RG8SN:
      case GFXFormat.RG8UI:
      case GFXFormat.RG8I:
        return gl.RG;

      case GFXFormat.RGB8:
      case GFXFormat.RGB8SN:
      case GFXFormat.RGB8UI:
      case GFXFormat.RGB8I:
        return gl.RGB;

      case GFXFormat.RGBA8:
      case GFXFormat.RGBA8SN:
      case GFXFormat.RGBA8UI:
      case GFXFormat.RGBA8I:
        return gl.RGBA;

      case GFXFormat.R16UI:
      case GFXFormat.R16I:
      case GFXFormat.R16F:
        return gl.RED;

      case GFXFormat.RG16UI:
      case GFXFormat.RG16I:
      case GFXFormat.RG16F:
        return gl.RG;

      case GFXFormat.RGB16UI:
      case GFXFormat.RGB16I:
      case GFXFormat.RGB16F:
        return gl.RGB;

      case GFXFormat.RGBA16UI:
      case GFXFormat.RGBA16I:
      case GFXFormat.RGBA16F:
        return gl.RGBA;

      case GFXFormat.R32UI:
      case GFXFormat.R32I:
      case GFXFormat.R32F:
        return gl.RED;

      case GFXFormat.RG32UI:
      case GFXFormat.RG32I:
      case GFXFormat.RG32F:
        return gl.RG;

      case GFXFormat.RGB32UI:
      case GFXFormat.RGB32I:
      case GFXFormat.RGB32F:
        return gl.RGB;

      case GFXFormat.RGBA32UI:
      case GFXFormat.RGBA32I:
      case GFXFormat.RGBA32F:
      case GFXFormat.RGB10A2:
        return gl.RGBA;

      case GFXFormat.R11G11B10F:
      case GFXFormat.R5G6B5:
        return gl.RGB;

      case GFXFormat.RGB5A1:
      case GFXFormat.RGBA4:
        return gl.RGBA;

      case GFXFormat.D16:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D16S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D24:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D24S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.D32F:
        return gl.DEPTH_COMPONENT;

      case GFXFormat.D32F_S8:
        return gl.DEPTH_STENCIL;

      case GFXFormat.BC1:
        return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_ALPHA:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

      case GFXFormat.BC1_SRGB_ALPHA:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

      case GFXFormat.BC2:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

      case GFXFormat.BC2_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

      case GFXFormat.BC3:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

      case GFXFormat.BC3_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

      case GFXFormat.ETC_RGB8:
        return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

      case GFXFormat.PVRTC_RGB2:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA2:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

      case GFXFormat.PVRTC_RGB4:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

      case GFXFormat.PVRTC_RGBA4:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

      default:
        return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
        gl.RGBA;
    }
}

function GFXTypeToWebGLType$1(type, gl) {
    switch (type) {
      case GFXType.BOOL:
        return gl.BOOL;

      case GFXType.BOOL2:
        return gl.BOOL_VEC2;

      case GFXType.BOOL3:
        return gl.BOOL_VEC3;

      case GFXType.BOOL4:
        return gl.BOOL_VEC4;

      case GFXType.INT:
        return gl.INT;

      case GFXType.INT2:
        return gl.INT_VEC2;

      case GFXType.INT3:
        return gl.INT_VEC3;

      case GFXType.INT4:
        return gl.INT_VEC4;

      case GFXType.UINT:
        return gl.UNSIGNED_INT;

      case GFXType.FLOAT:
        return gl.FLOAT;

      case GFXType.FLOAT2:
        return gl.FLOAT_VEC2;

      case GFXType.FLOAT3:
        return gl.FLOAT_VEC3;

      case GFXType.FLOAT4:
        return gl.FLOAT_VEC4;

      case GFXType.MAT2:
        return gl.FLOAT_MAT2;

      case GFXType.MAT2X3:
        return gl.FLOAT_MAT2x3;

      case GFXType.MAT2X4:
        return gl.FLOAT_MAT2x4;

      case GFXType.MAT3X2:
        return gl.FLOAT_MAT3x2;

      case GFXType.MAT3:
        return gl.FLOAT_MAT3;

      case GFXType.MAT3X4:
        return gl.FLOAT_MAT3x4;

      case GFXType.MAT4X2:
        return gl.FLOAT_MAT4x2;

      case GFXType.MAT4X3:
        return gl.FLOAT_MAT4x3;

      case GFXType.MAT4:
        return gl.FLOAT_MAT4;

      case GFXType.SAMPLER2D:
        return gl.SAMPLER_2D;

      case GFXType.SAMPLER2D_ARRAY:
        return gl.SAMPLER_2D_ARRAY;

      case GFXType.SAMPLER3D:
        return gl.SAMPLER_3D;

      case GFXType.SAMPLER_CUBE:
        return gl.SAMPLER_CUBE;

      default:
        return console.error("Unsupported GLType, convert to GL type failed."), GFXType.UNKNOWN;
    }
}

function WebGLTypeToGFXType$1(glType, gl) {
    switch (glType) {
      case gl.BOOL:
        return GFXType.BOOL;

      case gl.BOOL_VEC2:
        return GFXType.BOOL2;

      case gl.BOOL_VEC3:
        return GFXType.BOOL3;

      case gl.BOOL_VEC4:
        return GFXType.BOOL4;

      case gl.INT:
        return GFXType.INT;

      case gl.INT_VEC2:
        return GFXType.INT2;

      case gl.INT_VEC3:
        return GFXType.INT3;

      case gl.INT_VEC4:
        return GFXType.INT4;

      case gl.UNSIGNED_INT:
        return GFXType.UINT;

      case gl.UNSIGNED_INT_VEC2:
        return GFXType.UINT2;

      case gl.UNSIGNED_INT_VEC3:
        return GFXType.UINT3;

      case gl.UNSIGNED_INT_VEC4:
        return GFXType.UINT4;

      case gl.UNSIGNED_INT:
        return GFXType.UINT;

      case gl.FLOAT:
        return GFXType.FLOAT;

      case gl.FLOAT_VEC2:
        return GFXType.FLOAT2;

      case gl.FLOAT_VEC3:
        return GFXType.FLOAT3;

      case gl.FLOAT_VEC4:
        return GFXType.FLOAT4;

      case gl.FLOAT_MAT2:
        return GFXType.MAT2;

      case gl.FLOAT_MAT2x3:
        return GFXType.MAT2X3;

      case gl.FLOAT_MAT2x4:
        return GFXType.MAT2X4;

      case gl.FLOAT_MAT3x2:
        return GFXType.MAT3X2;

      case gl.FLOAT_MAT3:
        return GFXType.MAT3;

      case gl.FLOAT_MAT3x4:
        return GFXType.MAT3X4;

      case gl.FLOAT_MAT4x2:
        return GFXType.MAT4X2;

      case gl.FLOAT_MAT4x3:
        return GFXType.MAT4X3;

      case gl.FLOAT_MAT4:
        return GFXType.MAT4;

      case gl.SAMPLER_2D:
        return GFXType.SAMPLER2D;

      case gl.SAMPLER_2D_ARRAY:
        return GFXType.SAMPLER2D_ARRAY;

      case gl.SAMPLER_3D:
        return GFXType.SAMPLER3D;

      case gl.SAMPLER_CUBE:
        return GFXType.SAMPLER_CUBE;

      default:
        return console.error("Unsupported GLType, convert to GFXType failed."), GFXType.UNKNOWN;
    }
}

function WebGLGetTypeSize$1(glType, gl) {
    switch (glType) {
      case gl.BOOL:
        return 4;

      case gl.BOOL_VEC2:
        return 8;

      case gl.BOOL_VEC3:
        return 12;

      case gl.BOOL_VEC4:
        return 16;

      case gl.INT:
        return 4;

      case gl.INT_VEC2:
        return 8;

      case gl.INT_VEC3:
        return 12;

      case gl.INT_VEC4:
        return 16;

      case gl.UNSIGNED_INT:
        return 4;

      case gl.UNSIGNED_INT_VEC2:
        return 8;

      case gl.UNSIGNED_INT_VEC3:
        return 12;

      case gl.UNSIGNED_INT_VEC4:
        return 16;

      case gl.FLOAT:
        return 4;

      case gl.FLOAT_VEC2:
        return 8;

      case gl.FLOAT_VEC3:
        return 12;

      case gl.FLOAT_VEC4:
      case gl.FLOAT_MAT2:
        return 16;

      case gl.FLOAT_MAT2x3:
        return 24;

      case gl.FLOAT_MAT2x4:
        return 32;

      case gl.FLOAT_MAT3x2:
        return 24;

      case gl.FLOAT_MAT3:
        return 36;

      case gl.FLOAT_MAT3x4:
        return 48;

      case gl.FLOAT_MAT4x2:
        return 32;

      case gl.FLOAT_MAT4x3:
        return 48;

      case gl.FLOAT_MAT4:
        return 64;

      case gl.SAMPLER_2D:
      case gl.SAMPLER_2D_ARRAY:
      case gl.SAMPLER_2D_ARRAY_SHADOW:
      case gl.SAMPLER_3D:
      case gl.SAMPLER_CUBE:
      case gl.INT_SAMPLER_2D:
      case gl.INT_SAMPLER_2D_ARRAY:
      case gl.INT_SAMPLER_3D:
      case gl.INT_SAMPLER_CUBE:
      case gl.UNSIGNED_INT_SAMPLER_2D:
      case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
      case gl.UNSIGNED_INT_SAMPLER_3D:
      case gl.UNSIGNED_INT_SAMPLER_CUBE:
        return 4;

      default:
        return console.error("Unsupported GLType, get type failed."), 0;
    }
}

function WebGLGetComponentCount$1(glType, gl) {
    switch (glType) {
      case gl.FLOAT_MAT2:
      case gl.FLOAT_MAT2x3:
      case gl.FLOAT_MAT2x4:
        return 2;

      case gl.FLOAT_MAT3x2:
      case gl.FLOAT_MAT3:
      case gl.FLOAT_MAT3x4:
        return 3;

      case gl.FLOAT_MAT4x2:
      case gl.FLOAT_MAT4x3:
      case gl.FLOAT_MAT4:
        return 4;

      default:
        return 1;
    }
}

var WebGL2Cmd, WebGLCmpFuncs$1 = [ 512, 513, 514, 515, 516, 517, 518, 519 ], WebGLStencilOps$1 = [ 0, 7680, 7681, 7682, 7683, 5386, 34055, 34056 ], WebGLBlendOps$1 = [ 32774, 32778, 32779, 32774, 32774 ], WebGLBlendFactors$1 = [ 0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772 ];

!function(WebGL2Cmd) {
    WebGL2Cmd[WebGL2Cmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGL2Cmd[WebGL2Cmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
    WebGL2Cmd[WebGL2Cmd.BIND_STATES = 2] = "BIND_STATES", WebGL2Cmd[WebGL2Cmd.DRAW = 3] = "DRAW", 
    WebGL2Cmd[WebGL2Cmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGL2Cmd[WebGL2Cmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
    WebGL2Cmd[WebGL2Cmd.COUNT = 6] = "COUNT";
}(WebGL2Cmd || (WebGL2Cmd = {}));

var WebGL2CmdObject = function WebGL2CmdObject(type) {
    _classCallCheck(this, WebGL2CmdObject), this.cmdType = void 0, this.refCount = 0, 
    this.cmdType = type;
}, WebGL2CmdBeginRenderPass = function(_WebGL2CmdObject) {
    function WebGL2CmdBeginRenderPass() {
        var _this;
        return _classCallCheck(this, WebGL2CmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdBeginRenderPass).call(this, WebGL2Cmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
        _this.renderArea = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }, _this.clearFlag = GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
        _this.clearStencil = 0, _this;
    }
    return _inherits(WebGL2CmdBeginRenderPass, WebGL2CmdObject), _createClass(WebGL2CmdBeginRenderPass, [ {
        key: "clear",
        value: function clear() {
            this.gpuFramebuffer = null, this.clearColors = [];
        }
    } ]), WebGL2CmdBeginRenderPass;
}(), WebGL2CmdBindStates = function(_WebGL2CmdObject2) {
    function WebGL2CmdBindStates() {
        var _this2;
        return _classCallCheck(this, WebGL2CmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdBindStates).call(this, WebGL2Cmd.BIND_STATES))).gpuPipelineState = null, 
        _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
        _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
        _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
        _this2;
    }
    return _inherits(WebGL2CmdBindStates, WebGL2CmdObject), _createClass(WebGL2CmdBindStates, [ {
        key: "clear",
        value: function clear() {
            this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
            this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
            this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
            this.stencilCompareMask = null;
        }
    } ]), WebGL2CmdBindStates;
}(), WebGL2CmdDraw = function(_WebGL2CmdObject3) {
    function WebGL2CmdDraw() {
        var _this3;
        return _classCallCheck(this, WebGL2CmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdDraw).call(this, WebGL2Cmd.DRAW))).drawInfo = {
            vertexCount: 0,
            firstVertex: 0,
            indexCount: 0,
            firstIndex: 0,
            vertexOffset: 0,
            instanceCount: 0,
            firstInstance: 0
        }, _this3;
    }
    return _inherits(WebGL2CmdDraw, WebGL2CmdObject), _createClass(WebGL2CmdDraw, [ {
        key: "clear",
        value: function clear() {}
    } ]), WebGL2CmdDraw;
}(), WebGL2CmdUpdateBuffer = function(_WebGL2CmdObject4) {
    function WebGL2CmdUpdateBuffer() {
        var _this4;
        return _classCallCheck(this, WebGL2CmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdUpdateBuffer).call(this, WebGL2Cmd.UPDATE_BUFFER))).gpuBuffer = null, 
        _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
    }
    return _inherits(WebGL2CmdUpdateBuffer, WebGL2CmdObject), _createClass(WebGL2CmdUpdateBuffer, [ {
        key: "clear",
        value: function clear() {
            this.gpuBuffer = null, this.buffer = null;
        }
    } ]), WebGL2CmdUpdateBuffer;
}(), WebGL2CmdCopyBufferToTexture = function(_WebGL2CmdObject5) {
    function WebGL2CmdCopyBufferToTexture() {
        var _this5;
        return _classCallCheck(this, WebGL2CmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2CmdCopyBufferToTexture).call(this, WebGL2Cmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
        _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
    }
    return _inherits(WebGL2CmdCopyBufferToTexture, WebGL2CmdObject), _createClass(WebGL2CmdCopyBufferToTexture, [ {
        key: "clear",
        value: function clear() {
            this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions = [];
        }
    } ]), WebGL2CmdCopyBufferToTexture;
}(), WebGL2CmdPackage = function() {
    function WebGL2CmdPackage() {
        _classCallCheck(this, WebGL2CmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
        this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
        this.copyBufferToTextureCmds = new CachedArray(1);
    }
    return _createClass(WebGL2CmdPackage, [ {
        key: "clearCmds",
        value: function clearCmds(allocator) {
            this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
            this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
            this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
            this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
            this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
            this.copyBufferToTextureCmds.clear()), this.cmds.clear();
        }
    } ]), WebGL2CmdPackage;
}();

function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
    if (gpuBuffer.usage & GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
        var buff = buffer, gl = device.gl, cache = device.stateCache;
        switch (gpuBuffer.glTarget) {
          case gl.ARRAY_BUFFER:
            cache.glVAO && (gl.bindVertexArray(null), cache.glVAO = null), cache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
            cache.glArrayBuffer = gpuBuffer.glBuffer), size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
            break;

          case gl.ELEMENT_ARRAY_BUFFER:
            cache.glVAO && (gl.bindVertexArray(null), cache.glVAO = null), cache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
            cache.glElementArrayBuffer = gpuBuffer.glBuffer), size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
            break;

          case gl.UNIFORM_BUFFER:
            var buf;
            cache.glUniformBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
            cache.glUniformBuffer = gpuBuffer.glBuffer), size === (buf = buffer instanceof Float32Array ? buffer : new Float32Array(buffer, 0, size / 4)).byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buf) : gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
            break;

          default:
            return void console.error("Unsupported GFXBufferType, update buffer failed.");
        }
    }
}

var cmdIds$1 = new Array(WebGL2Cmd.COUNT);

function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
    for (var gl = device.gl, cache = device.stateCache, i = 0; i < WebGL2Cmd.COUNT; ++i) cmdIds$1[i] = 0;
    for (var gpuPipelineState = null, gpuShader = null, isShaderChanged = !1, gpuInputAssembler = null, glPrimitive = gl.TRIANGLES, _i17 = 0; _i17 < cmdPackage.cmds.length; ++_i17) {
        var cmd = cmdPackage.cmds.array[_i17], cmdId = cmdIds$1[cmd]++;
        switch (cmd) {
          case WebGL2Cmd.BEGIN_RENDER_PASS:
            var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId], clears = 0;
            if (cmd0.gpuFramebuffer) {
                cache.glFramebuffer !== cmd0.gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, cmd0.gpuFramebuffer.glFramebuffer), 
                cache.glFramebuffer = cmd0.gpuFramebuffer.glFramebuffer), cache.viewport.left === cmd0.renderArea.x && cache.viewport.top === cmd0.renderArea.y && cache.viewport.width === cmd0.renderArea.width && cache.viewport.height === cmd0.renderArea.height || (gl.viewport(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                cache.viewport.left = cmd0.renderArea.x, cache.viewport.top = cmd0.renderArea.y, 
                cache.viewport.width = cmd0.renderArea.width, cache.viewport.height = cmd0.renderArea.height), 
                cache.scissorRect.x === cmd0.renderArea.x && cache.scissorRect.y === cmd0.renderArea.y && cache.scissorRect.width === cmd0.renderArea.width && cache.scissorRect.height === cmd0.renderArea.height || (gl.scissor(cmd0.renderArea.x, cmd0.renderArea.y, cmd0.renderArea.width, cmd0.renderArea.height), 
                cache.scissorRect.x = cmd0.renderArea.x, cache.scissorRect.y = cmd0.renderArea.y, 
                cache.scissorRect.width = cmd0.renderArea.width, cache.scissorRect.height = cmd0.renderArea.height);
                for (var curGPURenderPass = cmd0.gpuFramebuffer.gpuRenderPass, invalidateAttachments = [], j = 0; j < cmd0.clearColors.length; ++j) {
                    var colorAttachment = curGPURenderPass.colorAttachments[j];
                    if (colorAttachment.format !== GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
                      case GFXLoadOp.LOAD:
                        break;

                      case GFXLoadOp.CLEAR:
                        if (cmd0.clearFlag & GFXClearFlag.COLOR) if (cache.bs.targets[0].blendColorMask !== GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0), 
                        cmd0.gpuFramebuffer.isOffscreen) _f32v4[0] = cmd0.clearColors[j].r, _f32v4[1] = cmd0.clearColors[j].g, 
                        _f32v4[2] = cmd0.clearColors[j].b, _f32v4[3] = cmd0.clearColors[j].a, gl.clearBufferfv(gl.COLOR, j, _f32v4); else {
                            var clearColor = cmd0.clearColors[0];
                            gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= gl.COLOR_BUFFER_BIT;
                        }
                        break;

                      case GFXLoadOp.DISCARD:
                        invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                    }
                }
                if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== GFXFormat.UNKNOWN) {
                    switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
                      case GFXLoadOp.LOAD:
                        break;

                      case GFXLoadOp.CLEAR:
                        cmd0.clearFlag & GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                        gl.clearDepth(cmd0.clearDepth), clears |= gl.DEPTH_BUFFER_BIT);
                        break;

                      case GFXLoadOp.DISCARD:
                        invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                    }
                    if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
                      case GFXLoadOp.LOAD:
                        break;

                      case GFXLoadOp.CLEAR:
                        cmd0.clearFlag & GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
                        cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.clearStencil(cmd0.clearStencil), 
                        clears |= gl.STENCIL_BUFFER_BIT);
                        break;

                      case GFXLoadOp.DISCARD:
                        invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                    }
                }
                if (invalidateAttachments.length && gl.invalidateFramebuffer(gl.FRAMEBUFFER, invalidateAttachments), 
                clears && gl.clear(clears), clears & gl.COLOR_BUFFER_BIT) {
                    var colorMask = cache.bs.targets[0].blendColorMask;
                    if (colorMask !== GFXColorMask.ALL) {
                        var r = (colorMask & GFXColorMask.R) !== GFXColorMask.NONE, g = (colorMask & GFXColorMask.G) !== GFXColorMask.NONE, b = (colorMask & GFXColorMask.B) !== GFXColorMask.NONE, a = (colorMask & GFXColorMask.A) !== GFXColorMask.NONE;
                        gl.colorMask(r, g, b, a);
                    }
                }
                clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), clears & gl.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 0), 
                cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 0));
            }
            break;

          case WebGL2Cmd.END_RENDER_PASS:
            break;

          case WebGL2Cmd.BIND_STATES:
            var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
            if (isShaderChanged = !1, cmd2.gpuPipelineState) {
                if (gpuPipelineState = cmd2.gpuPipelineState, glPrimitive = cmd2.gpuPipelineState.glPrimitive, 
                cmd2.gpuPipelineState.gpuShader) {
                    var glProgram = cmd2.gpuPipelineState.gpuShader.glProgram;
                    cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram, 
                    isShaderChanged = !0), gpuShader = cmd2.gpuPipelineState.gpuShader;
                }
                var rs = cmd2.gpuPipelineState.rs;
                if (rs) {
                    if (cache.rs.cullMode !== rs.cullMode) {
                        switch (rs.cullMode) {
                          case GFXCullMode.NONE:
                            gl.disable(gl.CULL_FACE);
                            break;

                          case GFXCullMode.FRONT:
                            gl.enable(gl.CULL_FACE), gl.cullFace(gl.FRONT);
                            break;

                          case GFXCullMode.BACK:
                            gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK);
                        }
                        device.stateCache.rs.cullMode = rs.cullMode;
                    }
                    device.stateCache.rs.isFrontFaceCCW !== rs.isFrontFaceCCW && (gl.frontFace(rs.isFrontFaceCCW ? gl.CCW : gl.CW), 
                    device.stateCache.rs.isFrontFaceCCW = rs.isFrontFaceCCW), device.stateCache.rs.depthBias === rs.depthBias && device.stateCache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
                    device.stateCache.rs.depthBias = rs.depthBias, device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop), 
                    device.stateCache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
                    device.stateCache.rs.lineWidth = rs.lineWidth);
                }
                var dss = cmd2.gpuPipelineState.dss;
                dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), 
                cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
                cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]), 
                cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST), 
                cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
                cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
                cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
                cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]), 
                cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
                cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront), 
                cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
                cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
                cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]), 
                cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
                cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack), 
                cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
                var bs = cmd2.gpuPipelineState.bs;
                if (bs) {
                    cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
                    cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
                    cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
                    cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
                    var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
                    target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND), 
                    target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]), 
                    target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
                    target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]), 
                    target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
                    target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & GFXColorMask.R) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.G) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.B) !== GFXColorMask.NONE, (target0.blendColorMask & GFXColorMask.A) !== GFXColorMask.NONE), 
                    target0Cache.blendColorMask = target0.blendColorMask);
                }
            }
            if (cmd2.gpuBindingLayout && gpuShader) {
                var _iterator8 = cmd2.gpuBindingLayout.gpuBindings, _isArray8 = Array.isArray(_iterator8), _i18 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i18 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i18++];
                    } else {
                        if ((_i18 = _iterator8.next()).done) break;
                        _ref8 = _i18.value;
                    }
                    var gpuBinding = _ref8;
                    switch (gpuBinding.type) {
                      case GFXBindingType.UNIFORM_BUFFER:
                        if (gpuBinding.gpuBuffer) {
                            var _iterator9 = gpuShader.glBlocks, _isArray9 = Array.isArray(_iterator9), _i19 = 0;
                            for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray9) {
                                    if (_i19 >= _iterator9.length) break;
                                    _ref9 = _iterator9[_i19++];
                                } else {
                                    if ((_i19 = _iterator9.next()).done) break;
                                    _ref9 = _i19.value;
                                }
                                var glBlock = _ref9;
                                if (glBlock.binding === gpuBinding.binding) {
                                    cache.glBindUBOs[glBlock.binding] !== gpuBinding.gpuBuffer.glBuffer && (gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.binding, gpuBinding.gpuBuffer.glBuffer), 
                                    cache.glBindUBOs[glBlock.binding] = gpuBinding.gpuBuffer.glBuffer, cache.glUniformBuffer = gpuBinding.gpuBuffer.glBuffer);
                                    break;
                                }
                            }
                        }
                        break;

                      case GFXBindingType.SAMPLER:
                        if (gpuBinding.gpuSampler) {
                            var glSampler = null, _iterator10 = gpuShader.glSamplers, _isArray10 = Array.isArray(_iterator10), _i20 = 0;
                            for (_iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator](); ;) {
                                var _ref10;
                                if (_isArray10) {
                                    if (_i20 >= _iterator10.length) break;
                                    _ref10 = _iterator10[_i20++];
                                } else {
                                    if ((_i20 = _iterator10.next()).done) break;
                                    _ref10 = _i20.value;
                                }
                                var sampler = _ref10;
                                if (sampler.binding === gpuBinding.binding) {
                                    glSampler = sampler;
                                    break;
                                }
                            }
                            if (glSampler) {
                                var _iterator11 = glSampler.units, _isArray11 = Array.isArray(_iterator11), _i21 = 0;
                                for (_iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator](); ;) {
                                    var _ref11;
                                    if (_isArray11) {
                                        if (_i21 >= _iterator11.length) break;
                                        _ref11 = _iterator11[_i21++];
                                    } else {
                                        if ((_i21 = _iterator11.next()).done) break;
                                        _ref11 = _i21.value;
                                    }
                                    var texUnit = _ref11, glTexUnit = null;
                                    if (gpuBinding.gpuTexView && gpuBinding.gpuTexView.gpuTexture.size > 0) {
                                        cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), cache.texUnit = texUnit);
                                        var gpuTexture = gpuBinding.gpuTexView.gpuTexture;
                                        switch (glSampler.glType) {
                                          case gl.SAMPLER_2D:
                                            (glTexUnit = cache.glTex2DUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_2D, device.nullTex2D.gpuTexture.glTexture), 
                                            glTexUnit.glTexture = gpuTexture.glTexture);
                                            break;

                                          case gl.SAMPLER_CUBE:
                                            (glTexUnit = cache.glTexCubeUnits[texUnit]).glTexture !== gpuTexture.glTexture && (gpuTexture.glTexture ? gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture) : gl.bindTexture(gl.TEXTURE_CUBE_MAP, device.nullTexCube.gpuTexture.glTexture), 
                                            glTexUnit.glTexture = gpuTexture.glTexture);
                                            break;

                                          default:
                                            console.error("Unsupported GL Texture type.");
                                        }
                                        var gpuSampler = gpuBinding.gpuSampler;
                                        cache.glSamplerUnits[texUnit] !== gpuSampler.glSampler && (gl.bindSampler(texUnit, gpuSampler.glSampler), 
                                        cache.glSamplerUnits[texUnit] = gpuSampler.glSampler);
                                    }
                                }
                            }
                        } else console.error("Not found sampler on binding unit " + gpuBinding.binding);
                    }
                }
            }
            if (cmd2.gpuInputAssembler && gpuShader && (isShaderChanged || gpuInputAssembler !== cmd2.gpuInputAssembler)) if (gpuInputAssembler = cmd2.gpuInputAssembler, 
            device.useVAO) {
                var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                if (!glVAO) {
                    glVAO = gl.createVertexArray(), gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO), 
                    gl.bindVertexArray(glVAO), gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    var glAttrib = void 0, _iterator12 = gpuShader.glInputs, _isArray12 = Array.isArray(_iterator12), _i22 = 0;
                    for (_iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator](); ;) {
                        var _ref12;
                        if (_isArray12) {
                            if (_i22 >= _iterator12.length) break;
                            _ref12 = _iterator12[_i22++];
                        } else {
                            if ((_i22 = _iterator12.next()).done) break;
                            _ref12 = _i22.value;
                        }
                        var glInput = _ref12;
                        glAttrib = null;
                        var _iterator13 = gpuInputAssembler.glAttribs, _isArray13 = Array.isArray(_iterator13), _i23 = 0;
                        for (_iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator](); ;) {
                            var _ref13;
                            if (_isArray13) {
                                if (_i23 >= _iterator13.length) break;
                                _ref13 = _iterator13[_i23++];
                            } else {
                                if ((_i23 = _iterator13.next()).done) break;
                                _ref13 = _i23.value;
                            }
                            var attrib = _ref13;
                            if (attrib.name === glInput.name) {
                                glAttrib = attrib;
                                break;
                            }
                        }
                        if (glAttrib) {
                            gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                            for (var c = 0; c < glAttrib.componentCount; ++c) {
                                var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                                gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset), 
                                gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                            }
                        }
                    }
                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    gpuBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), gl.bindVertexArray(null), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                    cache.glArrayBuffer = null, cache.glElementArrayBuffer = null;
                }
                cache.glVAO !== glVAO && (gl.bindVertexArray(glVAO), cache.glVAO = glVAO);
            } else {
                for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glCurrentAttribLocs[_a] = !1;
                var _iterator14 = gpuShader.glInputs, _isArray14 = Array.isArray(_iterator14), _i24 = 0;
                for (_iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator](); ;) {
                    var _ref14;
                    if (_isArray14) {
                        if (_i24 >= _iterator14.length) break;
                        _ref14 = _iterator14[_i24++];
                    } else {
                        if ((_i24 = _iterator14.next()).done) break;
                        _ref14 = _i24.value;
                    }
                    var _glInput = _ref14, _glAttrib = null, _iterator15 = gpuInputAssembler.glAttribs, _isArray15 = Array.isArray(_iterator15), _i25 = 0;
                    for (_iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator](); ;) {
                        var _ref15;
                        if (_isArray15) {
                            if (_i25 >= _iterator15.length) break;
                            _ref15 = _iterator15[_i25++];
                        } else {
                            if ((_i25 = _iterator15.next()).done) break;
                            _ref15 = _i25.value;
                        }
                        var _attrib = _ref15;
                        if (_attrib.name === _glInput.name) {
                            _glAttrib = _attrib;
                            break;
                        }
                    }
                    if (_glAttrib) {
                        cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer), 
                        cache.glArrayBuffer = _glAttrib.glBuffer);
                        for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                            var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                            !cache.glEnabledAttribLocs[_glLoc2] && _glLoc2 >= 0 && (gl.enableVertexAttribArray(_glLoc2), 
                            cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                            gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                        }
                    }
                }
                var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
                cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
                for (var _a2 = 0; _a2 < device.maxVertexAttributes; ++_a2) cache.glEnabledAttribLocs[_a2] !== cache.glCurrentAttribLocs[_a2] && (gl.disableVertexAttribArray(_a2), 
                cache.glEnabledAttribLocs[_a2] = !1);
            }
            if (gpuPipelineState) {
                var _iterator16 = gpuPipelineState.dynamicStates, _isArray16 = Array.isArray(_iterator16), _i26 = 0;
                for (_iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator](); ;) {
                    var _ref16;
                    if (_isArray16) {
                        if (_i26 >= _iterator16.length) break;
                        _ref16 = _iterator16[_i26++];
                    } else {
                        if ((_i26 = _iterator16.next()).done) break;
                        _ref16 = _i26.value;
                    }
                    switch (_ref16) {
                      case GFXDynamicState.VIEWPORT:
                        cmd2.viewport && (cache.viewport.left === cmd2.viewport.left && cache.viewport.top === cmd2.viewport.top && cache.viewport.width === cmd2.viewport.width && cache.viewport.height === cmd2.viewport.height || (gl.viewport(cmd2.viewport.left, cmd2.viewport.top, cmd2.viewport.width, cmd2.viewport.height), 
                        cache.viewport.left = cmd2.viewport.left, cache.viewport.top = cmd2.viewport.top, 
                        cache.viewport.width = cmd2.viewport.width, cache.viewport.height = cmd2.viewport.height));
                        break;

                      case GFXDynamicState.SCISSOR:
                        cmd2.scissor && (cache.scissorRect.x === cmd2.scissor.x && cache.scissorRect.y === cmd2.scissor.y && cache.scissorRect.width === cmd2.scissor.width && cache.scissorRect.height === cmd2.scissor.height || (gl.scissor(cmd2.scissor.x, cmd2.scissor.y, cmd2.scissor.width, cmd2.scissor.height), 
                        cache.scissorRect.x = cmd2.scissor.x, cache.scissorRect.y = cmd2.scissor.y, cache.scissorRect.width = cmd2.scissor.width, 
                        cache.scissorRect.height = cmd2.scissor.height));
                        break;

                      case GFXDynamicState.LINE_WIDTH:
                        cmd2.lineWidth && cache.rs.lineWidth !== cmd2.lineWidth && (gl.lineWidth(cmd2.lineWidth), 
                        cache.rs.lineWidth = cmd2.lineWidth);
                        break;

                      case GFXDynamicState.DEPTH_BIAS:
                        cmd2.depthBias && (cache.rs.depthBias === cmd2.depthBias.constantFactor && cache.rs.depthBiasSlop === cmd2.depthBias.slopeFactor || (gl.polygonOffset(cmd2.depthBias.constantFactor, cmd2.depthBias.slopeFactor), 
                        cache.rs.depthBias = cmd2.depthBias.constantFactor, cache.rs.depthBiasSlop = cmd2.depthBias.slopeFactor));
                        break;

                      case GFXDynamicState.BLEND_CONSTANTS:
                        cmd2.blendConstants && (cache.bs.blendColor[0] === cmd2.blendConstants[0] && cache.bs.blendColor[1] === cmd2.blendConstants[1] && cache.bs.blendColor[2] === cmd2.blendConstants[2] && cache.bs.blendColor[3] === cmd2.blendConstants[3] || (gl.blendColor(cmd2.blendConstants[0], cmd2.blendConstants[1], cmd2.blendConstants[2], cmd2.blendConstants[3]), 
                        cache.bs.blendColor[0] = cmd2.blendConstants[0], cache.bs.blendColor[1] = cmd2.blendConstants[1], 
                        cache.bs.blendColor[2] = cmd2.blendConstants[2], cache.bs.blendColor[3] = cmd2.blendConstants[3]));
                        break;

                      case GFXDynamicState.STENCIL_WRITE_MASK:
                        if (cmd2.stencilWriteMask) switch (cmd2.stencilWriteMask.face) {
                          case GFXStencilFace.FRONT:
                            cache.dss.stencilWriteMaskFront !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.FRONT, cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask);
                            break;

                          case GFXStencilFace.BACK:
                            cache.dss.stencilWriteMaskBack !== cmd2.stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.BACK, cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                            break;

                          case GFXStencilFace.ALL:
                            cache.dss.stencilWriteMaskFront === cmd2.stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === cmd2.stencilWriteMask.writeMask || (gl.stencilMask(cmd2.stencilWriteMask.writeMask), 
                            cache.dss.stencilWriteMaskFront = cmd2.stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = cmd2.stencilWriteMask.writeMask);
                        }
                        break;

                      case GFXDynamicState.STENCIL_COMPARE_MASK:
                        if (cmd2.stencilCompareMask) switch (cmd2.stencilCompareMask.face) {
                          case GFXStencilFace.FRONT:
                            cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask);
                            break;

                          case GFXStencilFace.BACK:
                            cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                            break;

                          case GFXStencilFace.ALL:
                            cache.dss.stencilRefFront === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskFront === cmd2.stencilCompareMask.compareMask && cache.dss.stencilRefBack === cmd2.stencilCompareMask.reference && cache.dss.stencilReadMaskBack === cmd2.stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs$1[cache.dss.stencilFuncBack], cmd2.stencilCompareMask.reference, cmd2.stencilCompareMask.compareMask), 
                            cache.dss.stencilRefFront = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskFront = cmd2.stencilCompareMask.compareMask, 
                            cache.dss.stencilRefBack = cmd2.stencilCompareMask.reference, cache.dss.stencilReadMaskBack = cmd2.stencilCompareMask.compareMask);
                        }
                    }
                }
            }
            break;

          case WebGL2Cmd.DRAW:
            var cmd3 = cmdPackage.drawCmds.array[cmdId];
            if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) {
                if (gpuInputAssembler.gpuIndirectBuffer) {
                    var _iterator17 = gpuInputAssembler.gpuIndirectBuffer.indirects, _isArray17 = Array.isArray(_iterator17), _i27 = 0;
                    for (_iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator](); ;) {
                        var _ref17;
                        if (_isArray17) {
                            if (_i27 >= _iterator17.length) break;
                            _ref17 = _iterator17[_i27++];
                        } else {
                            if ((_i27 = _iterator17.next()).done) break;
                            _ref17 = _i27.value;
                        }
                        var drawInfo = _ref17, _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                        if (_gpuBuffer2 && drawInfo.indexCount > -1) {
                            var _offset = drawInfo.firstIndex * _gpuBuffer2.stride;
                            gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                        } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                    }
                }
            } else if (gpuInputAssembler.gpuIndexBuffer && cmd3.drawInfo.indexCount > -1) {
                var offset = cmd3.drawInfo.firstIndex * gpuInputAssembler.gpuIndexBuffer.stride;
                gl.drawElements(glPrimitive, cmd3.drawInfo.indexCount, gpuInputAssembler.glIndexType, offset);
            } else gl.drawArrays(glPrimitive, cmd3.drawInfo.firstVertex, cmd3.drawInfo.vertexCount);
            break;

          case WebGL2Cmd.UPDATE_BUFFER:
            var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
            WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
            break;

          case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
            var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
            WebGL2CmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
        }
    }
}

function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
    var gl = device.gl, m = 0, n = 0, w = 1, h = 1, f = 0, fmtInfo = GFXFormatInfos[gpuTexture.format], isCompressed = fmtInfo.isCompressed;
    switch (gpuTexture.glTarget) {
      case gl.TEXTURE_2D:
        var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
        glTexUnit.glTexture = gpuTexture.glTexture);
        var _iterator20 = regions, _isArray20 = Array.isArray(_iterator20), _i30 = 0;
        for (_iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator](); ;) {
            var _ref20;
            if (_isArray20) {
                if (_i30 >= _iterator20.length) break;
                _ref20 = _iterator20[_i30++];
            } else {
                if ((_i30 = _iterator20.next()).done) break;
                _ref20 = _i30.value;
            }
            var region = _ref20;
            for (w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                var pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternelFmt, w, h, 0, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
            }
        }
        break;

      case gl.TEXTURE_CUBE_MAP:
        var _glTexUnit4 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
        _glTexUnit4.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
        _glTexUnit4.glTexture = gpuTexture.glTexture);
        var _iterator21 = regions, _isArray21 = Array.isArray(_iterator21), _i31 = 0;
        for (_iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator](); ;) {
            var _ref21;
            if (_isArray21) {
                if (_i31 >= _iterator21.length) break;
                _ref21 = _iterator21[_i31++];
            } else {
                if ((_i31 = _iterator21.next()).done) break;
                _ref21 = _i31.value;
            }
            var _region2 = _ref21;
            n = 0;
            var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
            for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                w = _region2.texExtent.width, h = _region2.texExtent.height;
                var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                    var _pixels = fmtInfo.type !== GFXFormatType.FLOAT || isCompressed ? new Uint8Array(buffers[n++]) : new Float32Array(buffers[n++]);
                    isCompressed ? gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternelFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                    w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                }
            }
        }
        break;

      default:
        console.error("Unsupported GL texture type, copy buffer to texture failed.");
    }
    gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
}

var WebGL2GFXBuffer = function(_GFXBuffer) {
    function WebGL2GFXBuffer(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXBuffer).call(this, device)))._gpuBuffer = null, 
        _this._indirectBuffer = null, _this;
    }
    return _inherits(WebGL2GFXBuffer, GFXBuffer), _createClass(WebGL2GFXBuffer, [ {
        key: "gpuBuffer",
        get: function get() {
            return this._gpuBuffer;
        }
    } ]), _createClass(WebGL2GFXBuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
            this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
            this._usage & GFXBufferUsageBit.INDIRECT && (this._indirectBuffer = {
                drawInfos: []
            }), this._gpuBuffer = {
                usage: info.usage,
                memUsage: info.memUsage,
                size: info.size,
                stride: this._stride,
                buffer: null,
                vf32: null,
                indirects: [],
                glTarget: 0,
                glBuffer: null
            }, info.usage & GFXBufferUsageBit.INDIRECT && (this._gpuBuffer.indirects = this._indirectBuffer.drawInfos), 
            function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
                var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                if (gpuBuffer.usage & GFXBufferUsageBit.VERTEX) {
                    gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                    var glBuffer = gl.createBuffer();
                    glBuffer && (gpuBuffer.glBuffer = glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                    cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                } else if (gpuBuffer.usage & GFXBufferUsageBit.INDEX) {
                    gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                    var _glBuffer = gl.createBuffer();
                    _glBuffer && (gpuBuffer.glBuffer = _glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                } else if (gpuBuffer.usage & GFXBufferUsageBit.UNIFORM) {
                    gpuBuffer.glTarget = gl.UNIFORM_BUFFER;
                    var _glBuffer2 = gl.createBuffer();
                    _glBuffer2 && gpuBuffer.size > 0 && (gpuBuffer.glBuffer = _glBuffer2, device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glUniformBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.UNIFORM_BUFFER, null), device.stateCache.glUniformBuffer = null);
                } else gpuBuffer.usage & GFXBufferUsageBit.INDIRECT ? gpuBuffer.glTarget = gl.NONE : gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST ? gpuBuffer.glTarget = gl.NONE : gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC ? gpuBuffer.glTarget = gl.NONE : (console.error("Unsupported GFXBufferType, create buffer failed."), 
                gpuBuffer.glTarget = gl.NONE);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size, 
            this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuBuffer && (!function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
                gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size, 
            this._gpuBuffer = null), this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(size) {
            var oldSize = this._size;
            this._size = size, this._count = this._size / this._stride, this._gpuBuffer && (this._gpuBuffer.size = this._size, 
            this._size > 0 && (!function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
                var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                gpuBuffer.usage & GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                cache.glVAO = null), cache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(gl.ARRAY_BUFFER, null), 
                cache.glArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (gl.bindVertexArray(null), 
                cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.UNIFORM ? (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer), 
                gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage), gl.bindBuffer(gl.UNIFORM_BUFFER, null), 
                device.stateCache.glUniformBuffer = null) : gpuBuffer.usage & GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & GFXBufferUsageBit.TRANSFER_SRC ? gpuBuffer.glTarget = gl.NONE : (console.error("Unsupported GFXBufferType, create buffer failed."), 
                gpuBuffer.glTarget = gl.NONE);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= oldSize, 
            this._device.memoryStatus.bufferSize += this._size));
        }
    }, {
        key: "update",
        value: function update(buffer, offset, size) {
            var buffSize;
            buffSize = void 0 !== size ? size : this._usage & GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
            WebGL2CmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
        }
    } ]), WebGL2GFXBuffer;
}(), WebGL2GFXCommandPool = function() {
    function WebGL2GFXCommandPool(clazz, count) {
        _classCallCheck(this, WebGL2GFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
        this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
        for (var i = 0; i < count; ++i) this._frees[i] = new clazz();
        this._freeIdx = count - 1;
    }
    return _createClass(WebGL2GFXCommandPool, [ {
        key: "alloc",
        value: function alloc(clazz) {
            return new clazz();
        }
    }, {
        key: "free",
        value: function free(cmd) {
            0 == --cmd.refCount && this._freeCmds.push(cmd);
        }
    }, {
        key: "freeCmds",
        value: function freeCmds(cmds) {}
    }, {
        key: "release",
        value: function release() {
            for (var i = 0; i < this._freeCmds.length; ++i) {
                var cmd = this._freeCmds.array[i];
                cmd.clear(), this._frees[++this._freeIdx] = cmd;
            }
            this._freeCmds.clear();
        }
    } ]), WebGL2GFXCommandPool;
}(), WebGL2GFXCommandAllocator = function(_GFXCommandAllocator) {
    function WebGL2GFXCommandAllocator(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
        _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
        _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGL2GFXCommandPool(WebGL2CmdBeginRenderPass, 16), 
        _this.bindStatesCmdPool = new WebGL2GFXCommandPool(WebGL2CmdBindStates, 16), _this.drawCmdPool = new WebGL2GFXCommandPool(WebGL2CmdDraw, 16), 
        _this.updateBufferCmdPool = new WebGL2GFXCommandPool(WebGL2CmdUpdateBuffer, 16), 
        _this.copyBufferToTextureCmdPool = new WebGL2GFXCommandPool(WebGL2CmdCopyBufferToTexture, 16), 
        _this;
    }
    return _inherits(WebGL2GFXCommandAllocator, GFXCommandAllocator), _createClass(WebGL2GFXCommandAllocator, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "clearCmds",
        value: function clearCmds(cmdPackage) {
            cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
            cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
            cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
            cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
            cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
            cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
        }
    }, {
        key: "releaseCmds",
        value: function releaseCmds() {
            this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
            this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
        }
    } ]), WebGL2GFXCommandAllocator;
}(), WebGL2GFXCommandBuffer = function(_GFXCommandBuffer) {
    function WebGL2GFXCommandBuffer(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXCommandBuffer).call(this, device))).cmdPackage = new WebGL2CmdPackage(), 
        _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
        _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
        _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
        _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
        _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
    }
    return _inherits(WebGL2GFXCommandBuffer, GFXCommandBuffer), _createClass(WebGL2GFXCommandBuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            return !!info.allocator && (this._allocator = info.allocator, this._webGLAllocator = this._allocator, 
            this._type = info.type, this._status = GFXStatus.SUCCESS, !0);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._allocator = null, 
            this._webGLAllocator = null), this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "begin",
        value: function begin() {
            this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
            this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
            this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
            this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
            this._numDrawCalls = 0, this._numTris = 0;
        }
    }, {
        key: "end",
        value: function end() {
            this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
        }
    }, {
        key: "beginRenderPass",
        value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
            var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);
            cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag;
            for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
            cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
            this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
        }
    }, {
        key: "endRenderPass",
        value: function endRenderPass() {
            this._isInRenderPass = !1;
        }
    }, {
        key: "bindPipelineState",
        value: function bindPipelineState(pipelineState) {
            var gpuPipelineState = pipelineState.gpuPipelineState;
            this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
        }
    }, {
        key: "bindBindingLayout",
        value: function bindBindingLayout(bindingLayout) {
            var gpuBindingLayout = bindingLayout.gpuBindingLayout;
            this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
        }
    }, {
        key: "bindInputAssembler",
        value: function bindInputAssembler(inputAssembler) {
            var gpuInputAssembler = inputAssembler.gpuInputAssembler;
            this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
        }
    }, {
        key: "setViewport",
        value: function setViewport(viewport) {
            this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
            this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
            this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
            this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                left: viewport.left,
                top: viewport.top,
                width: viewport.width,
                height: viewport.height,
                minDepth: viewport.minDepth,
                maxDepth: viewport.maxDepth
            }, this._curViewport !== viewport && (this._curViewport = viewport, this._isStateInvalied = !0);
        }
    }, {
        key: "setScissor",
        value: function setScissor(scissor) {
            this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
            this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
            this._isStateInvalied = !0) : this._curScissor = {
                x: scissor.x,
                y: scissor.y,
                width: scissor.width,
                height: scissor.height
            };
        }
    }, {
        key: "setLineWidth",
        value: function setLineWidth(lineWidth) {
            this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
        }
    }, {
        key: "setDepthBias",
        value: function setDepthBias(depthBiasConstantFacotr, depthBiasClamp, depthBiasSlopeFactor) {
            this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFacotr && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFacotr, 
            this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
            this._isStateInvalied = !0) : (this._curDepthBias = {
                constantFactor: depthBiasConstantFacotr,
                clamp: depthBiasClamp,
                slopeFactor: depthBiasSlopeFactor
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setBlendConstants",
        value: function setBlendConstants(blendConstants) {
            (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
            this._isStateInvalied = !0);
        }
    }, {
        key: "setDepthBound",
        value: function setDepthBound(minDepthBounds, maxDepthBounds) {
            this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                minBounds: minDepthBounds,
                maxBounds: maxDepthBounds
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setStencilWriteMask",
        value: function setStencilWriteMask(face, writeMask) {
            this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
            this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                face: face,
                writeMask: writeMask
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setStencilCompareMask",
        value: function setStencilCompareMask(face, reference, compareMask) {
            this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
            this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
            this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                face: face,
                reference: reference,
                compareMask: compareMask
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "draw",
        value: function draw(inputAssembler) {
            if (this._type === GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                this._isStateInvalied && this.bindStates();
                var cmd = this._allocator.drawCmdPool.alloc(WebGL2CmdDraw);
                if (inputAssembler.extractCmdDraw(cmd), this.cmdPackage.drawCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.DRAW), 
                ++this._numDrawCalls, this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                  case WebGL2RenderingContext.TRIANGLES:
                    this._numTris += inputAssembler.indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                    break;

                  case WebGL2RenderingContext.TRIANGLE_STRIP:
                  case WebGL2RenderingContext.TRIANGLE_FAN:
                    this._numTris += (inputAssembler.indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                }
            } else console.error("Command 'draw' must be recorded inside a render pass.");
        }
    }, {
        key: "updateBuffer",
        value: function updateBuffer(buffer, data, offset, size) {
            if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                var gpuBuffer = buffer.gpuBuffer;
                if (gpuBuffer) {
                    var buffSize, cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);
                    buffSize = void 0 !== size ? size : buffer.usage & GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                    var buff = data;
                    cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                    cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
                }
            } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
        }
    }, {
        key: "copyBufferToTexture",
        value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
            if (this._type === GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === GFXCommandBufferType.SECONDARY) {
                var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                if (gpuBuffer && gpuTexture) {
                    var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);
                    cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                    cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                }
            } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
        }
    }, {
        key: "execute",
        value: function execute(cmdBuffs, count) {
            for (var i = 0; i < count; ++i) {
                for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                }
                for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                }
                for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                }
                for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                }
                for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                }
                this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                this._numTris += webGLCmdBuff._numTris;
            }
        }
    }, {
        key: "bindStates",
        value: function bindStates() {
            var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);
            bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
            bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
            bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
            bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
            bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
            bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
            this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES), this._isStateInvalied = !1;
        }
    }, {
        key: "webGLDevice",
        get: function get() {
            return this._device;
        }
    } ]), WebGL2GFXCommandBuffer;
}(), WebGL2GFXFramebuffer = function(_GFXFramebuffer) {
    function WebGL2GFXFramebuffer(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXFramebuffer).call(this, device)))._gpuFramebuffer = null, 
        _this;
    }
    return _inherits(WebGL2GFXFramebuffer, GFXFramebuffer), _createClass(WebGL2GFXFramebuffer, [ {
        key: "gpuFramebuffer",
        get: function get() {
            return this._gpuFramebuffer;
        }
    } ]), _createClass(WebGL2GFXFramebuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
            this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
            this._isOffscreen) {
                var gpuColorViews = [];
                if (void 0 !== info.colorViews) {
                    var _iterator = info.colorViews, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var colorView = _ref;
                        gpuColorViews.push(colorView.gpuTextureView);
                    }
                }
                var gpuDepthStencilView = null;
                info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                this._gpuFramebuffer = {
                    gpuRenderPass: info.renderPass.gpuRenderPass,
                    gpuColorViews: gpuColorViews,
                    gpuDepthStencilView: gpuDepthStencilView,
                    isOffscreen: this._isOffscreen,
                    glFramebuffer: null
                }, function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                    if (gpuFramebuffer.isOffscreen) {
                        var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                        if (glFramebuffer) {
                            gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                            device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                            for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                var cv = gpuFramebuffer.gpuColorViews[i];
                                cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                attachments.push(gl.COLOR_ATTACHMENT0 + i));
                            }
                            var dsv = gpuFramebuffer.gpuDepthStencilView;
                            if (dsv) {
                                var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                            }
                            gl.drawBuffers(attachments);
                            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                            if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                break;

                              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                break;

                              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                break;

                              case gl.FRAMEBUFFER_UNSUPPORTED:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                            }
                        }
                    }
                }(this._device, this._gpuFramebuffer);
            } else this._gpuFramebuffer = {
                gpuRenderPass: info.renderPass.gpuRenderPass,
                gpuColorViews: [],
                gpuDepthStencilView: null,
                isOffscreen: info.isOffscreen,
                glFramebuffer: null
            };
            return this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._isOffscreen && this._gpuFramebuffer && function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                gpuFramebuffer.glFramebuffer = null);
            }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXFramebuffer;
}(), WebGL2GFXInputAssembler = function(_GFXInputAssembler) {
    function WebGL2GFXInputAssembler(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXInputAssembler).call(this, device)))._gpuInputAssembler = null, 
        _this;
    }
    return _inherits(WebGL2GFXInputAssembler, GFXInputAssembler), _createClass(WebGL2GFXInputAssembler, [ {
        key: "gpuInputAssembler",
        get: function get() {
            return this._gpuInputAssembler;
        }
    } ]), _createClass(WebGL2GFXInputAssembler, [ {
        key: "initialize",
        value: function initialize(info) {
            if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
            !1;
            if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
            void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                var vertBuff = this._vertexBuffers[0];
                this._vertexCount = vertBuff.size / vertBuff.stride;
            }
            this._indirectBuffer = info.indirectBuffer || null;
            for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                var vb = info.vertexBuffers[i];
                vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
            }
            var gpuIndexBuffer = null, glIndexType = 0;
            if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
              case 1:
                glIndexType = 5121;
                break;

              case 2:
                glIndexType = 5123;
                break;

              case 4:
                glIndexType = 5125;
                break;

              default:
                console.error("Illegal index buffer stride.");
            }
            var gpuIndirectBuffer = null;
            return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
            this._gpuInputAssembler = {
                attributes: info.attributes,
                gpuVertexBuffers: gpuVertexBuffers,
                gpuIndexBuffer: gpuIndexBuffer,
                gpuIndirectBuffer: gpuIndirectBuffer,
                glAttribs: [],
                glIndexType: glIndexType,
                glVAOs: new Map()
            }, function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
                var gl = device.gl;
                gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                    var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType$1(attrib.format, gl), size = GFXFormatInfos[attrib.format].size;
                    gpuInputAssembler.glAttribs[i] = {
                        name: attrib.name,
                        glBuffer: gpuBuffer.glBuffer,
                        glType: glType,
                        size: size,
                        count: GFXFormatInfos[attrib.format].count,
                        stride: gpuBuffer.stride,
                        componentCount: WebGLGetComponentCount$1(glType, gl),
                        isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                        isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                        offset: offsets[stream]
                    }, offsets[stream] += size;
                }
            }(this._device, this._gpuInputAssembler), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var webgl2Dev = this._device;
            this._gpuInputAssembler && webgl2Dev.useVAO && function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                var _iterator7 = gpuInputAssembler.glVAOs, _isArray7 = Array.isArray(_iterator7), _i16 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i16 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i16++];
                    } else {
                        if ((_i16 = _iterator7.next()).done) break;
                        _ref7 = _i16.value;
                    }
                    var vao = _ref7;
                    device.gl.deleteVertexArray(vao[1]);
                }
                gpuInputAssembler.glVAOs.clear();
            }(webgl2Dev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "extractCmdDraw",
        value: function extractCmdDraw(cmd) {
            cmd.drawInfo.vertexCount = this._vertexCount, cmd.drawInfo.firstVertex = this._firstVertex, 
            cmd.drawInfo.indexCount = this._indexCount, cmd.drawInfo.firstIndex = this._firstIndex, 
            cmd.drawInfo.vertexOffset = this._vertexOffset, cmd.drawInfo.instanceCount = this._instanceCount, 
            cmd.drawInfo.firstInstance = this._firstInstance;
        }
    } ]), WebGL2GFXInputAssembler;
}(), WebGL2GFXPipelineLayout = function(_GFXPipelineLayout) {
    function WebGL2GFXPipelineLayout(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXPipelineLayout).call(this, device)))._gpuPipelineLayout = null, 
        _this;
    }
    return _inherits(WebGL2GFXPipelineLayout, GFXPipelineLayout), _createClass(WebGL2GFXPipelineLayout, [ {
        key: "gpuPipelineLayout",
        get: function get() {
            return this._gpuPipelineLayout;
        }
    } ]), _createClass(WebGL2GFXPipelineLayout, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
            this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXPipelineLayout;
}(), WebGLPrimitives$1 = [ 0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0 ], WebGL2GFXPipelineState = function(_GFXPipelineState) {
    function WebGL2GFXPipelineState(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXPipelineState).call(this, device)))._gpuPipelineState = null, 
        _this;
    }
    return _inherits(WebGL2GFXPipelineState, GFXPipelineState), _createClass(WebGL2GFXPipelineState, [ {
        key: "gpuPipelineState",
        get: function get() {
            return this._gpuPipelineState;
        }
    } ]), _createClass(WebGL2GFXPipelineState, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._primitive = info.primitive, this._shader = info.shader, this._is = info.is, 
            this._rs = info.rs, this._dss = info.dss, this._bs = info.bs, this._dynamicStates = info.dynamicStates || [], 
            this._layout = info.layout, this._renderPass = info.renderPass, this._gpuPipelineState = {
                glPrimitive: WebGLPrimitives$1[info.primitive],
                gpuShader: info.shader.gpuShader,
                rs: info.rs,
                dss: info.dss,
                bs: info.bs,
                dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                gpuLayout: info.layout.gpuPipelineLayout,
                gpuRenderPass: info.renderPass.gpuRenderPass
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuPipelineState = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXPipelineState;
}(), WebGL2GFXQueue = function(_GFXQueue) {
    function WebGL2GFXQueue(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXQueue).call(this, device))).numDrawCalls = 0, 
        _this.numTris = 0, _this._isAsync = !1, _this;
    }
    return _inherits(WebGL2GFXQueue, GFXQueue), _createClass(WebGL2GFXQueue, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._type = info.type, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "submit",
        value: function submit(cmdBuffs, fence) {
            if (!this._isAsync) {
                var _iterator = cmdBuffs, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var cmdBuff = _ref;
                    WebGL2CmdFuncExecuteCmds(this._device, cmdBuff.cmdPackage), this.numDrawCalls += cmdBuff.numDrawCalls, 
                    this.numTris += cmdBuff.numTris;
                }
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            this.numDrawCalls = 0, this.numTris = 0;
        }
    } ]), WebGL2GFXQueue;
}(), WebGL2GFXRenderPass = function(_GFXRenderPass) {
    function WebGL2GFXRenderPass(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXRenderPass).call(this, device)))._gpuRenderPass = null, 
        _this;
    }
    return _inherits(WebGL2GFXRenderPass, GFXRenderPass), _createClass(WebGL2GFXRenderPass, [ {
        key: "gpuRenderPass",
        get: function get() {
            return this._gpuRenderPass;
        }
    } ]), _createClass(WebGL2GFXRenderPass, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
            this._gpuRenderPass = {
                colorAttachments: this._colorInfos,
                depthStencilAttachment: this._depthStencilInfo
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuRenderPass = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXRenderPass;
}(), WebGL2GFXSampler = function(_GFXSampler) {
    function WebGL2GFXSampler(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXSampler).call(this, device)))._gpuSampler = null, 
        _this._state = new GFXSamplerState(), _this;
    }
    return _inherits(WebGL2GFXSampler, GFXSampler), _createClass(WebGL2GFXSampler, [ {
        key: "gpuSampler",
        get: function get() {
            return this._gpuSampler;
        }
    } ]), _createClass(WebGL2GFXSampler, [ {
        key: "initialize",
        value: function initialize(info) {
            return void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
            void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
            void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
            void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
            void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
            void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
            void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias), this._gpuSampler = {
                glSampler: null,
                minFilter: this._state.minFilter,
                magFilter: this._state.magFilter,
                mipFilter: this._state.mipFilter,
                addressU: this._state.addressU,
                addressV: this._state.addressV,
                addressW: this._state.addressW,
                minLOD: this._state.minLOD,
                maxLOD: this._state.maxLOD,
                glMinFilter: WebGL2RenderingContext.NONE,
                glMagFilter: WebGL2RenderingContext.NONE,
                glWrapS: WebGL2RenderingContext.NONE,
                glWrapT: WebGL2RenderingContext.NONE,
                glWrapR: WebGL2RenderingContext.NONE
            }, function WebGL2CmdFuncCreateSampler(device, gpuSampler) {
                var gl = device.gl, glSampler = gl.createSampler();
                glSampler && (gpuSampler.minFilter === GFXFilter.LINEAR || gpuSampler.minFilter === GFXFilter.ANISOTROPIC ? gpuSampler.mipFilter === GFXFilter.LINEAR || gpuSampler.mipFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR : gpuSampler.mipFilter === GFXFilter.POINT ? gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST : gpuSampler.glMinFilter = gl.LINEAR : gpuSampler.mipFilter === GFXFilter.LINEAR || gpuSampler.mipFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR : gpuSampler.mipFilter === GFXFilter.POINT ? gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST : gpuSampler.glMinFilter = gl.NEAREST, 
                gpuSampler.magFilter === GFXFilter.LINEAR || gpuSampler.magFilter === GFXFilter.ANISOTROPIC ? gpuSampler.glMagFilter = WebGLRenderingContext.LINEAR : gpuSampler.glMagFilter = WebGLRenderingContext.NEAREST, 
                gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU], gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV], 
                gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW], gpuSampler.glSampler = glSampler, 
                gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gpuSampler.glMinFilter), 
                gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gpuSampler.glWrapS), gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gpuSampler.glWrapT), 
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, gpuSampler.glWrapR), gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, gpuSampler.minLOD), 
                gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, gpuSampler.maxLOD));
            }(this._device, this._gpuSampler), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuSampler && (!function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
                gpuSampler.glSampler && (device.gl.deleteSampler(gpuSampler.glSampler), gpuSampler.glSampler = null);
            }(this._device, this._gpuSampler), this._gpuSampler = null), this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXSampler;
}(), WebGL2GFXShader = function(_GFXShader) {
    function WebGL2GFXShader(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXShader).call(this, device)))._gpuShader = null, 
        _this;
    }
    return _inherits(WebGL2GFXShader, GFXShader), _createClass(WebGL2GFXShader, [ {
        key: "gpuShader",
        get: function get() {
            return this._gpuShader;
        }
    } ]), _createClass(WebGL2GFXShader, [ {
        key: "initialize",
        value: function initialize(info) {
            this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
            void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                name: info.name ? info.name : "",
                blocks: void 0 !== info.blocks ? info.blocks : [],
                samplers: void 0 !== info.samplers ? info.samplers : [],
                gpuStages: new Array(info.stages.length),
                glProgram: null,
                glInputs: [],
                glUniforms: [],
                glBlocks: [],
                glSamplers: []
            };
            for (var i = 0; i < info.stages.length; ++i) {
                var stage = info.stages[i];
                this._gpuShader.gpuStages[i] = {
                    type: stage.type,
                    source: stage.source,
                    macros: stage.macros ? stage.macros : [],
                    glShader: null
                };
            }
            return function WebGL2CmdFuncCreateShader(device, gpuShader) {
                var gl = device.gl, _loop2 = function _loop2() {
                    if (_isArray) {
                        if (_i7 >= _iterator.length) return "break";
                        _ref = _iterator[_i7++];
                    } else {
                        if ((_i7 = _iterator.next()).done) return "break";
                        _ref = _i7.value;
                    }
                    var gpuStage = _ref, glShaderType = 0, shaderTypeStr = "", lineNumber = 1;
                    switch (gpuStage.type) {
                      case GFXShaderType.VERTEX:
                        shaderTypeStr = "VertexShader", glShaderType = gl.VERTEX_SHADER;
                        break;

                      case GFXShaderType.FRAGMENT:
                        shaderTypeStr = "FragmentShader", glShaderType = gl.FRAGMENT_SHADER;
                        break;

                      default:
                        return console.error("Unsupported GFXShaderType."), {
                            v: void 0
                        };
                    }
                    var glShader = gl.createShader(glShaderType);
                    if (glShader && (gpuStage.glShader = glShader, gl.shaderSource(gpuStage.glShader, gpuStage.source), 
                    gl.compileShader(gpuStage.glShader), !gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS))) return console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                    console.error("Shader source dump:", gpuStage.source.replace(/^|\n/g, function() {
                        return "\n".concat(lineNumber++, " ");
                    })), console.error(gl.getShaderInfoLog(gpuStage.glShader)), gl.deleteShader(gpuStage.glShader), 
                    gpuStage.glShader = null, {
                        v: void 0
                    };
                }, _iterator = gpuShader.gpuStages, _isArray = Array.isArray(_iterator), _i7 = 0;
                _loop: for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref, _ret = _loop2();
                    switch (_ret) {
                      case "break":
                        break _loop;

                      default:
                        if ("object" === _typeof(_ret)) return _ret.v;
                    }
                }
                var glProgram = gl.createProgram();
                if (glProgram) {
                    gpuShader.glProgram = glProgram;
                    var _iterator2 = gpuShader.gpuStages, _isArray2 = Array.isArray(_iterator2), _i8 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i8 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i8++];
                        } else {
                            if ((_i8 = _iterator2.next()).done) break;
                            _ref2 = _i8.value;
                        }
                        var _gpuStage = _ref2;
                        gl.attachShader(gpuShader.glProgram, _gpuStage.glShader);
                    }
                    if (gl.linkProgram(gpuShader.glProgram), gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                        console.info("Shader '" + gpuShader.name + "' compilation successed.");
                        var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                        gpuShader.glInputs = new Array(activeAttribCount);
                        for (var i = 0; i < activeAttribCount; ++i) {
                            var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                            if (attribInfo) {
                                var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                                varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                                var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType$1(attribInfo.type, gl), stride = WebGLGetTypeSize$1(attribInfo.type, gl);
                                gpuShader.glInputs[i] = {
                                    binding: glLoc,
                                    name: varName,
                                    type: type,
                                    stride: stride,
                                    count: attribInfo.size,
                                    size: stride * attribInfo.size,
                                    glType: attribInfo.type,
                                    glLoc: glLoc
                                };
                            }
                        }
                        var blockName, blockIdx, blockSize, blockBinding, blockUniformCount, uIndices, indices, glUniformSizes, glUniformOffsets, glUniformInfo, activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
                        if (activeBlockCount) {
                            gpuShader.glBlocks = new Array(activeBlockCount);
                            for (var b = 0; b < activeBlockCount; ++b) {
                                var _nameOffset = (blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b)).indexOf("[");
                                -1 !== _nameOffset && (blockName = blockName.substr(0, _nameOffset)), blockBinding = -1;
                                var _iterator4 = gpuShader.blocks, _isArray4 = Array.isArray(_iterator4), _i10 = 0;
                                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                                    var _ref4;
                                    if (_isArray4) {
                                        if (_i10 >= _iterator4.length) break;
                                        _ref4 = _iterator4[_i10++];
                                    } else {
                                        if ((_i10 = _iterator4.next()).done) break;
                                        _ref4 = _i10.value;
                                    }
                                    var block = _ref4;
                                    if (block.name === blockName) {
                                        blockBinding = block.binding;
                                        break;
                                    }
                                }
                                if (blockBinding >= 0) {
                                    blockIdx = b, blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE), 
                                    blockUniformCount = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORMS), 
                                    gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, blockBinding);
                                    var glBlock = {
                                        binding: blockBinding,
                                        idx: blockIdx,
                                        name: blockName,
                                        size: blockSize,
                                        glUniforms: new Array(blockUniformCount),
                                        glActiveUniforms: [],
                                        isUniformPackage: !1
                                    };
                                    gpuShader.glBlocks[b] = glBlock, uIndices = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES), 
                                    indices = new Array(uIndices.length);
                                    for (var n = 0; n < uIndices.length; ++n) indices[n] = uIndices[n];
                                    glUniformSizes = gl.getActiveUniforms(gpuShader.glProgram, indices, gl.UNIFORM_SIZE), 
                                    glUniformOffsets = gl.getActiveUniforms(gpuShader.glProgram, indices, gl.UNIFORM_OFFSET);
                                    for (var u = 0; u < blockUniformCount; ++u) if (glUniformInfo = gl.getActiveUniform(gpuShader.glProgram, uIndices[u])) {
                                        var _stride = WebGLGetTypeSize$1(glUniformInfo.type, gl), size = glUniformSizes[u] * _stride, begin = glUniformOffsets[u] / 4, array = new Array(size / 4);
                                        array.fill(0), glBlock.glUniforms[u] = {
                                            binding: -1,
                                            name: glUniformInfo.name,
                                            type: WebGLTypeToGFXType$1(glUniformInfo.type, gl),
                                            stride: _stride,
                                            count: glUniformInfo.size,
                                            size: size,
                                            offset: glUniformOffsets[u],
                                            glType: glUniformInfo.type,
                                            glLoc: -1,
                                            array: array,
                                            begin: begin
                                        };
                                    }
                                }
                            }
                        }
                        if (gpuShader.samplers.length > 0) {
                            gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                            for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                                var sampler = gpuShader.samplers[_i11];
                                gpuShader.glSamplers[_i11] = {
                                    binding: sampler.binding,
                                    name: sampler.name,
                                    type: sampler.type,
                                    units: [],
                                    glType: GFXTypeToWebGLType$1(sampler.type, gl),
                                    glLoc: -1
                                };
                            }
                        }
                        for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i12 = 0; _i12 < activeUniformCount; ++_i12) {
                            var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i12);
                            if (uniformInfo) {
                                var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                                if (_glLoc) {
                                    var _varName = void 0, _nameOffset2 = uniformInfo.name.indexOf("[");
                                    if (_varName = -1 !== _nameOffset2 ? uniformInfo.name.substr(0, _nameOffset2) : uniformInfo.name, 
                                    uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE) {
                                        var _iterator5 = gpuShader.glSamplers, _isArray5 = Array.isArray(_iterator5), _i13 = 0;
                                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                            var _ref5;
                                            if (_isArray5) {
                                                if (_i13 >= _iterator5.length) break;
                                                _ref5 = _iterator5[_i13++];
                                            } else {
                                                if ((_i13 = _iterator5.next()).done) break;
                                                _ref5 = _i13.value;
                                            }
                                            var glSampler = _ref5;
                                            if (glSampler.name === _varName) {
                                                for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                                glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (glActiveSamplers.length) {
                            device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                            device.stateCache.glProgram = gpuShader.glProgram);
                            for (var _i14 = 0, _glActiveSamplers = glActiveSamplers; _i14 < _glActiveSamplers.length; _i14++) {
                                var _glSampler = _glActiveSamplers[_i14];
                                gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                            }
                        }
                    } else {
                        console.error("Failed to link shader '" + gpuShader.name + "'."), console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                        var _iterator3 = gpuShader.gpuStages, _isArray3 = Array.isArray(_iterator3), _i9 = 0;
                        for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray3) {
                                if (_i9 >= _iterator3.length) break;
                                _ref3 = _iterator3[_i9++];
                            } else {
                                if ((_i9 = _iterator3.next()).done) break;
                                _ref3 = _i9.value;
                            }
                            var gpuStage = _ref3;
                            gpuStage.glShader && (gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                        }
                    }
                }
            }(this._device, this._gpuShader), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuShader && (!function WebGL2CmdFuncDestroyShader(device, gpuShader) {
                var _iterator6 = gpuShader.gpuStages, _isArray6 = Array.isArray(_iterator6), _i15 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i15 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i15++];
                    } else {
                        if ((_i15 = _iterator6.next()).done) break;
                        _ref6 = _i15.value;
                    }
                    var gpuStage = _ref6;
                    gpuStage.glShader && (device.gl.deleteShader(gpuStage.glShader), gpuStage.glShader = null);
                }
                gpuShader.glProgram && (device.gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null);
            }(this._device, this._gpuShader), this._gpuShader = null), this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXShader;
}(), WebGL2StateCache = function WebGL2StateCache() {
    _classCallCheck(this, WebGL2StateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
    this.glUniformBuffer = null, this.glBindUBOs = void 0, this.glVAO = null, this.texUnit = 0, 
    this.glTex2DUnits = void 0, this.glTexCubeUnits = void 0, this.glSamplerUnits = void 0, 
    this.glRenderbuffer = null, this.glFramebuffer = null, this.glReadFramebuffer = null, 
    this.viewport = void 0, this.scissorRect = void 0, this.rs = void 0, this.dss = void 0, 
    this.bs = void 0, this.glProgram = null, this.glEnabledAttribLocs = void 0, this.glCurrentAttribLocs = void 0, 
    this.glBindUBOs = new Array(GFX_MAX_BUFFER_BINDINGS), this.glBindUBOs.fill(null), 
    this.glTex2DUnits = new Array(16), this.glTexCubeUnits = new Array(16), this.glSamplerUnits = new Array(16), 
    this.glSamplerUnits.fill(null), this.viewport = {
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        minDepth: 0,
        maxDepth: 0
    }, this.scissorRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }, this.rs = new GFXRasterizerState(), this.dss = new GFXDepthStencilState(), this.bs = new GFXBlendState(), 
    this.glEnabledAttribLocs = new Array(16), this.glCurrentAttribLocs = new Array(16), 
    this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
    for (var i = 0; i < 16; ++i) this.glTex2DUnits[i] = {
        glTexture: null
    }, this.glTexCubeUnits[i] = {
        glTexture: null
    };
};

function IsPowerOf2$1(x) {
    return x > 0 && 0 == (x & x - 1);
}

var BoxShape, SphereShape, RigidBody, PhysicsWorld, WebGL2GFXTexture = function(_GFXTexture) {
    function WebGL2GFXTexture(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXTexture).call(this, device)))._gpuTexture = null, 
        _this;
    }
    return _inherits(WebGL2GFXTexture, GFXTexture), _createClass(WebGL2GFXTexture, [ {
        key: "gpuTexture",
        get: function get() {
            return this._gpuTexture;
        }
    } ]), _createClass(WebGL2GFXTexture, [ {
        key: "initialize",
        value: function initialize(info) {
            var viewType;
            switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
            this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
            void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
            void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
            this._isPowerOf2 = IsPowerOf2$1(this._width) && IsPowerOf2$1(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
            this._flags & GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
            info.type) {
              case GFXTextureType.TEX1D:
                viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV1D : GFXTextureViewType.TV1D_ARRAY : GFXTextureViewType.TV1D;
                break;

              case GFXTextureType.TEX2D:
                var flags = GFXTextureFlagBit.NONE;
                info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? GFXTextureViewType.TV2D : flags & GFXTextureFlagBit.CUBEMAP ? GFXTextureViewType.CUBE : GFXTextureViewType.TV2D_ARRAY : GFXTextureViewType.TV2D;
                break;

              case GFXTextureType.TEX3D:
                viewType = GFXTextureViewType.TV3D;
                break;

              default:
                viewType = GFXTextureViewType.TV2D;
            }
            return this._gpuTexture = {
                type: this._type,
                viewType: viewType,
                format: this._format,
                usage: this._usage,
                width: this._width,
                height: this._height,
                depth: this._depth,
                size: this._size,
                arrayLayer: this._arrayLayer,
                mipLevel: this._mipLevel,
                samples: this._samples,
                flags: this._flags,
                isPowerOf2: this._isPowerOf2,
                glTarget: 0,
                glInternelFmt: 0,
                glFormat: 0,
                glType: 0,
                glUsage: 0,
                glTexture: null,
                glRenderbuffer: null,
                glWrapS: 0,
                glWrapT: 0,
                glMinFilter: 0,
                glMagFilter: 0
            }, function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
                var gl = device.gl;
                switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl), 
                gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl), 
                gpuTexture.viewType) {
                  case GFXTextureViewType.TV2D:
                    if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D, 
                    gpuTexture.samples === GFXSampleCount.X1) {
                        var glTexture = gl.createTexture();
                        if (glTexture && gpuTexture.size > 0) {
                            gpuTexture.glTexture = glTexture;
                            var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                            glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture);
                            var w = gpuTexture.width, h = gpuTexture.height;
                            if (GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternelFmt, w, h, 0, view), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            } else {
                                var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view);
                            } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                        }
                    } else {
                        var glRenderbuffer = gl.createRenderbuffer();
                        glRenderbuffer && gpuTexture.size > 0 && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                        device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternelFmt, gpuTexture.width, gpuTexture.height));
                    }
                    break;

                  case GFXTextureViewType.CUBE:
                    gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    var _glTexture = gl.createTexture();
                    if (_glTexture && gpuTexture.size > 0) {
                        gpuTexture.glTexture = _glTexture;
                        var _glTexUnit = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                        if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) for (var _w2 = gpuTexture.width, _h2 = gpuTexture.height, _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                            var _imgSize2 = GFXFormatSize(gpuTexture.format, _w2, _h2, 1), _view2 = new Uint8Array(_imgSize2);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternelFmt, _w2, _h2, 0, _view2), 
                            _w2 = Math.max(1, _w2 >> 1), _h2 = Math.max(1, _h2 >> 1);
                        } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                            var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternelFmt, 2, 2, 0, _view3);
                        } else for (var f = 0; f < 6; ++f) for (var _w = gpuTexture.width, _h = gpuTexture.height, _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternelFmt, _w, _h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        _w = Math.max(1, _w >> 1), _h = Math.max(1, _h >> 1);
                    }
                    break;

                  default:
                    console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                }
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, 
            this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuTexture && (!function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
                gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                gpuTexture.glRenderbuffer = null);
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= this._size, 
            this._gpuTexture = null), this._status = GFXStatus.UNREADY, this._buffer = null;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            var oldSize = this._size;
            this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
            this._gpuTexture && (this._gpuTexture.width = this._width, this._gpuTexture.height = this._height, 
            this._gpuTexture.size = this._size, function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
                var gl = device.gl;
                switch (gpuTexture.glInternelFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl), 
                gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl), 
                gpuTexture.viewType) {
                  case GFXTextureViewType.TV2D:
                    if (gpuTexture.viewType = GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D, 
                    gpuTexture.samples === GFXSampleCount.X1) {
                        var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                        glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                        glTexUnit.glTexture = gpuTexture.glTexture);
                        var w = gpuTexture.width, h = gpuTexture.height;
                        if (GFXFormatInfos[gpuTexture.format].isCompressed) {
                            if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternelFmt, w, h, 0, view), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                        } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternelFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                    } else {
                        var glRenderbuffer = gl.createRenderbuffer();
                        glRenderbuffer && gpuTexture.size > 0 && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                        device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternelFmt, gpuTexture.width, gpuTexture.height));
                    }
                    break;

                  case GFXTextureViewType.CUBE:
                    gpuTexture.viewType = GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    var _glTexUnit2 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                    _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                        if (gpuTexture.glInternelFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) for (var _w4 = gpuTexture.width, _h4 = gpuTexture.height, _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                            var _imgSize4 = GFXFormatSize(gpuTexture.format, _w4, _h4, 1), _view4 = new Uint8Array(_imgSize4);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternelFmt, _w4, _h4, 0, _view4), 
                            _w4 = Math.max(1, _w4 >> 1), _h4 = Math.max(1, _h4 >> 1);
                        }
                    } else for (var f = 0; f < 6; ++f) for (var _w3 = gpuTexture.width, _h3 = gpuTexture.height, _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternelFmt, _w3, _h3, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                    _w3 = Math.max(1, _w3 >> 1), _h3 = Math.max(1, _h3 >> 1);
                    break;

                  default:
                    console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = GFXTextureViewType.TV2D, 
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                }
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= oldSize, 
            this._device.memoryStatus.textureSize += this._size), this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXTexture;
}(), WebGL2GFXTextureView = function(_GFXTextureView) {
    function WebGL2GFXTextureView(device) {
        var _this;
        return _classCallCheck(this, WebGL2GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXTextureView).call(this, device)))._gpuTextureView = null, 
        _this;
    }
    return _inherits(WebGL2GFXTextureView, GFXTextureView), _createClass(WebGL2GFXTextureView, [ {
        key: "gpuTextureView",
        get: function get() {
            return this._gpuTextureView;
        }
    } ]), _createClass(WebGL2GFXTextureView, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._texture = info.texture, this._type = info.type, this._format = info.format, 
            this._format = info.format, void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), 
            void 0 !== info.levelCount && (this._levelCount = info.levelCount), void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), 
            void 0 !== info.layerCount && (this._layerCount = info.layerCount), this._gpuTextureView = {
                gpuTexture: info.texture.gpuTexture,
                type: info.type,
                format: info.format,
                baseLevel: info.baseLevel ? info.baseLevel : 0,
                levelCount: info.levelCount ? info.levelCount : 1
            }, this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuTextureView = null, this._texture = null, this._status = GFXStatus.UNREADY;
        }
    } ]), WebGL2GFXTextureView;
}(), WebGL2GFXWindow = function(_GFXWindow) {
    function WebGL2GFXWindow(device) {
        return _classCallCheck(this, WebGL2GFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXWindow).call(this, device));
    }
    return _inherits(WebGL2GFXWindow, GFXWindow), _createClass(WebGL2GFXWindow, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
            void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
            this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
            this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
            this._renderPass = this._device.createRenderPass({
                colorAttachments: [ {
                    format: this._colorFmt,
                    loadOp: GFXLoadOp.CLEAR,
                    storeOp: GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                    endLayout: GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL
                } ],
                depthStencilAttachment: {
                    format: this._depthStencilFmt,
                    depthLoadOp: GFXLoadOp.CLEAR,
                    depthStoreOp: GFXStoreOp.STORE,
                    stencilLoadOp: GFXLoadOp.CLEAR,
                    stencilStoreOp: GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                    endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                }
            });
            var colorViews = [];
            return this._isOffscreen && (this._colorFmt !== GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                format: this._colorFmt,
                width: this._width,
                height: this._height,
                depth: 1,
                arrayLayer: 1,
                mipLevel: 1,
                flags: GFXTextureFlagBit.NONE
            }), this._colorTexView = this._device.createTextureView({
                texture: this._colorTex,
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt,
                baseLevel: 0,
                levelCount: 1,
                baseLayer: 0,
                layerCount: 1
            }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                format: this._depthStencilFmt,
                width: this._width,
                height: this._height,
                depth: 1,
                arrayLayer: 1,
                mipLevel: 1,
                flags: GFXTextureFlagBit.NONE
            }), this._depthStencilTexView = this._device.createTextureView({
                texture: this._depthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt,
                baseLevel: 0,
                levelCount: 1,
                baseLayer: 0,
                layerCount: 1
            }))), this._framebuffer = this._device.createFramebuffer({
                renderPass: this._renderPass,
                colorViews: colorViews,
                depthStencilView: this._depthStencilTexView,
                isOffscreen: this._isOffscreen
            }), this._status = GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
            this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
            this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
            this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
            this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
            this._status = GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
            this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
            this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                texture: this._depthStencilTex,
                type: GFXTextureViewType.TV2D,
                format: this._depthStencilFmt
            })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
            this._colorTexView.initialize({
                texture: this._colorTex,
                type: GFXTextureViewType.TV2D,
                format: this._colorFmt
            })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
            this._framebuffer.initialize({
                renderPass: this._renderPass,
                colorViews: [ this._colorTexView ],
                depthStencilView: this._depthStencilTexView
            })));
        }
    } ]), WebGL2GFXWindow;
}(), WebGL2GFXDevice = function(_GFXDevice) {
    function WebGL2GFXDevice() {
        var _this;
        return _classCallCheck(this, WebGL2GFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGL2GFXDevice).call(this))).stateCache = new WebGL2StateCache(), 
        _this.nullTex2D = null, _this.nullTexCube = null, _this._webGL2RC = null, _this._isAntialias = !0, 
        _this._isPremultipliedAlpha = !0, _this._useVAO = !0, _this._extensions = null, 
        _this._EXT_texture_filter_anisotropic = null, _this._OES_texture_float_linear = null, 
        _this._OES_texture_half_float_linear = null, _this._EXT_color_buffer_float = null, 
        _this._EXT_disjoint_timer_query_webgl2 = null, _this._WEBGL_compressed_texture_etc1 = null, 
        _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
        _this._WEBGL_compressed_texture_s3tc = null, _this._WEBGL_compressed_texture_s3tc_srgb = null, 
        _this._WEBGL_debug_renderer_info = null, _this._WEBGL_texture_storage_multisample = null, 
        _this._WEBGL_debug_shaders = null, _this._WEBGL_lose_context = null, _this;
    }
    return _inherits(WebGL2GFXDevice, GFXDevice), _createClass(WebGL2GFXDevice, [ {
        key: "gl",
        get: function get() {
            return this._webGL2RC;
        }
    }, {
        key: "isAntialias",
        get: function get() {
            return this._isAntialias;
        }
    }, {
        key: "isPremultipliedAlpha",
        get: function get() {
            return this._isPremultipliedAlpha;
        }
    }, {
        key: "useVAO",
        get: function get() {
            return this._useVAO;
        }
    }, {
        key: "EXT_texture_filter_anisotropic",
        get: function get() {
            return this._EXT_texture_filter_anisotropic;
        }
    }, {
        key: "OES_texture_float_linear",
        get: function get() {
            return this._OES_texture_float_linear;
        }
    }, {
        key: "EXT_color_buffer_float",
        get: function get() {
            return this._EXT_color_buffer_float;
        }
    }, {
        key: "EXT_disjoint_timer_query_webgl2",
        get: function get() {
            return this._EXT_disjoint_timer_query_webgl2;
        }
    }, {
        key: "WEBGL_compressed_texture_etc1",
        get: function get() {
            return this._WEBGL_compressed_texture_etc1;
        }
    }, {
        key: "WEBGL_compressed_texture_etc",
        get: function get() {
            return this._WEBGL_compressed_texture_etc;
        }
    }, {
        key: "WEBGL_compressed_texture_pvrtc",
        get: function get() {
            return this._WEBGL_compressed_texture_pvrtc;
        }
    }, {
        key: "WEBGL_compressed_texture_s3tc",
        get: function get() {
            return this._WEBGL_compressed_texture_s3tc;
        }
    }, {
        key: "WEBGL_compressed_texture_s3tc_srgb",
        get: function get() {
            return this._WEBGL_compressed_texture_s3tc_srgb;
        }
    } ]), _createClass(WebGL2GFXDevice, [ {
        key: "initialize",
        value: function initialize(info) {
            this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
            this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
            try {
                var webGLCtxAttribs = {
                    alpha: !1,
                    antialias: this._isAntialias,
                    depth: !0,
                    stencil: !0,
                    premultipliedAlpha: this._isPremultipliedAlpha,
                    preserveDrawingBuffer: !1,
                    powerPreference: "default",
                    failIfMajorPerformanceCaveat: !1
                };
                this._webGL2RC = this._canvas.getContext("webgl2", webGLCtxAttribs);
            } catch (err) {
                return console.error(err), !1;
            }
            if (!this._webGL2RC) return console.error("This device does not support WebGL2."), 
            !1;
            this._canvas2D = document.createElement("canvas"), console.info("WebGL2 device initialized."), 
            this._gfxAPI = GFXAPI.WEBGL2, this._deviceName = "WebGL2";
            var gl = this._webGL2RC;
            this._WEBGL_debug_renderer_info = gl.getExtension("WEBGL_debug_renderer_info"), 
            this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
            this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(gl.RENDERER), 
            this._vendor = gl.getParameter(gl.VENDOR)), this._version = gl.getParameter(gl.VERSION), 
            this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), 
            this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), 
            this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
            this._maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS), 
            this._maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE), this._depthBits = gl.getParameter(gl.DEPTH_BITS), 
            this._stencilBits = gl.getParameter(gl.STENCIL_BITS), this._devicePixelRatio = info.devicePixelRatio || 1, 
            this._width = this._canvas.width, this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
            this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = GFXFormat.RGBA8, 
            32 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D32F_S8 : this._depthStencilFmt = GFXFormat.D32F : 24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D24S8 : this._depthStencilFmt = GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = GFXFormat.D16S8 : this._depthStencilFmt = GFXFormat.D16, 
            this._extensions = gl.getSupportedExtensions();
            var extensions = "";
            if (this._extensions) {
                var _iterator = this._extensions, _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    extensions += _ref + " ";
                }
                console.debug("EXTENSIONS: " + extensions);
            }
            this._EXT_texture_filter_anisotropic = gl.getExtension("EXT_texture_filter_anisotropic"), 
            this._EXT_color_buffer_float = gl.getExtension("EXT_color_buffer_float"), this._EXT_disjoint_timer_query_webgl2 = gl.getExtension("EXT_disjoint_timer_query_webgl2"), 
            this._OES_texture_float_linear = gl.getExtension("OES_texture_float_linear"), this._OES_texture_half_float_linear = gl.getExtension("OES_texture_half_float_linear"), 
            this._WEBGL_compressed_texture_etc1 = gl.getExtension("WEBGL_compressed_texture_etc1"), 
            this._WEBGL_compressed_texture_etc = gl.getExtension("WEBGL_compressed_texture_etc"), 
            this._WEBGL_compressed_texture_pvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc"), 
            this._WEBGL_compressed_texture_s3tc = gl.getExtension("WEBGL_compressed_texture_s3tc"), 
            this._WEBGL_compressed_texture_s3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
            this._WEBGL_texture_storage_multisample = gl.getExtension("WEBGL_texture_storage_multisample"), 
            this._WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders"), this._WEBGL_lose_context = gl.getExtension("WEBGL_lose_context"), 
            this._features.fill(!1), this._features[GFXFeature.TEXTURE_FLOAT] = !0, this._features[GFXFeature.TEXTURE_HALF_FLOAT] = !0, 
            this._features[GFXFeature.FORMAT_R11G11B10F] = !0, this._features[GFXFeature.FORMAT_D24S8] = !0, 
            this._features[GFXFeature.FORMAT_ETC2] = !0, this._features[GFXFeature.MSAA] = !0, 
            this._EXT_color_buffer_float && (this._features[GFXFeature.COLOR_FLOAT] = !0, this._features[GFXFeature.COLOR_HALF_FLOAT] = !0), 
            this._OES_texture_float_linear && (this._features[GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
            this._OES_texture_half_float_linear && (this._features[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0);
            var compressedFormat = "";
            this._WEBGL_compressed_texture_etc1 && (this._features[GFXFeature.FORMAT_ETC1] = !0, 
            compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[GFXFeature.FORMAT_ETC2] = !0, 
            compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[GFXFeature.FORMAT_DXT] = !0, 
            compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[GFXFeature.FORMAT_PVRTC] = !0, 
            compressedFormat += "pvrtc "), console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
            console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
            console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
            console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("MAX_UNIFORM_BUFFER_BINDINGS: " + this._maxUniformBufferBindings), 
            console.info("DEPTH_BITS: " + this._depthBits), console.info("STENCIL_BITS: " + this._stencilBits), 
            this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
            console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
            this.initStates(gl), this._queue = this.createQueue({
                type: GFXQueueType.GRAPHICS
            }), this._mainWindow = this.createWindow({
                title: this._webGL2RC.canvas.title,
                left: this._webGL2RC.canvas.offsetLeft,
                top: this._webGL2RC.canvas.offsetTop,
                width: this._webGL2RC.drawingBufferWidth,
                height: this._webGL2RC.drawingBufferHeight,
                colorFmt: this._colorFmt,
                depthStencilFmt: this._depthStencilFmt
            }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGL2GFXTexture(this), 
            this.nullTex2D.initialize({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.SAMPLED,
                format: GFXFormat.RGBA8,
                width: 2,
                height: 2,
                flags: GFXTextureFlagBit.GEN_MIPMAP
            }), this.nullTexCube = new WebGL2GFXTexture(this), this.nullTexCube.initialize({
                type: GFXTextureType.TEX2D,
                usage: GFXTextureUsageBit.SAMPLED,
                format: GFXFormat.RGBA8,
                width: 2,
                height: 2,
                arrayLayer: 6,
                flags: GFXTextureFlagBit.CUBEMAP | GFXTextureFlagBit.GEN_MIPMAP
            });
            var nullTexRegion = {
                buffOffset: 0,
                buffStride: 0,
                buffTexHeight: 0,
                texOffset: {
                    x: 0,
                    y: 0,
                    z: 0
                },
                texExtent: {
                    width: 2,
                    height: 2,
                    depth: 1
                },
                texSubres: {
                    baseMipLevel: 0,
                    levelCount: 1,
                    baseArrayLayer: 0,
                    layerCount: 1
                }
            }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
            return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
            nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
            this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
            this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
            this._queue && (this._queue.destroy(), this._queue = null), this._webGL2RC = null;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
            this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
        }
    }, {
        key: "createBuffer",
        value: function createBuffer(info) {
            var buffer = new WebGL2GFXBuffer(this);
            return buffer.initialize(info), buffer;
        }
    }, {
        key: "createTexture",
        value: function createTexture(info) {
            var texture = new WebGL2GFXTexture(this);
            return texture.initialize(info), texture;
        }
    }, {
        key: "createTextureView",
        value: function createTextureView(info) {
            var texView = new WebGL2GFXTextureView(this);
            return texView.initialize(info), texView;
        }
    }, {
        key: "createSampler",
        value: function createSampler(info) {
            var sampler = new WebGL2GFXSampler(this);
            return sampler.initialize(info), sampler;
        }
    }, {
        key: "createBindingLayout",
        value: function createBindingLayout(info) {
            var bindingLayout = new WebGL2GFXBindingLayout(this);
            return bindingLayout.initialize(info), bindingLayout;
        }
    }, {
        key: "createShader",
        value: function createShader(info) {
            var shader = new WebGL2GFXShader(this);
            return shader.initialize(info), shader;
        }
    }, {
        key: "createInputAssembler",
        value: function createInputAssembler(info) {
            var inputAssembler = new WebGL2GFXInputAssembler(this);
            return inputAssembler.initialize(info), inputAssembler;
        }
    }, {
        key: "createRenderPass",
        value: function createRenderPass(info) {
            var renderPass = new WebGL2GFXRenderPass(this);
            return renderPass.initialize(info), renderPass;
        }
    }, {
        key: "createFramebuffer",
        value: function createFramebuffer(info) {
            var framebuffer = new WebGL2GFXFramebuffer(this);
            return framebuffer.initialize(info), framebuffer;
        }
    }, {
        key: "createPipelineLayout",
        value: function createPipelineLayout(info) {
            var pipelineLayout = new WebGL2GFXPipelineLayout(this);
            return pipelineLayout.initialize(info), pipelineLayout;
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(info) {
            var pipelineState = new WebGL2GFXPipelineState(this);
            return pipelineState.initialize(info), pipelineState;
        }
    }, {
        key: "createCommandAllocator",
        value: function createCommandAllocator(info) {
            var cmdAllocator = new WebGL2GFXCommandAllocator(this);
            return cmdAllocator.initialize(info), cmdAllocator;
        }
    }, {
        key: "createCommandBuffer",
        value: function createCommandBuffer(info) {
            var cmdBuff = new WebGL2GFXCommandBuffer(this);
            return cmdBuff.initialize(info), cmdBuff;
        }
    }, {
        key: "createQueue",
        value: function createQueue(info) {
            var queue = new WebGL2GFXQueue(this);
            return queue.initialize(info), queue;
        }
    }, {
        key: "createWindow",
        value: function createWindow(info) {
            var window = new WebGL2GFXWindow(this);
            return window.initialize(info), window;
        }
    }, {
        key: "present",
        value: function present() {
            this._cmdAllocator.releaseCmds();
            var queue = this._queue;
            this._numDrawCalls = queue.numDrawCalls, this._numTris = queue.numTris, queue.clear();
        }
    }, {
        key: "copyBuffersToTexture",
        value: function copyBuffersToTexture(buffers, texture, regions) {
            WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        }
    }, {
        key: "copyTexImagesToTexture",
        value: function copyTexImagesToTexture(texImages, texture, regions) {
            !function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                var gl = device.gl, m = 0, n = 0, f = 0;
                switch (gpuTexture.glTarget) {
                  case gl.TEXTURE_2D:
                    var glTexUnit = device.stateCache.glTex2DUnits[device.stateCache.texUnit];
                    glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                    glTexUnit.glTexture = gpuTexture.glTexture);
                    var _iterator18 = regions, _isArray18 = Array.isArray(_iterator18), _i28 = 0;
                    for (_iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator](); ;) {
                        var _ref18;
                        if (_isArray18) {
                            if (_i28 >= _iterator18.length) break;
                            _ref18 = _iterator18[_i28++];
                        } else {
                            if ((_i28 = _iterator18.next()).done) break;
                            _ref18 = _i28.value;
                        }
                        var region = _ref18;
                        for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }
                    break;

                  case gl.TEXTURE_CUBE_MAP:
                    var _glTexUnit3 = device.stateCache.glTexCubeUnits[device.stateCache.texUnit];
                    _glTexUnit3.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                    _glTexUnit3.glTexture = gpuTexture.glTexture);
                    var _iterator19 = regions, _isArray19 = Array.isArray(_iterator19), _i29 = 0;
                    for (_iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator](); ;) {
                        var _ref19;
                        if (_isArray19) {
                            if (_i29 >= _iterator19.length) break;
                            _ref19 = _iterator19[_i29++];
                        } else {
                            if ((_i29 = _iterator19.next()).done) break;
                            _ref19 = _i29.value;
                        }
                        var _region = _ref19, fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                        for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                            var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                            for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                        }
                    }
                    break;

                  default:
                    console.error("Unsupported GL texture type, copy buffer to texture failed.");
                }
                gpuTexture.flags & GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
            }(this, texImages, texture.gpuTexture, regions);
        }
    }, {
        key: "copyFramebufferToBuffer",
        value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
            var gl = this._webGL2RC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, curFBO = this.stateCache.glFramebuffer;
            this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
            this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
            var view = new Uint8Array(dstBuffer), _iterator2 = regions, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                var _ref2;
                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    if ((_i2 = _iterator2.next()).done) break;
                    _ref2 = _i2.value;
                }
                var region = _ref2, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(GFXFormat.RGBA8, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO), 
            this.stateCache.glFramebuffer = curFBO);
        }
    }, {
        key: "blitFramebuffer",
        value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {
            !function WebGL2CmdFuncBlitFramebuffer(device, src, dst, srcRect, dstRect, filter) {
                var gl = device.gl;
                device.stateCache.glReadFramebuffer !== src.glFramebuffer && (gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src.glFramebuffer), 
                device.stateCache.glReadFramebuffer = src.glFramebuffer);
                var rebindFBO = dst.glFramebuffer !== device.stateCache.glFramebuffer;
                rebindFBO && gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst.glFramebuffer);
                var mask = 0;
                src.gpuColorViews.length > 0 && (mask |= gl.COLOR_BUFFER_BIT), src.gpuDepthStencilView && (mask |= gl.DEPTH_BUFFER_BIT, 
                GFXFormatInfos[src.gpuDepthStencilView.format].hasStencil && (mask |= gl.STENCIL_BUFFER_BIT));
                var glFilter = filter === GFXFilter.LINEAR || filter === GFXFilter.ANISOTROPIC ? gl.LINEAR : gl.NEAREST;
                gl.blitFramebuffer(srcRect.x, srcRect.y, srcRect.x + srcRect.width, srcRect.y + srcRect.height, dstRect.x, dstRect.y, dstRect.x + dstRect.width, dstRect.y + dstRect.height, mask, glFilter), 
                rebindFBO && gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
            }(this, src.gpuFramebuffer, dst.gpuFramebuffer, srcRect, dstRect, filter);
        }
    }, {
        key: "initStates",
        value: function initStates(gl) {
            gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
            gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), gl.polygonOffset(0, 0), 
            gl.enable(gl.DEPTH_TEST), gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 4294967295), 
            gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 4294967295), 
            gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 4294967295), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
            gl.stencilMaskSeparate(gl.BACK, 4294967295), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
            gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
            gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
        }
    } ]), WebGL2GFXDevice;
}();

cc.WebGL2GFXDevice = WebGL2GFXDevice;

var ERigidBodyType, ETransformSource, cannon_min = createCommonjsModule(function(module, exports) {
    module.exports = function n(s, r, a) {
        function h(i, t) {
            if (!r[i]) {
                if (!s[i]) {
                    if (!t && commonjsRequire) return commonjsRequire();
                    if (l) return l(i, !0);
                    throw new Error("Cannot find module '" + i + "'");
                }
                var o = r[i] = {
                    exports: {}
                };
                s[i][0].call(o.exports, function(t) {
                    return h(s[i][1][t] || t);
                }, o, o.exports, n, s, r, a);
            }
            return r[i].exports;
        }
        for (var l = commonjsRequire, t = 0; t < a.length; t++) h(a[t]);
        return h;
    }({
        1: [ function(t, e, i) {
            e.exports = {
                name: "cannon",
                version: "1.0.0",
                description: "A lightweight 3D physics engine written in JavaScript.",
                homepage: "https://github.com/cocos-creator/cannon.js",
                author: "JayceLai",
                keywords: [ "cannon.js", "cannon", "physics", "engine", "3d" ],
                scripts: {
                    build: "grunt && npm run preprocess && grunt addLicense && grunt addDate",
                    preprocess: "node node_modules/uglify-js/bin/uglifyjs build/cannon.js -o build/cannon.min.js -d doProfiling=false,CANNON=false,DEBUG=false -c -m"
                },
                main: "./build/cannon.min.js",
                engines: {
                    node: "*"
                },
                repository: {
                    type: "git",
                    url: "https://github.com/cocos-creator/cannon.js.git"
                },
                bugs: {
                    url: "https://github.com/cocos-creator/cannon.js/issues"
                },
                licenses: [ {
                    type: "MIT"
                } ],
                devDependencies: {
                    jshint: "latest",
                    "uglify-js": "latest",
                    nodeunit: "^0.9.0",
                    grunt: "~0.4.0",
                    "grunt-contrib-jshint": "~0.1.1",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-concat": "~0.1.3",
                    "grunt-contrib-uglify": "^0.5.1",
                    "grunt-browserify": "^2.1.4",
                    "grunt-contrib-yuidoc": "^0.5.2",
                    browserify: "*"
                },
                dependencies: {}
            };
        }, {} ],
        2: [ function(t, e, i) {
            e.exports = {
                version: t("../package.json").version,
                AABB: t("./collision/AABB"),
                ArrayCollisionMatrix: t("./collision/ArrayCollisionMatrix"),
                Body: t("./objects/Body"),
                Box: t("./shapes/Box"),
                Broadphase: t("./collision/Broadphase"),
                Constraint: t("./constraints/Constraint"),
                ContactEquation: t("./equations/ContactEquation"),
                Narrowphase: t("./world/Narrowphase"),
                ConeTwistConstraint: t("./constraints/ConeTwistConstraint"),
                ContactMaterial: t("./material/ContactMaterial"),
                ConvexPolyhedron: t("./shapes/ConvexPolyhedron"),
                Cylinder: t("./shapes/Cylinder"),
                DistanceConstraint: t("./constraints/DistanceConstraint"),
                Equation: t("./equations/Equation"),
                EventTarget: t("./utils/EventTarget"),
                FrictionEquation: t("./equations/FrictionEquation"),
                GSSolver: t("./solver/GSSolver"),
                GridBroadphase: t("./collision/GridBroadphase"),
                Heightfield: t("./shapes/Heightfield"),
                HingeConstraint: t("./constraints/HingeConstraint"),
                LockConstraint: t("./constraints/LockConstraint"),
                Mat3: t("./math/Mat3"),
                Material: t("./material/Material"),
                NaiveBroadphase: t("./collision/NaiveBroadphase"),
                ObjectCollisionMatrix: t("./collision/ObjectCollisionMatrix"),
                Pool: t("./utils/Pool"),
                Particle: t("./shapes/Particle"),
                Plane: t("./shapes/Plane"),
                PointToPointConstraint: t("./constraints/PointToPointConstraint"),
                Quaternion: t("./math/Quaternion"),
                Ray: t("./collision/Ray"),
                RaycastVehicle: t("./objects/RaycastVehicle"),
                RaycastResult: t("./collision/RaycastResult"),
                RigidVehicle: t("./objects/RigidVehicle"),
                RotationalEquation: t("./equations/RotationalEquation"),
                RotationalMotorEquation: t("./equations/RotationalMotorEquation"),
                SAPBroadphase: t("./collision/SAPBroadphase"),
                SPHSystem: t("./objects/SPHSystem"),
                Shape: t("./shapes/Shape"),
                Solver: t("./solver/Solver"),
                Sphere: t("./shapes/Sphere"),
                SplitSolver: t("./solver/SplitSolver"),
                Spring: t("./objects/Spring"),
                Transform: t("./math/Transform"),
                Trimesh: t("./shapes/Trimesh"),
                Vec3: t("./math/Vec3"),
                Vec3Pool: t("./utils/Vec3Pool"),
                World: t("./world/World")
            };
        }, {
            "../package.json": 1,
            "./collision/AABB": 3,
            "./collision/ArrayCollisionMatrix": 4,
            "./collision/Broadphase": 5,
            "./collision/GridBroadphase": 6,
            "./collision/NaiveBroadphase": 7,
            "./collision/ObjectCollisionMatrix": 8,
            "./collision/Ray": 10,
            "./collision/RaycastResult": 11,
            "./collision/SAPBroadphase": 12,
            "./constraints/ConeTwistConstraint": 13,
            "./constraints/Constraint": 14,
            "./constraints/DistanceConstraint": 15,
            "./constraints/HingeConstraint": 16,
            "./constraints/LockConstraint": 17,
            "./constraints/PointToPointConstraint": 18,
            "./equations/ContactEquation": 20,
            "./equations/Equation": 21,
            "./equations/FrictionEquation": 22,
            "./equations/RotationalEquation": 23,
            "./equations/RotationalMotorEquation": 24,
            "./material/ContactMaterial": 25,
            "./material/Material": 26,
            "./math/Mat3": 28,
            "./math/Quaternion": 29,
            "./math/Transform": 30,
            "./math/Vec3": 31,
            "./objects/Body": 32,
            "./objects/RaycastVehicle": 33,
            "./objects/RigidVehicle": 34,
            "./objects/SPHSystem": 35,
            "./objects/Spring": 36,
            "./shapes/Box": 38,
            "./shapes/ConvexPolyhedron": 39,
            "./shapes/Cylinder": 40,
            "./shapes/Heightfield": 41,
            "./shapes/Particle": 42,
            "./shapes/Plane": 43,
            "./shapes/Shape": 44,
            "./shapes/Sphere": 45,
            "./shapes/Trimesh": 46,
            "./solver/GSSolver": 47,
            "./solver/Solver": 48,
            "./solver/SplitSolver": 49,
            "./utils/EventTarget": 50,
            "./utils/Pool": 52,
            "./utils/Vec3Pool": 55,
            "./world/Narrowphase": 56,
            "./world/World": 57
        } ],
        3: [ function(t, e, i) {
            var o = t("../math/Vec3");
            function n(t) {
                t = t || {}, this.lowerBound = new o(), t.lowerBound && this.lowerBound.copy(t.lowerBound), 
                this.upperBound = new o(), t.upperBound && this.upperBound.copy(t.upperBound);
            }
            t("../utils/Utils"), e.exports = n;
            var l = new o();
            n.prototype.setFromPoints = function(t, e, i, o) {
                var n = this.lowerBound, s = this.upperBound, r = i;
                n.copy(t[0]), r && r.vmult(n, n), s.copy(n);
                for (var a = 1; a < t.length; a++) {
                    var h = t[a];
                    r && (r.vmult(h, l), h = l), h.x > s.x && (s.x = h.x), h.x < n.x && (n.x = h.x), 
                    h.y > s.y && (s.y = h.y), h.y < n.y && (n.y = h.y), h.z > s.z && (s.z = h.z), h.z < n.z && (n.z = h.z);
                }
                return e && (e.vadd(n, n), e.vadd(s, s)), o && (n.x -= o, n.y -= o, n.z -= o, s.x += o, 
                s.y += o, s.z += o), this;
            }, n.prototype.copy = function(t) {
                return this.lowerBound.copy(t.lowerBound), this.upperBound.copy(t.upperBound), this;
            }, n.prototype.clone = function() {
                return new n().copy(this);
            }, n.prototype.extend = function(t) {
                this.lowerBound.x = Math.min(this.lowerBound.x, t.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t.upperBound.x), 
                this.lowerBound.y = Math.min(this.lowerBound.y, t.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t.upperBound.y), 
                this.lowerBound.z = Math.min(this.lowerBound.z, t.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t.upperBound.z);
            }, n.prototype.overlaps = function(t) {
                var e = this.lowerBound, i = this.upperBound, o = t.lowerBound, n = t.upperBound, s = o.x <= i.x && i.x <= n.x || e.x <= n.x && n.x <= i.x, r = o.y <= i.y && i.y <= n.y || e.y <= n.y && n.y <= i.y, a = o.z <= i.z && i.z <= n.z || e.z <= n.z && n.z <= i.z;
                return s && r && a;
            }, n.prototype.volume = function() {
                var t = this.lowerBound, e = this.upperBound;
                return (e.x - t.x) * (e.y - t.y) * (e.z - t.z);
            }, n.prototype.contains = function(t) {
                var e = this.lowerBound, i = this.upperBound, o = t.lowerBound, n = t.upperBound;
                return e.x <= o.x && i.x >= n.x && e.y <= o.y && i.y >= n.y && e.z <= o.z && i.z >= n.z;
            }, n.prototype.getCorners = function(t, e, i, o, n, s, r, a) {
                var h = this.lowerBound, l = this.upperBound;
                t.copy(h), e.set(l.x, h.y, h.z), i.set(l.x, l.y, h.z), o.set(h.x, l.y, l.z), n.set(l.x, h.y, h.z), 
                s.set(h.x, l.y, h.z), r.set(h.x, h.y, l.z), a.copy(l);
            };
            var d = [ new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o() ];
            n.prototype.toLocalFrame = function(t, e) {
                var i = d, o = i[0], n = i[1], s = i[2], r = i[3], a = i[4], h = i[5], l = i[6], p = i[7];
                this.getCorners(o, n, s, r, a, h, l, p);
                for (var c = 0; 8 !== c; c++) {
                    var u = i[c];
                    t.pointToLocal(u, u);
                }
                return e.setFromPoints(i);
            }, n.prototype.toWorldFrame = function(t, e) {
                var i = d, o = i[0], n = i[1], s = i[2], r = i[3], a = i[4], h = i[5], l = i[6], p = i[7];
                this.getCorners(o, n, s, r, a, h, l, p);
                for (var c = 0; 8 !== c; c++) {
                    var u = i[c];
                    t.pointToWorld(u, u);
                }
                return e.setFromPoints(i);
            }, n.prototype.overlapsRay = function(t) {
                var e = 1 / t._direction.x, i = 1 / t._direction.y, o = 1 / t._direction.z, n = (this.lowerBound.x - t.from.x) * e, s = (this.upperBound.x - t.from.x) * e, r = (this.lowerBound.y - t.from.y) * i, a = (this.upperBound.y - t.from.y) * i, h = (this.lowerBound.z - t.from.z) * o, l = (this.upperBound.z - t.from.z) * o, p = Math.max(Math.max(Math.min(n, s), Math.min(r, a)), Math.min(h, l)), c = Math.min(Math.min(Math.max(n, s), Math.max(r, a)), Math.max(h, l));
                return !(c < 0 || c < p);
            };
        }, {
            "../math/Vec3": 31,
            "../utils/Utils": 54
        } ],
        4: [ function(t, e, i) {
            function o() {
                this.matrix = [];
            }
            (e.exports = o).prototype.get = function(t, e) {
                if ((t = t.index) < (e = e.index)) {
                    var i = e;
                    e = t, t = i;
                }
                return this.matrix[(t * (t + 1) >> 1) + e - 1];
            }, o.prototype.set = function(t, e, i) {
                if ((t = t.index) < (e = e.index)) {
                    var o = e;
                    e = t, t = o;
                }
                this.matrix[(t * (t + 1) >> 1) + e - 1] = i ? 1 : 0;
            }, o.prototype.reset = function() {
                for (var t = 0, e = this.matrix.length; t !== e; t++) this.matrix[t] = 0;
            }, o.prototype.setNumObjects = function(t) {
                this.matrix.length = t * (t - 1) >> 1;
            };
        }, {} ],
        5: [ function(t, e, i) {
            var o = t("../objects/Body"), n = t("../math/Vec3"), s = t("../math/Quaternion");
            function r() {
                this.world = null, this.useBoundingBoxes = !1, this.dirty = !0;
            }
            t("../shapes/Shape"), t("../shapes/Plane"), (e.exports = r).prototype.collisionPairs = function(t, e, i) {
                throw new Error("collisionPairs not implemented for this BroadPhase class!");
            }, r.prototype.needBroadphaseCollision = function(t, e) {
                return 0 != (t.collisionFilterGroup & e.collisionFilterMask) && 0 != (e.collisionFilterGroup & t.collisionFilterMask) && (0 == (t.type & o.STATIC) && t.sleepState !== o.SLEEPING || 0 == (e.type & o.STATIC) && e.sleepState !== o.SLEEPING);
            }, r.prototype.intersectionTest = function(t, e, i, o) {
                this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t, e, i, o) : this.doBoundingSphereBroadphase(t, e, i, o);
            };
            var a = new n();
            new n(), new s(), new n(), r.prototype.doBoundingSphereBroadphase = function(t, e, i, o) {
                var n = a;
                e.position.vsub(t.position, n);
                var s = Math.pow(t.boundingRadius + e.boundingRadius, 2);
                n.norm2() < s && (i.push(t), o.push(e));
            }, r.prototype.doBoundingBoxBroadphase = function(t, e, i, o) {
                t.aabbNeedsUpdate && t.computeAABB(), e.aabbNeedsUpdate && e.computeAABB(), t.aabb.overlaps(e.aabb) && (i.push(t), 
                o.push(e));
            };
            var c = {
                keys: []
            }, u = [], d = [];
            r.prototype.makePairsUnique = function(t, e) {
                for (var i = c, o = u, n = d, s = t.length, r = 0; r !== s; r++) o[r] = t[r], n[r] = e[r];
                for (t.length = 0, r = e.length = 0; r !== s; r++) {
                    var a = o[r].id, h = n[r].id;
                    i[l = a < h ? a + "," + h : h + "," + a] = r, i.keys.push(l);
                }
                for (r = 0; r !== i.keys.length; r++) {
                    var l = i.keys.pop(), p = i[l];
                    t.push(o[p]), e.push(n[p]), delete i[l];
                }
            }, r.prototype.setWorld = function(t) {};
            var h = new n();
            r.boundingSphereCheck = function(t, e) {
                var i = h;
                return t.position.vsub(e.position, i), Math.pow(t.shape.boundingSphereRadius + e.shape.boundingSphereRadius, 2) > i.norm2();
            }, r.prototype.aabbQuery = function(t, e, i) {
                return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), 
                [];
            };
        }, {
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../objects/Body": 32,
            "../shapes/Plane": 43,
            "../shapes/Shape": 44
        } ],
        6: [ function(t, e, i) {
            e.exports = o;
            var a = t("./Broadphase"), h = t("../math/Vec3"), it = t("../shapes/Shape");
            function o(t, e, i, o, n) {
                a.apply(this), this.nx = i || 10, this.ny = o || 10, this.nz = n || 10, this.aabbMin = t || new h(100, 100, 100), 
                this.aabbMax = e || new h(-100, -100, -100);
                var s = this.nx * this.ny * this.nz;
                if (s <= 0) throw "GridBroadphase: Each dimension's n must be >0";
                this.bins = [], this.binLengths = [], this.bins.length = s, this.binLengths.length = s;
                for (var r = 0; r < s; r++) this.bins[r] = [], this.binLengths[r] = 0;
            }
            (o.prototype = new a()).constructor = o;
            var ot = new h();
            new h(), o.prototype.collisionPairs = function(t, e, i) {
                for (var o = t.numObjects(), n = t.bodies, s = this.aabbMax, r = this.aabbMin, m = this.nx, w = this.ny, g = this.nz, x = w * g, b = g, B = 1, a = s.x, h = s.y, l = s.z, E = r.x, A = r.y, S = r.z, z = m / (a - E), M = w / (h - A), C = g / (l - S), p = (a - E) / m, c = (h - A) / w, u = (l - S) / g, d = .5 * Math.sqrt(p * p + c * c + u * u), v = it.types, y = v.SPHERE, f = v.PLANE, q = (v.BOX, 
                v.COMPOUND, v.CONVEXPOLYHEDRON, this.bins), F = this.binLengths, R = this.bins.length, T = 0; T !== R; T++) F[T] = 0;
                var P = Math.ceil;
                function V(t, e, i, o, n, s, r) {
                    var a = (t - E) * z | 0, h = (e - A) * M | 0, l = (i - S) * C | 0, p = P((o - E) * z), c = P((n - A) * M), u = P((s - S) * C);
                    a < 0 ? a = 0 : m <= a && (a = m - 1), h < 0 ? h = 0 : w <= h && (h = w - 1), l < 0 ? l = 0 : g <= l && (l = g - 1), 
                    p < 0 ? p = 0 : m <= p && (p = m - 1), c < 0 ? c = 0 : w <= c && (c = w - 1), u < 0 ? u = 0 : g <= u && (u = g - 1), 
                    h *= b, l *= B, p *= x, c *= b, u *= B;
                    for (var d = a *= x; d <= p; d += x) for (var v = h; v <= c; v += b) for (var y = l; y <= u; y += B) {
                        var f = d + v + y;
                        q[f][F[f]++] = r;
                    }
                }
                for (r = Math.min, s = Math.max, T = 0; T !== o; T++) {
                    var I = (tt = n[T]).shape;
                    switch (I.type) {
                      case y:
                        var N = tt.position.x, L = tt.position.y, W = tt.position.z, j = I.radius;
                        V(N - j, L - j, W - j, N + j, L + j, W + j, tt);
                        break;

                      case f:
                        I.worldNormalNeedsUpdate && I.computeWorldNormal(tt.quaternion);
                        var O = I.worldNormal, k = E + .5 * p - tt.position.x, _ = A + .5 * c - tt.position.y, D = S + .5 * u - tt.position.z, U = ot;
                        U.set(k, _, D);
                        for (var H = 0, G = 0; H !== m; H++, G += x, U.y = _, U.x += p) for (var X = 0, Q = 0; X !== w; X++, 
                        Q += b, U.z = D, U.y += c) for (var Y = 0, K = 0; Y !== g; Y++, K += B, U.z += u) if (U.dot(O) < d) {
                            var Z = G + Q + K;
                            q[Z][F[Z]++] = tt;
                        }
                        break;

                      default:
                        tt.aabbNeedsUpdate && tt.computeAABB(), V(tt.aabb.lowerBound.x, tt.aabb.lowerBound.y, tt.aabb.lowerBound.z, tt.aabb.upperBound.x, tt.aabb.upperBound.y, tt.aabb.upperBound.z, tt);
                    }
                }
                for (T = 0; T !== R; T++) {
                    var J = F[T];
                    if (1 < J) {
                        var $ = q[T];
                        for (H = 0; H !== J; H++) {
                            var tt = $[H];
                            for (X = 0; X !== H; X++) {
                                var et = $[X];
                                this.needBroadphaseCollision(tt, et) && this.intersectionTest(tt, et, e, i);
                            }
                        }
                    }
                }
                this.makePairsUnique(e, i);
            };
        }, {
            "../math/Vec3": 31,
            "../shapes/Shape": 44,
            "./Broadphase": 5
        } ],
        7: [ function(t, e, i) {
            e.exports = s;
            var o = t("./Broadphase"), n = t("./AABB");
            function s() {
                o.apply(this);
            }
            ((s.prototype = new o()).constructor = s).prototype.collisionPairs = function(t, e, i) {
                var o, n, s, r, a = t.bodies, h = a.length;
                for (o = 0; o !== h; o++) for (n = 0; n !== o; n++) s = a[o], r = a[n], this.needBroadphaseCollision(s, r) && this.intersectionTest(s, r, e, i);
            }, new n(), s.prototype.aabbQuery = function(t, e, i) {
                i = i || [];
                for (var o = 0; o < t.bodies.length; o++) {
                    var n = t.bodies[o];
                    n.aabbNeedsUpdate && n.computeAABB(), n.aabb.overlaps(e) && i.push(n);
                }
                return i;
            };
        }, {
            "./AABB": 3,
            "./Broadphase": 5
        } ],
        8: [ function(t, e, i) {
            function o() {
                this.matrix = {};
            }
            (e.exports = o).prototype.get = function(t, e) {
                if ((t = t.id) < (e = e.id)) {
                    var i = e;
                    e = t, t = i;
                }
                return t + "-" + e in this.matrix;
            }, o.prototype.set = function(t, e, i) {
                if ((t = t.id) < (e = e.id)) {
                    var o = e;
                    e = t, t = o;
                }
                i ? this.matrix[t + "-" + e] = !0 : delete this.matrix[t + "-" + e];
            }, o.prototype.reset = function() {
                this.matrix = {};
            }, o.prototype.setNumObjects = function(t) {};
        }, {} ],
        9: [ function(t, e, i) {
            function o() {
                this.current = [], this.previous = [];
            }
            function p(t, e) {
                t.push((4294901760 & e) >> 16, 65535 & e);
            }
            (e.exports = o).prototype.getKey = function(t, e) {
                if (e < t) {
                    var i = e;
                    e = t, t = i;
                }
                return t << 16 | e;
            }, o.prototype.set = function(t, e) {
                for (var i = this.getKey(t, e), o = this.current, n = 0; i > o[n]; ) n++;
                if (i !== o[n]) {
                    for (e = o.length - 1; n <= e; e--) o[e + 1] = o[e];
                    o[n] = i;
                }
            }, o.prototype.tick = function() {
                var t = this.current;
                this.current = this.previous, this.previous = t, this.current.length = 0;
            }, o.prototype.reset = function() {
                this.previous.length = 0, this.current.length = 0;
            }, o.prototype.getDiff = function(t, e) {
                for (var i = this.current, o = this.previous, n = i.length, s = o.length, r = 0, a = 0; a < n; a++) {
                    for (var h = i[a]; h > o[r]; ) r++;
                    h === o[r] || p(t, h);
                }
                for (a = r = 0; a < s; a++) {
                    for (var l = o[a]; l > i[r]; ) r++;
                    i[r] === l || p(e, l);
                }
            }, o.prototype.copy = function(t) {
                this.current.length = 0, this.previous.length = 0, this.current = t.current.slice(), 
                this.previous = t.previous.slice();
            };
        }, {} ],
        10: [ function(t, e, i) {
            e.exports = l;
            var f = t("../math/Vec3"), o = t("../math/Quaternion"), z = t("../math/Transform"), n = (t("../shapes/ConvexPolyhedron"), 
            t("../shapes/Box"), t("../collision/RaycastResult")), s = t("../shapes/Shape"), v = t("../collision/AABB");
            function l(t, e) {
                this.from = t ? t.clone() : new f(), this.to = e ? e.clone() : new f(), this._direction = new f(), 
                this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, 
                this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = l.ANY, 
                this.result = new n(), this.hasHit = !1, this.callback = function(t) {};
            }
            (l.prototype.constructor = l).CLOSEST = 1, l.ANY = 2, l.ALL = 4;
            var r = new v(), a = [];
            l.prototype.intersectWorld = function(t, e) {
                return this.mode = e.mode || l.ANY, this.result = e.result || new n(), this.skipBackfaces = !!e.skipBackfaces, 
                this.collisionFilterMask = void 0 !== e.collisionFilterMask ? e.collisionFilterMask : -1, 
                this.collisionFilterGroup = void 0 !== e.collisionFilterGroup ? e.collisionFilterGroup : -1, 
                e.from && this.from.copy(e.from), e.to && this.to.copy(e.to), this.callback = e.callback || function() {}, 
                this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(r), 
                a.length = 0, t.broadphase.aabbQuery(t, r, a), this.intersectBodies(a), this.hasHit;
            };
            var c = new f(), u = new f();
            function C(t, e, i, o) {
                o.vsub(e, d), i.vsub(e, c), t.vsub(e, u);
                var n, s, r = d.dot(d), a = d.dot(c), h = d.dot(u), l = c.dot(c), p = c.dot(u);
                return 0 <= (n = l * h - a * p) && 0 <= (s = r * p - a * h) && n + s < r * l - a * a;
            }
            l.pointInTriangle = C;
            var h = new f(), p = new o();
            l.prototype.intersectBody = function(t, e) {
                e && (this.result = e, this._updateDirection());
                var i = this.checkCollisionResponse;
                if ((!i || t.collisionResponse) && 0 != (this.collisionFilterGroup & t.collisionFilterMask) && 0 != (t.collisionFilterGroup & this.collisionFilterMask)) for (var o = h, n = p, s = 0, r = t.shapes.length; s < r; s++) {
                    var a = t.shapes[s];
                    if ((!i || a.collisionResponse) && (t.quaternion.mult(t.shapeOrientations[s], n), 
                    t.quaternion.vmult(t.shapeOffsets[s], o), o.vadd(t.position, o), this.intersectShape(a, n, o, t), 
                    this.result._shouldStop)) break;
                }
            }, l.prototype.intersectBodies = function(t, e) {
                e && (this.result = e, this._updateDirection());
                for (var i = 0, o = t.length; !this.result._shouldStop && i < o; i++) this.intersectBody(t[i]);
            }, l.prototype._updateDirection = function() {
                this.to.vsub(this.from, this._direction), this._direction.normalize();
            }, l.prototype.intersectShape = function(t, e, i, o) {
                if (!(function(t, e, i) {
                    i.vsub(t, d);
                    var o = d.dot(e);
                    return e.mult(o, B), B.vadd(t, B), i.distanceTo(B);
                }(this.from, this._direction, i) > t.boundingSphereRadius)) {
                    var n = this[t.type];
                    n && n.call(this, t, e, i, o, t);
                }
            }, new f(), new f();
            var q = new f(), F = new f(), R = new f(), T = new f();
            new f(), new n(), l.prototype.intersectBox = function(t, e, i, o, n) {
                return this.intersectConvex(t.convexPolyhedronRepresentation, e, i, o, n);
            }, l.prototype[s.types.BOX] = l.prototype.intersectBox, l.prototype.intersectPlane = function(t, e, i, o, n) {
                var s = this.from, r = this.to, a = this._direction, h = new f(0, 0, 1);
                e.vmult(h, h);
                var l = new f();
                s.vsub(i, l);
                var p = l.dot(h);
                if (r.vsub(i, l), !(0 < p * l.dot(h) || s.distanceTo(r) < p)) {
                    var c = h.dot(a);
                    if (!(Math.abs(c) < this.precision)) {
                        var u = new f(), d = new f(), v = new f();
                        s.vsub(i, u);
                        var y = -h.dot(u) / c;
                        a.scale(y, d), s.vadd(d, v), this.reportIntersection(h, v, n, o, -1);
                    }
                }
            }, l.prototype[s.types.PLANE] = l.prototype.intersectPlane, l.prototype.getAABB = function(t) {
                var e = this.to, i = this.from;
                t.lowerBound.x = Math.min(e.x, i.x), t.lowerBound.y = Math.min(e.y, i.y), t.lowerBound.z = Math.min(e.z, i.z), 
                t.upperBound.x = Math.max(e.x, i.x), t.upperBound.y = Math.max(e.y, i.y), t.upperBound.z = Math.max(e.z, i.z);
            };
            var y = {
                faceList: [ 0 ]
            }, m = new f(), w = new l(), g = [];
            l.prototype.intersectHeightfield = function(t, e, i, o, n) {
                t.data, t.elementSize;
                var s = w;
                s.from.copy(this.from), s.to.copy(this.to), z.pointToLocalFrame(i, e, s.from, s.from), 
                z.pointToLocalFrame(i, e, s.to, s.to), s._updateDirection();
                var r, a, h, l, p = g;
                r = a = 0, h = l = t.data.length - 1;
                var c = new v();
                s.getAABB(c), t.getIndexOfPosition(c.lowerBound.x, c.lowerBound.y, p, !0), r = Math.max(r, p[0]), 
                a = Math.max(a, p[1]), t.getIndexOfPosition(c.upperBound.x, c.upperBound.y, p, !0), 
                h = Math.min(h, p[0] + 1), l = Math.min(l, p[1] + 1);
                for (var u = r; u < h; u++) for (var d = a; d < l; d++) {
                    if (this.result._shouldStop) return;
                    if (t.getAabbAtIndex(u, d, c), c.overlapsRay(s)) {
                        if (t.getConvexTrianglePillar(u, d, !1), z.pointToWorldFrame(i, e, t.pillarOffset, m), 
                        this.intersectConvex(t.pillarConvex, e, m, o, n, y), this.result._shouldStop) return;
                        t.getConvexTrianglePillar(u, d, !0), z.pointToWorldFrame(i, e, t.pillarOffset, m), 
                        this.intersectConvex(t.pillarConvex, e, m, o, n, y);
                    }
                }
            }, l.prototype[s.types.HEIGHTFIELD] = l.prototype.intersectHeightfield;
            var x = new f(), b = new f();
            l.prototype.intersectSphere = function(t, e, i, o, n) {
                var s = this.from, r = this.to, a = t.radius, h = Math.pow(r.x - s.x, 2) + Math.pow(r.y - s.y, 2) + Math.pow(r.z - s.z, 2), l = 2 * ((r.x - s.x) * (s.x - i.x) + (r.y - s.y) * (s.y - i.y) + (r.z - s.z) * (s.z - i.z)), p = Math.pow(s.x - i.x, 2) + Math.pow(s.y - i.y, 2) + Math.pow(s.z - i.z, 2) - Math.pow(a, 2), c = Math.pow(l, 2) - 4 * h * p, u = x, d = b;
                if (!(c < 0)) if (0 == c) s.lerp(r, c, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1); else {
                    var v = (-l - Math.sqrt(c)) / (2 * h), y = (-l + Math.sqrt(c)) / (2 * h);
                    if (0 <= v && v <= 1 && (s.lerp(r, v, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1)), 
                    this.result._shouldStop) return;
                    0 <= y && y <= 1 && (s.lerp(r, y, u), u.vsub(i, d), d.normalize(), this.reportIntersection(d, u, n, o, -1));
                }
            }, l.prototype[s.types.SPHERE] = l.prototype.intersectSphere;
            var P = new f(), V = (new f(), new f(), new f());
            l.prototype.intersectConvex = function(t, e, i, o, n, s) {
                for (var r = P, a = V, h = s && s.faceList || null, l = t.faces, p = t.vertices, c = t.faceNormals, u = this._direction, d = this.from, v = this.to, y = d.distanceTo(v), f = h ? h.length : l.length, m = this.result, w = 0; !m._shouldStop && w < f; w++) {
                    var g = h ? h[w] : w, x = l[g], b = c[g], B = e, E = i;
                    a.copy(p[x[0]]), B.vmult(a, a), a.vadd(E, a), a.vsub(d, a), B.vmult(b, r);
                    var A = u.dot(r);
                    if (!(Math.abs(A) < this.precision)) {
                        var S = r.dot(a) / A;
                        if (!(S < 0)) {
                            u.mult(S, q), q.vadd(d, q), F.copy(p[x[0]]), B.vmult(F, F), E.vadd(F, F);
                            for (var z = 1; !m._shouldStop && z < x.length - 1; z++) {
                                R.copy(p[x[z]]), T.copy(p[x[z + 1]]), B.vmult(R, R), B.vmult(T, T), E.vadd(R, R), 
                                E.vadd(T, T);
                                var M = q.distanceTo(d);
                                !C(q, F, R, T) && !C(q, R, F, T) || y < M || this.reportIntersection(r, q, n, o, g);
                            }
                        }
                    }
                }
            }, l.prototype[s.types.CONVEXPOLYHEDRON] = l.prototype.intersectConvex;
            var M = new f(), I = new f(), N = new f(), L = new f(), W = new f(), j = new f(), O = (new v(), 
            []), k = new z();
            l.prototype.intersectTrimesh = function(t, e, i, o, n, s) {
                var r = M, a = O, h = k, l = V, p = I, c = N, u = L, d = j, v = W, y = (s && s.faceList, 
                t.indices), f = (t.vertices, t.faceNormals, this.from), m = this.to, w = this._direction;
                h.position.copy(i), h.quaternion.copy(e), z.vectorToLocalFrame(i, e, w, p), z.pointToLocalFrame(i, e, f, c), 
                z.pointToLocalFrame(i, e, m, u), u.x *= t.scale.x, u.y *= t.scale.y, u.z *= t.scale.z, 
                c.x *= t.scale.x, c.y *= t.scale.y, c.z *= t.scale.z, u.vsub(c, p), p.normalize();
                var g = c.distanceSquared(u);
                t.tree.rayQuery(this, h, a);
                for (var x = 0, b = a.length; !this.result._shouldStop && x !== b; x++) {
                    var B = a[x];
                    t.getNormal(B, r), t.getVertex(y[3 * B], F), F.vsub(c, l);
                    var E = p.dot(r), A = r.dot(l) / E;
                    if (!(A < 0)) {
                        p.scale(A, q), q.vadd(c, q), t.getVertex(y[3 * B + 1], R), t.getVertex(y[3 * B + 2], T);
                        var S = q.distanceSquared(c);
                        !C(q, R, F, T) && !C(q, F, R, T) || g < S || (z.vectorToWorldFrame(e, r, v), z.pointToWorldFrame(i, e, q, d), 
                        this.reportIntersection(v, d, n, o, B));
                    }
                }
                a.length = 0;
            }, l.prototype[s.types.TRIMESH] = l.prototype.intersectTrimesh, l.prototype.reportIntersection = function(t, e, i, o, n) {
                var s = this.from, r = this.to, a = s.distanceTo(e), h = this.result;
                if (!(this.skipBackfaces && 0 < t.dot(this._direction))) switch (h.hitFaceIndex = void 0 !== n ? n : -1, 
                this.mode) {
                  case l.ALL:
                    this.hasHit = !0, h.set(s, r, t, e, i, o, a), h.hasHit = !0, this.callback(h);
                    break;

                  case l.CLOSEST:
                    (a < h.distance || !h.hasHit) && (this.hasHit = !0, h.hasHit = !0, h.set(s, r, t, e, i, o, a));
                    break;

                  case l.ANY:
                    this.hasHit = !0, h.hasHit = !0, h.set(s, r, t, e, i, o, a), h._shouldStop = !0;
                }
            };
            var d = new f(), B = new f();
        }, {
            "../collision/AABB": 3,
            "../collision/RaycastResult": 11,
            "../math/Quaternion": 29,
            "../math/Transform": 30,
            "../math/Vec3": 31,
            "../shapes/Box": 38,
            "../shapes/ConvexPolyhedron": 39,
            "../shapes/Shape": 44
        } ],
        11: [ function(t, e, i) {
            var o = t("../math/Vec3");
            function n() {
                this.rayFromWorld = new o(), this.rayToWorld = new o(), this.hitNormalWorld = new o(), 
                this.hitPointWorld = new o(), this.hasHit = !1, this.shape = null, this.body = null, 
                this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
            }
            (e.exports = n).prototype.reset = function() {
                this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), 
                this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, 
                this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1;
            }, n.prototype.abort = function() {
                this._shouldStop = !0;
            }, n.prototype.set = function(t, e, i, o, n, s, r) {
                this.rayFromWorld.copy(t), this.rayToWorld.copy(e), this.hitNormalWorld.copy(i), 
                this.hitPointWorld.copy(o), this.shape = n, this.body = s, this.distance = r;
            };
        }, {
            "../math/Vec3": 31
        } ],
        12: [ function(t, e, i) {
            t("../shapes/Shape");
            var o = t("../collision/Broadphase");
            function p(t) {
                o.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0;
                var i = this.axisList;
                this._addBodyHandler = function(t) {
                    i.push(t.body);
                }, this._removeBodyHandler = function(t) {
                    var e = i.indexOf(t.body);
                    -1 !== e && i.splice(e, 1);
                }, t && this.setWorld(t);
            }
            ((e.exports = p).prototype = new o()).setWorld = function(t) {
                for (var e = this.axisList.length = 0; e < t.bodies.length; e++) this.axisList.push(t.bodies[e]);
                t.removeEventListener("addBody", this._addBodyHandler), t.removeEventListener("removeBody", this._removeBodyHandler), 
                t.addEventListener("addBody", this._addBodyHandler), t.addEventListener("removeBody", this._removeBodyHandler), 
                this.world = t, this.dirty = !0;
            }, p.insertionSortX = function(t) {
                for (var e = 1, i = t.length; e < i; e++) {
                    for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.x <= o.aabb.lowerBound.x); n--) t[n + 1] = t[n];
                    t[n + 1] = o;
                }
                return t;
            }, p.insertionSortY = function(t) {
                for (var e = 1, i = t.length; e < i; e++) {
                    for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.y <= o.aabb.lowerBound.y); n--) t[n + 1] = t[n];
                    t[n + 1] = o;
                }
                return t;
            }, p.insertionSortZ = function(t) {
                for (var e = 1, i = t.length; e < i; e++) {
                    for (var o = t[e], n = e - 1; 0 <= n && !(t[n].aabb.lowerBound.z <= o.aabb.lowerBound.z); n--) t[n + 1] = t[n];
                    t[n + 1] = o;
                }
                return t;
            }, p.prototype.collisionPairs = function(t, e, i) {
                var o, n, s = this.axisList, r = s.length, a = this.axisIndex;
                for (this.dirty && (this.sortList(), this.dirty = !1), o = 0; o !== r; o++) {
                    var h = s[o];
                    for (n = o + 1; n < r; n++) {
                        var l = s[n];
                        if (this.needBroadphaseCollision(h, l)) {
                            if (!p.checkBounds(h, l, a)) break;
                            this.intersectionTest(h, l, e, i);
                        }
                    }
                }
            }, p.prototype.sortList = function() {
                for (var t = this.axisList, e = this.axisIndex, i = t.length, o = 0; o !== i; o++) {
                    var n = t[o];
                    n.aabbNeedsUpdate && n.computeAABB();
                }
                0 === e ? p.insertionSortX(t) : 1 === e ? p.insertionSortY(t) : 2 === e && p.insertionSortZ(t);
            }, p.checkBounds = function(t, e, i) {
                var o, n;
                0 === i ? (o = t.position.x, n = e.position.x) : 1 === i ? (o = t.position.y, n = e.position.y) : 2 === i && (o = t.position.z, 
                n = e.position.z);
                var s = t.boundingRadius;
                return n - e.boundingRadius < o + s;
            }, p.prototype.autoDetectAxis = function() {
                for (var t = 0, e = 0, i = 0, o = 0, n = 0, s = 0, r = this.axisList, a = r.length, h = 1 / a, l = 0; l !== a; l++) {
                    var p = r[l], c = p.position.x;
                    t += c, e += c * c;
                    var u = p.position.y;
                    i += u, o += u * u;
                    var d = p.position.z;
                    n += d, s += d * d;
                }
                var v = e - t * t * h, y = o - i * i * h, f = s - n * n * h;
                this.axisIndex = y < v ? f < v ? 0 : 2 : f < y ? 1 : 2;
            }, p.prototype.aabbQuery = function(t, e, i) {
                i = i || [], this.dirty && (this.sortList(), this.dirty = !1);
                var o = this.axisIndex, n = "x";
                1 === o && (n = "y"), 2 === o && (n = "z");
                for (var s = this.axisList, r = (e.lowerBound[n], e.upperBound[n], 0); r < s.length; r++) {
                    var a = s[r];
                    a.aabbNeedsUpdate && a.computeAABB(), a.aabb.overlaps(e) && i.push(a);
                }
                return i;
            };
        }, {
            "../collision/Broadphase": 5,
            "../shapes/Shape": 44
        } ],
        13: [ function(t, e, i) {
            e.exports = o, t("./Constraint");
            var h = t("./PointToPointConstraint"), l = t("../equations/ConeEquation"), p = t("../equations/RotationalEquation"), c = (t("../equations/ContactEquation"), 
            t("../math/Vec3"));
            function o(t, e, i) {
                var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new c(), s = i.pivotB ? i.pivotB.clone() : new c();
                this.axisA = i.axisA ? i.axisA.clone() : new c(), this.axisB = i.axisB ? i.axisB.clone() : new c(), 
                h.call(this, t, n, e, s, o), this.collideConnected = !!i.collideConnected, this.angle = void 0 !== i.angle ? i.angle : 0;
                var r = this.coneEquation = new l(t, e, i), a = this.twistEquation = new p(t, e, i);
                this.twistAngle = void 0 !== i.twistAngle ? i.twistAngle : 0, r.maxForce = 0, r.minForce = -o, 
                a.maxForce = 0, a.minForce = -o, this.equations.push(r, a);
            }
            o.prototype = new h(), o.constructor = o, new c(), new c(), o.prototype.update = function() {
                var t = this.bodyA, e = this.bodyB, i = this.coneEquation, o = this.twistEquation;
                h.prototype.update.call(this), t.vectorToWorldFrame(this.axisA, i.axisA), e.vectorToWorldFrame(this.axisB, i.axisB), 
                this.axisA.tangents(o.axisA, o.axisA), t.vectorToWorldFrame(o.axisA, o.axisA), this.axisB.tangents(o.axisB, o.axisB), 
                e.vectorToWorldFrame(o.axisB, o.axisB), i.angle = this.angle, o.maxAngle = this.twistAngle;
            };
        }, {
            "../equations/ConeEquation": 19,
            "../equations/ContactEquation": 20,
            "../equations/RotationalEquation": 23,
            "../math/Vec3": 31,
            "./Constraint": 14,
            "./PointToPointConstraint": 18
        } ],
        14: [ function(t, e, i) {
            e.exports = n;
            var o = t("../utils/Utils");
            function n(t, e, i) {
                i = o.defaults(i, {
                    collideConnected: !0,
                    wakeUpBodies: !0
                }), this.equations = [], this.bodyA = t, this.bodyB = e, this.id = n.idCounter++, 
                this.collideConnected = i.collideConnected, i.wakeUpBodies && (t && t.wakeUp(), 
                e && e.wakeUp());
            }
            n.prototype.update = function() {
                throw new Error("method update() not implmemented in this Constraint subclass!");
            }, n.prototype.enable = function() {
                for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !0;
            }, n.prototype.disable = function() {
                for (var t = this.equations, e = 0; e < t.length; e++) t[e].enabled = !1;
            }, n.idCounter = 0;
        }, {
            "../utils/Utils": 54
        } ],
        15: [ function(t, e, i) {
            e.exports = o;
            var s = t("./Constraint"), r = t("../equations/ContactEquation");
            function o(t, e, i, o) {
                s.call(this, t, e), void 0 === i && (i = t.position.distanceTo(e.position)), void 0 === o && (o = 1e6), 
                this.distance = i;
                var n = this.distanceEquation = new r(t, e);
                this.equations.push(n), n.minForce = -o, n.maxForce = o;
            }
            (o.prototype = new s()).update = function() {
                var t = this.bodyA, e = this.bodyB, i = this.distanceEquation, o = .5 * this.distance, n = i.ni;
                e.position.vsub(t.position, n), n.normalize(), n.mult(o, i.ri), n.mult(-o, i.rj);
            };
        }, {
            "../equations/ContactEquation": 20,
            "./Constraint": 14
        } ],
        16: [ function(t, e, i) {
            e.exports = o, t("./Constraint");
            var l = t("./PointToPointConstraint"), p = t("../equations/RotationalEquation"), c = t("../equations/RotationalMotorEquation"), u = (t("../equations/ContactEquation"), 
            t("../math/Vec3"));
            function o(t, e, i) {
                var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new u(), s = i.pivotB ? i.pivotB.clone() : new u();
                l.call(this, t, n, e, s, o), (this.axisA = i.axisA ? i.axisA.clone() : new u(1, 0, 0)).normalize(), 
                (this.axisB = i.axisB ? i.axisB.clone() : new u(1, 0, 0)).normalize();
                var r = this.rotationalEquation1 = new p(t, e, i), a = this.rotationalEquation2 = new p(t, e, i), h = this.motorEquation = new c(t, e, o);
                h.enabled = !1, this.equations.push(r, a, h);
            }
            o.prototype = new l(), (o.constructor = o).prototype.enableMotor = function() {
                this.motorEquation.enabled = !0;
            }, o.prototype.disableMotor = function() {
                this.motorEquation.enabled = !1;
            }, o.prototype.setMotorSpeed = function(t) {
                this.motorEquation.targetVelocity = t;
            }, o.prototype.setMotorMaxForce = function(t) {
                this.motorEquation.maxForce = t, this.motorEquation.minForce = -t;
            };
            var d = new u(), v = new u();
            o.prototype.update = function() {
                var t = this.bodyA, e = this.bodyB, i = this.motorEquation, o = this.rotationalEquation1, n = this.rotationalEquation2, s = d, r = v, a = this.axisA, h = this.axisB;
                l.prototype.update.call(this), t.quaternion.vmult(a, s), e.quaternion.vmult(h, r), 
                s.tangents(o.axisA, n.axisA), o.axisB.copy(r), n.axisB.copy(r), this.motorEquation.enabled && (t.quaternion.vmult(this.axisA, i.axisA), 
                e.quaternion.vmult(this.axisB, i.axisB));
            };
        }, {
            "../equations/ContactEquation": 20,
            "../equations/RotationalEquation": 23,
            "../equations/RotationalMotorEquation": 24,
            "../math/Vec3": 31,
            "./Constraint": 14,
            "./PointToPointConstraint": 18
        } ],
        17: [ function(t, e, i) {
            e.exports = o, t("./Constraint");
            var p = t("./PointToPointConstraint"), c = t("../equations/RotationalEquation"), u = (t("../equations/RotationalMotorEquation"), 
            t("../equations/ContactEquation"), t("../math/Vec3"));
            function o(t, e, i) {
                var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = new u(), s = new u(), r = new u();
                t.position.vadd(e.position, r), r.scale(.5, r), e.pointToLocalFrame(r, s), t.pointToLocalFrame(r, n), 
                p.call(this, t, n, e, s, o), this.xA = t.vectorToLocalFrame(u.UNIT_X), this.xB = e.vectorToLocalFrame(u.UNIT_X), 
                this.yA = t.vectorToLocalFrame(u.UNIT_Y), this.yB = e.vectorToLocalFrame(u.UNIT_Y), 
                this.zA = t.vectorToLocalFrame(u.UNIT_Z), this.zB = e.vectorToLocalFrame(u.UNIT_Z);
                var a = this.rotationalEquation1 = new c(t, e, i), h = this.rotationalEquation2 = new c(t, e, i), l = this.rotationalEquation3 = new c(t, e, i);
                this.equations.push(a, h, l);
            }
            o.prototype = new p(), o.constructor = o, new u(), new u(), o.prototype.update = function() {
                var t = this.bodyA, e = this.bodyB, i = (this.motorEquation, this.rotationalEquation1), o = this.rotationalEquation2, n = this.rotationalEquation3;
                p.prototype.update.call(this), t.vectorToWorldFrame(this.xA, i.axisA), e.vectorToWorldFrame(this.yB, i.axisB), 
                t.vectorToWorldFrame(this.yA, o.axisA), e.vectorToWorldFrame(this.zB, o.axisB), 
                t.vectorToWorldFrame(this.zA, n.axisA), e.vectorToWorldFrame(this.xB, n.axisB);
            };
        }, {
            "../equations/ContactEquation": 20,
            "../equations/RotationalEquation": 23,
            "../equations/RotationalMotorEquation": 24,
            "../math/Vec3": 31,
            "./Constraint": 14,
            "./PointToPointConstraint": 18
        } ],
        18: [ function(t, e, i) {
            e.exports = o;
            var h = t("./Constraint"), l = t("../equations/ContactEquation"), p = t("../math/Vec3");
            function o(t, e, i, o, n) {
                h.call(this, t, i), n = void 0 !== n ? n : 1e6, this.pivotA = e ? e.clone() : new p(), 
                this.pivotB = o ? o.clone() : new p();
                var s = this.equationX = new l(t, i), r = this.equationY = new l(t, i), a = this.equationZ = new l(t, i);
                this.equations.push(s, r, a), s.minForce = r.minForce = a.minForce = -n, s.maxForce = r.maxForce = a.maxForce = n, 
                s.ni.set(1, 0, 0), r.ni.set(0, 1, 0), a.ni.set(0, 0, 1);
            }
            (o.prototype = new h()).update = function() {
                var t = this.bodyA, e = this.bodyB, i = this.equationX, o = this.equationY, n = this.equationZ;
                t.quaternion.vmult(this.pivotA, i.ri), e.quaternion.vmult(this.pivotB, i.rj), o.ri.copy(i.ri), 
                o.rj.copy(i.rj), n.ri.copy(i.ri), n.rj.copy(i.rj);
            };
        }, {
            "../equations/ContactEquation": 20,
            "../math/Vec3": 31,
            "./Constraint": 14
        } ],
        19: [ function(t, e, i) {
            e.exports = o;
            var n = t("../math/Vec3"), s = (t("../math/Mat3"), t("./Equation"));
            function o(t, e, i) {
                var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
                s.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), 
                this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.angle = void 0 !== i.angle ? i.angle : 0;
            }
            (o.prototype = new s()).constructor = o;
            var l = new n(), p = new n();
            o.prototype.computeB = function(t) {
                var e = this.a, i = this.b, o = this.axisA, n = this.axisB, s = l, r = p, a = this.jacobianElementA, h = this.jacobianElementB;
                return o.cross(n, s), n.cross(o, r), a.rotational.copy(r), h.rotational.copy(s), 
                -(Math.cos(this.angle) - o.dot(n)) * e - this.computeGW() * i - t * this.computeGiMf();
            };
        }, {
            "../math/Mat3": 28,
            "../math/Vec3": 31,
            "./Equation": 21
        } ],
        20: [ function(t, e, i) {
            e.exports = s;
            var o = t("./Equation"), n = t("../math/Vec3");
            function s(t, e, i) {
                i = void 0 !== i ? i : 1e6, o.call(this, t, e, 0, i), this.si = null, this.sj = null, 
                this.restitution = 0, this.ri = new n(), this.rj = new n(), this.ni = new n();
            }
            t("../math/Mat3"), (s.prototype = new o()).constructor = s;
            var g = new n(), x = new n(), b = new n();
            s.prototype.computeB = function(t) {
                var e = this.a, i = this.b, o = this.bi, n = this.bj, s = this.ri, r = this.rj, a = g, h = x, l = o.velocity, p = o.angularVelocity, c = (o.force, 
                o.torque, n.velocity), u = n.angularVelocity, d = (n.force, n.torque, b), v = this.jacobianElementA, y = this.jacobianElementB, f = this.ni;
                s.cross(f, a), r.cross(f, h), f.negate(v.spatial), a.negate(v.rotational), y.spatial.copy(f), 
                y.rotational.copy(h), d.copy(n.position), d.vadd(r, d), d.vsub(o.position, d), d.vsub(s, d);
                var m = f.dot(d), w = this.restitution + 1;
                return -m * e - (w * c.dot(f) - w * l.dot(f) + u.dot(h) - p.dot(a)) * i - t * this.computeGiMf();
            };
            var r = new n(), a = new n(), h = new n(), l = new n(), p = new n();
            s.prototype.getImpactVelocityAlongNormal = function() {
                var t = r, e = a, i = h, o = l, n = p;
                return this.bi.position.vadd(this.ri, i), this.bj.position.vadd(this.rj, o), this.bi.getVelocityAtWorldPoint(i, t), 
                this.bj.getVelocityAtWorldPoint(o, e), t.vsub(e, n), this.ni.dot(n);
            };
        }, {
            "../math/Mat3": 28,
            "../math/Vec3": 31,
            "./Equation": 21
        } ],
        21: [ function(t, e, i) {
            e.exports = s;
            var n = t("../math/JacobianElement"), o = t("../math/Vec3");
            function s(t, e, i, o) {
                this.id = s.id++, this.minForce = void 0 === i ? -1e6 : i, this.maxForce = void 0 === o ? 1e6 : o, 
                this.bi = t, this.bj = e, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new n(), 
                this.jacobianElementB = new n(), this.enabled = !0, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
            }
            (s.prototype.constructor = s).id = 0, s.prototype.setSpookParams = function(t, e, i) {
                var o = e, n = t, s = i;
                this.a = 4 / (s * (1 + 4 * o)), this.b = 4 * o / (1 + 4 * o), this.eps = 4 / (s * s * n * (1 + 4 * o));
            }, s.prototype.computeB = function(t, e, i) {
                var o = this.computeGW();
                return -this.computeGq() * t - o * e - this.computeGiMf() * i;
            }, s.prototype.computeGq = function() {
                var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.position, s = o.position;
                return t.spatial.dot(n) + e.spatial.dot(s);
            }, new o(), s.prototype.computeGW = function() {
                var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.velocity, s = o.velocity, r = i.angularVelocity, a = o.angularVelocity;
                return t.multiplyVectors(n, r) + e.multiplyVectors(s, a);
            }, s.prototype.computeGWlambda = function() {
                var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.vlambda, s = o.vlambda, r = i.wlambda, a = o.wlambda;
                return t.multiplyVectors(n, r) + e.multiplyVectors(s, a);
            };
            var p = new o(), c = new o(), u = new o(), d = new o();
            s.prototype.computeGiMf = function() {
                var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.force, s = i.torque, r = o.force, a = o.torque, h = i.invMassSolve, l = o.invMassSolve;
                return n.scale(h, p), r.scale(l, c), i.invInertiaWorldSolve.vmult(s, u), o.invInertiaWorldSolve.vmult(a, d), 
                t.multiplyVectors(p, u) + e.multiplyVectors(c, d);
            };
            var l = new o();
            s.prototype.computeGiMGt = function() {
                var t = this.jacobianElementA, e = this.jacobianElementB, i = this.bi, o = this.bj, n = i.invMassSolve, s = o.invMassSolve, r = i.invInertiaWorldSolve, a = o.invInertiaWorldSolve, h = n + s;
                return r.vmult(t.rotational, l), h += l.dot(t.rotational), a.vmult(e.rotational, l), 
                h + l.dot(e.rotational);
            };
            var r = new o();
            new o(), new o(), new o(), new o(), new o(), s.prototype.addToWlambda = function(t) {
                var e = this.jacobianElementA, i = this.jacobianElementB, o = this.bi, n = this.bj, s = r;
                o.vlambda.addScaledVector(o.invMassSolve * t, e.spatial, o.vlambda), n.vlambda.addScaledVector(n.invMassSolve * t, i.spatial, n.vlambda), 
                o.invInertiaWorldSolve.vmult(e.rotational, s), o.wlambda.addScaledVector(t, s, o.wlambda), 
                n.invInertiaWorldSolve.vmult(i.rotational, s), n.wlambda.addScaledVector(t, s, n.wlambda);
            }, s.prototype.computeC = function() {
                return this.computeGiMGt() + this.eps;
            };
        }, {
            "../math/JacobianElement": 27,
            "../math/Vec3": 31
        } ],
        22: [ function(t, e, i) {
            e.exports = s;
            var o = t("./Equation"), n = t("../math/Vec3");
            function s(t, e, i) {
                o.call(this, t, e, -i, i), this.ri = new n(), this.rj = new n(), this.t = new n();
            }
            t("../math/Mat3"), (s.prototype = new o()).constructor = s;
            var l = new n(), p = new n();
            s.prototype.computeB = function(t) {
                this.a;
                var e = this.b, i = (this.bi, this.bj, this.ri), o = this.rj, n = l, s = p, r = this.t;
                i.cross(r, n), o.cross(r, s);
                var a = this.jacobianElementA, h = this.jacobianElementB;
                return r.negate(a.spatial), n.negate(a.rotational), h.spatial.copy(r), h.rotational.copy(s), 
                -this.computeGW() * e - t * this.computeGiMf();
            };
        }, {
            "../math/Mat3": 28,
            "../math/Vec3": 31,
            "./Equation": 21
        } ],
        23: [ function(t, e, i) {
            e.exports = o;
            var n = t("../math/Vec3"), s = (t("../math/Mat3"), t("./Equation"));
            function o(t, e, i) {
                var o = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6;
                s.call(this, t, e, -o, o), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), 
                this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.maxAngle = Math.PI / 2;
            }
            (o.prototype = new s()).constructor = o;
            var l = new n(), p = new n();
            o.prototype.computeB = function(t) {
                var e = this.a, i = this.b, o = this.axisA, n = this.axisB, s = l, r = p, a = this.jacobianElementA, h = this.jacobianElementB;
                return o.cross(n, s), n.cross(o, r), a.rotational.copy(r), h.rotational.copy(s), 
                -(Math.cos(this.maxAngle) - o.dot(n)) * e - this.computeGW() * i - t * this.computeGiMf();
            };
        }, {
            "../math/Mat3": 28,
            "../math/Vec3": 31,
            "./Equation": 21
        } ],
        24: [ function(t, e, i) {
            e.exports = s;
            var o = t("../math/Vec3"), n = (t("../math/Mat3"), t("./Equation"));
            function s(t, e, i) {
                i = void 0 !== i ? i : 1e6, n.call(this, t, e, -i, i), this.axisA = new o(), this.axisB = new o(), 
                this.targetVelocity = 0;
            }
            ((s.prototype = new n()).constructor = s).prototype.computeB = function(t) {
                this.a;
                var e = this.b, i = (this.bi, this.bj, this.axisA), o = this.axisB, n = this.jacobianElementA, s = this.jacobianElementB;
                return n.rotational.copy(i), o.negate(s.rotational), -(this.computeGW() - this.targetVelocity) * e - t * this.computeGiMf();
            };
        }, {
            "../math/Mat3": 28,
            "../math/Vec3": 31,
            "./Equation": 21
        } ],
        25: [ function(t, e, i) {
            var o = t("../utils/Utils");
            (e.exports = function n(t, e, i) {
                i = o.defaults(i, {
                    friction: .3,
                    restitution: .3,
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3,
                    frictionEquationStiffness: 1e7,
                    frictionEquationRelaxation: 3
                }), this.id = n.idCounter++, this.materials = [ t, e ], this.friction = i.friction, 
                this.restitution = i.restitution, this.contactEquationStiffness = i.contactEquationStiffness, 
                this.contactEquationRelaxation = i.contactEquationRelaxation, this.frictionEquationStiffness = i.frictionEquationStiffness, 
                this.frictionEquationRelaxation = i.frictionEquationRelaxation;
            }).idCounter = 0;
        }, {
            "../utils/Utils": 54
        } ],
        26: [ function(t, e, i) {
            (e.exports = function o(t) {
                var e = "";
                "string" == typeof (t = t || {}) ? (e = t, t = {}) : "object" == typeof t && (e = ""), 
                this.name = e, this.id = o.idCounter++, this.friction = void 0 !== t.friction ? t.friction : -1, 
                this.restitution = void 0 !== t.restitution ? t.restitution : -1;
            }).idCounter = 0;
        }, {} ],
        27: [ function(t, e, i) {
            e.exports = n;
            var o = t("./Vec3");
            function n() {
                this.spatial = new o(), this.rotational = new o();
            }
            n.prototype.multiplyElement = function(t) {
                return t.spatial.dot(this.spatial) + t.rotational.dot(this.rotational);
            }, n.prototype.multiplyVectors = function(t, e) {
                return t.dot(this.spatial) + e.dot(this.rotational);
            };
        }, {
            "./Vec3": 31
        } ],
        28: [ function(t, e, i) {
            e.exports = l;
            var p = t("./Vec3");
            function l(t) {
                this.elements = t || [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
            }
            l.prototype.identity = function() {
                var t = this.elements;
                t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, 
                t[8] = 1;
            }, l.prototype.setZero = function() {
                var t = this.elements;
                t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, 
                t[8] = 0;
            }, l.prototype.setTrace = function(t) {
                var e = this.elements;
                e[0] = t.x, e[4] = t.y, e[8] = t.z;
            }, l.prototype.getTrace = function(t) {
                t = t || new p();
                var e = this.elements;
                t.x = e[0], t.y = e[4], t.z = e[8];
            }, l.prototype.vmult = function(t, e) {
                e = e || new p();
                var i = this.elements, o = t.x, n = t.y, s = t.z;
                return e.x = i[0] * o + i[1] * n + i[2] * s, e.y = i[3] * o + i[4] * n + i[5] * s, 
                e.z = i[6] * o + i[7] * n + i[8] * s, e;
            }, l.prototype.smult = function(t) {
                for (var e = 0; e < this.elements.length; e++) this.elements[e] *= t;
            }, l.prototype.mmult = function(t, e) {
                for (var i = e || new l(), o = 0; o < 3; o++) for (var n = 0; n < 3; n++) {
                    for (var s = 0, r = 0; r < 3; r++) s += t.elements[o + 3 * r] * this.elements[r + 3 * n];
                    i.elements[o + 3 * n] = s;
                }
                return i;
            }, l.prototype.scale = function(t, e) {
                e = e || new l();
                for (var i = this.elements, o = e.elements, n = 0; 3 !== n; n++) o[3 * n + 0] = t.x * i[3 * n + 0], 
                o[3 * n + 1] = t.y * i[3 * n + 1], o[3 * n + 2] = t.z * i[3 * n + 2];
                return e;
            }, l.prototype.solve = function(t, e) {
                e = e || new p();
                for (var i, o = [], n = 0; n < 12; n++) o.push(0);
                for (n = 0; n < 3; n++) for (i = 0; i < 3; i++) o[n + 4 * i] = this.elements[n + 3 * i];
                o[3] = t.x, o[7] = t.y, o[11] = t.z;
                var s, r, a = 3, h = a;
                do {
                    if (0 === o[(n = h - a) + 4 * n]) for (i = n + 1; i < h; i++) if (0 !== o[n + 4 * i]) {
                        for (s = 4; o[(r = 4 - s) + 4 * n] += o[r + 4 * i], --s; ) ;
                        break;
                    }
                    if (0 !== o[n + 4 * n]) for (i = n + 1; i < h; i++) {
                        var l = o[n + 4 * i] / o[n + 4 * n];
                        for (s = 4; o[(r = 4 - s) + 4 * i] = r <= n ? 0 : o[r + 4 * i] - o[r + 4 * n] * l, 
                        --s; ) ;
                    }
                } while (--a);
                if (e.z = o[11] / o[10], e.y = (o[7] - o[6] * e.z) / o[5], e.x = (o[3] - o[2] * e.z - o[1] * e.y) / o[0], 
                isNaN(e.x) || isNaN(e.y) || isNaN(e.z) || e.x === 1 / 0 || e.y === 1 / 0 || e.z === 1 / 0) throw "Could not solve equation! Got x=[" + e.toString() + "], b=[" + t.toString() + "], A=[" + this.toString() + "]";
                return e;
            }, l.prototype.e = function(t, e, i) {
                if (void 0 === i) return this.elements[e + 3 * t];
                this.elements[e + 3 * t] = i;
            }, l.prototype.copy = function(t) {
                for (var e = 0; e < t.elements.length; e++) this.elements[e] = t.elements[e];
                return this;
            }, l.prototype.toString = function() {
                for (var t = "", e = 0; e < 9; e++) t += this.elements[e] + ",";
                return t;
            }, l.prototype.reverse = function(t) {
                t = t || new l();
                for (var e, i = [], o = 0; o < 18; o++) i.push(0);
                for (o = 0; o < 3; o++) for (e = 0; e < 3; e++) i[o + 6 * e] = this.elements[o + 3 * e];
                i[3] = 1, i[9] = 0, i[15] = 0, i[4] = 0, i[10] = 1, i[16] = 0, i[5] = 0, i[11] = 0, 
                i[17] = 1;
                var n, s, r = 3, a = r;
                do {
                    if (0 === i[(o = a - r) + 6 * o]) for (e = o + 1; e < a; e++) if (0 !== i[o + 6 * e]) {
                        for (n = 6; i[(s = 6 - n) + 6 * o] += i[s + 6 * e], --n; ) ;
                        break;
                    }
                    if (0 !== i[o + 6 * o]) for (e = o + 1; e < a; e++) {
                        var h = i[o + 6 * e] / i[o + 6 * o];
                        for (n = 6; i[(s = 6 - n) + 6 * e] = s <= o ? 0 : i[s + 6 * e] - i[s + 6 * o] * h, 
                        --n; ) ;
                    }
                } while (--r);
                o = 2;
                do {
                    e = o - 1;
                    do {
                        for (h = i[o + 6 * e] / i[o + 6 * o], n = 6; i[(s = 6 - n) + 6 * e] = i[s + 6 * e] - i[s + 6 * o] * h, 
                        --n; ) ;
                    } while (e--);
                } while (--o);
                o = 2;
                do {
                    for (h = 1 / i[o + 6 * o], n = 6; i[(s = 6 - n) + 6 * o] = i[s + 6 * o] * h, --n; ) ;
                } while (o--);
                o = 2;
                do {
                    e = 2;
                    do {
                        if (s = i[3 + e + 6 * o], isNaN(s) || s === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
                        t.e(o, e, s);
                    } while (e--);
                } while (o--);
                return t;
            }, l.prototype.setRotationFromQuaternion = function(t) {
                var e = t.x, i = t.y, o = t.z, n = t.w, s = e + e, r = i + i, a = o + o, h = e * s, l = e * r, p = e * a, c = i * r, u = i * a, d = o * a, v = n * s, y = n * r, f = n * a, m = this.elements;
                return m[0] = 1 - (c + d), m[1] = l - f, m[2] = p + y, m[3] = l + f, m[4] = 1 - (h + d), 
                m[5] = u - v, m[6] = p - y, m[7] = u + v, m[8] = 1 - (h + c), this;
            }, l.prototype.transpose = function(t) {
                for (var e = (t = t || new l()).elements, i = this.elements, o = 0; 3 !== o; o++) for (var n = 0; 3 !== n; n++) e[3 * o + n] = i[3 * n + o];
                return t;
            };
        }, {
            "./Vec3": 31
        } ],
        29: [ function(t, e, i) {
            e.exports = f;
            var d = t("./Vec3");
            function f(t, e, i, o) {
                this.x = void 0 !== t ? t : 0, this.y = void 0 !== e ? e : 0, this.z = void 0 !== i ? i : 0, 
                this.w = void 0 !== o ? o : 1;
            }
            f.prototype.set = function(t, e, i, o) {
                return this.x = t, this.y = e, this.z = i, this.w = o, this;
            }, f.prototype.toString = function() {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            }, f.prototype.toArray = function() {
                return [ this.x, this.y, this.z, this.w ];
            }, f.prototype.setFromAxisAngle = function(t, e) {
                var i = Math.sin(.5 * e);
                return this.x = t.x * i, this.y = t.y * i, this.z = t.z * i, this.w = Math.cos(.5 * e), 
                this;
            }, f.prototype.toAxisAngle = function(t) {
                t = t || new d(), this.normalize();
                var e = 2 * Math.acos(this.w), i = Math.sqrt(1 - this.w * this.w);
                return i < .001 ? (t.x = this.x, t.y = this.y, t.z = this.z) : (t.x = this.x / i, 
                t.y = this.y / i, t.z = this.z / i), [ t, e ];
            };
            var s = new d(), r = new d();
            f.prototype.setFromVectors = function(t, e) {
                if (t.isAntiparallelTo(e)) {
                    var i = s, o = r;
                    t.tangents(i, o), this.setFromAxisAngle(i, Math.PI);
                } else {
                    var n = t.cross(e);
                    this.x = n.x, this.y = n.y, this.z = n.z, this.w = Math.sqrt(Math.pow(t.norm(), 2) * Math.pow(e.norm(), 2)) + t.dot(e), 
                    this.normalize();
                }
                return this;
            }, new d(), new d(), new d(), f.prototype.mult = function(t, e) {
                e = e || new f();
                var i = this.x, o = this.y, n = this.z, s = this.w, r = t.x, a = t.y, h = t.z, l = t.w;
                return e.x = i * l + s * r + o * h - n * a, e.y = o * l + s * a + n * r - i * h, 
                e.z = n * l + s * h + i * a - o * r, e.w = s * l - i * r - o * a - n * h, e;
            }, f.prototype.inverse = function(t) {
                var e = this.x, i = this.y, o = this.z, n = this.w;
                t = t || new f(), this.conjugate(t);
                var s = 1 / (e * e + i * i + o * o + n * n);
                return t.x *= s, t.y *= s, t.z *= s, t.w *= s, t;
            }, f.prototype.conjugate = function(t) {
                return (t = t || new f()).x = -this.x, t.y = -this.y, t.z = -this.z, t.w = this.w, 
                t;
            }, f.prototype.normalize = function() {
                var t = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                return 0 === t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t = 1 / t, 
                this.x *= t, this.y *= t, this.z *= t, this.w *= t), this;
            }, f.prototype.normalizeFast = function() {
                var t = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
                return 0 == t ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t, 
                this.y *= t, this.z *= t, this.w *= t), this;
            }, f.prototype.vmult = function(t, e) {
                e = e || new d();
                var i = t.x, o = t.y, n = t.z, s = this.x, r = this.y, a = this.z, h = this.w, l = h * i + r * n - a * o, p = h * o + a * i - s * n, c = h * n + s * o - r * i, u = -s * i - r * o - a * n;
                return e.x = l * h + u * -s + p * -a - c * -r, e.y = p * h + u * -r + c * -s - l * -a, 
                e.z = c * h + u * -a + l * -r - p * -s, e;
            }, f.prototype.copy = function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this;
            }, f.prototype.toEuler = function(t, e) {
                var i, o, n;
                e = e || "YZX";
                var s = this.x, r = this.y, a = this.z, h = this.w;
                switch (e) {
                  case "YZX":
                    var l = s * r + a * h;
                    if (.499 < l && (i = 2 * Math.atan2(s, h), o = Math.PI / 2, n = 0), l < -.499 && (i = -2 * Math.atan2(s, h), 
                    o = -Math.PI / 2, n = 0), isNaN(i)) {
                        var p = s * s, c = r * r, u = a * a;
                        i = Math.atan2(2 * r * h - 2 * s * a, 1 - 2 * c - 2 * u), o = Math.asin(2 * l), 
                        n = Math.atan2(2 * s * h - 2 * r * a, 1 - 2 * p - 2 * u);
                    }
                    break;

                  default:
                    throw new Error("Euler order " + e + " not supported yet.");
                }
                t.y = i, t.z = o, t.x = n;
            }, f.prototype.setFromEuler = function(t, e, i, o) {
                o = o || "XYZ";
                var n = Math.cos(t / 2), s = Math.cos(e / 2), r = Math.cos(i / 2), a = Math.sin(t / 2), h = Math.sin(e / 2), l = Math.sin(i / 2);
                return "XYZ" === o ? (this.x = a * s * r + n * h * l, this.y = n * h * r - a * s * l, 
                this.z = n * s * l + a * h * r, this.w = n * s * r - a * h * l) : "YXZ" === o ? (this.x = a * s * r + n * h * l, 
                this.y = n * h * r - a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r + a * h * l) : "ZXY" === o ? (this.x = a * s * r - n * h * l, 
                this.y = n * h * r + a * s * l, this.z = n * s * l + a * h * r, this.w = n * s * r - a * h * l) : "ZYX" === o ? (this.x = a * s * r - n * h * l, 
                this.y = n * h * r + a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r + a * h * l) : "YZX" === o ? (this.x = a * s * r + n * h * l, 
                this.y = n * h * r + a * s * l, this.z = n * s * l - a * h * r, this.w = n * s * r - a * h * l) : "XZY" === o && (this.x = a * s * r - n * h * l, 
                this.y = n * h * r - a * s * l, this.z = n * s * l + a * h * r, this.w = n * s * r + a * h * l), 
                this;
            }, f.prototype.clone = function() {
                return new f(this.x, this.y, this.z, this.w);
            }, f.prototype.slerp = function(t, e, i) {
                i = i || new f();
                var o, n, s, r, a, h = this.x, l = this.y, p = this.z, c = this.w, u = t.x, d = t.y, v = t.z, y = t.w;
                return (n = h * u + l * d + p * v + c * y) < 0 && (n = -n, u = -u, d = -d, v = -v, 
                y = -y), a = 1e-6 < 1 - n ? (o = Math.acos(n), s = Math.sin(o), r = Math.sin((1 - e) * o) / s, 
                Math.sin(e * o) / s) : (r = 1 - e, e), i.x = r * h + a * u, i.y = r * l + a * d, 
                i.z = r * p + a * v, i.w = r * c + a * y, i;
            }, f.prototype.integrate = function(t, e, i, o) {
                o = o || new f();
                var n = t.x * i.x, s = t.y * i.y, r = t.z * i.z, a = this.x, h = this.y, l = this.z, p = this.w, c = .5 * e;
                return o.x += c * (n * p + s * l - r * h), o.y += c * (s * p + r * a - n * l), o.z += c * (r * p + n * h - s * a), 
                o.w += c * (-n * a - s * h - r * l), o;
            };
        }, {
            "./Vec3": 31
        } ],
        30: [ function(t, e, i) {
            var n = t("./Vec3"), o = t("./Quaternion");
            function s(t) {
                t = t || {}, this.position = new n(), t.position && this.position.copy(t.position), 
                this.quaternion = new o(), t.quaternion && this.quaternion.copy(t.quaternion);
            }
            e.exports = s;
            var r = new o();
            s.pointToLocalFrame = function(t, e, i, o) {
                return o = o || new n(), i.vsub(t, o), e.conjugate(r), r.vmult(o, o), o;
            }, s.prototype.pointToLocal = function(t, e) {
                return s.pointToLocalFrame(this.position, this.quaternion, t, e);
            }, s.pointToWorldFrame = function(t, e, i, o) {
                return o = o || new n(), e.vmult(i, o), o.vadd(t, o), o;
            }, s.prototype.pointToWorld = function(t, e) {
                return s.pointToWorldFrame(this.position, this.quaternion, t, e);
            }, s.prototype.vectorToWorldFrame = function(t, e) {
                return e = e || new n(), this.quaternion.vmult(t, e), e;
            }, s.vectorToWorldFrame = function(t, e, i) {
                return t.vmult(e, i), i;
            }, s.vectorToLocalFrame = function(t, e, i, o) {
                return o = o || new n(), e.w *= -1, e.vmult(i, o), e.w *= -1, o;
            };
        }, {
            "./Quaternion": 29,
            "./Vec3": 31
        } ],
        31: [ function(t, e, i) {
            e.exports = h;
            var o = t("./Mat3");
            function h(t, e, i) {
                this.x = t || 0, this.y = e || 0, this.z = i || 0;
            }
            h.ZERO = new h(0, 0, 0), h.UNIT_X = new h(1, 0, 0), h.UNIT_Y = new h(0, 1, 0), h.UNIT_Z = new h(0, 0, 1), 
            h.prototype.cross = function(t, e) {
                var i = t.x, o = t.y, n = t.z, s = this.x, r = this.y, a = this.z;
                return (e = e || new h()).x = r * n - a * o, e.y = a * i - s * n, e.z = s * o - r * i, 
                e;
            }, h.prototype.set = function(t, e, i) {
                return this.x = t, this.y = e, this.z = i, this;
            }, h.prototype.setZero = function() {
                this.x = this.y = this.z = 0;
            }, h.prototype.vadd = function(t, e) {
                if (!e) return new h(this.x + t.x, this.y + t.y, this.z + t.z);
                e.x = t.x + this.x, e.y = t.y + this.y, e.z = t.z + this.z;
            }, h.prototype.vsub = function(t, e) {
                if (!e) return new h(this.x - t.x, this.y - t.y, this.z - t.z);
                e.x = this.x - t.x, e.y = this.y - t.y, e.z = this.z - t.z;
            }, h.prototype.crossmat = function() {
                return new o([ 0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0 ]);
            }, h.prototype.normalize = function() {
                var t = this.x, e = this.y, i = this.z, o = Math.sqrt(t * t + e * e + i * i);
                if (0 < o) {
                    var n = 1 / o;
                    this.x *= n, this.y *= n, this.z *= n;
                } else this.x = 0, this.y = 0, this.z = 0;
                return o;
            }, h.prototype.unit = function(t) {
                t = t || new h();
                var e = this.x, i = this.y, o = this.z, n = Math.sqrt(e * e + i * i + o * o);
                return 0 < n ? (n = 1 / n, t.x = e * n, t.y = i * n, t.z = o * n) : (t.x = 1, t.y = 0, 
                t.z = 0), t;
            }, h.prototype.length = h.prototype.norm = function() {
                var t = this.x, e = this.y, i = this.z;
                return Math.sqrt(t * t + e * e + i * i);
            }, h.prototype.lengthSquared = h.prototype.norm2 = function() {
                return this.dot(this);
            }, h.prototype.distanceTo = function(t) {
                var e = this.x, i = this.y, o = this.z, n = t.x, s = t.y, r = t.z;
                return Math.sqrt((n - e) * (n - e) + (s - i) * (s - i) + (r - o) * (r - o));
            }, h.prototype.distanceSquared = function(t) {
                var e = this.x, i = this.y, o = this.z, n = t.x, s = t.y, r = t.z;
                return (n - e) * (n - e) + (s - i) * (s - i) + (r - o) * (r - o);
            }, h.prototype.mult = function(t, e) {
                e = e || new h();
                var i = this.x, o = this.y, n = this.z;
                return e.x = t * i, e.y = t * o, e.z = t * n, e;
            }, h.prototype.vmul = function(t, e) {
                return (e = e || new h()).x = t.x * this.x, e.y = t.y * this.y, e.z = t.z * this.z, 
                e;
            }, h.prototype.scale = h.prototype.mult, h.prototype.addScaledVector = function(t, e, i) {
                return (i = i || new h()).x = this.x + t * e.x, i.y = this.y + t * e.y, i.z = this.z + t * e.z, 
                i;
            }, h.prototype.dot = function(t) {
                return this.x * t.x + this.y * t.y + this.z * t.z;
            }, h.prototype.isZero = function() {
                return 0 === this.x && 0 === this.y && 0 === this.z;
            }, h.prototype.negate = function(t) {
                return (t = t || new h()).x = -this.x, t.y = -this.y, t.z = -this.z, t;
            };
            var r = new h(), a = new h();
            h.prototype.tangents = function(t, e) {
                var i = this.norm();
                if (0 < i) {
                    var o = r, n = 1 / i;
                    o.set(this.x * n, this.y * n, this.z * n);
                    var s = a;
                    Math.abs(o.x) < .9 ? s.set(1, 0, 0) : s.set(0, 1, 0), o.cross(s, t), o.cross(t, e);
                } else t.set(1, 0, 0), e.set(0, 1, 0);
            }, h.prototype.toString = function() {
                return this.x + "," + this.y + "," + this.z;
            }, h.prototype.toArray = function() {
                return [ this.x, this.y, this.z ];
            }, h.prototype.copy = function(t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this;
            }, h.prototype.lerp = function(t, e, i) {
                var o = this.x, n = this.y, s = this.z;
                i.x = o + (t.x - o) * e, i.y = n + (t.y - n) * e, i.z = s + (t.z - s) * e;
            }, h.prototype.almostEquals = function(t, e) {
                return void 0 === e && (e = 1e-6), !(Math.abs(this.x - t.x) > e || Math.abs(this.y - t.y) > e || Math.abs(this.z - t.z) > e);
            }, h.prototype.almostZero = function(t) {
                return void 0 === t && (t = 1e-6), !(Math.abs(this.x) > t || Math.abs(this.y) > t || Math.abs(this.z) > t);
            };
            var n = new h();
            h.prototype.isAntiparallelTo = function(t, e) {
                return this.negate(n), n.almostEquals(t, e);
            }, h.prototype.clone = function() {
                return new h(this.x, this.y, this.z);
            };
        }, {
            "./Mat3": 28
        } ],
        32: [ function(t, e, i) {
            e.exports = w;
            var o = t("../utils/EventTarget"), s = (t("../shapes/Shape"), t("../math/Vec3")), n = t("../math/Mat3"), r = t("../math/Quaternion"), a = (t("../material/Material"), 
            t("../collision/AABB")), h = t("../shapes/Box"), l = t("../world/World");
            function w(t) {
                t = t || {}, o.apply(this), this.id = w.idCounter++, this.world = null, this.preStep = null, 
                this.postStep = null, this.vlambda = new s(), this.collisionFilterGroup = "number" == typeof t.collisionFilterGroup ? t.collisionFilterGroup : 1, 
                this.collisionFilterMask = "number" == typeof t.collisionFilterMask ? t.collisionFilterMask : -1, 
                this.collisionResponse = !0, this.position = new s(), this.previousPosition = new s(), 
                this.interpolatedPosition = new s(), this.initPosition = new s(), t.position && (this.position.copy(t.position), 
                this.previousPosition.copy(t.position), this.interpolatedPosition.copy(t.position), 
                this.initPosition.copy(t.position)), this.velocity = new s(), t.velocity && this.velocity.copy(t.velocity), 
                this.initVelocity = new s(), this.force = new s();
                var e = "number" == typeof t.mass ? t.mass : 0;
                this.mass = e, this.invMass = 0 < e ? 1 / e : 0, this.material = t.material || null, 
                this.linearDamping = "number" == typeof t.linearDamping ? t.linearDamping : .01, 
                this.type = e <= 0 ? w.STATIC : w.DYNAMIC, typeof t.type == typeof w.STATIC && (this.type = t.type), 
                this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.sleepState = 0, 
                this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .1, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, 
                this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new s(), 
                this.quaternion = new r(), this.initQuaternion = new r(), this.previousQuaternion = new r(), 
                this.interpolatedQuaternion = new r(), t.quaternion && (this.quaternion.copy(t.quaternion), 
                this.initQuaternion.copy(t.quaternion), this.previousQuaternion.copy(t.quaternion), 
                this.interpolatedQuaternion.copy(t.quaternion)), this.angularVelocity = new s(), 
                t.angularVelocity && this.angularVelocity.copy(t.angularVelocity), this.initAngularVelocity = new s(), 
                this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new s(), 
                this.invInertia = new s(), this.invInertiaWorld = new n(), this.invMassSolve = 0, 
                this.invInertiaSolve = new s(), this.invInertiaWorldSolve = new n(), this.fixedRotation = void 0 !== t.fixedRotation && t.fixedRotation, 
                this.useGravity = !0, this.angularDamping = void 0 !== t.angularDamping ? t.angularDamping : .01, 
                this.linearFactor = new s(1, 1, 1), t.linearFactor && this.linearFactor.copy(t.linearFactor), 
                this.angularFactor = new s(1, 1, 1), t.angularFactor && this.angularFactor.copy(t.angularFactor), 
                this.aabb = new a(), this.aabbNeedsUpdate = !0, this.boundingRadius = 0, this.wlambda = new s(), 
                t.shape && this.addShape(t.shape), this.updateMassProperties();
            }
            ((w.prototype = new o()).constructor = w).COLLIDE_EVENT_NAME = "collide", w.DYNAMIC = 1, 
            w.STATIC = 2, w.KINEMATIC = 4, w.AWAKE = 0, w.SLEEPY = 1, w.SLEEPING = 2, w.idCounter = 0, 
            w.wakeupEvent = {
                type: "wakeup"
            }, w.prototype.wakeUp = function() {
                var t = this.sleepState;
                this.sleepState = 0, this._wakeUpAfterNarrowphase = !1, t === w.SLEEPING && this.dispatchEvent(w.wakeupEvent);
            }, w.prototype.sleep = function() {
                this.sleepState = w.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), 
                this._wakeUpAfterNarrowphase = !1;
            }, w.sleepyEvent = {
                type: "sleepy"
            }, w.sleepEvent = {
                type: "sleep"
            }, w.prototype.sleepTick = function(t) {
                if (this.allowSleep) {
                    var e = this.sleepState, i = this.velocity.norm2() + this.angularVelocity.norm2(), o = Math.pow(this.sleepSpeedLimit, 2);
                    e === w.AWAKE && i < o ? (this.sleepState = w.SLEEPY, this.timeLastSleepy = t, this.dispatchEvent(w.sleepyEvent)) : e === w.SLEEPY && o < i ? this.wakeUp() : e === w.SLEEPY && t - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), 
                    this.dispatchEvent(w.sleepEvent));
                }
            }, w.prototype.updateSolveMassProperties = function() {
                this.sleepState === w.SLEEPING || this.type === w.KINEMATIC ? (this.invMassSolve = 0, 
                this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, 
                this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
            }, w.prototype.pointToLocalFrame = function(t, e) {
                return e = e || new s(), t.vsub(this.position, e), this.quaternion.conjugate().vmult(e, e), 
                e;
            }, w.prototype.vectorToLocalFrame = function(t, e) {
                return e = e || new s(), this.quaternion.conjugate().vmult(t, e), e;
            }, w.prototype.pointToWorldFrame = function(t, e) {
                return e = e || new s(), this.quaternion.vmult(t, e), e.vadd(this.position, e), 
                e;
            }, w.prototype.vectorToWorldFrame = function(t, e) {
                return e = e || new s(), this.quaternion.vmult(t, e), e;
            };
            var c = new s(), u = new r();
            w.prototype.addShape = function(t, e, i) {
                if (-1 === this.shapes.indexOf(t)) {
                    var o = new s(), n = new r();
                    return e && o.copy(e), i && n.copy(i), l.idToShapeMap[t.id] = t, this.shapes.push(t), 
                    this.shapeOffsets.push(o), this.shapeOrientations.push(n), this.updateMassProperties(), 
                    this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, t.body = this;
                }
            }, w.prototype.removeShape = function(t) {
                var e = this.shapes.indexOf(t);
                -1 !== e && (this.shapes.splice(e, 1), this.shapeOffsets.splice(e, 1), this.shapeOrientations.splice(e, 1), 
                this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0);
            }, w.prototype.updateBoundingRadius = function() {
                for (var t = this.shapes, e = this.shapeOffsets, i = t.length, o = 0, n = 0; n !== i; n++) {
                    var s = t[n];
                    s.updateBoundingSphereRadius();
                    var r = e[n].norm(), a = s.boundingSphereRadius;
                    o < r + a && (o = r + a);
                }
                this.boundingRadius = o;
            };
            var d = new a();
            w.prototype.computeAABB = function() {
                for (var t = this.shapes, e = this.shapeOffsets, i = this.shapeOrientations, o = t.length, n = c, s = u, r = this.quaternion, a = this.aabb, h = d, l = 0; l !== o; l++) {
                    var p = t[l];
                    r.vmult(e[l], n), n.vadd(this.position, n), i[l].mult(r, s), p.calculateWorldAABB(n, s, h.lowerBound, h.upperBound), 
                    0 === l ? a.copy(h) : a.extend(h);
                }
                this.aabbNeedsUpdate = !1;
            };
            var p = new n(), v = new n();
            new n(), w.prototype.updateInertiaWorld = function(t) {
                var e = this.invInertia;
                if (e.x !== e.y || e.y !== e.z || t) {
                    var i = p, o = v;
                    i.setRotationFromQuaternion(this.quaternion), i.transpose(o), i.scale(e, i), i.mmult(o, this.invInertiaWorld);
                }
            };
            var y = new s();
            w.prototype.applyForce = function(t, e) {
                if (this.type === w.DYNAMIC) {
                    var i = y;
                    e.cross(t, i), this.force.vadd(t, this.force), this.torque.vadd(i, this.torque);
                }
            };
            var f = new s(), m = new s();
            w.prototype.applyLocalForce = function(t, e) {
                if (this.type === w.DYNAMIC) {
                    var i = f, o = m;
                    this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, o), this.applyForce(i, o);
                }
            };
            var g = new s(), x = new s();
            w.prototype.applyImpulse = function(t, e) {
                if (this.type === w.DYNAMIC) {
                    var i = e, o = g;
                    o.copy(t), o.mult(this.invMass, o), this.velocity.vadd(o, this.velocity);
                    var n = x;
                    i.cross(t, n), this.invInertiaWorld.vmult(n, n), this.angularVelocity.vadd(n, this.angularVelocity);
                }
            };
            var b = new s(), B = new s();
            w.prototype.applyLocalImpulse = function(t, e) {
                if (this.type === w.DYNAMIC) {
                    var i = b, o = B;
                    this.vectorToWorldFrame(t, i), this.vectorToWorldFrame(e, o), this.applyImpulse(i, o);
                }
            };
            var E = new s();
            w.prototype.updateMassProperties = function() {
                var t = E;
                this.invMass = 0 < this.mass ? 1 / this.mass : 0;
                var e = this.inertia, i = this.fixedRotation;
                this.computeAABB(), t.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), 
                h.calculateInertia(t, this.mass, e), this.invInertia.set(0 < e.x && !i ? 1 / e.x : 0, 0 < e.y && !i ? 1 / e.y : 0, 0 < e.z && !i ? 1 / e.z : 0), 
                this.updateInertiaWorld(!0);
            }, w.prototype.getVelocityAtWorldPoint = function(t, e) {
                var i = new s();
                return t.vsub(this.position, i), this.angularVelocity.cross(i, e), this.velocity.vadd(e, e), 
                e;
            }, w.prototype.integrate = function(t, e, i) {
                if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), 
                (this.type === w.DYNAMIC || this.type === w.KINEMATIC) && this.sleepState !== w.SLEEPING) {
                    var o = this.velocity, n = this.angularVelocity, s = this.position, r = this.force, a = this.torque, h = this.quaternion, l = this.invMass, p = this.invInertiaWorld, c = this.linearFactor, u = l * t;
                    o.x += r.x * u * c.x, o.y += r.y * u * c.y, o.z += r.z * u * c.z;
                    var d = p.elements, v = this.angularFactor, y = a.x * v.x, f = a.y * v.y, m = a.z * v.z;
                    n.x += t * (d[0] * y + d[1] * f + d[2] * m), n.y += t * (d[3] * y + d[4] * f + d[5] * m), 
                    n.z += t * (d[6] * y + d[7] * f + d[8] * m), s.x += o.x * t, s.y += o.y * t, s.z += o.z * t, 
                    h.integrate(this.angularVelocity, t, this.angularFactor, h), e && (i ? h.normalizeFast() : h.normalize()), 
                    this.aabbNeedsUpdate = !0, this.updateInertiaWorld();
                }
            }, w.prototype.isSleeping = function() {
                return this.sleepState === w.SLEEPING;
            }, w.prototype.isSleepy = function() {
                return this.sleepState === w.SLEEPY;
            }, w.prototype.isAwake = function() {
                return this.sleepState === w.AWAKE;
            };
        }, {
            "../collision/AABB": 3,
            "../material/Material": 26,
            "../math/Mat3": 28,
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../shapes/Box": 38,
            "../shapes/Shape": 44,
            "../utils/EventTarget": 50,
            "../world/World": 57
        } ],
        33: [ function(t, e, i) {
            t("./Body");
            var S = t("../math/Vec3"), p = t("../math/Quaternion"), o = (t("../collision/RaycastResult"), 
            t("../collision/Ray")), n = t("../objects/WheelInfo");
            function s(t) {
                this.chassisBody = t.chassisBody, this.wheelInfos = [], this.sliding = !1, this.world = null, 
                this.indexRightAxis = void 0 !== t.indexRightAxis ? t.indexRightAxis : 1, this.indexForwardAxis = void 0 !== t.indexForwardAxis ? t.indexForwardAxis : 0, 
                this.indexUpAxis = void 0 !== t.indexUpAxis ? t.indexUpAxis : 2;
            }
            e.exports = s, new S(), new S(), new S();
            var c = new S(), u = new S(), d = new S();
            new o(), s.prototype.addWheel = function(t) {
                var e = new n(t = t || {}), i = this.wheelInfos.length;
                return this.wheelInfos.push(e), i;
            }, s.prototype.setSteeringValue = function(t, e) {
                this.wheelInfos[e].steering = t;
            }, new S(), s.prototype.applyEngineForce = function(t, e) {
                this.wheelInfos[e].engineForce = t;
            }, s.prototype.setBrake = function(t, e) {
                this.wheelInfos[e].brake = t;
            }, s.prototype.addToWorld = function(t) {
                this.constraints, t.addBody(this.chassisBody);
                var e = this;
                this.preStepCallback = function() {
                    e.updateVehicle(t.dt);
                }, t.addEventListener("preStep", this.preStepCallback), this.world = t;
            }, s.prototype.getVehicleAxisWorld = function(t, e) {
                e.set(0 === t ? 1 : 0, 1 === t ? 1 : 0, 2 === t ? 1 : 0), this.chassisBody.vectorToWorldFrame(e, e);
            }, s.prototype.updateVehicle = function(t) {
                for (var e = this.wheelInfos, i = e.length, o = this.chassisBody, n = 0; n < i; n++) this.updateWheelTransform(n);
                this.currentVehicleSpeedKmHour = 3.6 * o.velocity.norm();
                var s = new S();
                for (this.getVehicleAxisWorld(this.indexForwardAxis, s), s.dot(o.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1), 
                n = 0; n < i; n++) this.castRay(e[n]);
                this.updateSuspension(t);
                var r = new S(), a = new S();
                for (n = 0; n < i; n++) {
                    var h = (u = e[n]).suspensionForce;
                    h > u.maxSuspensionForce && (h = u.maxSuspensionForce), u.raycastResult.hitNormalWorld.scale(h * t, r), 
                    u.raycastResult.hitPointWorld.vsub(o.position, a), o.applyImpulse(r, a);
                }
                this.updateFriction(t);
                var l = new S(), p = new S(), c = new S();
                for (n = 0; n < i; n++) {
                    var u = e[n];
                    o.getVelocityAtWorldPoint(u.chassisConnectionPointWorld, c);
                    var d = 1;
                    switch (this.indexUpAxis) {
                      case 1:
                        d = -1;
                    }
                    if (u.isInContact) {
                        this.getVehicleAxisWorld(this.indexForwardAxis, p);
                        var v = p.dot(u.raycastResult.hitNormalWorld);
                        u.raycastResult.hitNormalWorld.scale(v, l), p.vsub(l, p);
                        var y = p.dot(c);
                        u.deltaRotation = d * y * t / u.radius;
                    }
                    !u.sliding && u.isInContact || 0 === u.engineForce || !u.useCustomSlidingRotationalSpeed || (u.deltaRotation = (0 < u.engineForce ? 1 : -1) * u.customSlidingRotationalSpeed * t), 
                    Math.abs(u.brake) > Math.abs(u.engineForce) && (u.deltaRotation = 0), u.rotation += u.deltaRotation, 
                    u.deltaRotation *= .99;
                }
            }, s.prototype.updateSuspension = function(t) {
                for (var e = this.chassisBody.mass, i = this.wheelInfos, o = i.length, n = 0; n < o; n++) {
                    var s = i[n];
                    if (s.isInContact) {
                        var r, a = s.suspensionRestLength - s.suspensionLength;
                        r = s.suspensionStiffness * a * s.clippedInvContactDotSuspension;
                        var h = s.suspensionRelativeVelocity;
                        r -= (h < 0 ? s.dampingCompression : s.dampingRelaxation) * h, s.suspensionForce = r * e, 
                        s.suspensionForce < 0 && (s.suspensionForce = 0);
                    } else s.suspensionForce = 0;
                }
            }, s.prototype.removeFromWorld = function(t) {
                this.constraints, t.remove(this.chassisBody), t.removeEventListener("preStep", this.preStepCallback), 
                this.world = null;
            };
            var m = new S(), w = new S();
            s.prototype.castRay = function(t) {
                var e = m, i = w;
                this.updateWheelTransformWorld(t);
                var o = this.chassisBody, n = -1, s = t.suspensionRestLength + t.radius;
                t.directionWorld.scale(s, e);
                var r = t.chassisConnectionPointWorld;
                r.vadd(e, i);
                var a = t.raycastResult;
                a.reset();
                var h = o.collisionResponse;
                o.collisionResponse = !1, this.world.rayTest(r, i, a), o.collisionResponse = h;
                var l = a.body;
                if (t.raycastResult.groundObject = 0, l) {
                    n = a.distance, t.raycastResult.hitNormalWorld = a.hitNormalWorld, t.isInContact = !0;
                    var p = a.distance;
                    t.suspensionLength = p - t.radius;
                    var c = t.suspensionRestLength - t.maxSuspensionTravel, u = t.suspensionRestLength + t.maxSuspensionTravel;
                    t.suspensionLength < c && (t.suspensionLength = c), t.suspensionLength > u && (t.suspensionLength = u, 
                    t.raycastResult.reset());
                    var d = t.raycastResult.hitNormalWorld.dot(t.directionWorld), v = new S();
                    o.getVelocityAtWorldPoint(t.raycastResult.hitPointWorld, v);
                    var y = t.raycastResult.hitNormalWorld.dot(v);
                    if (-.1 <= d) t.suspensionRelativeVelocity = 0, t.clippedInvContactDotSuspension = 10; else {
                        var f = -1 / d;
                        t.suspensionRelativeVelocity = y * f, t.clippedInvContactDotSuspension = f;
                    }
                } else t.suspensionLength = t.suspensionRestLength + 0 * t.maxSuspensionTravel, 
                t.suspensionRelativeVelocity = 0, t.directionWorld.scale(-1, t.raycastResult.hitNormalWorld), 
                t.clippedInvContactDotSuspension = 1;
                return n;
            }, s.prototype.updateWheelTransformWorld = function(t) {
                t.isInContact = !1;
                var e = this.chassisBody;
                e.pointToWorldFrame(t.chassisConnectionPointLocal, t.chassisConnectionPointWorld), 
                e.vectorToWorldFrame(t.directionLocal, t.directionWorld), e.vectorToWorldFrame(t.axleLocal, t.axleWorld);
            }, s.prototype.updateWheelTransform = function(t) {
                var e = c, i = u, o = d, n = this.wheelInfos[t];
                this.updateWheelTransformWorld(n), n.directionLocal.scale(-1, e), i.copy(n.axleLocal), 
                e.cross(i, o), o.normalize(), i.normalize();
                var s = n.steering, r = new p();
                r.setFromAxisAngle(e, s);
                var a = new p();
                a.setFromAxisAngle(i, n.rotation);
                var h = n.worldTransform.quaternion;
                this.chassisBody.quaternion.mult(r, h), h.mult(a, h), h.normalize();
                var l = n.worldTransform.position;
                l.copy(n.directionWorld), l.scale(n.suspensionLength, l), l.vadd(n.chassisConnectionPointWorld, l);
            };
            var z = [ new S(1, 0, 0), new S(0, 1, 0), new S(0, 0, 1) ];
            s.prototype.getWheelTransformWorld = function(t) {
                return this.wheelInfos[t].worldTransform;
            };
            var M = new S(), C = [], q = [];
            s.prototype.updateFriction = function(t) {
                for (var e = M, i = this.wheelInfos, o = i.length, n = this.chassisBody, s = q, r = C, a = 0; a < o; a++) c = (x = i[a]).raycastResult.body, 
                x.sideImpulse = 0, x.forwardImpulse = 0, s[a] || (s[a] = new S()), r[a] || (r[a] = new S());
                for (a = 0; a < o; a++) if (c = (x = i[a]).raycastResult.body) {
                    var h = r[a];
                    this.getWheelTransformWorld(a).vectorToWorldFrame(z[this.indexRightAxis], h);
                    var l = x.raycastResult.hitNormalWorld, p = h.dot(l);
                    l.scale(p, e), h.vsub(e, h), h.normalize(), l.cross(h, s[a]), s[a].normalize(), 
                    x.sideImpulse = R(n, x.raycastResult.hitPointWorld, c, x.raycastResult.hitPointWorld, h), 
                    x.sideImpulse *= 1;
                }
                for (this.sliding = !1, a = 0; a < o; a++) {
                    var c = (x = i[a]).raycastResult.body, u = 0;
                    if (x.slipInfo = 1, c) {
                        var d = x.brake ? x.brake : 0;
                        u = F(n, c, x.raycastResult.hitPointWorld, s[a], d);
                        var v = d / (u += x.engineForce * t);
                        x.slipInfo *= v;
                    }
                    if (x.forwardImpulse = 0, x.skidInfo = 1, c) {
                        x.skidInfo = 1;
                        var y = x.suspensionForce * t * x.frictionSlip, f = y * y;
                        x.forwardImpulse = u;
                        var m = .5 * x.forwardImpulse, w = 1 * x.sideImpulse, g = m * m + w * w;
                        x.sliding = !1, f < g && (this.sliding = !0, x.sliding = !0, v = y / Math.sqrt(g), 
                        x.skidInfo *= v);
                    }
                }
                if (this.sliding) for (a = 0; a < o; a++) 0 !== (x = i[a]).sideImpulse && x.skidInfo < 1 && (x.forwardImpulse *= x.skidInfo, 
                x.sideImpulse *= x.skidInfo);
                for (a = 0; a < o; a++) {
                    var x = i[a], b = new S();
                    if (x.raycastResult.hitPointWorld.vsub(n.position, b), 0 !== x.forwardImpulse) {
                        var B = new S();
                        s[a].scale(x.forwardImpulse, B), n.applyImpulse(B, b);
                    }
                    if (0 !== x.sideImpulse) {
                        c = x.raycastResult.body;
                        var E = new S();
                        x.raycastResult.hitPointWorld.vsub(c.position, E);
                        var A = new S();
                        r[a].scale(x.sideImpulse, A), n.vectorToLocalFrame(b, b), b["xyz"[this.indexUpAxis]] *= x.rollInfluence, 
                        n.vectorToWorldFrame(b, b), n.applyImpulse(A, b), A.scale(-1, A), c.applyImpulse(A, E);
                    }
                }
            };
            var v = new S(), y = new S(), f = new S();
            function F(t, e, i, o, n) {
                var s = 0, r = i, a = v, h = y, l = f;
                return t.getVelocityAtWorldPoint(r, a), e.getVelocityAtWorldPoint(r, h), a.vsub(h, l), 
                n < (s = -o.dot(l) * (1 / (x(t, i, o) + x(e, i, o)))) && (s = n), s < -n && (s = -n), 
                s;
            }
            var a = new S(), h = new S(), l = new S(), g = new S();
            function x(t, e, i) {
                var o = a, n = h, s = l, r = g;
                return e.vsub(t.position, o), o.cross(i, n), t.invInertiaWorld.vmult(n, r), r.cross(o, s), 
                t.invMass + i.dot(s);
            }
            var b = new S(), B = new S(), E = new S();
            function R(t, e, i, o, n) {
                if (1.1 < n.norm2()) return 0;
                var s = b, r = B, a = E;
                return t.getVelocityAtWorldPoint(e, s), i.getVelocityAtWorldPoint(o, r), s.vsub(r, a), 
                -.2 * n.dot(a) * (1 / (t.invMass + i.invMass));
            }
        }, {
            "../collision/Ray": 10,
            "../collision/RaycastResult": 11,
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../objects/WheelInfo": 37,
            "./Body": 32
        } ],
        34: [ function(t, e, i) {
            var r = t("./Body"), a = t("../shapes/Sphere"), o = t("../shapes/Box"), h = t("../math/Vec3"), l = t("../constraints/HingeConstraint");
            function n(t) {
                if (this.wheelBodies = [], this.coordinateSystem = void 0 === t.coordinateSystem ? new h(1, 2, 3) : t.coordinateSystem.clone(), 
                this.chassisBody = t.chassisBody, !this.chassisBody) {
                    var e = new o(new h(5, 2, .5));
                    this.chassisBody = new r(1, e);
                }
                this.constraints = [], this.wheelAxes = [], this.wheelForces = [];
            }
            (e.exports = n).prototype.addWheel = function(t) {
                var e = (t = t || {}).body;
                e = e || new r(1, new a(1.2)), this.wheelBodies.push(e), this.wheelForces.push(0), 
                new h();
                var i = void 0 !== t.position ? t.position.clone() : new h(), o = new h();
                this.chassisBody.pointToWorldFrame(i, o), e.position.set(o.x, o.y, o.z);
                var n = void 0 !== t.axis ? t.axis.clone() : new h(0, 1, 0);
                this.wheelAxes.push(n);
                var s = new l(this.chassisBody, e, {
                    pivotA: i,
                    axisA: n,
                    pivotB: h.ZERO,
                    axisB: n,
                    collideConnected: !1
                });
                return this.constraints.push(s), this.wheelBodies.length - 1;
            }, n.prototype.setSteeringValue = function(t, e) {
                var i = this.wheelAxes[e], o = Math.cos(t), n = Math.sin(t), s = i.x, r = i.y;
                this.constraints[e].axisA.set(o * s - n * r, n * s + o * r, 0);
            }, n.prototype.setMotorSpeed = function(t, e) {
                var i = this.constraints[e];
                i.enableMotor(), i.motorTargetVelocity = t;
            }, n.prototype.disableMotor = function(t) {
                this.constraints[t].disableMotor();
            };
            var s = new h();
            n.prototype.setWheelForce = function(t, e) {
                this.wheelForces[e] = t;
            }, n.prototype.applyWheelForce = function(t, e) {
                var i = this.wheelAxes[e], o = this.wheelBodies[e], n = o.torque;
                i.scale(t, s), o.vectorToWorldFrame(s, s), n.vadd(s, n);
            }, n.prototype.addToWorld = function(t) {
                for (var e = this.constraints, i = this.wheelBodies.concat([ this.chassisBody ]), o = 0; o < i.length; o++) t.addBody(i[o]);
                for (o = 0; o < e.length; o++) t.addConstraint(e[o]);
                t.addEventListener("preStep", this._update.bind(this));
            }, n.prototype._update = function() {
                for (var t = this.wheelForces, e = 0; e < t.length; e++) this.applyWheelForce(t[e], e);
            }, n.prototype.removeFromWorld = function(t) {
                for (var e = this.constraints, i = this.wheelBodies.concat([ this.chassisBody ]), o = 0; o < i.length; o++) t.remove(i[o]);
                for (o = 0; o < e.length; o++) t.removeConstraint(e[o]);
            };
            var p = new h();
            n.prototype.getWheelSpeed = function(t) {
                var e = this.wheelAxes[t], i = this.wheelBodies[t].angularVelocity;
                return this.chassisBody.vectorToWorldFrame(e, p), i.dot(p);
            };
        }, {
            "../constraints/HingeConstraint": 16,
            "../math/Vec3": 31,
            "../shapes/Box": 38,
            "../shapes/Sphere": 45,
            "./Body": 32
        } ],
        35: [ function(t, e, i) {
            e.exports = n, t("../shapes/Shape");
            var o = t("../math/Vec3");
            function n() {
                this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, 
                this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], 
                this.neighbors = [];
            }
            t("../math/Quaternion"), t("../shapes/Particle"), t("../objects/Body"), t("../material/Material"), 
            n.prototype.add = function(t) {
                this.particles.push(t), this.neighbors.length < this.particles.length && this.neighbors.push([]);
            }, n.prototype.remove = function(t) {
                var e = this.particles.indexOf(t);
                -1 !== e && (this.particles.splice(e, 1), this.neighbors.length > this.particles.length && this.neighbors.pop());
            };
            var h = new o();
            n.prototype.getNeighbors = function(t, e) {
                for (var i = this.particles.length, o = t.id, n = this.smoothingRadius * this.smoothingRadius, s = h, r = 0; r !== i; r++) {
                    var a = this.particles[r];
                    a.position.vsub(t.position, s), o !== a.id && s.norm2() < n && e.push(a);
                }
            };
            var B = new o(), E = new o(), A = new o(), S = new o(), z = new o(), M = new o();
            n.prototype.update = function() {
                for (var t = this.particles.length, e = B, i = this.speedOfSound, o = this.eps, n = 0; n !== t; n++) {
                    var s = this.particles[n];
                    (g = this.neighbors[n]).length = 0, this.getNeighbors(s, g), g.push(this.particles[n]);
                    for (var r = g.length, a = 0, h = 0; h !== r; h++) {
                        s.position.vsub(g[h].position, e);
                        var l = e.norm(), p = this.w(l);
                        a += g[h].mass * p;
                    }
                    this.densities[n] = a, this.pressures[n] = i * i * (this.densities[n] - this.density);
                }
                var c = E, u = A, d = S, v = z, y = M;
                for (n = 0; n !== t; n++) {
                    var f, m, g, w = this.particles[n];
                    for (c.set(0, 0, 0), u.set(0, 0, 0), r = (g = this.neighbors[n]).length, h = 0; h !== r; h++) {
                        var x = g[h];
                        w.position.vsub(x.position, v);
                        var b = v.norm();
                        f = -x.mass * (this.pressures[n] / (this.densities[n] * this.densities[n] + o) + this.pressures[h] / (this.densities[h] * this.densities[h] + o)), 
                        this.gradw(v, d), d.mult(f, d), c.vadd(d, c), x.velocity.vsub(w.velocity, y), y.mult(1 / (1e-4 + this.densities[n] * this.densities[h]) * this.viscosity * x.mass, y), 
                        m = this.nablaw(b), y.mult(m, y), u.vadd(y, u);
                    }
                    u.mult(w.mass, u), c.mult(w.mass, c), w.force.vadd(u, w.force), w.force.vadd(c, w.force);
                }
            }, n.prototype.w = function(t) {
                var e = this.smoothingRadius;
                return 315 / (64 * Math.PI * Math.pow(e, 9)) * Math.pow(e * e - t * t, 3);
            }, n.prototype.gradw = function(t, e) {
                var i = t.norm(), o = this.smoothingRadius;
                t.mult(945 / (32 * Math.PI * Math.pow(o, 9)) * Math.pow(o * o - i * i, 2), e);
            }, n.prototype.nablaw = function(t) {
                var e = this.smoothingRadius;
                return 945 / (32 * Math.PI * Math.pow(e, 9)) * (e * e - t * t) * (7 * t * t - 3 * e * e);
            };
        }, {
            "../material/Material": 26,
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../objects/Body": 32,
            "../shapes/Particle": 42,
            "../shapes/Shape": 44
        } ],
        36: [ function(t, e, i) {
            var o = t("../math/Vec3");
            function n(t, e, i) {
                i = i || {}, this.restLength = "number" == typeof i.restLength ? i.restLength : 1, 
                this.stiffness = i.stiffness || 100, this.damping = i.damping || 1, this.bodyA = t, 
                this.bodyB = e, this.localAnchorA = new o(), this.localAnchorB = new o(), i.localAnchorA && this.localAnchorA.copy(i.localAnchorA), 
                i.localAnchorB && this.localAnchorB.copy(i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), 
                i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
            }
            (e.exports = n).prototype.setWorldAnchorA = function(t) {
                this.bodyA.pointToLocalFrame(t, this.localAnchorA);
            }, n.prototype.setWorldAnchorB = function(t) {
                this.bodyB.pointToLocalFrame(t, this.localAnchorB);
            }, n.prototype.getWorldAnchorA = function(t) {
                this.bodyA.pointToWorldFrame(this.localAnchorA, t);
            }, n.prototype.getWorldAnchorB = function(t) {
                this.bodyB.pointToWorldFrame(this.localAnchorB, t);
            };
            var m = new o(), w = new o(), g = new o(), x = new o(), b = new o(), B = new o(), E = new o(), A = new o(), S = new o(), z = new o(), M = new o();
            n.prototype.applyForce = function() {
                var t = this.stiffness, e = this.damping, i = this.restLength, o = this.bodyA, n = this.bodyB, s = m, r = w, a = g, h = x, l = M, p = b, c = B, u = E, d = A, v = S, y = z;
                this.getWorldAnchorA(p), this.getWorldAnchorB(c), p.vsub(o.position, u), c.vsub(n.position, d), 
                c.vsub(p, s);
                var f = s.norm();
                r.copy(s), r.normalize(), n.velocity.vsub(o.velocity, a), n.angularVelocity.cross(d, l), 
                a.vadd(l, a), o.angularVelocity.cross(u, l), a.vsub(l, a), r.mult(-t * (f - i) - e * a.dot(r), h), 
                o.force.vsub(h, o.force), n.force.vadd(h, n.force), u.cross(h, v), d.cross(h, y), 
                o.torque.vsub(v, o.torque), n.torque.vadd(y, n.torque);
            };
        }, {
            "../math/Vec3": 31
        } ],
        37: [ function(t, e, i) {
            var o = t("../math/Vec3"), n = t("../math/Transform"), s = t("../collision/RaycastResult"), r = t("../utils/Utils");
            function a(t) {
                t = r.defaults(t, {
                    chassisConnectionPointLocal: new o(),
                    chassisConnectionPointWorld: new o(),
                    directionLocal: new o(),
                    directionWorld: new o(),
                    axleLocal: new o(),
                    axleWorld: new o(),
                    suspensionRestLength: 1,
                    suspensionMaxLength: 2,
                    radius: 1,
                    suspensionStiffness: 100,
                    dampingCompression: 10,
                    dampingRelaxation: 10,
                    frictionSlip: 1e4,
                    steering: 0,
                    rotation: 0,
                    deltaRotation: 0,
                    rollInfluence: .01,
                    maxSuspensionForce: Number.MAX_VALUE,
                    isFrontWheel: !0,
                    clippedInvContactDotSuspension: 1,
                    suspensionRelativeVelocity: 0,
                    suspensionForce: 0,
                    skidInfo: 0,
                    suspensionLength: 0,
                    maxSuspensionTravel: 1,
                    useCustomSlidingRotationalSpeed: !1,
                    customSlidingRotationalSpeed: -.1
                }), this.maxSuspensionTravel = t.maxSuspensionTravel, this.customSlidingRotationalSpeed = t.customSlidingRotationalSpeed, 
                this.useCustomSlidingRotationalSpeed = t.useCustomSlidingRotationalSpeed, this.sliding = !1, 
                this.chassisConnectionPointLocal = t.chassisConnectionPointLocal.clone(), this.chassisConnectionPointWorld = t.chassisConnectionPointWorld.clone(), 
                this.directionLocal = t.directionLocal.clone(), this.directionWorld = t.directionWorld.clone(), 
                this.axleLocal = t.axleLocal.clone(), this.axleWorld = t.axleWorld.clone(), this.suspensionRestLength = t.suspensionRestLength, 
                this.suspensionMaxLength = t.suspensionMaxLength, this.radius = t.radius, this.suspensionStiffness = t.suspensionStiffness, 
                this.dampingCompression = t.dampingCompression, this.dampingRelaxation = t.dampingRelaxation, 
                this.frictionSlip = t.frictionSlip, this.steering = 0, this.rotation = 0, this.deltaRotation = 0, 
                this.rollInfluence = t.rollInfluence, this.maxSuspensionForce = t.maxSuspensionForce, 
                this.engineForce = 0, this.brake = 0, this.isFrontWheel = t.isFrontWheel, this.clippedInvContactDotSuspension = 1, 
                this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, this.skidInfo = 0, 
                this.suspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, this.raycastResult = new s(), 
                this.worldTransform = new n(), this.isInContact = !1;
            }
            e.exports = a;
            var h = new o(), l = new o();
            h = new o(), a.prototype.updateWheel = function(t) {
                var e = this.raycastResult;
                if (this.isInContact) {
                    var i = e.hitNormalWorld.dot(e.directionWorld);
                    e.hitPointWorld.vsub(t.position, l), t.getVelocityAtWorldPoint(l, h);
                    var o = e.hitNormalWorld.dot(h);
                    if (-.1 <= i) this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10; else {
                        var n = -1 / i;
                        this.suspensionRelativeVelocity = o * n, this.clippedInvContactDotSuspension = n;
                    }
                } else e.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, 
                e.directionWorld.scale(-1, e.hitNormalWorld), this.clippedInvContactDotSuspension = 1;
            };
        }, {
            "../collision/RaycastResult": 11,
            "../math/Transform": 30,
            "../math/Vec3": 31,
            "../utils/Utils": 54
        } ],
        38: [ function(t, e, i) {
            e.exports = n;
            var o = t("./Shape"), r = t("../math/Vec3"), a = t("./ConvexPolyhedron");
            function n(t) {
                o.call(this, {
                    type: o.types.BOX
                }), this.halfExtents = t, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), 
                this.updateBoundingSphereRadius();
            }
            ((n.prototype = new o()).constructor = n).prototype.updateConvexPolyhedronRepresentation = function() {
                var t = this.halfExtents.x, e = this.halfExtents.y, i = this.halfExtents.z, o = r, n = [ new o(-t, -e, -i), new o(t, -e, -i), new o(t, e, -i), new o(-t, e, -i), new o(-t, -e, i), new o(t, -e, i), new o(t, e, i), new o(-t, e, i) ], s = (new o(0, 0, 1), 
                new o(0, 1, 0), new o(1, 0, 0), new a(n, [ [ 3, 2, 1, 0 ], [ 4, 5, 6, 7 ], [ 5, 4, 0, 1 ], [ 2, 3, 7, 6 ], [ 0, 4, 7, 3 ], [ 1, 2, 6, 5 ] ]));
                (this.convexPolyhedronRepresentation = s).material = this.material;
            }, n.prototype.calculateLocalInertia = function(t, e) {
                return e = e || new r(), n.calculateInertia(this.halfExtents, t, e), e;
            }, n.calculateInertia = function(t, e, i) {
                var o = t;
                i.x = 1 / 12 * e * (2 * o.y * 2 * o.y + 2 * o.z * 2 * o.z), i.y = 1 / 12 * e * (2 * o.x * 2 * o.x + 2 * o.z * 2 * o.z), 
                i.z = 1 / 12 * e * (2 * o.y * 2 * o.y + 2 * o.x * 2 * o.x);
            }, n.prototype.getSideNormals = function(t, e) {
                var i = t, o = this.halfExtents;
                if (i[0].set(o.x, 0, 0), i[1].set(0, o.y, 0), i[2].set(0, 0, o.z), i[3].set(-o.x, 0, 0), 
                i[4].set(0, -o.y, 0), i[5].set(0, 0, -o.z), void 0 !== e) for (var n = 0; n !== i.length; n++) e.vmult(i[n], i[n]);
                return i;
            }, n.prototype.volume = function() {
                return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
            }, n.prototype.updateBoundingSphereRadius = function() {
                this.boundingSphereRadius = this.halfExtents.norm();
            };
            var h = new r();
            new r(), n.prototype.forEachWorldCorner = function(t, e, i) {
                for (var o = this.halfExtents, n = [ [ o.x, o.y, o.z ], [ -o.x, o.y, o.z ], [ -o.x, -o.y, o.z ], [ -o.x, -o.y, -o.z ], [ o.x, -o.y, -o.z ], [ o.x, o.y, -o.z ], [ -o.x, o.y, -o.z ], [ o.x, -o.y, o.z ] ], s = 0; s < n.length; s++) h.set(n[s][0], n[s][1], n[s][2]), 
                e.vmult(h, h), t.vadd(h, h), i(h.x, h.y, h.z);
            };
            var p = [ new r(), new r(), new r(), new r(), new r(), new r(), new r(), new r() ];
            n.prototype.calculateWorldAABB = function(t, e, i, o) {
                var n = this.halfExtents;
                p[0].set(n.x, n.y, n.z), p[1].set(-n.x, n.y, n.z), p[2].set(-n.x, -n.y, n.z), p[3].set(-n.x, -n.y, -n.z), 
                p[4].set(n.x, -n.y, -n.z), p[5].set(n.x, n.y, -n.z), p[6].set(-n.x, n.y, -n.z), 
                p[7].set(n.x, -n.y, n.z);
                var s = p[0];
                e.vmult(s, s), t.vadd(s, s), o.copy(s), i.copy(s);
                for (var r = 1; r < 8; r++) {
                    s = p[r], e.vmult(s, s), t.vadd(s, s);
                    var a = s.x, h = s.y, l = s.z;
                    a > o.x && (o.x = a), h > o.y && (o.y = h), l > o.z && (o.z = l), a < i.x && (i.x = a), 
                    h < i.y && (i.y = h), l < i.z && (i.z = l);
                }
            };
        }, {
            "../math/Vec3": 31,
            "./ConvexPolyhedron": 39,
            "./Shape": 44
        } ],
        39: [ function(t, e, i) {
            e.exports = u;
            var o = t("./Shape"), x = t("../math/Vec3"), y = (t("../math/Quaternion"), t("../math/Transform"));
            function u(t, e, i) {
                o.call(this, {
                    type: o.types.CONVEXPOLYHEDRON
                }), this.vertices = t || [], this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, 
                this.faces = e || [], this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, 
                this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = i ? i.slice() : null, 
                this.computeEdges(), this.updateBoundingSphereRadius();
            }
            (u.prototype = new o()).constructor = u;
            var c = new x();
            u.prototype.computeEdges = function() {
                var t = this.faces, e = this.vertices, i = (e.length, this.uniqueEdges);
                i.length = 0;
                for (var o = c, n = 0; n !== t.length; n++) for (var s = t[n], r = s.length, a = 0; a !== r; a++) {
                    var h = (a + 1) % r;
                    e[s[a]].vsub(e[s[h]], o), o.normalize();
                    for (var l = !1, p = 0; p !== i.length; p++) if (i[p].almostEquals(o) || i[p].almostEquals(o)) {
                        l = !0;
                        break;
                    }
                    l || i.push(o.clone());
                }
            }, u.prototype.computeNormals = function() {
                this.faceNormals.length = this.faces.length;
                for (var t = 0; t < this.faces.length; t++) {
                    for (var e = 0; e < this.faces[t].length; e++) if (!this.vertices[this.faces[t][e]]) throw new Error("Vertex " + this.faces[t][e] + " not found!");
                    var i = this.faceNormals[t] || new x();
                    this.getFaceNormal(t, i), i.negate(i), this.faceNormals[t] = i;
                    var o = this.vertices[this.faces[t][0]];
                    if (i.dot(o) < 0) for (console.error(".faceNormals[" + t + "] = Vec3(" + i.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), 
                    e = 0; e < this.faces[t].length; e++) console.warn(".vertices[" + this.faces[t][e] + "] = Vec3(" + this.vertices[this.faces[t][e]].toString() + ")");
                }
            };
            var n = new x(), s = new x();
            u.computeNormal = function(t, e, i, o) {
                e.vsub(t, s), i.vsub(e, n), n.cross(s, o), o.isZero() || o.normalize();
            }, u.prototype.getFaceNormal = function(t, e) {
                var i = this.faces[t], o = this.vertices[i[0]], n = this.vertices[i[1]], s = this.vertices[i[2]];
                return u.computeNormal(o, n, s, e);
            };
            var b = new x();
            u.prototype.clipAgainstHull = function(t, e, i, o, n, s, r, a, h) {
                for (var l = b, p = -1, c = -Number.MAX_VALUE, u = 0; u < i.faces.length; u++) {
                    l.copy(i.faceNormals[u]), n.vmult(l, l);
                    var d = l.dot(s);
                    c < d && (c = d, p = u);
                }
                for (var v = [], y = i.faces[p], f = y.length, m = 0; m < f; m++) {
                    var w = i.vertices[y[m]], g = new x();
                    g.copy(w), n.vmult(g, g), o.vadd(g, g), v.push(g);
                }
                0 <= p && this.clipFaceAgainstHull(s, t, e, v, r, a, h);
            };
            var A = new x(), S = new x(), z = new x(), M = new x(), C = new x(), q = new x();
            u.prototype.findSeparatingAxis = function(t, e, i, o, n, s, r, a) {
                var h = A, l = S, p = z, c = M, u = C, d = q, v = Number.MAX_VALUE, y = this;
                if (y.uniqueAxes) for (m = 0; m !== y.uniqueAxes.length; m++) {
                    if (i.vmult(y.uniqueAxes[m], h), !1 === (x = y.testSepAxis(h, t, e, i, o, n))) return !1;
                    x < v && (v = x, s.copy(h));
                } else for (var f = r ? r.length : y.faces.length, m = 0; m < f; m++) {
                    var w = r ? r[m] : m;
                    if (h.copy(y.faceNormals[w]), i.vmult(h, h), !1 === (x = y.testSepAxis(h, t, e, i, o, n))) return !1;
                    x < v && (v = x, s.copy(h));
                }
                if (t.uniqueAxes) for (m = 0; m !== t.uniqueAxes.length; m++) {
                    if (n.vmult(t.uniqueAxes[m], l), !1 === (x = y.testSepAxis(l, t, e, i, o, n))) return !1;
                    x < v && (v = x, s.copy(l));
                } else {
                    var g = a ? a.length : t.faces.length;
                    for (m = 0; m < g; m++) {
                        var x;
                        if (w = a ? a[m] : m, l.copy(t.faceNormals[w]), n.vmult(l, l), !1 === (x = y.testSepAxis(l, t, e, i, o, n))) return !1;
                        x < v && (v = x, s.copy(l));
                    }
                }
                for (var b = 0; b !== y.uniqueEdges.length; b++) {
                    i.vmult(y.uniqueEdges[b], c);
                    for (var B = 0; B !== t.uniqueEdges.length; B++) if (n.vmult(t.uniqueEdges[B], u), 
                    c.cross(u, d), !d.almostZero()) {
                        d.normalize();
                        var E = y.testSepAxis(d, t, e, i, o, n);
                        if (!1 === E) return !1;
                        E < v && (v = E, s.copy(d));
                    }
                }
                return o.vsub(e, p), 0 < p.dot(s) && s.negate(s), !0;
            };
            var d = [], v = [];
            u.prototype.testSepAxis = function(t, e, i, o, n, s) {
                u.project(this, t, i, o, d), u.project(e, t, n, s, v);
                var r = d[0], a = d[1], h = v[0], l = v[1];
                if (r < l || h < a) return !1;
                var p = r - l, c = h - a;
                return p < c ? p : c;
            };
            var r = new x(), a = new x();
            u.prototype.calculateLocalInertia = function(t, e) {
                this.computeLocalAABB(r, a);
                var i = a.x - r.x, o = a.y - r.y, n = a.z - r.z;
                e.x = 1 / 12 * t * (2 * o * 2 * o + 2 * n * 2 * n), e.y = 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n), 
                e.z = 1 / 12 * t * (2 * o * 2 * o + 2 * i * 2 * i);
            }, u.prototype.getPlaneConstantOfFace = function(t) {
                var e = this.faces[t], i = this.faceNormals[t], o = this.vertices[e[0]];
                return -i.dot(o);
            };
            var I = new x(), N = new x(), L = new x(), W = new x(), j = new x(), O = new x(), k = new x(), _ = new x();
            u.prototype.clipFaceAgainstHull = function(t, e, i, o, n, s, r) {
                for (var a = I, h = N, l = L, p = W, c = j, u = O, d = k, v = _, y = this, f = o, m = [], w = -1, g = Number.MAX_VALUE, x = 0; x < y.faces.length; x++) {
                    a.copy(y.faceNormals[x]), i.vmult(a, a);
                    var b = a.dot(t);
                    b < g && (g = b, w = x);
                }
                if (!(w < 0)) {
                    var B = y.faces[w];
                    B.connectedFaces = [];
                    for (var E = 0; E < y.faces.length; E++) for (var A = 0; A < y.faces[E].length; A++) -1 !== B.indexOf(y.faces[E][A]) && E !== w && -1 === B.connectedFaces.indexOf(E) && B.connectedFaces.push(E);
                    f.length;
                    for (var S = B.length, z = 0; z < S; z++) {
                        var M = y.vertices[B[z]], C = y.vertices[B[(z + 1) % S]];
                        M.vsub(C, h), l.copy(h), i.vmult(l, l), e.vadd(l, l), p.copy(this.faceNormals[w]), 
                        i.vmult(p, p), e.vadd(p, p), l.cross(p, c), c.negate(c), u.copy(M), i.vmult(u, u), 
                        e.vadd(u, u), u.dot(c);
                        var q = B.connectedFaces[z];
                        d.copy(this.faceNormals[q]);
                        var F = this.getPlaneConstantOfFace(q);
                        v.copy(d), i.vmult(v, v);
                        var R = F - v.dot(e);
                        for (this.clipFaceAgainstPlane(f, m, v, R); f.length; ) f.shift();
                        for (;m.length; ) f.push(m.shift());
                    }
                    for (d.copy(this.faceNormals[w]), F = this.getPlaneConstantOfFace(w), v.copy(d), 
                    i.vmult(v, v), R = F - v.dot(e), E = 0; E < f.length; E++) {
                        var T = v.dot(f[E]) + R;
                        if (T <= n && (T = n), T <= s) {
                            var P = f[E];
                            if (T <= 0) {
                                var V = {
                                    point: P,
                                    normal: v,
                                    depth: T
                                };
                                r.push(V);
                            }
                        }
                    }
                }
            }, u.prototype.clipFaceAgainstPlane = function(t, e, i, o) {
                var n, s, r = t.length;
                if (r < 2) return e;
                var a = t[t.length - 1], h = t[0];
                n = i.dot(a) + o;
                for (var l = 0; l < r; l++) {
                    if (h = t[l], s = i.dot(h) + o, n < 0) if (s < 0) (p = new x()).copy(h), e.push(p); else {
                        var p = new x();
                        a.lerp(h, n / (n - s), p), e.push(p);
                    } else s < 0 && (p = new x(), a.lerp(h, n / (n - s), p), e.push(p), e.push(h));
                    a = h, n = s;
                }
                return e;
            }, u.prototype.computeWorldVertices = function(t, e) {
                for (var i = this.vertices.length; this.worldVertices.length < i; ) this.worldVertices.push(new x());
                for (var o = this.vertices, n = this.worldVertices, s = 0; s !== i; s++) e.vmult(o[s], n[s]), 
                t.vadd(n[s], n[s]);
                this.worldVerticesNeedsUpdate = !1;
            }, new x(), u.prototype.computeLocalAABB = function(t, e) {
                var i = this.vertices.length, o = this.vertices;
                t.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                for (var n = 0; n < i; n++) {
                    var s = o[n];
                    s.x < t.x ? t.x = s.x : s.x > e.x && (e.x = s.x), s.y < t.y ? t.y = s.y : s.y > e.y && (e.y = s.y), 
                    s.z < t.z ? t.z = s.z : s.z > e.z && (e.z = s.z);
                }
            }, u.prototype.computeWorldFaceNormals = function(t) {
                for (var e = this.faceNormals.length; this.worldFaceNormals.length < e; ) this.worldFaceNormals.push(new x());
                for (var i = this.faceNormals, o = this.worldFaceNormals, n = 0; n !== e; n++) t.vmult(i[n], o[n]);
                this.worldFaceNormalsNeedsUpdate = !1;
            }, u.prototype.updateBoundingSphereRadius = function() {
                for (var t = 0, e = this.vertices, i = 0, o = e.length; i !== o; i++) {
                    var n = e[i].norm2();
                    t < n && (t = n);
                }
                this.boundingSphereRadius = Math.sqrt(t);
            };
            var f = new x();
            u.prototype.calculateWorldAABB = function(t, e, i, o) {
                for (var n, s, r, a, h, l, p = this.vertices.length, c = this.vertices, u = 0; u < p; u++) {
                    f.copy(c[u]), e.vmult(f, f), t.vadd(f, f);
                    var d = f;
                    d.x < n || void 0 === n ? n = d.x : (d.x > a || void 0 === a) && (a = d.x), d.y < s || void 0 === s ? s = d.y : (d.y > h || void 0 === h) && (h = d.y), 
                    d.z < r || void 0 === r ? r = d.z : (d.z > l || void 0 === l) && (l = d.z);
                }
                i.set(n, s, r), o.set(a, h, l);
            }, u.prototype.volume = function() {
                return 4 * Math.PI * this.boundingSphereRadius / 3;
            }, u.prototype.getAveragePointLocal = function(t) {
                t = t || new x();
                for (var e = this.vertices.length, i = this.vertices, o = 0; o < e; o++) t.vadd(i[o], t);
                return t.mult(1 / e, t), t;
            }, u.prototype.transformAllPoints = function(t, e) {
                var i = this.vertices.length, o = this.vertices;
                if (e) {
                    for (var n = 0; n < i; n++) {
                        var s = o[n];
                        e.vmult(s, s);
                    }
                    for (n = 0; n < this.faceNormals.length; n++) s = this.faceNormals[n], e.vmult(s, s);
                }
                if (t) for (n = 0; n < i; n++) (s = o[n]).vadd(t, s);
            };
            var m = new x(), w = new x(), g = new x();
            u.prototype.pointIsInside = function(t) {
                var e = this.vertices.length, i = this.vertices, o = this.faces, n = this.faceNormals, s = this.faces.length, r = m;
                this.getAveragePointLocal(r);
                for (var a = 0; a < s; a++) {
                    this.faces[a].length, e = n[a];
                    var h = i[o[a][0]], l = w;
                    t.vsub(h, l);
                    var p = e.dot(l), c = g;
                    r.vsub(h, c);
                    var u = e.dot(c);
                    if (p < 0 && 0 < u || 0 < p && u < 0) return !1;
                }
                return -1;
            }, new x();
            var B = new x(), E = new x();
            u.project = function(t, e, i, o, n) {
                var s = t.vertices.length, r = B, a = 0, h = 0, l = E, p = t.vertices;
                l.setZero(), y.vectorToLocalFrame(i, o, e, r), y.pointToLocalFrame(i, o, l, l);
                var c = l.dot(r);
                h = a = p[0].dot(r);
                for (var u = 1; u < s; u++) {
                    var d = p[u].dot(r);
                    a < d && (a = d), d < h && (h = d);
                }
                if ((a -= c) < (h -= c)) {
                    var v = h;
                    h = a, a = v;
                }
                n[0] = a, n[1] = h;
            };
        }, {
            "../math/Quaternion": 29,
            "../math/Transform": 30,
            "../math/Vec3": 31,
            "./Shape": 44
        } ],
        40: [ function(t, e, i) {
            e.exports = o, t("./Shape");
            var f = t("../math/Vec3"), m = (t("../math/Quaternion"), t("./ConvexPolyhedron"));
            function o(t, e, i, o) {
                var n = o, s = [], r = [], a = [], h = [], l = [], p = Math.cos, c = Math.sin;
                s.push(new f(e * p(0), e * c(0), .5 * -i)), h.push(0), s.push(new f(t * p(0), t * c(0), .5 * i)), 
                l.push(1);
                for (var u = 0; u < n; u++) {
                    var d = 2 * Math.PI / n * (u + 1), v = 2 * Math.PI / n * (u + .5);
                    u < n - 1 ? (s.push(new f(e * p(d), e * c(d), .5 * -i)), h.push(2 * u + 2), s.push(new f(t * p(d), t * c(d), .5 * i)), 
                    l.push(2 * u + 3), a.push([ 2 * u + 2, 2 * u + 3, 2 * u + 1, 2 * u ])) : a.push([ 0, 1, 2 * u + 1, 2 * u ]), 
                    (n % 2 == 1 || u < n / 2) && r.push(new f(p(v), c(v), 0));
                }
                a.push(l), r.push(new f(0, 0, 1));
                var y = [];
                for (u = 0; u < h.length; u++) y.push(h[h.length - u - 1]);
                a.push(y), m.call(this, s, a, r);
            }
            o.prototype = new m();
        }, {
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "./ConvexPolyhedron": 39,
            "./Shape": 44
        } ],
        41: [ function(t, e, i) {
            var o = t("./Shape"), c = t("./ConvexPolyhedron"), u = t("../math/Vec3"), n = t("../utils/Utils");
            function s(t, e) {
                e = n.defaults(e, {
                    maxValue: null,
                    minValue: null,
                    elementSize: 1
                }), this.data = t, this.maxValue = e.maxValue, this.minValue = e.minValue, this.elementSize = e.elementSize, 
                null === e.minValue && this.updateMinValue(), null === e.maxValue && this.updateMaxValue(), 
                this.cacheEnabled = !0, o.call(this, {
                    type: o.types.HEIGHTFIELD
                }), this.pillarConvex = new c(), this.pillarOffset = new u(), this.updateBoundingSphereRadius(), 
                this._cachedPillars = {};
            }
            ((e.exports = s).prototype = new o()).update = function() {
                this._cachedPillars = {};
            }, s.prototype.updateMinValue = function() {
                for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++) for (var o = 0; o !== t[i].length; o++) {
                    var n = t[i][o];
                    n < e && (e = n);
                }
                this.minValue = e;
            }, s.prototype.updateMaxValue = function() {
                for (var t = this.data, e = t[0][0], i = 0; i !== t.length; i++) for (var o = 0; o !== t[i].length; o++) {
                    var n = t[i][o];
                    e < n && (e = n);
                }
                this.maxValue = e;
            }, s.prototype.setHeightValueAtIndex = function(t, e, i) {
                this.data[t][e] = i, this.clearCachedConvexTrianglePillar(t, e, !1), 0 < t && (this.clearCachedConvexTrianglePillar(t - 1, e, !0), 
                this.clearCachedConvexTrianglePillar(t - 1, e, !1)), 0 < e && (this.clearCachedConvexTrianglePillar(t, e - 1, !0), 
                this.clearCachedConvexTrianglePillar(t, e - 1, !1)), 0 < e && 0 < t && this.clearCachedConvexTrianglePillar(t - 1, e - 1, !0);
            }, s.prototype.getRectMinMax = function(t, e, i, o, n) {
                n = n || [];
                for (var s = this.data, r = this.minValue, a = t; a <= i; a++) for (var h = e; h <= o; h++) {
                    var l = s[a][h];
                    r < l && (r = l);
                }
                n[0] = this.minValue, n[1] = r;
            }, s.prototype.getIndexOfPosition = function(t, e, i, o) {
                var n = this.elementSize, s = this.data, r = Math.floor(t / n), a = Math.floor(e / n);
                return i[0] = r, i[1] = a, o && (r < 0 && (r = 0), a < 0 && (a = 0), r >= s.length - 1 && (r = s.length - 1), 
                a >= s[0].length - 1 && (a = s[0].length - 1)), !(r < 0 || a < 0 || r >= s.length - 1 || a >= s[0].length - 1);
            };
            var d = [], v = new u(), y = new u(), f = new u(), m = new u();
            s.prototype.getTriangleAt = function(t, e, i, o, n, s) {
                var r = d;
                this.getIndexOfPosition(t, e, r, i);
                var a = r[0], h = r[1], l = this.data;
                i && (a = Math.min(l.length - 2, Math.max(0, a)), h = Math.min(l[0].length - 2, Math.max(0, h)));
                var p = this.elementSize, c = Math.pow(t / p - a, 2) + Math.pow(e / p - h, 2), u = Math.pow(t / p - (a + 1), 2) + Math.pow(e / p - (h + 1), 2) < c;
                return this.getTriangle(a, h, u, o, n, s), u;
            };
            var l = new u(), p = new u(), w = new u(), g = new u(), x = new u();
            s.prototype.getNormalAt = function(t, e, i, o) {
                var n = l, s = p, r = w, a = g, h = x;
                this.getTriangleAt(t, e, i, n, s, r), s.vsub(n, a), r.vsub(n, h), a.cross(h, o), 
                o.normalize();
            }, s.prototype.getAabbAtIndex = function(t, e, i) {
                var o = this.data, n = this.elementSize;
                i.lowerBound.set(t * n, e * n, o[t][e]), i.upperBound.set((t + 1) * n, (e + 1) * n, o[t + 1][e + 1]);
            }, s.prototype.getHeightAt = function(t, e, i) {
                var o = this.data, n = y, s = f, r = m, a = d;
                this.getIndexOfPosition(t, e, a, i);
                var h = a[0], l = a[1];
                i && (h = Math.min(o.length - 2, Math.max(0, h)), l = Math.min(o[0].length - 2, Math.max(0, l)));
                var p = this.getTriangleAt(t, e, i, n, s, r);
                !function(t, e, i, o, n, s, r, a, h) {
                    h.x = ((s - a) * (t - r) + (r - n) * (e - a)) / ((s - a) * (i - r) + (r - n) * (o - a)), 
                    h.y = ((a - o) * (t - r) + (i - r) * (e - a)) / ((s - a) * (i - r) + (r - n) * (o - a)), 
                    h.z = 1 - h.x - h.y;
                }(t, e, n.x, n.y, s.x, s.y, r.x, r.y, v);
                var c = v;
                return p ? o[h + 1][l + 1] * c.x + o[h][l + 1] * c.y + o[h + 1][l] * c.z : o[h][l] * c.x + o[h + 1][l] * c.y + o[h][l + 1] * c.z;
            }, s.prototype.getCacheConvexTrianglePillarKey = function(t, e, i) {
                return t + "_" + e + "_" + (i ? 1 : 0);
            }, s.prototype.getCachedConvexTrianglePillar = function(t, e, i) {
                return this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)];
            }, s.prototype.setCachedConvexTrianglePillar = function(t, e, i, o, n) {
                this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)] = {
                    convex: o,
                    offset: n
                };
            }, s.prototype.clearCachedConvexTrianglePillar = function(t, e, i) {
                delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(t, e, i)];
            }, s.prototype.getTriangle = function(t, e, i, o, n, s) {
                var r = this.data, a = this.elementSize;
                i ? (o.set((t + 1) * a, (e + 1) * a, r[t + 1][e + 1]), n.set(t * a, (e + 1) * a, r[t][e + 1]), 
                s.set((t + 1) * a, e * a, r[t + 1][e])) : (o.set(t * a, e * a, r[t][e]), n.set((t + 1) * a, e * a, r[t + 1][e]), 
                s.set(t * a, (e + 1) * a, r[t][e + 1]));
            }, s.prototype.getConvexTrianglePillar = function(t, e, i) {
                var o = this.pillarConvex, n = this.pillarOffset;
                if (this.cacheEnabled) {
                    if (s = this.getCachedConvexTrianglePillar(t, e, i)) return this.pillarConvex = s.convex, 
                    void (this.pillarOffset = s.offset);
                    o = new c(), n = new u(), this.pillarConvex = o, this.pillarOffset = n;
                }
                var s = this.data, r = this.elementSize, a = o.faces;
                o.vertices.length = 6;
                for (var h = 0; h < 6; h++) o.vertices[h] || (o.vertices[h] = new u());
                for (a.length = 5, h = 0; h < 5; h++) a[h] || (a[h] = []);
                var l = o.vertices, p = (Math.min(s[t][e], s[t + 1][e], s[t][e + 1], s[t + 1][e + 1]) - this.minValue) / 2 + this.minValue;
                i ? (n.set((t + .75) * r, (e + .75) * r, p), l[0].set(.25 * r, .25 * r, s[t + 1][e + 1] - p), 
                l[1].set(-.75 * r, .25 * r, s[t][e + 1] - p), l[2].set(.25 * r, -.75 * r, s[t + 1][e] - p), 
                l[3].set(.25 * r, .25 * r, -p - 1), l[4].set(-.75 * r, .25 * r, -p - 1), l[5].set(.25 * r, -.75 * r, -p - 1), 
                a[0][0] = 0, a[0][1] = 1, a[0][2] = 2, a[1][0] = 5, a[1][1] = 4, a[1][2] = 3, a[2][0] = 2, 
                a[2][1] = 5, a[2][2] = 3, a[2][3] = 0, a[3][0] = 3, a[3][1] = 4, a[3][2] = 1, a[3][3] = 0, 
                a[4][0] = 1, a[4][1] = 4, a[4][2] = 5, a[4][3] = 2) : (n.set((t + .25) * r, (e + .25) * r, p), 
                l[0].set(-.25 * r, -.25 * r, s[t][e] - p), l[1].set(.75 * r, -.25 * r, s[t + 1][e] - p), 
                l[2].set(-.25 * r, .75 * r, s[t][e + 1] - p), l[3].set(-.25 * r, -.25 * r, -p - 1), 
                l[4].set(.75 * r, -.25 * r, -p - 1), l[5].set(-.25 * r, .75 * r, -p - 1), a[0][0] = 0, 
                a[0][1] = 1, a[0][2] = 2, a[1][0] = 5, a[1][1] = 4, a[1][2] = 3, a[2][0] = 0, a[2][1] = 2, 
                a[2][2] = 5, a[2][3] = 3, a[3][0] = 1, a[3][1] = 0, a[3][2] = 3, a[3][3] = 4, a[4][0] = 4, 
                a[4][1] = 5, a[4][2] = 2, a[4][3] = 1), o.computeNormals(), o.computeEdges(), o.updateBoundingSphereRadius(), 
                this.setCachedConvexTrianglePillar(t, e, i, o, n);
            }, s.prototype.calculateLocalInertia = function(t, e) {
                return (e = e || new u()).set(0, 0, 0), e;
            }, s.prototype.volume = function() {
                return Number.MAX_VALUE;
            }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                i.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), o.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            }, s.prototype.updateBoundingSphereRadius = function() {
                var t = this.data, e = this.elementSize;
                this.boundingSphereRadius = new u(t.length * e, t[0].length * e, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
            }, s.prototype.setHeightsFromImage = function(t, e) {
                var i = document.createElement("canvas");
                i.width = t.width, i.height = t.height;
                var o = i.getContext("2d");
                o.drawImage(t, 0, 0);
                var n = o.getImageData(0, 0, t.width, t.height), s = this.data;
                s.length = 0, this.elementSize = Math.abs(e.x) / n.width;
                for (var r = 0; r < n.height; r++) {
                    for (var a = [], h = 0; h < n.width; h++) {
                        var l = (n.data[4 * (r * n.height + h)] + n.data[4 * (r * n.height + h) + 1] + n.data[4 * (r * n.height + h) + 2]) / 4 / 255 * e.z;
                        e.x < 0 ? a.push(l) : a.unshift(l);
                    }
                    e.y < 0 ? s.unshift(a) : s.push(a);
                }
                this.updateMaxValue(), this.updateMinValue(), this.update();
            };
        }, {
            "../math/Vec3": 31,
            "../utils/Utils": 54,
            "./ConvexPolyhedron": 39,
            "./Shape": 44
        } ],
        42: [ function(t, e, i) {
            e.exports = s;
            var o = t("./Shape"), n = t("../math/Vec3");
            function s() {
                o.call(this, {
                    type: o.types.PARTICLE
                });
            }
            ((s.prototype = new o()).constructor = s).prototype.calculateLocalInertia = function(t, e) {
                return (e = e || new n()).set(0, 0, 0), e;
            }, s.prototype.volume = function() {
                return 0;
            }, s.prototype.updateBoundingSphereRadius = function() {
                this.boundingSphereRadius = 0;
            }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                i.copy(t), o.copy(t);
            };
        }, {
            "../math/Vec3": 31,
            "./Shape": 44
        } ],
        43: [ function(t, e, i) {
            e.exports = s;
            var o = t("./Shape"), n = t("../math/Vec3");
            function s() {
                o.call(this, {
                    type: o.types.PLANE
                }), this.worldNormal = new n(), this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE;
            }
            ((s.prototype = new o()).constructor = s).prototype.computeWorldNormal = function(t) {
                var e = this.worldNormal;
                e.set(0, 0, 1), t.vmult(e, e), this.worldNormalNeedsUpdate = !1;
            }, s.prototype.calculateLocalInertia = function(t, e) {
                return e || new n();
            }, s.prototype.volume = function() {
                return Number.MAX_VALUE;
            };
            var r = new n();
            s.prototype.calculateWorldAABB = function(t, e, i, o) {
                r.set(0, 0, 1), e.vmult(r, r);
                var n = Number.MAX_VALUE;
                i.set(-n, -n, -n), o.set(n, n, n), 1 === r.x && (o.x = t.x), 1 === r.y && (o.y = t.y), 
                1 === r.z && (o.z = t.z), -1 === r.x && (i.x = t.x), -1 === r.y && (i.y = t.y), 
                -1 === r.z && (i.z = t.z);
            }, s.prototype.updateBoundingSphereRadius = function() {
                this.boundingSphereRadius = Number.MAX_VALUE;
            };
        }, {
            "../math/Vec3": 31,
            "./Shape": 44
        } ],
        44: [ function(t, e, i) {
            e.exports = n;
            var o = t("../utils/EventTarget"), n = t("./Shape");
            function n(t) {
                t = t || {}, o.apply(this), this.id = n.idCounter++, this.type = t.type || 0, this.boundingSphereRadius = 0, 
                this.collisionResponse = !t.collisionResponse || t.collisionResponse, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : 1, 
                this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, 
                this.material = t.material ? t.material : null, this.body = null;
            }
            t("../math/Vec3"), t("../math/Quaternion"), t("../material/Material"), n.prototype = new o(), 
            (n.prototype.constructor = n).prototype.updateBoundingSphereRadius = function() {
                throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
            }, n.prototype.volume = function() {
                throw "volume() not implemented for shape type " + this.type;
            }, n.prototype.calculateLocalInertia = function(t, e) {
                throw "calculateLocalInertia() not implemented for shape type " + this.type;
            }, n.idCounter = 0, n.types = {
                SPHERE: 1,
                PLANE: 2,
                BOX: 4,
                COMPOUND: 8,
                CONVEXPOLYHEDRON: 16,
                HEIGHTFIELD: 32,
                PARTICLE: 64,
                CYLINDER: 128,
                TRIMESH: 256
            };
        }, {
            "../material/Material": 26,
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../utils/EventTarget": 50,
            "./Shape": 44
        } ],
        45: [ function(t, e, i) {
            e.exports = s;
            var o = t("./Shape"), n = t("../math/Vec3");
            function s(t) {
                if (o.call(this, {
                    type: o.types.SPHERE
                }), this.radius = void 0 !== t ? t : 1, this.radius < 0) throw new Error("The sphere radius cannot be negative.");
                this.updateBoundingSphereRadius();
            }
            ((s.prototype = new o()).constructor = s).prototype.calculateLocalInertia = function(t, e) {
                e = e || new n();
                var i = 2 * t * this.radius * this.radius / 5;
                return e.x = i, e.y = i, e.z = i, e;
            }, s.prototype.volume = function() {
                return 4 * Math.PI * this.radius / 3;
            }, s.prototype.updateBoundingSphereRadius = function() {
                this.boundingSphereRadius = this.radius;
            }, s.prototype.calculateWorldAABB = function(t, e, i, o) {
                for (var n = this.radius, s = [ "x", "y", "z" ], r = 0; r < s.length; r++) {
                    var a = s[r];
                    i[a] = t[a] - n, o[a] = t[a] + n;
                }
            };
        }, {
            "../math/Vec3": 31,
            "./Shape": 44
        } ],
        46: [ function(t, e, i) {
            e.exports = w;
            var o = t("./Shape"), l = t("../math/Vec3"), n = (t("../math/Quaternion"), t("../math/Transform")), p = t("../collision/AABB"), s = t("../utils/Octree");
            function w(t, e) {
                o.call(this, {
                    type: o.types.TRIMESH
                }), this.vertices = new Float32Array(t), this.indices = new Int16Array(e), this.normals = new Float32Array(e.length), 
                this.aabb = new p(), this.edges = null, this.scale = new l(1, 1, 1), this.tree = new s(), 
                this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), 
                this.updateTree();
            }
            (w.prototype = new o()).constructor = w;
            var a = new l();
            w.prototype.updateTree = function() {
                var t = this.tree;
                t.reset(), t.aabb.copy(this.aabb);
                var e = this.scale;
                t.aabb.lowerBound.x *= 1 / e.x, t.aabb.lowerBound.y *= 1 / e.y, t.aabb.lowerBound.z *= 1 / e.z, 
                t.aabb.upperBound.x *= 1 / e.x, t.aabb.upperBound.y *= 1 / e.y, t.aabb.upperBound.z *= 1 / e.z;
                for (var i = new p(), o = new l(), n = new l(), s = new l(), r = [ o, n, s ], a = 0; a < this.indices.length / 3; a++) {
                    var h = 3 * a;
                    this._getUnscaledVertex(this.indices[h], o), this._getUnscaledVertex(this.indices[1 + h], n), 
                    this._getUnscaledVertex(this.indices[2 + h], s), i.setFromPoints(r), t.insert(i, a);
                }
                t.removeEmptyNodes();
            };
            var h = new p();
            w.prototype.getTrianglesInAABB = function(t, e) {
                h.copy(t);
                var i = this.scale, o = i.x, n = i.y, s = i.z, r = h.lowerBound, a = h.upperBound;
                return r.x /= o, r.y /= n, r.z /= s, a.x /= o, a.y /= n, a.z /= s, this.tree.aabbQuery(h, e);
            }, w.prototype.setScale = function(t) {
                var e = this.scale.x === this.scale.y === this.scale.z, i = t.x === t.y === t.z;
                e && i || this.updateNormals(), this.scale.copy(t), this.updateAABB(), this.updateBoundingSphereRadius();
            }, w.prototype.updateNormals = function() {
                for (var t = a, e = this.normals, i = 0; i < this.indices.length / 3; i++) {
                    var o = 3 * i, n = this.indices[o], s = this.indices[1 + o], r = this.indices[2 + o];
                    this.getVertex(n, v), this.getVertex(s, y), this.getVertex(r, f), w.computeNormal(y, v, f, t), 
                    e[o] = t.x, e[1 + o] = t.y, e[2 + o] = t.z;
                }
            }, w.prototype.updateEdges = function() {
                function t(t, e) {
                    i[n < s ? n + "_" + s : s + "_" + n] = !0;
                }
                for (var i = {}, e = 0; e < this.indices.length / 3; e++) {
                    var o = 3 * e, n = this.indices[o], s = this.indices[1 + o];
                    this.indices[2 + o], t(), t(), t();
                }
                var r = Object.keys(i);
                for (this.edges = new Int16Array(2 * r.length), e = 0; e < r.length; e++) {
                    var a = r[e].split("_");
                    this.edges[2 * e] = parseInt(a[0], 10), this.edges[2 * e + 1] = parseInt(a[1], 10);
                }
            }, w.prototype.getEdgeVertex = function(t, e, i) {
                var o = this.edges[2 * t + (e ? 1 : 0)];
                this.getVertex(o, i);
            };
            var r = new l(), c = new l();
            w.prototype.getEdgeVector = function(t, e) {
                var i = r, o = c;
                this.getEdgeVertex(t, 0, i), this.getEdgeVertex(t, 1, o), o.vsub(i, e);
            };
            var u = new l(), d = new l();
            w.computeNormal = function(t, e, i, o) {
                e.vsub(t, d), i.vsub(e, u), u.cross(d, o), o.isZero() || o.normalize();
            };
            var v = new l(), y = new l(), f = new l();
            w.prototype.getVertex = function(t, e) {
                var i = this.scale;
                return this._getUnscaledVertex(t, e), e.x *= i.x, e.y *= i.y, e.z *= i.z, e;
            }, w.prototype._getUnscaledVertex = function(t, e) {
                var i = 3 * t, o = this.vertices;
                return e.set(o[i], o[1 + i], o[2 + i]);
            }, w.prototype.getWorldVertex = function(t, e, i, o) {
                return this.getVertex(t, o), n.pointToWorldFrame(e, i, o, o), o;
            }, w.prototype.getTriangleVertices = function(t, e, i, o) {
                var n = 3 * t;
                this.getVertex(this.indices[n], e), this.getVertex(this.indices[1 + n], i), this.getVertex(this.indices[2 + n], o);
            }, w.prototype.getNormal = function(t, e) {
                var i = 3 * t;
                return e.set(this.normals[i], this.normals[1 + i], this.normals[2 + i]);
            };
            var m = new p();
            w.prototype.calculateLocalInertia = function(t, e) {
                this.computeLocalAABB(m);
                var i = m.upperBound.x - m.lowerBound.x, o = m.upperBound.y - m.lowerBound.y, n = m.upperBound.z - m.lowerBound.z;
                return e.set(1 / 12 * t * (2 * o * 2 * o + 2 * n * 2 * n), 1 / 12 * t * (2 * i * 2 * i + 2 * n * 2 * n), 1 / 12 * t * (2 * o * 2 * o + 2 * i * 2 * i));
            };
            var g = new l();
            w.prototype.computeLocalAABB = function(t) {
                var e = t.lowerBound, i = t.upperBound, o = this.vertices.length, n = (this.vertices, 
                g);
                this.getVertex(0, n), e.copy(n), i.copy(n);
                for (var s = 0; s !== o; s++) this.getVertex(s, n), n.x < e.x ? e.x = n.x : n.x > i.x && (i.x = n.x), 
                n.y < e.y ? e.y = n.y : n.y > i.y && (i.y = n.y), n.z < e.z ? e.z = n.z : n.z > i.z && (i.z = n.z);
            }, w.prototype.updateAABB = function() {
                this.computeLocalAABB(this.aabb);
            }, w.prototype.updateBoundingSphereRadius = function() {
                for (var t = 0, e = this.vertices, i = new l(), o = 0, n = e.length / 3; o !== n; o++) {
                    this.getVertex(o, i);
                    var s = i.norm2();
                    t < s && (t = s);
                }
                this.boundingSphereRadius = Math.sqrt(t);
            }, new l();
            var x = new n(), b = new p();
            w.prototype.calculateWorldAABB = function(t, e, i, o) {
                var n = x, s = b;
                n.position = t, n.quaternion = e, this.aabb.toWorldFrame(n, s), i.copy(s.lowerBound), 
                o.copy(s.upperBound);
            }, w.prototype.volume = function() {
                return 4 * Math.PI * this.boundingSphereRadius / 3;
            }, w.createTorus = function(t, e, i, o, n) {
                t = t || 1, e = e || .5, i = i || 8, o = o || 6, n = n || 2 * Math.PI;
                for (var s = [], r = [], a = 0; a <= i; a++) for (var h = 0; h <= o; h++) {
                    var l = h / o * n, p = a / i * Math.PI * 2, c = (t + e * Math.cos(p)) * Math.cos(l), u = (t + e * Math.cos(p)) * Math.sin(l), d = e * Math.sin(p);
                    s.push(c, u, d);
                }
                for (a = 1; a <= i; a++) for (h = 1; h <= o; h++) {
                    var v = (o + 1) * a + h - 1, y = (o + 1) * (a - 1) + h - 1, f = (o + 1) * (a - 1) + h, m = (o + 1) * a + h;
                    r.push(v, y, m), r.push(y, f, m);
                }
                return new w(s, r);
            };
        }, {
            "../collision/AABB": 3,
            "../math/Quaternion": 29,
            "../math/Transform": 30,
            "../math/Vec3": 31,
            "../utils/Octree": 51,
            "./Shape": 44
        } ],
        47: [ function(t, e, i) {
            e.exports = n, t("../math/Vec3"), t("../math/Quaternion");
            var o = t("./Solver");
            function n() {
                o.call(this), this.iterations = 10, this.tolerance = 1e-7;
            }
            n.prototype = new o();
            var C = [], q = [], F = [];
            n.prototype.solve = function(t, e) {
                var i, o, n, s, r, a = 0, h = this.iterations, l = this.tolerance * this.tolerance, p = this.equations, c = p.length, u = e.bodies, d = u.length, v = t;
                if (0 !== c) for (var y = 0; y !== d; y++) u[y].updateSolveMassProperties();
                var f = q, m = F, w = C;
                for (f.length = c, m.length = c, w.length = c, y = 0; y !== c; y++) {
                    var g = p[y];
                    w[y] = 0, m[y] = g.computeB(v), f[y] = 1 / g.computeC();
                }
                if (0 !== c) {
                    for (y = 0; y !== d; y++) {
                        var x = (E = u[y]).vlambda, b = E.wlambda;
                        x.set(0, 0, 0), b.set(0, 0, 0);
                    }
                    for (a = 0; a !== h; a++) {
                        for (var B = s = 0; B !== c; B++) g = p[B], i = m[B], o = f[B], (r = w[B]) + (n = o * (i - g.computeGWlambda() - g.eps * r)) < g.minForce ? n = g.minForce - r : r + n > g.maxForce && (n = g.maxForce - r), 
                        w[B] += n, s += 0 < n ? n : -n, g.addToWlambda(n);
                        if (s * s < l) break;
                    }
                    for (y = 0; y !== d; y++) {
                        var E, A = (E = u[y]).velocity, S = E.angularVelocity;
                        E.vlambda.vmul(E.linearFactor, E.vlambda), A.vadd(E.vlambda, A), E.wlambda.vmul(E.angularFactor, E.wlambda), 
                        S.vadd(E.wlambda, S);
                    }
                    for (var z = p.length, M = 1 / v; z--; ) p[z].multiplier = w[z] * M;
                }
                return a;
            };
        }, {
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "./Solver": 48
        } ],
        48: [ function(t, e, i) {
            function o() {
                this.equations = [];
            }
            (e.exports = o).prototype.solve = function(t, e) {
                return 0;
            }, o.prototype.addEquation = function(t) {
                t.enabled && this.equations.push(t);
            }, o.prototype.removeEquation = function(t) {
                var e = this.equations, i = e.indexOf(t);
                -1 !== i && e.splice(i, 1);
            }, o.prototype.removeAllEquations = function() {
                this.equations.length = 0;
            };
        }, {} ],
        49: [ function(t, e, i) {
            e.exports = s, t("../math/Vec3"), t("../math/Quaternion");
            var o = t("./Solver"), n = t("../objects/Body");
            function s(t) {
                for (o.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = t, 
                this.nodes = [], this.nodePool = []; this.nodePool.length < 128; ) this.nodePool.push(this.createNode());
            }
            s.prototype = new o();
            var b = [], B = [], E = {
                bodies: []
            }, r = n.STATIC;
            function A(t) {
                for (var e = t.length, i = 0; i !== e; i++) {
                    var o = t[i];
                    if (!(o.visited || o.body.type & r)) return o;
                }
                return !1;
            }
            var a = [];
            function S(t, e, i, o) {
                for (a.push(t), t.visited = !0, e(t, i, o); a.length; ) for (var n, s = a.pop(); n = A(s.children); ) n.visited = !0, 
                e(n, i, o), a.push(n);
            }
            function z(t, e, i) {
                e.push(t.body);
                for (var o = t.eqs.length, n = 0; n !== o; n++) {
                    var s = t.eqs[n];
                    -1 === i.indexOf(s) && i.push(s);
                }
            }
            function M(t, e) {
                return e.id - t.id;
            }
            s.prototype.createNode = function() {
                return {
                    body: null,
                    children: [],
                    eqs: [],
                    visited: !1
                };
            }, s.prototype.solve = function(t, e) {
                for (var i = b, o = this.nodePool, n = e.bodies, s = this.equations, r = s.length, a = n.length, h = this.subsolver; o.length < a; ) o.push(this.createNode());
                i.length = a;
                for (var l = 0; l < a; l++) i[l] = o[l];
                for (l = 0; l !== a; l++) {
                    var p = i[l];
                    p.body = n[l], p.children.length = 0, p.eqs.length = 0, p.visited = !1;
                }
                for (var c = 0; c !== r; c++) {
                    var u = s[c], d = (l = n.indexOf(u.bi), n.indexOf(u.bj)), v = i[l], y = i[d];
                    v.children.push(y), v.eqs.push(u), y.children.push(v), y.eqs.push(u);
                }
                var f, m = 0, w = B;
                h.tolerance = this.tolerance, h.iterations = this.iterations;
                for (var g = E; f = A(i); ) {
                    w.length = 0, g.bodies.length = 0, S(f, z, g.bodies, w);
                    var x = w.length;
                    for (w = w.sort(M), l = 0; l !== x; l++) h.addEquation(w[l]);
                    h.solve(t, g), h.removeAllEquations(), m++;
                }
                return m;
            };
        }, {
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../objects/Body": 32,
            "./Solver": 48
        } ],
        50: [ function(t, e, i) {
            function o() {}
            (e.exports = o).prototype = {
                constructor: o,
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var i = this._listeners;
                    return void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e), this;
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e);
                },
                hasAnyEventListener: function(t) {
                    return void 0 !== this._listeners && void 0 !== this._listeners[t];
                },
                removeEventListener: function(t, e) {
                    if (void 0 === this._listeners) return this;
                    var i = this._listeners;
                    if (void 0 === i[t]) return this;
                    var o = i[t].indexOf(e);
                    return -1 !== o && i[t].splice(o, 1), this;
                },
                dispatchEvent: function(t) {
                    if (void 0 === this._listeners) return this;
                    var e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        for (var i = 0, o = e.length; i < o; i++) e[i].call(this, t);
                    }
                    return this;
                }
            };
        }, {} ],
        51: [ function(t, e, i) {
            var h = t("../collision/AABB"), l = t("../math/Vec3");
            function p(t) {
                t = t || {}, this.root = t.root || null, this.aabb = t.aabb ? t.aabb.clone() : new h(), 
                this.data = [], this.children = [];
            }
            (e.exports = function o(t, e) {
                (e = e || {}).root = null, e.aabb = t, p.call(this, e), this.maxDepth = void 0 !== e.maxDepth ? e.maxDepth : 8;
            }).prototype = new p(), p.prototype.reset = function(t, e) {
                this.children.length = this.data.length = 0;
            }, p.prototype.insert = function(t, e, i) {
                var o = this.data;
                if (i = i || 0, !this.aabb.contains(t)) return !1;
                var n = this.children;
                if (i < (this.maxDepth || this.root.maxDepth)) {
                    var s = !1;
                    n.length || (this.subdivide(), s = !0);
                    for (var r = 0; 8 !== r; r++) if (n[r].insert(t, e, i + 1)) return !0;
                    s && (n.length = 0);
                }
                return o.push(e), !0;
            };
            var c = new l();
            p.prototype.subdivide = function() {
                var t = this.aabb, e = t.lowerBound, i = t.upperBound, o = this.children;
                o.push(new p({
                    aabb: new h({
                        lowerBound: new l(0, 0, 0)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(1, 0, 0)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(1, 1, 0)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(1, 1, 1)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(0, 1, 1)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(0, 0, 1)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(1, 0, 1)
                    })
                }), new p({
                    aabb: new h({
                        lowerBound: new l(0, 1, 0)
                    })
                })), i.vsub(e, c), c.scale(.5, c);
                for (var n = this.root || this, s = 0; 8 !== s; s++) {
                    var r = o[s];
                    r.root = n;
                    var a = r.aabb.lowerBound;
                    a.x *= c.x, a.y *= c.y, a.z *= c.z, a.vadd(e, a), a.vadd(c, r.aabb.upperBound);
                }
            }, p.prototype.aabbQuery = function(t, e) {
                this.data, this.children;
                for (var i = [ this ]; i.length; ) {
                    var o = i.pop();
                    o.aabb.overlaps(t) && Array.prototype.push.apply(e, o.data), Array.prototype.push.apply(i, o.children);
                }
                return e;
            };
            var n = new h();
            p.prototype.rayQuery = function(t, e, i) {
                return t.getAABB(n), n.toLocalFrame(e, n), this.aabbQuery(n, i), i;
            }, p.prototype.removeEmptyNodes = function() {
                for (var t = [ this ]; t.length; ) {
                    for (var e = t.pop(), i = e.children.length - 1; 0 <= i; i--) e.children[i].data.length || e.children.splice(i, 1);
                    Array.prototype.push.apply(t, e.children);
                }
            };
        }, {
            "../collision/AABB": 3,
            "../math/Vec3": 31
        } ],
        52: [ function(t, e, i) {
            function o() {
                this.objects = [], this.type = Object;
            }
            (e.exports = o).prototype.release = function() {
                for (var t = arguments.length, e = 0; e !== t; e++) this.objects.push(arguments[e]);
                return this;
            }, o.prototype.get = function() {
                return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
            }, o.prototype.constructObject = function() {
                throw new Error("constructObject() not implemented in this Pool subclass yet!");
            }, o.prototype.resize = function(t) {
                for (var e = this.objects; e.length > t; ) e.pop();
                for (;e.length < t; ) e.push(this.constructObject());
                return this;
            };
        }, {} ],
        53: [ function(t, e, i) {
            function o() {
                this.data = {
                    keys: []
                };
            }
            (e.exports = o).prototype.get = function(t, e) {
                if (e < t) {
                    var i = e;
                    e = t, t = i;
                }
                return this.data[t + "-" + e];
            }, o.prototype.set = function(t, e, i) {
                if (e < t) {
                    var o = e;
                    e = t, t = o;
                }
                var n = t + "-" + e;
                return this.get(t, e) || this.data.keys.push(n), this.data[n] = i, this.data[n];
            }, o.prototype.reset = function() {
                for (var t = this.data, e = t.keys; 0 < e.length; ) delete t[e.pop()];
            }, o.prototype.getLength = function() {
                return this.data.keys.length;
            }, o.prototype.getKeyByIndex = function(t) {
                return this.data.keys[t];
            }, o.prototype.getDataByKey = function(t) {
                return this.data[t];
            };
        }, {} ],
        54: [ function(t, e, i) {
            (e.exports = function o() {}).defaults = function(t, e) {
                for (var i in t = t || {}, e) i in t || (t[i] = e[i]);
                return t;
            };
        }, {} ],
        55: [ function(t, e, i) {
            e.exports = s;
            var o = t("../math/Vec3"), n = t("./Pool");
            function s() {
                n.call(this), this.type = o;
            }
            (s.prototype = new n()).constructObject = function() {
                return new o();
            };
        }, {
            "../math/Vec3": 31,
            "./Pool": 52
        } ],
        56: [ function(t, e, i) {
            e.exports = a;
            var o = t("../collision/AABB"), E = t("../objects/Body"), n = t("../shapes/Shape"), I = t("../collision/Ray"), w = t("../math/Vec3"), N = t("../math/Transform"), s = (t("../shapes/ConvexPolyhedron"), 
            t("../math/Quaternion")), r = (t("../solver/Solver"), t("../utils/Vec3Pool")), p = t("../equations/ContactEquation"), f = t("../equations/FrictionEquation");
            function a(t) {
                this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], 
                this.v3pool = new r(), this.world = t, this.currentContactMaterial = null, this.enableFrictionReduction = !1;
            }
            a.prototype.createContactEquation = function(t, e, i, o, n, s) {
                var r;
                this.contactPointPool.length ? ((r = this.contactPointPool.pop()).bi = t, r.bj = e) : r = new p(t, e);
                var a = this.currentContactMaterial;
                r.restitution = a.restitution, r.setSpookParams(a.contactEquationStiffness, a.contactEquationRelaxation, this.world.dt);
                var h = i.material || t.material, l = o.material || e.material;
                return h && l && 0 <= h.restitution && 0 <= l.restitution && (r.restitution = h.restitution * l.restitution), 
                r.si = n || i, r.sj = s || o, r;
            }, a.prototype.createFrictionEquationsFromContact = function(t, e) {
                var i = t.bi, o = t.bj, n = t.si, s = t.sj, r = this.world, a = this.currentContactMaterial, h = a.friction, l = n.material || i.material, p = s.material || o.material;
                if (l && p && 0 <= l.friction && 0 <= p.friction && (h = l.friction * p.friction), 
                0 < h) {
                    var c = h * r.gravity.length(), u = i.invMass + o.invMass;
                    0 < u && (u = 1 / u);
                    var d = this.frictionEquationPool, v = d.length ? d.pop() : new f(i, o, c * u), y = d.length ? d.pop() : new f(i, o, c * u);
                    return v.bi = y.bi = i, v.bj = y.bj = o, v.minForce = y.minForce = -c * u, v.maxForce = y.maxForce = c * u, 
                    v.ri.copy(t.ri), v.rj.copy(t.rj), y.ri.copy(t.ri), y.rj.copy(t.rj), t.ni.tangents(v.t, y.t), 
                    v.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, r.dt), 
                    y.setSpookParams(a.frictionEquationStiffness, a.frictionEquationRelaxation, r.dt), 
                    v.enabled = y.enabled = t.enabled, e.push(v, y), !0;
                }
                return !1;
            };
            var h = new w(), l = new w(), c = new w();
            a.prototype.createFrictionFromAverage = function(t) {
                var e = this.result[this.result.length - 1];
                if (this.createFrictionEquationsFromContact(e, this.frictionResult) && 1 !== t) {
                    var i = this.frictionResult[this.frictionResult.length - 2], o = this.frictionResult[this.frictionResult.length - 1];
                    h.setZero(), l.setZero(), c.setZero();
                    for (var n = e.bi, s = (e.bj, 0); s !== t; s++) (e = this.result[this.result.length - 1 - s]).bodyA !== n ? (h.vadd(e.ni, h), 
                    l.vadd(e.ri, l), c.vadd(e.rj, c)) : (h.vsub(e.ni, h), l.vadd(e.rj, l), c.vadd(e.ri, c));
                    var r = 1 / t;
                    l.scale(r, i.ri), c.scale(r, i.rj), o.ri.copy(i.ri), o.rj.copy(i.rj), h.normalize(), 
                    h.tangents(i.t, o.t);
                }
            };
            var A = new w(), S = new w(), z = new s(), M = new s();
            a.prototype.getContacts = function(t, e, i, o, n, s, r) {
                this.contactPointPool = n, this.frictionEquationPool = r, this.result = o, this.frictionResult = s;
                for (var a = z, h = M, l = A, p = S, c = 0, u = t.length; c !== u; c++) {
                    var d = t[c], v = e[c], y = null;
                    d.material && v.material && (y = i.getContactMaterial(d.material, v.material) || null);
                    for (var f = 0 == d.collisionResponse || 0 == v.collisionResponse || d.type & E.KINEMATIC && v.type & E.STATIC || d.type & E.STATIC && v.type & E.KINEMATIC || d.type & E.KINEMATIC && v.type & E.KINEMATIC, m = 0; m < d.shapes.length; m++) {
                        d.quaternion.mult(d.shapeOrientations[m], a), d.quaternion.vmult(d.shapeOffsets[m], l), 
                        l.vadd(d.position, l);
                        for (var w = d.shapes[m], g = 0; g < v.shapes.length; g++) {
                            v.quaternion.mult(v.shapeOrientations[g], h), v.quaternion.vmult(v.shapeOffsets[g], p), 
                            p.vadd(v.position, p);
                            var x = v.shapes[g];
                            if (w.collisionFilterMask & x.collisionFilterGroup && x.collisionFilterMask & w.collisionFilterGroup && !(l.distanceTo(p) > w.boundingSphereRadius + x.boundingSphereRadius)) {
                                f |= 0 == w.collisionResponse || 0 == x.collisionResponse;
                                var b = null;
                                w.material && x.material && (b = i.getContactMaterial(w.material, x.material) || null), 
                                this.currentContactMaterial = b || y || i.defaultContactMaterial;
                                var B = this[w.type | x.type];
                                B && (w.type < x.type ? B.call(this, w, x, l, p, a, h, d, v, w, x, f) : B.call(this, x, w, p, l, h, a, v, d, w, x, f)) && f && (i.shapeOverlapKeeper.set(w.id, x.id), 
                                i.shapeOverlapKeeperExit.set(w.id, x.id), i.bodyOverlapKeeper.set(d.id, v.id));
                            }
                        }
                    }
                }
            }, a.prototype[n.types.BOX | n.types.BOX] = a.prototype.boxBox = function(t, e, i, o, n, s, r, a, h, l, p) {
                return t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.material = e.material, 
                t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, 
                this.convexConvex(t.convexPolyhedronRepresentation, e.convexPolyhedronRepresentation, i, o, n, s, r, a, t, e, p);
            }, a.prototype[n.types.BOX | n.types.CONVEXPOLYHEDRON] = a.prototype.boxConvex = function(t, e, i, o, n, s, r, a, h, l, p) {
                return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                this.convexConvex(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, p);
            }, a.prototype[n.types.BOX | n.types.PARTICLE] = a.prototype.boxParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                this.convexParticle(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, p);
            }, a.prototype[n.types.SPHERE] = a.prototype.sphereSphere = function(t, e, i, o, n, s, r, a, h, l, p) {
                if (p) return i.distanceSquared(o) < Math.pow(t.radius + e.radius, 2);
                var c = this.createContactEquation(r, a, t, e, h, l);
                o.vsub(i, c.ni), c.ni.normalize(), c.ri.copy(c.ni), c.rj.copy(c.ni), c.ri.mult(t.radius, c.ri), 
                c.rj.mult(-e.radius, c.rj), c.ri.vadd(i, c.ri), c.ri.vsub(r.position, c.ri), c.rj.vadd(o, c.rj), 
                c.rj.vsub(a.position, c.rj), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult);
            };
            var g = new w(), x = new w(), b = new w();
            a.prototype[n.types.PLANE | n.types.TRIMESH] = a.prototype.planeTrimesh = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = new w(), u = g;
                u.set(0, 0, 1), n.vmult(u, u);
                for (var d = 0; d < e.vertices.length / 3; d++) {
                    e.getVertex(d, c);
                    var v = new w();
                    v.copy(c), N.pointToWorldFrame(o, s, v, c);
                    var y = x;
                    if (c.vsub(i, y), u.dot(y) <= 0) {
                        if (p) return !0;
                        var f = this.createContactEquation(r, a, t, e, h, l);
                        f.ni.copy(u);
                        var m = b;
                        u.scale(y.dot(u), m), c.vsub(m, m), f.ri.copy(m), f.ri.vsub(r.position, f.ri), f.rj.copy(c), 
                        f.rj.vsub(a.position, f.rj), this.result.push(f), this.createFrictionEquationsFromContact(f, this.frictionResult);
                    }
                }
            };
            var L = new w(), W = new w(), j = (new w(), new w()), O = new w(), k = new w(), _ = new w(), D = new w(), U = new w(), H = new w(), G = new w(), X = new w(), Q = new w(), Y = new w(), K = new o(), Z = [];
            a.prototype[n.types.SPHERE | n.types.TRIMESH] = a.prototype.sphereTrimesh = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = k, u = _, d = D, v = U, y = H, f = G, m = K, w = O, g = W, x = Z;
                N.pointToLocalFrame(o, s, i, y);
                var b = t.radius;
                m.lowerBound.set(y.x - b, y.y - b, y.z - b), m.upperBound.set(y.x + b, y.y + b, y.z + b), 
                e.getTrianglesInAABB(m, x);
                for (var B = j, E = t.radius * t.radius, A = 0; A < x.length; A++) for (var S = 0; S < 3; S++) if (e.getVertex(e.indices[3 * x[A] + S], B), 
                B.vsub(y, g), g.norm2() <= E) {
                    if (w.copy(B), N.pointToWorldFrame(o, s, w, B), B.vsub(i, g), p) return !0;
                    (C = this.createContactEquation(r, a, t, e, h, l)).ni.copy(g), C.ni.normalize(), 
                    C.ri.copy(C.ni), C.ri.scale(t.radius, C.ri), C.ri.vadd(i, C.ri), C.ri.vsub(r.position, C.ri), 
                    C.rj.copy(B), C.rj.vsub(a.position, C.rj), this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
                }
                for (A = 0; A < x.length; A++) for (S = 0; S < 3; S++) {
                    e.getVertex(e.indices[3 * x[A] + S], c), e.getVertex(e.indices[3 * x[A] + (S + 1) % 3], u), 
                    u.vsub(c, d), y.vsub(u, f);
                    var z = f.dot(d);
                    y.vsub(c, f);
                    var M = f.dot(d);
                    if (0 < M && z < 0 && (y.vsub(c, f), v.copy(d), v.normalize(), M = f.dot(v), v.scale(M, f), 
                    f.vadd(c, f), (V = f.distanceTo(y)) < t.radius)) {
                        if (p) return !0;
                        var C = this.createContactEquation(r, a, t, e, h, l);
                        f.vsub(y, C.ni), C.ni.normalize(), C.ni.scale(t.radius, C.ri), N.pointToWorldFrame(o, s, f, f), 
                        f.vsub(a.position, C.rj), N.vectorToWorldFrame(s, C.ni, C.ni), N.vectorToWorldFrame(s, C.ri, C.ri), 
                        this.result.push(C), this.createFrictionEquationsFromContact(C, this.frictionResult);
                    }
                }
                for (var q = X, F = Q, R = Y, T = L, P = (A = 0, x.length); A !== P; A++) {
                    e.getTriangleVertices(x[A], q, F, R), e.getNormal(x[A], T), y.vsub(q, f);
                    var V = f.dot(T);
                    if (T.scale(V, f), y.vsub(f, f), V = f.distanceTo(y), I.pointInTriangle(f, q, F, R) && V < t.radius) {
                        if (p) return !0;
                        C = this.createContactEquation(r, a, t, e, h, l), f.vsub(y, C.ni), C.ni.normalize(), 
                        C.ni.scale(t.radius, C.ri), N.pointToWorldFrame(o, s, f, f), f.vsub(a.position, C.rj), 
                        N.vectorToWorldFrame(s, C.ni, C.ni), N.vectorToWorldFrame(s, C.ri, C.ri), this.result.push(C), 
                        this.createFrictionEquationsFromContact(C, this.frictionResult);
                    }
                }
                x.length = 0;
            };
            var v = new w(), y = new w(), m = new w(), B = new w(), C = new w();
            a.prototype[n.types.SPHERE | n.types.PLANE] = a.prototype.spherePlane = function(t, e, i, o, n, s, r, a, h, l, p) {
                if (m.set(0, 0, 1), s.vmult(m, m), m.negate(m), m.normalize(), m.mult(t.radius, B), 
                i.vsub(o, v), m.mult(m.dot(v), y), v.vsub(y, C), -v.dot(m) <= t.radius) {
                    if (p) return !0;
                    var c = this.createContactEquation(r, a, t, e, h, l);
                    c.ni.copy(m), c.ri.copy(B), c.rj.copy(C);
                    var u = c.ri, d = c.rj;
                    u.vadd(i, u), u.vsub(r.position, u), d.vadd(o, d), d.vsub(a.position, d), this.result.push(c), 
                    this.createFrictionEquationsFromContact(c, this.frictionResult);
                }
            };
            var u = new w(), d = new w(), q = new w();
            function J(t, e, i) {
                for (var o = null, n = t.length, s = 0; s !== n; s++) {
                    var r = t[s], a = u;
                    t[(s + 1) % n].vsub(r, a);
                    var h = d;
                    a.cross(e, h);
                    var l = q;
                    i.vsub(r, l);
                    var p = h.dot(l);
                    if (!(null === o || 0 < p && !0 === o || p <= 0 && !1 === o)) return !1;
                    null === o && (o = 0 < p);
                }
                return !0;
            }
            var $ = new w(), tt = new w(), et = new w(), it = new w(), ot = [ new w(), new w(), new w(), new w(), new w(), new w() ], nt = new w(), st = new w(), rt = new w(), at = new w();
            a.prototype[n.types.SPHERE | n.types.BOX] = a.prototype.sphereBox = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = this.v3pool, u = ot;
                i.vsub(o, $), e.getSideNormals(u, s);
                for (var d = t.radius, v = !1, y = st, f = rt, m = at, w = null, g = 0, x = 0, b = 0, B = null, E = 0, A = u.length; E !== A && !1 === v; E++) {
                    var S = tt;
                    S.copy(u[E]);
                    var z = S.norm();
                    S.normalize();
                    var M = $.dot(S);
                    if (M < z + d && 0 < M) {
                        var C = et, q = it;
                        C.copy(u[(E + 1) % 3]), q.copy(u[(E + 2) % 3]);
                        var F = C.norm(), R = q.norm();
                        C.normalize(), q.normalize();
                        var T = $.dot(C), P = $.dot(q);
                        if (T < F && -F < T && P < R && -R < P) {
                            var V = Math.abs(M - z - d);
                            if ((null === B || V < B) && (B = V, x = T, b = P, w = z, y.copy(S), f.copy(C), 
                            m.copy(q), g++, p)) return !0;
                        }
                    }
                }
                if (g) {
                    v = !0;
                    var I = this.createContactEquation(r, a, t, e, h, l);
                    y.mult(-d, I.ri), I.ni.copy(y), I.ni.negate(I.ni), y.mult(w, y), f.mult(x, f), y.vadd(f, y), 
                    m.mult(b, m), y.vadd(m, I.rj), I.ri.vadd(i, I.ri), I.ri.vsub(r.position, I.ri), 
                    I.rj.vadd(o, I.rj), I.rj.vsub(a.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
                }
                for (var N = c.get(), L = nt, W = 0; 2 !== W && !v; W++) for (var j = 0; 2 !== j && !v; j++) for (var O = 0; 2 !== O && !v; O++) if (N.set(0, 0, 0), 
                W ? N.vadd(u[0], N) : N.vsub(u[0], N), j ? N.vadd(u[1], N) : N.vsub(u[1], N), O ? N.vadd(u[2], N) : N.vsub(u[2], N), 
                o.vadd(N, L), L.vsub(i, L), L.norm2() < d * d) {
                    if (p) return !0;
                    v = !0, (I = this.createContactEquation(r, a, t, e, h, l)).ri.copy(L), I.ri.normalize(), 
                    I.ni.copy(I.ri), I.ri.mult(d, I.ri), I.rj.copy(N), I.ri.vadd(i, I.ri), I.ri.vsub(r.position, I.ri), 
                    I.rj.vadd(o, I.rj), I.rj.vsub(a.position, I.rj), this.result.push(I), this.createFrictionEquationsFromContact(I, this.frictionResult);
                }
                c.release(N), N = null;
                var k = c.get(), _ = c.get(), D = (I = c.get(), c.get()), U = (V = c.get(), u.length);
                for (W = 0; W !== U && !v; W++) for (j = 0; j !== U && !v; j++) if (W % 3 != j % 3) {
                    u[j].cross(u[W], k), k.normalize(), u[W].vadd(u[j], _), I.copy(i), I.vsub(_, I), 
                    I.vsub(o, I);
                    var H = I.dot(k);
                    for (k.mult(H, D), O = 0; O === W % 3 || O === j % 3; ) O++;
                    V.copy(i), V.vsub(D, V), V.vsub(_, V), V.vsub(o, V);
                    var G = Math.abs(H), X = V.norm();
                    if (G < u[O].norm() && X < d) {
                        if (p) return !0;
                        v = !0;
                        var Q = this.createContactEquation(r, a, t, e, h, l);
                        _.vadd(D, Q.rj), Q.rj.copy(Q.rj), V.negate(Q.ni), Q.ni.normalize(), Q.ri.copy(Q.rj), 
                        Q.ri.vadd(o, Q.ri), Q.ri.vsub(i, Q.ri), Q.ri.normalize(), Q.ri.mult(d, Q.ri), Q.ri.vadd(i, Q.ri), 
                        Q.ri.vsub(r.position, Q.ri), Q.rj.vadd(o, Q.rj), Q.rj.vsub(a.position, Q.rj), this.result.push(Q), 
                        this.createFrictionEquationsFromContact(Q, this.frictionResult);
                    }
                }
                c.release(k, _, I, D, V);
            };
            var ht = new w(), lt = new w(), pt = new w(), ct = new w(), ut = new w(), dt = new w(), vt = new w(), yt = new w(), ft = new w(), mt = new w();
            a.prototype[n.types.SPHERE | n.types.CONVEXPOLYHEDRON] = a.prototype.sphereConvex = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = this.v3pool;
                i.vsub(o, ht);
                for (var u = e.faceNormals, d = e.faces, v = e.vertices, y = t.radius, f = 0; f !== v.length; f++) {
                    var m = v[f], w = ut;
                    s.vmult(m, w), o.vadd(w, w);
                    var g = ct;
                    if (w.vsub(i, g), g.norm2() < y * y) return !!p || (x = !0, (V = this.createContactEquation(r, a, t, e, h, l)).ri.copy(g), 
                    V.ri.normalize(), V.ni.copy(V.ri), V.ri.mult(y, V.ri), w.vsub(o, V.rj), V.ri.vadd(i, V.ri), 
                    V.ri.vsub(r.position, V.ri), V.rj.vadd(o, V.rj), V.rj.vsub(a.position, V.rj), this.result.push(V), 
                    void this.createFrictionEquationsFromContact(V, this.frictionResult));
                }
                for (var x = !1, b = (f = 0, d.length); f !== b && !1 === x; f++) {
                    var B = u[f], E = d[f], A = dt;
                    s.vmult(B, A);
                    var S = vt;
                    s.vmult(v[E[0]], S), S.vadd(o, S);
                    var z = yt;
                    A.mult(-y, z), i.vadd(z, z);
                    var M = ft;
                    z.vsub(S, M);
                    var C = M.dot(A), q = mt;
                    if (i.vsub(S, q), C < 0 && 0 < q.dot(A)) {
                        for (var F = [], R = 0, T = E.length; R !== T; R++) {
                            var P = c.get();
                            s.vmult(v[E[R]], P), o.vadd(P, P), F.push(P);
                        }
                        if (J(F, A, i)) {
                            if (p) return !0;
                            x = !0;
                            var V = this.createContactEquation(r, a, t, e, h, l);
                            A.mult(-y, V.ri), A.negate(V.ni);
                            var I = c.get();
                            A.mult(-C, I);
                            var N = c.get();
                            A.mult(-y, N), i.vsub(o, V.rj), V.rj.vadd(N, V.rj), V.rj.vadd(I, V.rj), V.rj.vadd(o, V.rj), 
                            V.rj.vsub(a.position, V.rj), V.ri.vadd(i, V.ri), V.ri.vsub(r.position, V.ri), c.release(I), 
                            c.release(N), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult), 
                            R = 0;
                            for (var L = F.length; R !== L; R++) c.release(F[R]);
                            return;
                        }
                        for (R = 0; R !== E.length; R++) {
                            var W = c.get(), j = c.get();
                            s.vmult(v[E[(R + 1) % E.length]], W), s.vmult(v[E[(R + 2) % E.length]], j), o.vadd(W, W), 
                            o.vadd(j, j);
                            var O = lt;
                            j.vsub(W, O);
                            var k = pt;
                            O.unit(k);
                            var _ = c.get(), D = c.get();
                            i.vsub(W, D);
                            var U = D.dot(k);
                            k.mult(U, _), _.vadd(W, _);
                            var H = c.get();
                            if (_.vsub(i, H), 0 < U && U * U < O.norm2() && H.norm2() < y * y) {
                                if (p) return !0;
                                for (V = this.createContactEquation(r, a, t, e, h, l), _.vsub(o, V.rj), _.vsub(i, V.ni), 
                                V.ni.normalize(), V.ni.mult(y, V.ri), V.rj.vadd(o, V.rj), V.rj.vsub(a.position, V.rj), 
                                V.ri.vadd(i, V.ri), V.ri.vsub(r.position, V.ri), this.result.push(V), this.createFrictionEquationsFromContact(V, this.frictionResult), 
                                R = 0, L = F.length; R !== L; R++) c.release(F[R]);
                                return c.release(W), c.release(j), c.release(_), c.release(H), void c.release(D);
                            }
                            c.release(W), c.release(j), c.release(_), c.release(H), c.release(D);
                        }
                        for (R = 0, L = F.length; R !== L; R++) c.release(F[R]);
                    }
                }
            }, new w(), new w(), a.prototype[n.types.PLANE | n.types.BOX] = a.prototype.planeBox = function(t, e, i, o, n, s, r, a, h, l, p) {
                return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, 
                e.convexPolyhedronRepresentation.id = e.id, this.planeConvex(t, e.convexPolyhedronRepresentation, i, o, n, s, r, a, t, e, p);
            };
            var F = new w(), R = new w(), T = new w(), P = new w();
            a.prototype[n.types.PLANE | n.types.CONVEXPOLYHEDRON] = a.prototype.planeConvex = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = F, u = R;
                u.set(0, 0, 1), n.vmult(u, u);
                for (var d = 0, v = T, y = 0; y !== e.vertices.length; y++) if (c.copy(e.vertices[y]), 
                s.vmult(c, c), o.vadd(c, c), c.vsub(i, v), u.dot(v) <= 0) {
                    if (p) return !0;
                    var f = this.createContactEquation(r, a, t, e, h, l), m = P;
                    u.mult(u.dot(v), m), c.vsub(m, m), m.vsub(i, f.ri), f.ni.copy(u), c.vsub(o, f.rj), 
                    f.ri.vadd(i, f.ri), f.ri.vsub(r.position, f.ri), f.rj.vadd(o, f.rj), f.rj.vsub(a.position, f.rj), 
                    this.result.push(f), d++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(f, this.frictionResult);
                }
                this.enableFrictionReduction && d && this.createFrictionFromAverage(d);
            };
            var V = new w(), wt = new w();
            a.prototype[n.types.CONVEXPOLYHEDRON] = a.prototype.convexConvex = function(t, e, i, o, n, s, r, a, h, l, p, c, u) {
                var d = V;
                if (!(i.distanceTo(o) > t.boundingSphereRadius + e.boundingSphereRadius) && t.findSeparatingAxis(e, i, n, o, s, d, c, u)) {
                    var v = [], y = wt;
                    t.clipAgainstHull(i, n, e, o, s, d, -100, 100, v);
                    for (var f = 0, m = 0; m !== v.length; m++) {
                        if (p) return !0;
                        var w = this.createContactEquation(r, a, t, e, h, l), g = w.ri, x = w.rj;
                        d.negate(w.ni), v[m].normal.negate(y), y.mult(v[m].depth, y), v[m].point.vadd(y, g), 
                        x.copy(v[m].point), g.vsub(i, g), x.vsub(o, x), g.vadd(i, g), g.vsub(r.position, g), 
                        x.vadd(o, x), x.vsub(a.position, x), this.result.push(w), f++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(w, this.frictionResult);
                    }
                    this.enableFrictionReduction && f && this.createFrictionFromAverage(f);
                }
            };
            var gt = new w(), xt = new w(), bt = new w();
            a.prototype[n.types.PLANE | n.types.PARTICLE] = a.prototype.planeParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = gt;
                c.set(0, 0, 1), r.quaternion.vmult(c, c);
                var u = xt;
                if (o.vsub(r.position, u), c.dot(u) <= 0) {
                    if (p) return !0;
                    var d = this.createContactEquation(a, r, e, t, h, l);
                    d.ni.copy(c), d.ni.negate(d.ni), d.ri.set(0, 0, 0);
                    var v = bt;
                    c.mult(c.dot(o), v), o.vsub(v, v), d.rj.copy(v), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
                }
            };
            var Bt = new w();
            a.prototype[n.types.PARTICLE | n.types.SPHERE] = a.prototype.sphereParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = Bt;
                if (c.set(0, 0, 1), o.vsub(i, c), c.norm2() <= t.radius * t.radius) {
                    if (p) return !0;
                    var u = this.createContactEquation(a, r, e, t, h, l);
                    c.normalize(), u.rj.copy(c), u.rj.mult(t.radius, u.rj), u.ni.copy(c), u.ni.negate(u.ni), 
                    u.ri.set(0, 0, 0), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult);
                }
            };
            var Et = new s(), At = new w(), St = (new w(), new w()), zt = new w(), Mt = new w();
            a.prototype[n.types.PARTICLE | n.types.CONVEXPOLYHEDRON] = a.prototype.convexParticle = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = -1, u = St, d = Mt, v = null, y = At;
                if (y.copy(o), y.vsub(i, y), n.conjugate(Et), Et.vmult(y, y), t.pointIsInside(y)) {
                    t.worldVerticesNeedsUpdate && t.computeWorldVertices(i, n), t.worldFaceNormalsNeedsUpdate && t.computeWorldFaceNormals(n);
                    for (var f = 0, m = t.faces.length; f !== m; f++) {
                        var w = [ t.worldVertices[t.faces[f][0]] ], g = t.worldFaceNormals[f];
                        o.vsub(w[0], zt);
                        var x = -g.dot(zt);
                        if (null === v || Math.abs(x) < Math.abs(v)) {
                            if (p) return !0;
                            v = x, c = f, u.copy(g);
                        }
                    }
                    if (-1 !== c) {
                        var b = this.createContactEquation(a, r, e, t, h, l);
                        u.mult(v, d), d.vadd(o, d), d.vsub(i, d), b.rj.copy(d), u.negate(b.ni), b.ri.set(0, 0, 0);
                        var B = b.ri, E = b.rj;
                        B.vadd(o, B), B.vsub(a.position, B), E.vadd(i, E), E.vsub(r.position, E), this.result.push(b), 
                        this.createFrictionEquationsFromContact(b, this.frictionResult);
                    } else console.warn("Point found inside convex, but did not find penetrating face!");
                }
            }, a.prototype[n.types.BOX | n.types.HEIGHTFIELD] = a.prototype.boxHeightfield = function(t, e, i, o, n, s, r, a, h, l, p) {
                return t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, 
                this.convexHeightfield(t.convexPolyhedronRepresentation, e, i, o, n, s, r, a, t, e, p);
            };
            var Ct = new w(), qt = new w(), Ft = [ 0 ];
            a.prototype[n.types.CONVEXPOLYHEDRON | n.types.HEIGHTFIELD] = a.prototype.convexHeightfield = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = e.data, u = e.elementSize, d = t.boundingSphereRadius, v = qt, y = Ft, f = Ct;
                N.pointToLocalFrame(o, s, i, f);
                var m = Math.floor((f.x - d) / u) - 1, w = Math.ceil((f.x + d) / u) + 1, g = Math.floor((f.y - d) / u) - 1, x = Math.ceil((f.y + d) / u) + 1;
                if (!(w < 0 || x < 0 || m > c.length || g > c[0].length)) {
                    m < 0 && (m = 0), w < 0 && (w = 0), g < 0 && (g = 0), x < 0 && (x = 0), m >= c.length && (m = c.length - 1), 
                    w >= c.length && (w = c.length - 1), x >= c[0].length && (x = c[0].length - 1), 
                    g >= c[0].length && (g = c[0].length - 1);
                    var b = [];
                    e.getRectMinMax(m, g, w, x, b);
                    var B = b[0], E = b[1];
                    if (!(f.z - d > E || f.z + d < B)) for (var A = m; A < w; A++) for (var S = g; S < x; S++) {
                        var z = !1;
                        if (e.getConvexTrianglePillar(A, S, !1), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                        i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (z = this.convexConvex(t, e.pillarConvex, i, v, n, s, r, a, null, null, p, y, null)), 
                        p && z) return !0;
                        if (e.getConvexTrianglePillar(A, S, !0), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                        i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (z = this.convexConvex(t, e.pillarConvex, i, v, n, s, r, a, null, null, p, y, null)), 
                        p && z) return !0;
                    }
                }
            };
            var Rt = new w(), Tt = new w();
            a.prototype[n.types.SPHERE | n.types.HEIGHTFIELD] = a.prototype.sphereHeightfield = function(t, e, i, o, n, s, r, a, h, l, p) {
                var c = e.data, u = t.radius, d = e.elementSize, v = Tt, y = Rt;
                N.pointToLocalFrame(o, s, i, y);
                var f = Math.floor((y.x - u) / d) - 1, m = Math.ceil((y.x + u) / d) + 1, w = Math.floor((y.y - u) / d) - 1, g = Math.ceil((y.y + u) / d) + 1;
                if (!(m < 0 || g < 0 || f > c.length || g > c[0].length)) {
                    f < 0 && (f = 0), m < 0 && (m = 0), w < 0 && (w = 0), g < 0 && (g = 0), f >= c.length && (f = c.length - 1), 
                    m >= c.length && (m = c.length - 1), g >= c[0].length && (g = c[0].length - 1), 
                    w >= c[0].length && (w = c[0].length - 1);
                    var x = [];
                    e.getRectMinMax(f, w, m, g, x);
                    var b = x[0], B = x[1];
                    if (!(y.z - u > B || y.z + u < b)) for (var E = this.result, A = f; A < m; A++) for (var S = w; S < g; S++) {
                        var z = E.length, M = !1;
                        if (e.getConvexTrianglePillar(A, S, !1), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                        i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (M = this.sphereConvex(t, e.pillarConvex, i, v, n, s, r, a, t, e, p)), 
                        p && M) return !0;
                        if (e.getConvexTrianglePillar(A, S, !0), N.pointToWorldFrame(o, s, e.pillarOffset, v), 
                        i.distanceTo(v) < e.pillarConvex.boundingSphereRadius + t.boundingSphereRadius && (M = this.sphereConvex(t, e.pillarConvex, i, v, n, s, r, a, t, e, p)), 
                        p && M) return !0;
                        if (2 < E.length - z) return;
                    }
                }
            };
        }, {
            "../collision/AABB": 3,
            "../collision/Ray": 10,
            "../equations/ContactEquation": 20,
            "../equations/FrictionEquation": 22,
            "../math/Quaternion": 29,
            "../math/Transform": 30,
            "../math/Vec3": 31,
            "../objects/Body": 32,
            "../shapes/ConvexPolyhedron": 39,
            "../shapes/Shape": 44,
            "../solver/Solver": 48,
            "../utils/Vec3Pool": 55
        } ],
        57: [ function(w, g, t) {
            (function(t) {
                g.exports = d, w("../shapes/Shape");
                var e = w("../math/Vec3"), i = (w("../math/Quaternion"), w("../solver/GSSolver")), o = (w("../equations/ContactEquation"), 
                w("../equations/FrictionEquation"), w("./Narrowphase")), n = w("../utils/EventTarget"), s = (w("../collision/ArrayCollisionMatrix"), 
                w("../collision/ObjectCollisionMatrix")), r = w("../collision/OverlapKeeper"), a = w("../material/Material"), h = w("../material/ContactMaterial"), N = w("../objects/Body"), l = w("../utils/TupleDictionary"), p = w("../collision/RaycastResult"), c = (w("../collision/AABB"), 
                w("../collision/Ray")), u = w("../collision/NaiveBroadphase");
                function d(t) {
                    t = t || {}, n.apply(this), this.dt = -1, this.allowSleep = !!t.allowSleep, this.contacts = [], 
                    this.frictionEquations = [], this.contactsDic = new l(), this.oldContactsDic = new l(), 
                    this.quatNormalizeSkip = void 0 !== t.quatNormalizeSkip ? t.quatNormalizeSkip : 0, 
                    this.quatNormalizeFast = void 0 !== t.quatNormalizeFast && t.quatNormalizeFast, 
                    this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new e(), 
                    t.gravity && this.gravity.copy(t.gravity), this.broadphase = void 0 !== t.broadphase ? t.broadphase : new u(), 
                    this.bodies = [], this.solver = void 0 !== t.solver ? t.solver : new i(), this.constraints = [], 
                    this.narrowphase = new o(this), this.collisionMatrix = new s(), this.triggerMatrix = new s(), 
                    this.bodyOverlapKeeper = new r(), this.shapeOverlapKeeper = new r(), this.shapeOverlapKeeperExit = new r(), 
                    this.materials = [], this.contactmaterials = [], this.contactMaterialTable = new l(), 
                    this.defaultMaterial = new a("default"), this.defaultContactMaterial = new h(this.defaultMaterial, this.defaultMaterial, {
                        friction: .3,
                        restitution: 0
                    }), this.profile = {
                        solve: 0,
                        makeContactConstraints: 0,
                        broadphase: 0,
                        integrate: 0,
                        narrowphase: 0
                    }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    }, this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    }, this.broadphase.setWorld(this);
                }
                t && (t.CANNON = !0), d.idToBodyMap = {}, d.idToShapeMap = {}, d.prototype = new n();
                var v = new c();
                d.prototype.getContactMaterial = function(t, e) {
                    return this.contactMaterialTable.get(t.id, e.id);
                }, d.prototype.numObjects = function() {
                    return this.bodies.length;
                }, d.prototype.collisionMatrixTick = function() {}, d.prototype.add = d.prototype.addBody = function(t) {
                    -1 === this.bodies.indexOf(t) && (t.index = this.bodies.length, this.bodies.push(t), 
                    t.world = this, t.initPosition.copy(t.position), t.initVelocity.copy(t.velocity), 
                    t.timeLastSleepy = this.time, t instanceof N && (t.initAngularVelocity.copy(t.angularVelocity), 
                    t.initQuaternion.copy(t.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), 
                    this.addBodyEvent.body = t, d.idToBodyMap[t.id] = t, this.dispatchEvent(this.addBodyEvent));
                }, d.prototype.addConstraint = function(t) {
                    this.constraints.push(t);
                }, d.prototype.removeConstraint = function(t) {
                    var e = this.constraints.indexOf(t);
                    -1 !== e && this.constraints.splice(e, 1);
                }, d.prototype.rayTest = function(t, e, i) {
                    i instanceof p ? this.raycastClosest(t, e, {
                        skipBackfaces: !0
                    }, i) : this.raycastAll(t, e, {
                        skipBackfaces: !0
                    }, i);
                }, d.prototype.raycastAll = function(t, e, i, o) {
                    return i.mode = c.ALL, i.from = t, i.to = e, i.callback = o, v.intersectWorld(this, i);
                }, d.prototype.raycastAny = function(t, e, i, o) {
                    return i.mode = c.ANY, i.from = t, i.to = e, i.result = o, v.intersectWorld(this, i);
                }, d.prototype.raycastClosest = function(t, e, i, o) {
                    return i.mode = c.CLOSEST, i.from = t, i.to = e, i.result = o, v.intersectWorld(this, i);
                }, d.prototype.removeBody = d.prototype.remove = function(t) {
                    t.world = null;
                    var e = this.bodies.length - 1, i = this.bodies, o = i.indexOf(t);
                    if (-1 !== o) {
                        i.splice(o, 1);
                        for (var n = 0; n !== i.length; n++) i[n].index = n;
                        this.collisionMatrix.setNumObjects(e), this.removeBodyEvent.body = t, delete d.idToBodyMap[t.id], 
                        this.dispatchEvent(this.removeBodyEvent);
                    }
                }, d.prototype.getBodyById = function(t) {
                    return d.idToBodyMap[t];
                }, d.prototype.getShapeById = function(t) {
                    return d.idToShapeMap[t];
                }, d.prototype.addMaterial = function(t) {
                    this.materials.push(t);
                }, d.prototype.addContactMaterial = function(t) {
                    this.contactmaterials.push(t), this.contactMaterialTable.set(t.materials[0].id, t.materials[1].id, t);
                }, d.prototype.step = function(t, e, i) {
                    if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t; else {
                        this.accumulator += e;
                        for (var o = 0; this.accumulator >= t && o < i; ) this.internalStep(t), this.accumulator -= t, 
                        o++;
                        for (var n = this.accumulator % t / t, s = 0; s !== this.bodies.length; s++) {
                            var r = this.bodies[s];
                            r.previousPosition.lerp(r.position, n, r.interpolatedPosition), r.previousQuaternion.slerp(r.quaternion, n, r.interpolatedQuaternion), 
                            r.previousQuaternion.normalize();
                        }
                        this.time += e;
                    }
                    for (var a, h, l = this.contacts, p = this.contacts.length; p--; ) {
                        var c = (g = l[p]).si, u = g.sj, d = this.contactsDic.get(c.id, u.id);
                        null == d && (d = this.contactsDic.set(c.id, u.id, [])), d.push(g);
                    }
                    for (this.emitTriggeredEvents(), p = this.contactsDic.getLength(); p--; ) if (a = this.contactsDic.getKeyByIndex(p), 
                    null != (h = this.contactsDic.getDataByKey(a))) {
                        var v = h[0].bi, y = h[0].bj;
                        if (c = h[0].si, u = h[0].sj, v.allowSleep && v.type === N.DYNAMIC && v.sleepState === N.SLEEPING && y.sleepState === N.AWAKE && y.type !== N.STATIC) {
                            var f = y.velocity.norm2() + y.angularVelocity.norm2();
                            2 * Math.pow(y.sleepSpeedLimit, 2) <= f && v.wakeUp();
                        }
                        if (y.allowSleep && y.type === N.DYNAMIC && y.sleepState === N.SLEEPING && v.sleepState === N.AWAKE && v.type !== N.STATIC) {
                            var m = v.velocity.norm2() + v.angularVelocity.norm2();
                            2 * Math.pow(v.sleepSpeedLimit, 2) <= m && y.wakeUp();
                        }
                        this.collisionMatrix.get(v, y) ? x.event = "onCollisionStay" : (this.collisionMatrix.set(v, y, !0), 
                        x.event = "onCollisionEnter"), x.contacts = h, x.body = u.body, x.selfShape = c, 
                        x.otherShape = u, c.body.dispatchEvent(x), x.body = c.body, x.selfShape = u, x.otherShape = c, 
                        u.body.dispatchEvent(x), this.bodyOverlapKeeper.set(v.id, y.id);
                    }
                    var w = L;
                    for (p = w.length; p--; ) {
                        var g;
                        c = (g = w[p]).si, u = g.sj, null == this.oldContactsDic.get(c.id, u.id) && this.oldContactsDic.set(c.id, u.id, g);
                    }
                    for (p = this.oldContactsDic.getLength(); p--; ) a = this.oldContactsDic.getKeyByIndex(p), 
                    null == this.contactsDic.getDataByKey(a) && (v = (h = this.oldContactsDic.getDataByKey(a)).bi, 
                    y = h.bj, c = h.si, u = h.sj, this.collisionMatrix.get(v, y) && (v.isSleeping() && y.isSleeping() || (this.collisionMatrix.set(v, y, !1), 
                    x.event = "onCollisionExit", x.body = u.body, x.selfShape = c, x.otherShape = u, 
                    x.contacts.length = 0, x.contacts.push(h), c.body.dispatchEvent(x), x.body = c.body, 
                    x.selfShape = u, x.otherShape = c, u.body.dispatchEvent(x))));
                    this.contactsDic.reset(), this.oldContactsDic.reset(), this.shapeOverlapKeeper.reset();
                };
                var x = {
                    type: "collide",
                    event: "",
                    body: null,
                    selfShape: null,
                    otherShape: null,
                    contacts: null
                }, L = [], W = [], j = [], O = [];
                d.prototype.internalStep = function(t) {
                    this.dt = t;
                    var e = this.contacts, i = j, o = O, n = this.numObjects(), s = this.bodies, r = this.solver, a = this.gravity, h = (this.profile, 
                    N.DYNAMIC), l = this.constraints, p = W, c = a.x, u = a.y, d = a.z, v = 0;
                    for (v = 0; v !== n; v++) if ((A = s[v]).useGravity && A.type === h) {
                        var y = A.force, f = A.mass;
                        y.x += f * c, y.y += f * u, y.z += f * d;
                    }
                    v = 0;
                    for (var m = this.subsystems.length; v !== m; v++) this.subsystems[v].update();
                    i.length = 0, o.length = 0, this.broadphase.collisionPairs(this, i, o);
                    var w = l.length;
                    for (v = 0; v !== w; v++) if (!(z = l[v]).collideConnected) for (var g = i.length - 1; 0 <= g; g -= 1) (z.bodyA === i[g] && z.bodyB === o[g] || z.bodyB === i[g] && z.bodyA === o[g]) && (i.splice(g, 1), 
                    o.splice(g, 1));
                    this.shapeOverlapKeeperExit.tick();
                    var x = L, b = e.length;
                    for (v = 0; v !== b; v++) x.push(e[v]);
                    e.length = 0;
                    var B = this.frictionEquations.length;
                    for (v = 0; v !== B; v++) p.push(this.frictionEquations[v]);
                    for (this.frictionEquations.length = 0, this.narrowphase.getContacts(i, o, this, e, x, this.frictionEquations, p), 
                    v = 0; v < this.frictionEquations.length; v++) r.addEquation(this.frictionEquations[v]);
                    var E = e.length;
                    for (v = 0; v !== E; v++) {
                        var A = (z = e[v]).bi, S = z.bj;
                        z.si, z.sj, (A.material && S.material && this.getContactMaterial(A.material, S.material) || this.defaultContactMaterial).friction, 
                        A.material && S.material && (0 <= A.material.friction && 0 <= S.material.friction && (A.material.friction, 
                        S.material.friction), 0 <= A.material.restitution && 0 <= S.material.restitution && (z.restitution = A.material.restitution * S.material.restitution)), 
                        r.addEquation(z);
                    }
                    for (w = l.length, v = 0; v !== w; v++) {
                        var z;
                        (z = l[v]).update(), g = 0;
                        for (var M = z.equations.length; g !== M; g++) {
                            var C = z.equations[g];
                            r.addEquation(C);
                        }
                    }
                    r.solve(t, this), r.removeAllEquations();
                    var q = Math.pow;
                    for (n = this.numObjects(), v = 0; v !== n; v++) if ((A = s[v]).type & h) {
                        var F = q(1 - A.linearDamping, t), R = A.velocity;
                        R.mult(F, R);
                        var T = A.angularVelocity;
                        if (T) {
                            var P = q(1 - A.angularDamping, t);
                            T.mult(P, T);
                        }
                    }
                    var V = this.stepnumber % (this.quatNormalizeSkip + 1) == 0, I = this.quatNormalizeFast;
                    for (v = 0; v !== n; v++) s[v].integrate(t, V, I);
                    if (this.clearForces(), this.broadphase.dirty = !0, this.time += t, this.stepnumber += 1, 
                    this.allowSleep) for (v = 0; v !== n; v++) s[v].sleepTick(this.time);
                };
                var y = [], f = [], m = {
                    type: "triggered",
                    event: "",
                    selfBody: null,
                    otherBody: null,
                    selfShape: null,
                    otherShape: null
                };
                d.prototype.emitTriggeredEvents = function() {
                    y.length = f.length = 0, this.shapeOverlapKeeperExit.getDiff(y, f);
                    for (var t = 0, e = f.length; t < e; t += 2) {
                        m.event = "onTriggerExit";
                        var i = this.getShapeById(f[t]), o = this.getShapeById(f[t + 1]);
                        this.triggerMatrix.set(i, o, !1), m.selfShape = i, m.otherShape = o, m.selfBody = i.body, 
                        m.otherBody = o.body, i.dispatchEvent(m), m.selfShape = o, m.otherShape = i, m.selfBody = o.body, 
                        m.otherBody = i.body, o.dispatchEvent(m);
                    }
                    for (y.length = f.length = 0, this.shapeOverlapKeeper.getDiff(y, f), t = 0, e = y.length; t < e; t += 2) {
                        var n = y[t], s = y[t + 1];
                        i = this.getShapeById(n), o = this.getShapeById(s), this.triggerMatrix.get(i, o) ? m.event = "onTriggerStay" : (this.triggerMatrix.set(i, o, !0), 
                        m.event = "onTriggerEnter"), m.selfShape = i, m.otherShape = o, m.selfBody = i.body, 
                        m.otherBody = o.body, i.dispatchEvent(m), m.selfShape = o, m.otherShape = i, m.selfBody = o.body, 
                        m.otherBody = i.body, o.dispatchEvent(m);
                    }
                }, d.prototype.clearForces = function() {
                    for (var t = this.bodies, e = t.length, i = 0; i !== e; i++) {
                        var o = t[i];
                        o.force.set(0, 0, 0), o.torque.set(0, 0, 0);
                    }
                };
            }).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {
            "../collision/AABB": 3,
            "../collision/ArrayCollisionMatrix": 4,
            "../collision/NaiveBroadphase": 7,
            "../collision/ObjectCollisionMatrix": 8,
            "../collision/OverlapKeeper": 9,
            "../collision/Ray": 10,
            "../collision/RaycastResult": 11,
            "../equations/ContactEquation": 20,
            "../equations/FrictionEquation": 22,
            "../material/ContactMaterial": 25,
            "../material/Material": 26,
            "../math/Quaternion": 29,
            "../math/Vec3": 31,
            "../objects/Body": 32,
            "../shapes/Shape": 44,
            "../solver/GSSolver": 47,
            "../utils/EventTarget": 50,
            "../utils/TupleDictionary": 53,
            "./Narrowphase": 56
        } ]
    }, {}, [ 2 ])(2);
});

cannon_min.CANNON, cannon_min.Shape;

function stringfyVec3(value) {
    return Vec3.strictEquals(value, new Vec3()) ? "<origin>" : "(x: ".concat(value.x, ", y: ").concat(value.y, ", z: ").concat(value.z, ")");
}

function setWrap(object, wrapper) {
    object.__cc_wrapper__ = wrapper;
}

function getWrap(object) {
    return object.__cc_wrapper__;
}

!function(ERigidBodyType) {
    ERigidBodyType[ERigidBodyType.DYNAMIC = 1] = "DYNAMIC", ERigidBodyType[ERigidBodyType.STATIC = 2] = "STATIC", 
    ERigidBodyType[ERigidBodyType.KINEMATIC = 4] = "KINEMATIC";
}(ERigidBodyType || (ERigidBodyType = {})), function(ETransformSource) {
    ETransformSource[ETransformSource.SCENE = 0] = "SCENE", ETransformSource[ETransformSource.PHYSIC = 1] = "PHYSIC";
}(ETransformSource || (ETransformSource = {}));

var defaultCannonMaterial = new cannon_min.Material(""), defaultCannonContactMaterial = new cannon_min.ContactMaterial(defaultCannonMaterial, defaultCannonMaterial, {
    friction: .06,
    restitution: 0
});

function toCannonRaycastOptions(options) {
    return function toCannonOptions(options, optionsRename) {
        for (var result = {}, _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i], destKey = key;
            if (optionsRename) {
                var rename = optionsRename[key];
                rename && (destKey = rename);
            }
            result[destKey] = options[key];
        }
        return result;
    }(options, {
        queryTriggerInteraction: "checkCollisionResponse"
    });
}

function toCannonVec3(value) {
    return new cannon_min.Vec3(value.x, value.y, value.z);
}

function toCocosVec3(cannonVec3, out) {
    return Vec3.copy(out, cannonVec3);
}

function fillRaycastResult(result, cannonResult) {
    result._assign(cannonResult.hitPointWorld, cannonResult.distance, getWrap(cannonResult.shape), getWrap(cannonResult.body));
}

function commitShapeUpdates(body) {
    body.updateMassProperties(), body.updateBoundingRadius(), body.aabbNeedsUpdate = !0;
}

var CannonRigidBody = function() {
    function CannonRigidBody(options) {
        _classCallCheck(this, CannonRigidBody), this._body = void 0, this._material = void 0, 
        this._onCollidedListener = void 0, this._collisionCallbacks = [], this._shapes = [], 
        this._userData = void 0, this._world = null, this._name = void 0, options = options || {}, 
        this._name = options.name || "", this._material = defaultCannonMaterial, this._body = new cannon_min.Body({
            material: this._material,
            type: ERigidBodyType.DYNAMIC
        }), setWrap(this._body, this), this._body.sleepSpeedLimit = .1, this._body.sleepTimeLimit = 1, 
        this._onCollidedListener = this._onCollided.bind(this);
    }
    return _createClass(CannonRigidBody, [ {
        key: "impl",
        get: function get() {
            return this._body;
        }
    } ]), _createClass(CannonRigidBody, [ {
        key: "getAllowSleep",
        value: function getAllowSleep() {
            return this._body.allowSleep;
        }
    }, {
        key: "setAllowSleep",
        value: function setAllowSleep(v) {
            this._body.isSleeping() && this._body.wakeUp(), this._body.allowSleep = v;
        }
    }, {
        key: "getGroup",
        value: function getGroup() {
            return this._body.collisionFilterGroup;
        }
    }, {
        key: "setGroup",
        value: function setGroup(v) {
            this._body.collisionFilterGroup = v;
        }
    }, {
        key: "addGroup",
        value: function addGroup(v) {
            this._body.collisionFilterGroup |= v;
        }
    }, {
        key: "removeGroup",
        value: function removeGroup(v) {
            this._body.collisionFilterGroup &= ~v;
        }
    }, {
        key: "getMask",
        value: function getMask() {
            return this._body.collisionFilterMask;
        }
    }, {
        key: "setMask",
        value: function setMask(v) {
            this._body.collisionFilterMask = v;
        }
    }, {
        key: "addMask",
        value: function addMask(v) {
            this._body.collisionFilterMask |= v;
        }
    }, {
        key: "removeMask",
        value: function removeMask(v) {
            this._body.collisionFilterMask &= ~v;
        }
    }, {
        key: "wakeUp",
        value: function wakeUp() {
            return this._body.wakeUp();
        }
    }, {
        key: "sleep",
        value: function sleep() {
            return this._body.sleep();
        }
    }, {
        key: "name",
        value: function name() {
            return this._name;
        }
    }, {
        key: "getType",
        value: function getType() {
            return this._body.type;
        }
    }, {
        key: "setType",
        value: function setType(v) {
            this._body.type = v;
        }
    }, {
        key: "isAwake",
        value: function isAwake() {
            return this._body.isAwake();
        }
    }, {
        key: "isSleepy",
        value: function isSleepy() {
            return this._body.isSleepy();
        }
    }, {
        key: "isSleeping",
        value: function isSleeping() {
            return this._body.isSleeping();
        }
    }, {
        key: "addShape",
        value: function addShape(shape, offset) {
            this._shapes.push(shape), null != offset ? this._body.addShape(shape.impl, toCannonVec3(offset)) : this._body.addShape(shape.impl), 
            shape.setBody(this._body, this._shapes.length - 1);
        }
    }, {
        key: "removeShape",
        value: function removeShape(shape) {
            var index = this._shapes.indexOf(shape);
            index >= 0 && (this._shapes.splice(index, 1), this._body.removeShape(shape.impl), 
            shape.setBody(null, -1));
        }
    }, {
        key: "getMass",
        value: function getMass() {
            return this._body.mass;
        }
    }, {
        key: "setMass",
        value: function setMass(value) {
            this._body.isSleeping() && this._body.wakeUp(), this._body.mass = value, this._body.updateMassProperties();
        }
    }, {
        key: "getIsKinematic",
        value: function getIsKinematic() {
            return this._body.type === cannon_min.Body.KINEMATIC;
        }
    }, {
        key: "setIsKinematic",
        value: function setIsKinematic(value) {
            this._body.type = value ? cannon_min.Body.KINEMATIC : cannon_min.Body.DYNAMIC;
        }
    }, {
        key: "getLinearDamping",
        value: function getLinearDamping() {
            return this._body.linearDamping;
        }
    }, {
        key: "setLinearDamping",
        value: function setLinearDamping(value) {
            this._body.linearDamping = value;
        }
    }, {
        key: "getAngularDamping",
        value: function getAngularDamping() {
            return this._body.angularDamping;
        }
    }, {
        key: "setAngularDamping",
        value: function setAngularDamping(value) {
            this._body.angularDamping = value;
        }
    }, {
        key: "getUseGravity",
        value: function getUseGravity() {
            return this._body.useGravity;
        }
    }, {
        key: "setUseGravity",
        value: function setUseGravity(value) {
            this._body.isSleeping() && this._body.wakeUp(), this._body.useGravity = value;
        }
    }, {
        key: "getCollisionResponse",
        value: function getCollisionResponse() {
            return this._body.collisionResponse;
        }
    }, {
        key: "setCollisionResponse",
        value: function setCollisionResponse(value) {
            this._body.isSleeping() && this._body.wakeUp(), this._body.collisionResponse = !value;
        }
    }, {
        key: "getLinearVelocity",
        value: function getLinearVelocity(out) {
            return out = out || new Vec3(), Vec3.copy(out, this._body.velocity), out;
        }
    }, {
        key: "setLinearVelocity",
        value: function setLinearVelocity(value) {
            this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.velocity, value);
        }
    }, {
        key: "getAngularVelocity",
        value: function getAngularVelocity(out) {
            return out = out || new Vec3(), Vec3.copy(out, this._body.angularVelocity), out;
        }
    }, {
        key: "setAngularVelocity",
        value: function setAngularVelocity(value) {
            this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.angularVelocity, value);
        }
    }, {
        key: "getLinearFactor",
        value: function getLinearFactor(out) {
            return out = out || new Vec3(), Vec3.copy(out, this._body.linearFactor), out;
        }
    }, {
        key: "setLinearFactor",
        value: function setLinearFactor(value) {
            this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.linearFactor, value);
        }
    }, {
        key: "getAngularFactor",
        value: function getAngularFactor(out) {
            return out = out || new Vec3(), Vec3.copy(out, this._body.angularFactor), out;
        }
    }, {
        key: "setAngularFactor",
        value: function setAngularFactor(value) {
            this._body.isSleeping() && this._body.wakeUp(), Vec3.copy(this._body.angularFactor, value);
        }
    }, {
        key: "getFreezeRotation",
        value: function getFreezeRotation() {
            return this._body.fixedRotation;
        }
    }, {
        key: "setFreezeRotation",
        value: function setFreezeRotation(value) {
            this._body.isSleeping() && this._body.wakeUp(), this._body.fixedRotation = value, 
            this._body.updateMassProperties();
        }
    }, {
        key: "applyForce",
        value: function applyForce(force, worldPoint) {
            null == worldPoint && (worldPoint = new Vec3(), Vec3.copy(worldPoint, this._body.position)), 
            this._body.isSleeping() && this._body.wakeUp(), this._body.applyForce(toCannonVec3(force), toCannonVec3(worldPoint));
        }
    }, {
        key: "applyImpulse",
        value: function applyImpulse(impulse, worldPoint) {
            null == worldPoint && (worldPoint = new Vec3(), Vec3.copy(worldPoint, this._body.position)), 
            this._body.isSleeping() && this._body.wakeUp(), this._body.applyImpulse(toCannonVec3(impulse), toCannonVec3(worldPoint));
        }
    }, {
        key: "applyLocalForce",
        value: function applyLocalForce(force, localPoint) {
            null == localPoint && (localPoint = new Vec3()), this._body.isSleeping() && this._body.wakeUp(), 
            this._body.applyLocalForce(toCannonVec3(force), toCannonVec3(localPoint));
        }
    }, {
        key: "applyLocalImpulse",
        value: function applyLocalImpulse(impulse, localPoint) {
            null == localPoint && (localPoint = new Vec3()), this._body.isSleeping() && this._body.wakeUp(), 
            this._body.applyLocalImpulse(toCannonVec3(impulse), toCannonVec3(localPoint));
        }
    }, {
        key: "setWorld",
        value: function setWorld(world) {
            this._world && (this._body.removeEventListener("collide", this._onCollidedListener), 
            this._body.world.remove(this._body), this._world = null);
            var cworld = world;
            cworld && (cworld.impl.addBody(this._body), this._body.addEventListener("collide", this._onCollidedListener)), 
            this._world = cworld;
        }
    }, {
        key: "getPosition",
        value: function getPosition(out) {
            Vec3.copy(out, this._body.position);
        }
    }, {
        key: "setPosition",
        value: function setPosition(value) {
            Vec3.copy(this._body.position, value);
        }
    }, {
        key: "getRotation",
        value: function getRotation(out) {
            Quat.copy(out, this._body.quaternion);
        }
    }, {
        key: "setRotation",
        value: function setRotation(value) {
            Quat.copy(this._body.quaternion, value);
        }
    }, {
        key: "translateAndRotate",
        value: function translateAndRotate(m, rot) {
            Mat4.getTranslation(this._body.position, m), Quat.copy(this._body.quaternion, rot);
        }
    }, {
        key: "scaleAllShapes",
        value: function scaleAllShapes(scale) {
            var _iterator = this._shapes, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref.setScale(scale);
            }
        }
    }, {
        key: "addCollisionCallback",
        value: function addCollisionCallback(callback) {
            this._collisionCallbacks.push(callback);
        }
    }, {
        key: "removeCollisionCllback",
        value: function removeCollisionCllback(callback) {
            var i = this._collisionCallbacks.indexOf(callback);
            i >= 0 && this._collisionCallbacks.splice(i, 1);
        }
    }, {
        key: "getUserData",
        value: function getUserData() {
            return this._userData;
        }
    }, {
        key: "setUserData",
        value: function setUserData(data) {
            this._userData = data;
        }
    }, {
        key: "_stringfyThis",
        value: function _stringfyThis() {
            return "".concat(this._name.length ? this._name : "<No-name>");
        }
    }, {
        key: "_devStrinfy",
        value: function _devStrinfy() {
            var shapes = this._body.shapes.map(function(s) {
                return getWrap(s)._devStrinfy();
            }).join("; ");
            return "Name: [[".concat(this._name.length ? this._name : "<No-name>", "]], position: ").concat(stringfyVec3(this._body.position), ", shapes: [").concat(shapes, "]");
        }
    }, {
        key: "_onCollided",
        value: function _onCollided(event) {
            CollisionEventObject.type = event.event, CollisionEventObject.selfCollider = getWrap(event.selfShape).getUserData(), 
            CollisionEventObject.otherCollider = getWrap(event.otherShape).getUserData();
            var i = 0;
            for (i = CollisionEventObject.contacts.length; i--; ) contactsPool.push(CollisionEventObject.contacts.pop());
            for (i = 0; i < event.contacts.length; i++) {
                var cq = event.contacts[i];
                if (contactsPool.length > 0) {
                    var c = contactsPool.pop();
                    toCocosVec3(cq.ri, c.contactA), toCocosVec3(cq.rj, c.contactB), toCocosVec3(cq.ni, c.normal), 
                    CollisionEventObject.contacts.push(c);
                } else {
                    var _c = {
                        contactA: toCocosVec3(cq.ri, new Vec3()),
                        contactB: toCocosVec3(cq.rj, new Vec3()),
                        normal: toCocosVec3(cq.ni, new Vec3())
                    };
                    CollisionEventObject.contacts.push(_c);
                }
            }
            for (i = 0; i < this._collisionCallbacks.length; i++) {
                (0, this._collisionCallbacks[i])(CollisionEventObject);
            }
        }
    } ]), CannonRigidBody;
}(), CollisionEventObject = {
    type: "onCollisionEnter",
    selfCollider: null,
    otherCollider: null,
    contacts: []
}, contactsPool = [], RaycastResult = function() {
    function RaycastResult() {
        _classCallCheck(this, RaycastResult), this._hitPoint = new Vec3(), this._distance = 0, 
        this._collidier = null, this._node = null;
    }
    return _createClass(RaycastResult, [ {
        key: "_assign",
        value: function _assign(hitPoint, distance, shape, body) {
            Vec3.copy(this._hitPoint, hitPoint), this._distance = distance, this._node = body.getUserData(), 
            this._collidier = shape.getUserData();
        }
    }, {
        key: "hitPoint",
        get: function get() {
            return this._hitPoint;
        }
    }, {
        key: "distance",
        get: function get() {
            return this._distance;
        }
    }, {
        key: "collider",
        get: function get() {
            return this._collidier;
        }
    }, {
        key: "node",
        get: function get() {
            return this._node;
        }
    } ]), RaycastResult;
}(), CannonWorld = function() {
    function CannonWorld() {
        _classCallCheck(this, CannonWorld), this._world = void 0, this._customBeforeStepListener = [], 
        this._customAfterStepListener = [], this._raycastResult = new cannon_min.RaycastResult(), 
        this._world = new cannon_min.World(), setWrap(this._world, this), this._world.broadphase = new cannon_min.NaiveBroadphase(), 
        this._world.defaultMaterial = defaultCannonMaterial, this._world.defaultContactMaterial = defaultCannonContactMaterial;
    }
    return _createClass(CannonWorld, [ {
        key: "impl",
        get: function get() {
            return this._world;
        }
    } ]), _createClass(CannonWorld, [ {
        key: "getAllowSleep",
        value: function getAllowSleep() {
            return this._world.allowSleep;
        }
    }, {
        key: "setAllowSleep",
        value: function setAllowSleep(v) {
            this._world.allowSleep = v;
        }
    }, {
        key: "setGravity",
        value: function setGravity(gravity) {
            this._world.gravity = toCannonVec3(gravity);
        }
    }, {
        key: "getGravity",
        value: function getGravity(out) {
            toCocosVec3(this._world.gravity, out);
        }
    }, {
        key: "destroy",
        value: function destroy() {}
    }, {
        key: "step",
        value: function step(deltaTime, time, maxSubStep) {
            this._callCustomBeforeSteps(), this._world.step(deltaTime, time, maxSubStep), this._callCustomAfterSteps();
        }
    }, {
        key: "addBeforeStep",
        value: function addBeforeStep(cb) {
            this._customBeforeStepListener.push(cb);
        }
    }, {
        key: "removeBeforeStep",
        value: function removeBeforeStep(cb) {
            var i = this._customBeforeStepListener.indexOf(cb);
            i < 0 || this._customBeforeStepListener.splice(i, 1);
        }
    }, {
        key: "addAfterStep",
        value: function addAfterStep(cb) {
            this._customAfterStepListener.push(cb);
        }
    }, {
        key: "removeAfterStep",
        value: function removeAfterStep(cb) {
            var i = this._customAfterStepListener.indexOf(cb);
            i < 0 || this._customAfterStepListener.splice(i, 1);
        }
    }, {
        key: "raycastClosest",
        value: function raycastClosest(from, to, options, result) {
            var hit = this._world.raycastClosest(from, to, toCannonRaycastOptions(options), this._raycastResult);
            return hit && fillRaycastResult(result, this._raycastResult), hit;
        }
    }, {
        key: "raycastAny",
        value: function raycastAny(from, to, options, result) {
            var hit = this._world.raycastAny(from, to, toCannonRaycastOptions(options), this._raycastResult);
            return hit && fillRaycastResult(result, this._raycastResult), hit;
        }
    }, {
        key: "raycastAll",
        value: function raycastAll(from, to, options, callback) {
            return this._world.raycastAll(from, to, toCannonRaycastOptions(options), function(cannonResult) {
                var result = new RaycastResult();
                fillRaycastResult(result, cannonResult), callback(result);
            });
        }
    }, {
        key: "addConstraint",
        value: function addConstraint(constraint) {
            this._world.addConstraint(constraint.impl);
        }
    }, {
        key: "removeConstraint",
        value: function removeConstraint(constraint) {
            this._world.removeConstraint(constraint.impl);
        }
    }, {
        key: "_callCustomBeforeSteps",
        value: function _callCustomBeforeSteps() {
            this._customBeforeStepListener.forEach(function(fx) {
                return fx();
            });
        }
    }, {
        key: "_callCustomAfterSteps",
        value: function _callCustomAfterSteps() {
            this._customAfterStepListener.forEach(function(fx) {
                return fx();
            });
        }
    } ]), CannonWorld;
}(), CannonShape = function() {
    function CannonShape() {
        _classCallCheck(this, CannonShape), this._scale = new Vec3(1, 1, 1), this._shape = null, 
        this._body = null, this._index = -1, this._center = new Vec3(0, 0, 0), this._userData = void 0, 
        this._onTriggerListener = void 0, this._triggeredCB = [], this._onTriggerListener = this.onTrigger.bind(this);
    }
    return _createClass(CannonShape, [ {
        key: "impl",
        get: function get() {
            return this._shape;
        }
    } ]), _createClass(CannonShape, [ {
        key: "addTriggerCallback",
        value: function addTriggerCallback(callback) {
            this._triggeredCB.push(callback);
        }
    }, {
        key: "removeTriggerCallback",
        value: function removeTriggerCallback(callback) {
            var i = this._triggeredCB.indexOf(callback);
            i >= 0 && this._triggeredCB.splice(i, 1);
        }
    }, {
        key: "getUserData",
        value: function getUserData() {
            return this._userData;
        }
    }, {
        key: "setUserData",
        value: function setUserData(data) {
            this._userData = data;
        }
    }, {
        key: "setBody",
        value: function setBody(body, index) {
            null == body ? this._shape.removeEventListener("triggered", this._onTriggerListener) : this._shape.addEventListener("triggered", this._onTriggerListener), 
            this._body = body, this._index = index;
        }
    }, {
        key: "setCenter",
        value: function setCenter(center) {
            Vec3.copy(this._center, center), this._recalcCenter();
        }
    }, {
        key: "setScale",
        value: function setScale(scale) {
            Vec3.copy(this._scale, scale), this._recalcCenter();
        }
    }, {
        key: "setRotation",
        value: function setRotation(rotation) {}
    }, {
        key: "getCollisionResponse",
        value: function getCollisionResponse() {
            return this.impl.collisionResponse;
        }
    }, {
        key: "setCollisionResponse",
        value: function setCollisionResponse(v) {
            this.impl.collisionResponse = v;
        }
    }, {
        key: "_devStrinfy",
        value: function _devStrinfy() {
            return this._body ? "centerOffset: ".concat(stringfyVec3(this._body.shapeOffsets[this._index])) : "<NotAttached>";
        }
    }, {
        key: "onTrigger",
        value: function onTrigger(event) {
            TriggerEventObject.type = event.event, TriggerEventObject.selfCollider = getWrap(event.selfShape).getUserData(), 
            TriggerEventObject.otherCollider = getWrap(event.otherShape).getUserData();
            var _iterator = this._triggeredCB, _isArray = Array.isArray(_iterator), _i = 0;
            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                var _ref;
                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    if ((_i = _iterator.next()).done) break;
                    _ref = _i.value;
                }
                _ref(TriggerEventObject);
            }
        }
    }, {
        key: "_recalcCenter",
        value: function _recalcCenter() {
            if (this._body) {
                var shapeOffset = this._body.shapeOffsets[this._index];
                Vec3.copy(shapeOffset, this._center), Vec3.multiply(shapeOffset, shapeOffset, this._scale), 
                commitShapeUpdates(this._body);
            }
        }
    } ]), CannonShape;
}(), TriggerEventObject = {
    type: "",
    selfCollider: null,
    otherCollider: null
};

(function instantiate$1(boxShape, sphereShape, body, world) {
    BoxShape = boxShape, SphereShape = sphereShape, RigidBody = body, PhysicsWorld = world;
})(function(_CannonShape) {
    function CannonBoxShape(size) {
        var _this;
        return _classCallCheck(this, CannonBoxShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonBoxShape).call(this)))._box = void 0, 
        _this._halfExtent = new cannon_min.Vec3(), Vec3.multiplyScalar(_this._halfExtent, size, .5), 
        _this._box = new cannon_min.Box(_this._halfExtent.clone()), setWrap(_this._box, _assertThisInitialized(_this)), 
        _this._shape = _this._box, _this._shape.addEventListener("trigger", _this.onTrigger), 
        _this;
    }
    return _inherits(CannonBoxShape, CannonShape), _createClass(CannonBoxShape, [ {
        key: "setScale",
        value: function setScale(scale) {
            _get(_getPrototypeOf(CannonBoxShape.prototype), "setScale", this).call(this, scale), 
            this._recalcExtents();
        }
    }, {
        key: "setSize",
        value: function setSize(size) {
            Vec3.multiplyScalar(this._halfExtent, size, .5), this._recalcExtents();
        }
    }, {
        key: "_stringfyThis",
        value: function _stringfyThis() {
            return "".concat(this._body ? getWrap(this._body)._stringfyThis() : "<No-body>", "(Box)");
        }
    }, {
        key: "_devStrinfy",
        value: function _devStrinfy() {
            return "Box(".concat(_get(_getPrototypeOf(CannonBoxShape.prototype), "_devStrinfy", this).call(this), ", halfExtents: ").concat(stringfyVec3(this._box.halfExtents), ")");
        }
    }, {
        key: "_recalcExtents",
        value: function _recalcExtents() {
            Vec3.multiply(this._box.halfExtents, this._halfExtent, this._scale), this._box.updateConvexPolyhedronRepresentation(), 
            null != this._body && commitShapeUpdates(this._body);
        }
    } ]), CannonBoxShape;
}(), function(_CannonShape) {
    function CannonSphereShape(radius) {
        var _this;
        return _classCallCheck(this, CannonSphereShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CannonSphereShape).call(this)))._sphere = void 0, 
        _this._radius = 0, _this._radius = radius, _this._sphere = new cannon_min.Sphere(_this._radius), 
        setWrap(_this._sphere, _assertThisInitialized(_this)), _this._shape = _this._sphere, 
        _this;
    }
    return _inherits(CannonSphereShape, CannonShape), _createClass(CannonSphereShape, [ {
        key: "setScale",
        value: function setScale(scale) {
            _get(_getPrototypeOf(CannonSphereShape.prototype), "setScale", this).call(this, scale), 
            this._recalcRadius();
        }
    }, {
        key: "setRadius",
        value: function setRadius(radius) {
            this._radius = radius, this._recalcRadius();
        }
    }, {
        key: "_devStrinfy",
        value: function _devStrinfy() {
            return "Sphere(".concat(_get(_getPrototypeOf(CannonSphereShape.prototype), "_devStrinfy", this).call(this), ", radius: ").concat(this._sphere.radius, ")");
        }
    }, {
        key: "_recalcRadius",
        value: function _recalcRadius() {
            this._sphere.radius = this._radius * function maxComponent$1(v) {
                return Math.max(v.x, Math.max(v.y, v.z));
            }(this._scale), null != this._body && commitShapeUpdates(this._body);
        }
    } ]), CannonSphereShape;
}(), CannonRigidBody, CannonWorld), cc.createRaycastResult = function createRaycastResult() {
    return new RaycastResult();
};

var _dec$1A, _dec2$1a, _dec3$V, _class$1C, _class2$1l, _descriptor$1i, _descriptor2$18, PhysicsBasedComponent = function(_Component) {
    function PhysicsBasedComponent() {
        var _this;
        return _classCallCheck(this, PhysicsBasedComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsBasedComponent).call(this)))._sharedBody = void 0, 
        _this._isPreLoaded = !1, _this;
    }
    return _inherits(PhysicsBasedComponent, Component), _createClass(PhysicsBasedComponent, [ {
        key: "_body",
        get: function get() {
            return this._sharedBody.body;
        }
    }, {
        key: "sharedBody",
        get: function get() {
            return this._sharedBody;
        }
    }, {
        key: "_assertPreload",
        get: function get() {
            return this._isPreLoaded || console.error("Physic Error :", "Please make sure that the node has been added to the scene"), 
            this._isPreLoaded;
        }
    } ]), _createClass(PhysicsBasedComponent, [ {
        key: "setGroup",
        value: function setGroup(v) {
            if (this._assertPreload) return this._body.setGroup(v);
        }
    }, {
        key: "getGroup",
        value: function getGroup() {
            return this._assertPreload ? this._body.getGroup() : 0;
        }
    }, {
        key: "addGroup",
        value: function addGroup(v) {
            if (this._assertPreload) return this._body.addGroup(v);
        }
    }, {
        key: "removeGroup",
        value: function removeGroup(v) {
            if (this._assertPreload) return this._body.removeGroup(v);
        }
    }, {
        key: "getMask",
        value: function getMask() {
            return this._assertPreload ? this._body.getMask() : 0;
        }
    }, {
        key: "setMask",
        value: function setMask(v) {
            if (this._assertPreload) return this._body.setMask(v);
        }
    }, {
        key: "addMask",
        value: function addMask(v) {
            if (this._assertPreload) return this._body.addMask(v);
        }
    }, {
        key: "removeMask",
        value: function removeMask(v) {
            if (this._assertPreload) return this._body.removeMask(v);
        }
    }, {
        key: "__preload",
        value: function __preload() {
            if (null == this._sharedBody) {
                var sharedBody = null, _iterator = this.node.getComponents(PhysicsBasedComponent), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var physicsBasedComponent = _ref;
                    if (physicsBasedComponent._sharedBody) {
                        sharedBody = physicsBasedComponent._sharedBody;
                        break;
                    }
                }
                if (!sharedBody) {
                    var rigidbody = this.getComponent(cc.RigidBodyComponent);
                    sharedBody = new SharedRigidBody(this.node, rigidbody, cc.director._physicsSystem._world);
                }
                sharedBody.ref(), this._sharedBody = sharedBody;
            }
            this._isPreLoaded = !0;
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.sharedBody.enable();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.sharedBody.disable();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._sharedBody.deref(), this._sharedBody = null;
        }
    }, {
        key: "_findRigidbody",
        value: function _findRigidbody(begin) {
            var rigidbody = begin.getComponent(cc.RigidBodyComponent);
            return rigidbody || (begin.parent ? begin.parent === begin.scene ? null : this._findRigidbody(begin.parent) : null);
        }
    } ]), PhysicsBasedComponent;
}(), SharedRigidBody = function() {
    function SharedRigidBody(node, rigidBody, world) {
        _classCallCheck(this, SharedRigidBody), this._body = void 0, this._refCount = 0, 
        this._actived = !1, this._world = void 0, this._rigidBody = void 0, this._node = void 0, 
        this._worldScale = new Vec3(1, 1, 1), this._beforeStepCallback = void 0, this._afterStepCallback = void 0, 
        this._isShapeOnly = !0, this._prevScale = new Vec3(), this._body = function createRigidBody(options) {
            return new RigidBody(options);
        }({
            name: node.name
        }), this._node = node, this._rigidBody = rigidBody, this._world = world, this._body.setUserData(this._rigidBody), 
        this._beforeStepCallback = this._beforeStep.bind(this), this._afterStepCallback = this._afterStep.bind(this), 
        this._rigidBody ? this._isShapeOnly = !1 : (this._isShapeOnly = !0, this._body.setUseGravity(!1));
    }
    return _createClass(SharedRigidBody, [ {
        key: "isShapeOnly",
        get: function get() {
            return this._isShapeOnly;
        }
    }, {
        key: "body",
        get: function get() {
            return this._body;
        }
    }, {
        key: "transfromSource",
        set: function set(v) {
            v === ETransformSource.SCENE ? this._isShapeOnly = !0 : this._isShapeOnly = !1;
        }
    }, {
        key: "rigidBody",
        get: function get() {
            return this._rigidBody;
        }
    } ]), _createClass(SharedRigidBody, [ {
        key: "ref",
        value: function ref() {
            ++this._refCount;
        }
    }, {
        key: "deref",
        value: function deref() {
            --this._refCount, this._refCount || this.destroy();
        }
    }, {
        key: "enable",
        value: function enable() {
            this._activeBody();
        }
    }, {
        key: "disable",
        value: function disable() {
            this._deactiveBody();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._deactiveBody(), this._body.setUserData(null), this._body = null, this._beforeStepCallback = null, 
            this._afterStepCallback = null, this._world = null, this._node = null, this._rigidBody && (this._rigidBody = null);
        }
    }, {
        key: "syncPhysWithScene",
        value: function syncPhysWithScene() {
            this._syncPhysWithScene(this._node);
        }
    }, {
        key: "_syncPhysWithScene",
        value: function _syncPhysWithScene(node) {
            node.getWorldMatrix(SharedRigidBody._tempMat4), node.getWorldRotation(SharedRigidBody._tempQuat), 
            this._body.translateAndRotate(SharedRigidBody._tempMat4, SharedRigidBody._tempQuat);
        }
    }, {
        key: "_syncSceneWithPhys",
        value: function _syncSceneWithPhys() {
            this._node && (this._body.getPosition(SharedRigidBody._tempVec3), this._node.setWorldPosition(SharedRigidBody._tempVec3), 
            this._body.getFreezeRotation() || (this._body.getRotation(SharedRigidBody._tempQuat), 
            this._node.setWorldRotation(SharedRigidBody._tempQuat)));
        }
    }, {
        key: "_activeBody",
        value: function _activeBody() {
            this._syncPhysWithScene(this._node), this._actived || (this._actived = !0, this._body.setWorld(this._world), 
            this._world.addBeforeStep(this._beforeStepCallback), this._world.addAfterStep(this._afterStepCallback), 
            this._body.wakeUp());
        }
    }, {
        key: "_deactiveBody",
        value: function _deactiveBody() {
            this._actived && (this._actived = !1, this._world.removeBeforeStep(this._beforeStepCallback), 
            this._world.removeAfterStep(this._afterStepCallback), this._body.sleep(), this._body.setWorld(null));
        }
    }, {
        key: "_beforeStep",
        value: function _beforeStep() {
            this._node.hasChangedFlags && (Vec3.equals(this._prevScale, this._node.worldScale) || (this._body.scaleAllShapes(this._node.worldScale), 
            Vec3.copy(this._prevScale, this._node.worldScale)), this._syncPhysWithScene(this._node), 
            this._body.isSleeping() && this._body.wakeUp());
        }
    }, {
        key: "_afterStep",
        value: function _afterStep() {
            this._isShapeOnly || this._body.getType() !== ERigidBodyType.DYNAMIC ? this._node.hasChangedFlags && (this._syncPhysWithScene(this._node), 
            this._body.isSleeping() && this._body.wakeUp()) : this._syncSceneWithPhys();
        }
    } ]), SharedRigidBody;
}();

SharedRigidBody._tempMat4 = new Mat4(), SharedRigidBody._tempQuat = new Quat(), 
SharedRigidBody._tempVec3 = new Vec3();

var ColliderComponent = (_dec$1A = ccclass("cc.ColliderComponent"), _dec2$1a = property({
    displayOrder: 0
}), _dec3$V = property({
    type: Vec3,
    displayOrder: 1,
    tooltip: "The center of the collider, in local space"
}), _dec$1A((_applyDecoratedDescriptor((_class2$1l = function(_PhysicsBasedComponen) {
    function ColliderComponent() {
        var _this;
        return _classCallCheck(this, ColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ColliderComponent).call(this)))._callbackTable = createMap(!0), 
        _this._shapeBase = void 0, _this._trrigerCallback = void 0, _this._collisionCallBack = void 0, 
        _initializerDefineProperty(_this, "_isTrigger", _descriptor$1i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_center", _descriptor2$18, _assertThisInitialized(_this)), 
        _this._trrigerCallback = _this._onTrigger.bind(_assertThisInitialized(_this)), _this._collisionCallBack = _this._onCollision.bind(_assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ColliderComponent, PhysicsBasedComponent), _createClass(ColliderComponent, [ {
        key: "isTrigger",
        get: function get() {
            return this._isTrigger;
        },
        set: function set(value) {
            if (this._isTrigger = value, this.sharedBody) {
                var type = this._isTrigger ? ERigidBodyType.DYNAMIC : ERigidBodyType.STATIC;
                this.sharedBody.body.setType(type), this._shapeBase.setCollisionResponse(!this._isTrigger);
            }
        }
    }, {
        key: "center",
        get: function get() {
            return this._center;
        },
        set: function set(value) {
            Vec3.copy(this._center, value);
            var rigidBody = this.sharedBody.rigidBody;
            null != rigidBody ? (Vec3.subtract(offset, this.node.worldPosition, rigidBody.node.worldPosition), 
            Vec3.add(offset, offset, this._center), this._shapeBase.setCenter(offset)) : this._shapeBase.setCenter(this._center);
        }
    }, {
        key: "attachedRigidbody",
        get: function get() {
            return this.sharedBody.rigidBody;
        }
    } ]), _createClass(ColliderComponent, [ {
        key: "on",
        value: function on(type, callback, target, useCapture) {}
    }, {
        key: "off",
        value: function off(type, callback, target, useCapture) {}
    }, {
        key: "once",
        value: function once(type, callback, target, useCapture) {}
    }, {
        key: "targetOff",
        value: function targetOff(keyOrTarget) {}
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {}
    }, {
        key: "hasEventListener",
        value: function hasEventListener(key, callback, target) {
            return !1;
        }
    }, {
        key: "removeAll",
        value: function removeAll(keyOrTarget) {}
    }, {
        key: "emit",
        value: function emit(key) {}
    }, {
        key: "onLoad",
        value: function onLoad() {
            this.isTrigger = this._isTrigger, this.center = this._center;
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(ColliderComponent.prototype), "onEnable", this).call(this);
            var rigidBody = this.sharedBody.rigidBody;
            null != rigidBody ? (Vec3.subtract(offset, this.node.worldPosition, rigidBody.node.worldPosition), 
            Vec3.add(offset, offset, this._center), this.sharedBody.body.addShape(this._shapeBase, offset)) : this.sharedBody.body.addShape(this._shapeBase, this._center), 
            this._shapeBase.addTriggerCallback(this._trrigerCallback), this.sharedBody.body.addCollisionCallback(this._collisionCallBack), 
            this.sharedBody.syncPhysWithScene();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._shapeBase.removeTriggerCallback(this._trrigerCallback), this.sharedBody.body.removeCollisionCllback(this._collisionCallBack), 
            this.sharedBody.body.removeShape(this._shapeBase), this.sharedBody.isShapeOnly && _get(_getPrototypeOf(ColliderComponent.prototype), "onDisable", this).call(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.sharedBody.body.removeShape(this._shapeBase), _get(_getPrototypeOf(ColliderComponent.prototype), "onDestroy", this).call(this);
        }
    }, {
        key: "_onTrigger",
        value: function _onTrigger(event) {
            this.emit(event.type, event);
        }
    }, {
        key: "_onCollision",
        value: function _onCollision(event) {
            this.emit(event.type, event);
        }
    } ]), ColliderComponent;
}()).prototype, "isTrigger", [ _dec2$1a ], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "isTrigger"), _class2$1l.prototype), 
_applyDecoratedDescriptor(_class2$1l.prototype, "center", [ _dec3$V ], Object.getOwnPropertyDescriptor(_class2$1l.prototype, "center"), _class2$1l.prototype), 
_descriptor$1i = _applyDecoratedDescriptor(_class2$1l.prototype, "_isTrigger", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$18 = _applyDecoratedDescriptor(_class2$1l.prototype, "_center", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new cc.Vec3(0, 0, 0);
    }
}), _class$1C = _class2$1l)) || _class$1C);

applyMixins(ColliderComponent, [ CallbacksInvoker, EventTarget ]);

var _dec$1B, _dec2$1b, _dec3$W, _dec4$M, _class$1D, _class2$1m, _descriptor$1j, _class$1E, _class2$1n, _descriptor$1k, _dec$1D, _dec2$1d, _dec3$Y, _dec4$N, _dec5$J, _dec6$E, _dec7$s, _dec8$j, _dec9$g, _dec10$e, _dec11$d, _class$1F, _class2$1o, _descriptor$1l, _descriptor2$19, _descriptor3$S, _descriptor4$M, _descriptor5$F, _descriptor6$u, _descriptor7$p, _descriptor8$m, _dec$1E, _dec2$1e, _dec3$Z, _dec4$O, _class$1G, _class2$1p, _descriptor$1m, _descriptor2$1a, _descriptor3$T, _descriptor4$N, offset = new Vec3(), BoxColliderComponent = (_dec$1B = ccclass("cc.BoxColliderComponent"), 
_dec2$1b = executionOrder(98), _dec3$W = menu("Components/BoxColliderComponent"), 
_dec4$M = property({
    type: Vec3
}), _dec$1B(_class$1D = _dec2$1b(_class$1D = _dec3$W(_class$1D = executeInEditMode((_descriptor$1j = _applyDecoratedDescriptor((_class2$1m = function(_ColliderComponent) {
    function BoxColliderComponent() {
        var _this;
        return _classCallCheck(this, BoxColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderComponent).call(this)))._shape = void 0, 
        _initializerDefineProperty(_this, "_size", _descriptor$1j, _assertThisInitialized(_this)), 
        _this._shape = function createBoxShape(size) {
            return new BoxShape(size);
        }(_this._size), _this._shape.setUserData(_assertThisInitialized(_this)), _this._shapeBase = _this._shape, 
        _this;
    }
    return _inherits(BoxColliderComponent, ColliderComponent), _createClass(BoxColliderComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(BoxColliderComponent.prototype), "onLoad", this).call(this), 
            this.size = this._size, this._shape.setScale(this.node.worldScale);
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        },
        set: function set(value) {
            Vec3.copy(this._size, value), this._shape.setSize(this._size);
        }
    } ]), BoxColliderComponent;
}()).prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _applyDecoratedDescriptor(_class2$1m.prototype, "size", [ _dec4$M ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "size"), _class2$1m.prototype), 
_class$1D = _class2$1m)) || _class$1D) || _class$1D) || _class$1D) || _class$1D), SphereColliderComponent = ccclass("cc.SphereColliderComponent")(_class$1E = executionOrder(98)(_class$1E = menu("Components/SphereColliderComponent")(_class$1E = executeInEditMode((_descriptor$1k = _applyDecoratedDescriptor((_class2$1n = function(_ColliderComponent) {
    function SphereColliderComponent() {
        var _this;
        return _classCallCheck(this, SphereColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderComponent).call(this)))._shape = void 0, 
        _initializerDefineProperty(_this, "_radius", _descriptor$1k, _assertThisInitialized(_this)), 
        _this._shape = function createSphereShape(radius) {
            return new SphereShape(radius);
        }(_this._radius), _this._shape.setUserData(_assertThisInitialized(_this)), _this._shapeBase = _this._shape, 
        _this;
    }
    return _inherits(SphereColliderComponent, ColliderComponent), _createClass(SphereColliderComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(SphereColliderComponent.prototype), "onLoad", this).call(this), 
            this.radius = this._radius, this._shape.setScale(this.node.worldScale);
        }
    }, {
        key: "radius",
        get: function get() {
            return this._radius;
        },
        set: function set(value) {
            this._radius = value, this._shape.setRadius(this._radius);
        }
    } ]), SphereColliderComponent;
}()).prototype, "_radius", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "radius", [ property ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "radius"), _class2$1n.prototype), 
_class$1E = _class2$1n)) || _class$1E) || _class$1E) || _class$1E) || _class$1E, NonRigidBodyProperties_mass = 10, NonRigidBodyProperties_linearDamping = 0, NonRigidBodyProperties_angularDamping = 0, RigidBodyComponent = (_dec$1D = ccclass("cc.RigidBodyComponent"), 
_dec2$1d = executionOrder(99), _dec3$Y = menu("Components/RigidBodyComponent"), 
_dec4$N = property({
    displayOrder: 0
}), _dec5$J = property({
    displayOrder: 1
}), _dec6$E = property({
    displayOrder: 2
}), _dec7$s = property({
    displayOrder: 3
}), _dec8$j = property({
    displayOrder: 4
}), _dec9$g = property({
    displayOrder: 5
}), _dec10$e = property({
    displayOrder: 6
}), _dec11$d = property({
    displayOrder: 7
}), _dec$1D(_class$1F = _dec2$1d(_class$1F = _dec3$Y(_class$1F = executeInEditMode((_applyDecoratedDescriptor((_class2$1o = function(_PhysicsBasedComponen) {
    function RigidBodyComponent() {
        var _this;
        return _classCallCheck(this, RigidBodyComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RigidBodyComponent).call(this)))._allowSleep = !0, 
        _initializerDefineProperty(_this, "_mass", _descriptor$1l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_linearDamping", _descriptor2$19, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_angularDamping", _descriptor3$S, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fixedRotation", _descriptor4$M, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isKinematic", _descriptor5$F, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useGravity", _descriptor6$u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_linearFactor", _descriptor7$p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_angularFactor", _descriptor8$m, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(RigidBodyComponent, PhysicsBasedComponent), _createClass(RigidBodyComponent, [ {
        key: "allowSleep",
        get: function get() {
            return this._allowSleep;
        },
        set: function set(v) {
            this._allowSleep = v, this.sharedBody.body.setAllowSleep(v);
        }
    }, {
        key: "mass",
        get: function get() {
            return this._mass;
        },
        set: function set(value) {
            this._mass = value, this._body.setMass(value);
        }
    }, {
        key: "linearDamping",
        get: function get() {
            return this._linearDamping;
        },
        set: function set(value) {
            this._linearDamping = value, this._body.setLinearDamping(value);
        }
    }, {
        key: "angularDamping",
        get: function get() {
            return this._angularDamping;
        },
        set: function set(value) {
            this._angularDamping = value, this._body.setAngularDamping(value);
        }
    }, {
        key: "isKinematic",
        get: function get() {
            return this._isKinematic;
        },
        set: function set(value) {
            this._isKinematic = value, this._body.setIsKinematic(value);
        }
    }, {
        key: "useGravity",
        get: function get() {
            return this._useGravity;
        },
        set: function set(value) {
            this._useGravity = value, this._body.setUseGravity(value);
        }
    }, {
        key: "fixedRotation",
        get: function get() {
            return this._fixedRotation;
        },
        set: function set(value) {
            this._fixedRotation = value, this._body.setFreezeRotation(value);
        }
    }, {
        key: "linearFactor",
        get: function get() {
            return this._body.getLinearFactor(this._linearFactor);
        },
        set: function set(value) {
            Vec3.copy(this._linearFactor, value), this._body.setLinearFactor(this._linearFactor);
        }
    }, {
        key: "angularFactor",
        get: function get() {
            return this._body.getAngularFactor(this._angularFactor);
        },
        set: function set(value) {
            Vec3.copy(this._angularFactor, value), this._body.setAngularFactor(this._angularFactor);
        }
    }, {
        key: "isAwake",
        get: function get() {
            return !!this._assertPreload && this._body.isAwake();
        }
    }, {
        key: "isSleepy",
        get: function get() {
            return !!this._assertPreload && this._body.isSleepy();
        }
    }, {
        key: "isSleeping",
        get: function get() {
            return !!this._assertPreload && this._body.isSleeping();
        }
    } ]), _createClass(RigidBodyComponent, [ {
        key: "applyForce",
        value: function applyForce(force, relativePoint) {
            this._assertPreload && this._body.applyForce(force, relativePoint);
        }
    }, {
        key: "applyLocalForce",
        value: function applyLocalForce(force, localPoint) {
            this._assertPreload && this._body.applyLocalForce(force, localPoint);
        }
    }, {
        key: "applyImpulse",
        value: function applyImpulse(impulse, relativePoint) {
            this._assertPreload && this._body.applyImpulse(impulse, relativePoint);
        }
    }, {
        key: "applyLocalImpulse",
        value: function applyLocalImpulse(impulse, localPoint) {
            this._assertPreload && this._body.applyLocalImpulse(impulse, localPoint);
        }
    }, {
        key: "wakeUp",
        value: function wakeUp() {
            this._assertPreload && this._body.wakeUp();
        }
    }, {
        key: "sleep",
        value: function sleep() {
            this._assertPreload && this._body.sleep();
        }
    }, {
        key: "getLinearVelocity",
        value: function getLinearVelocity(out) {
            this._assertPreload && this._body.getLinearVelocity(out);
        }
    }, {
        key: "setLinearVelocity",
        value: function setLinearVelocity(value) {
            this._assertPreload && this._body.setLinearVelocity(value);
        }
    }, {
        key: "getAngularVelocity",
        value: function getAngularVelocity(out) {
            this._assertPreload && this._body.getAngularVelocity(out);
        }
    }, {
        key: "setAngularVelocity",
        value: function setAngularVelocity(value) {
            this._assertPreload && this._body.setAngularVelocity(value);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this.sharedBody && (this.allowSleep = this._allowSleep, this.mass = this._mass, 
            this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, 
            this.useGravity = this._useGravity, this.isKinematic = this._isKinematic, this.fixedRotation = this._fixedRotation, 
            this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor);
        }
    } ]), RigidBodyComponent;
}()).prototype, "mass", [ _dec4$N ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "mass"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "linearDamping", [ _dec5$J ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "linearDamping"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "angularDamping", [ _dec6$E ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "angularDamping"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "isKinematic", [ _dec7$s ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "isKinematic"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "useGravity", [ _dec8$j ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "useGravity"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "fixedRotation", [ _dec9$g ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "fixedRotation"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "linearFactor", [ _dec10$e ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "linearFactor"), _class2$1o.prototype), 
_applyDecoratedDescriptor(_class2$1o.prototype, "angularFactor", [ _dec11$d ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "angularFactor"), _class2$1o.prototype), 
_descriptor$1l = _applyDecoratedDescriptor(_class2$1o.prototype, "_mass", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return NonRigidBodyProperties_mass;
    }
}), _descriptor2$19 = _applyDecoratedDescriptor(_class2$1o.prototype, "_linearDamping", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return NonRigidBodyProperties_linearDamping;
    }
}), _descriptor3$S = _applyDecoratedDescriptor(_class2$1o.prototype, "_angularDamping", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return NonRigidBodyProperties_angularDamping;
    }
}), _descriptor4$M = _applyDecoratedDescriptor(_class2$1o.prototype, "_fixedRotation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$F = _applyDecoratedDescriptor(_class2$1o.prototype, "_isKinematic", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor6$u = _applyDecoratedDescriptor(_class2$1o.prototype, "_useGravity", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor7$p = _applyDecoratedDescriptor(_class2$1o.prototype, "_linearFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _descriptor8$m = _applyDecoratedDescriptor(_class2$1o.prototype, "_angularFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _class$1F = _class2$1o)) || _class$1F) || _class$1F) || _class$1F) || _class$1F), PhysicsSystem = function() {
    function PhysicsSystem() {
        _classCallCheck(this, PhysicsSystem), this._world = void 0, this._enable = !0, this._deltaTime = 1 / 60, 
        this._maxSubStep = 2, this._allowSleep = !0, this._gravity = new Vec3(0, -10, 0), 
        this._world = function createPhysicsWorld() {
            return new PhysicsWorld();
        }(), this.gravity = this._gravity, this.allowSleep = this._allowSleep;
    }
    return _createClass(PhysicsSystem, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(value) {
            this._enable = value;
        }
    }, {
        key: "allowSleep",
        get: function get() {
            return this._allowSleep;
        },
        set: function set(v) {
            this._allowSleep = v, this._world.setAllowSleep(this._allowSleep);
        }
    }, {
        key: "maxSubStep",
        get: function get() {
            return this._maxSubStep;
        },
        set: function set(value) {
            this._maxSubStep = value;
        }
    }, {
        key: "deltaTime",
        get: function get() {
            return this._deltaTime;
        },
        set: function set(value) {
            this._deltaTime = value;
        }
    }, {
        key: "gravity",
        get: function get() {
            return this._world.getGravity(this._gravity), this._gravity;
        },
        set: function set(gravity) {
            this._gravity.x = gravity.x, this._gravity.y = gravity.y, this._gravity.z = gravity.z, 
            this._world.setGravity(gravity);
        }
    } ], [ {
        key: "ins",
        get: function get() {
            return cc.director._physicsSystem;
        }
    } ]), _createClass(PhysicsSystem, [ {
        key: "update",
        value: function update(deltaTime) {
            this._enable && this._world.step(this._deltaTime, deltaTime, this._maxSubStep);
        }
    } ]), PhysicsSystem;
}();

cc.PhysicsSystem = PhysicsSystem, cc.ColliderComponent = ColliderComponent, cc.BoxColliderComponent = BoxColliderComponent, 
cc.SphereColliderComponent = SphereColliderComponent, cc.RigidBodyComponent = RigidBodyComponent;

var AudioSourceComponent = (_dec$1E = ccclass("cc.AudioSourceComponent"), _dec2$1e = menu("Components/AudioSourceComponent"), 
_dec3$Z = property(AudioClip), _dec4$O = property({
    type: AudioClip
}), _dec$1E(_class$1G = _dec2$1e((_descriptor$1m = _applyDecoratedDescriptor((_class2$1p = function(_Component) {
    function AudioSourceComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AudioSourceComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AudioSourceComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_clip", _descriptor$1m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_loop", _descriptor2$1a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_playOnAwake", _descriptor3$T, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_volume", _descriptor4$N, _assertThisInitialized(_this)), 
        _this._cachedCurrentTime = 0, _this;
    }
    return _inherits(AudioSourceComponent, Component), _createClass(AudioSourceComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._syncStates(), this._playOnAwake && this.play();
        }
    }, {
        key: "play",
        value: function play() {
            this._clip && (this.playing ? this.currentTime = 0 : this._clip.play());
        }
    }, {
        key: "pause",
        value: function pause() {
            this._clip && this._clip.pause();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._clip && this._clip.stop();
        }
    }, {
        key: "playOneShot",
        value: function playOneShot(clip) {
            var volumeScale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            clip.playOneShot(this._volume * volumeScale);
        }
    }, {
        key: "_syncStates",
        value: function _syncStates() {
            this._clip && (this._clip.setCurrentTime(this._cachedCurrentTime), this._clip.setLoop(this._loop), 
            this._clip.setVolume(this._volume, !0), this._volume = this._clip.getVolume());
        }
    }, {
        key: "clip",
        set: function set(val) {
            this._clip = val, this._syncStates();
        },
        get: function get() {
            return this._clip;
        }
    }, {
        key: "loop",
        set: function set(val) {
            this._loop = val, this._clip && this._clip.setLoop(val);
        },
        get: function get() {
            return this._loop;
        }
    }, {
        key: "playOnAwake",
        set: function set(val) {
            this._playOnAwake = val;
        },
        get: function get() {
            return this._playOnAwake;
        }
    }, {
        key: "volume",
        set: function set(val) {
            isNaN(val) ? console.warn("illegal audio volume!") : (val = clamp(val, 0, 1), this._clip ? (this._clip.setVolume(val), 
            this._volume = this._clip.getVolume()) : this._volume = val);
        },
        get: function get() {
            return this._volume;
        }
    }, {
        key: "currentTime",
        set: function set(num) {
            isNaN(num) ? console.warn("illegal audio time!") : (num = clamp(num, 0, this.duration), 
            this._cachedCurrentTime = num, this._clip && this._clip.setCurrentTime(this._cachedCurrentTime));
        },
        get: function get() {
            return this._clip ? this._clip.getCurrentTime() : this._cachedCurrentTime;
        }
    }, {
        key: "duration",
        get: function get() {
            return this._clip ? this._clip.getDuration() : 0;
        }
    }, {
        key: "state",
        get: function get() {
            return this._clip ? this._clip.state : AudioClip.PlayingState.INITIALIZING;
        }
    }, {
        key: "playing",
        get: function get() {
            return this.state === AudioClip.PlayingState.PLAYING;
        }
    } ]), AudioSourceComponent;
}()).prototype, "_clip", [ _dec3$Z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$1a = _applyDecoratedDescriptor(_class2$1p.prototype, "_loop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$T = _applyDecoratedDescriptor(_class2$1p.prototype, "_playOnAwake", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$N = _applyDecoratedDescriptor(_class2$1p.prototype, "_volume", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$1p.prototype, "clip", [ _dec4$O ], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "clip"), _class2$1p.prototype), 
_applyDecoratedDescriptor(_class2$1p.prototype, "loop", [ property ], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "loop"), _class2$1p.prototype), 
_applyDecoratedDescriptor(_class2$1p.prototype, "playOnAwake", [ property ], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "playOnAwake"), _class2$1p.prototype), 
_applyDecoratedDescriptor(_class2$1p.prototype, "volume", [ property ], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "volume"), _class2$1p.prototype), 
_class$1G = _class2$1p)) || _class$1G) || _class$1G);

cc.AudioSourceComponent = AudioSourceComponent;

var Tween_min = createCommonjsModule(function(module, exports) {
    var _Group = function() {
        this._tweens = {}, this._tweensAddedDuringUpdate = {};
    };
    _Group.prototype = {
        getAll: function() {
            return Object.keys(this._tweens).map(function(t) {
                return this._tweens[t];
            }.bind(this));
        },
        removeAll: function() {
            this._tweens = {};
        },
        add: function(t) {
            this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;
        },
        remove: function(t) {
            delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];
        },
        update: function(t, n) {
            var e = Object.keys(this._tweens);
            if (0 === e.length) return !1;
            for (t = void 0 !== t ? t : TWEEN.now(); 0 < e.length; ) {
                this._tweensAddedDuringUpdate = {};
                for (var i = 0; i < e.length; i++) {
                    var r = this._tweens[e[i]];
                    r && !1 === r.update(t) && (r._isPlaying = !1, n || delete this._tweens[e[i]]);
                }
                e = Object.keys(this._tweensAddedDuringUpdate);
            }
            return !0;
        }
    };
    var TWEEN = new _Group();
    TWEEN.Group = _Group, TWEEN._nextId = 0, TWEEN.nextId = function() {
        return TWEEN._nextId++;
    }, "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? TWEEN.now = function() {
        var t = process.hrtime();
        return 1e3 * t[0] + t[1] / 1e6;
    } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? TWEEN.now = self.performance.now.bind(self.performance) : void 0 !== Date.now ? TWEEN.now = Date.now : TWEEN.now = function() {
        return new Date().getTime();
    }, TWEEN.Tween = function(t, n) {
        this._object = t, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, 
        this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, 
        this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, 
        this._easingFunction = TWEEN.Easing.Linear.None, this._interpolationFunction = TWEEN.Interpolation.Linear, 
        this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, 
        this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, 
        this._onStopCallback = null, this._group = n || TWEEN, this._id = TWEEN.nextId(), 
        this._onCompleteCallbackForCocos = null;
    }, TWEEN.Tween.prototype = {
        getId: function() {
            return this._id;
        },
        isPlaying: function() {
            return this._isPlaying;
        },
        to: function(t, n) {
            return this._valuesEnd = JSON.parse(JSON.stringify(t)), void 0 !== n && (this._duration = n), 
            this;
        },
        duration: function(t) {
            return this._duration = t, this;
        },
        start: function(t) {
            return this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, 
            this._startTime = void 0 !== t ? "string" == typeof t ? TWEEN.now() + parseFloat(t) : t : TWEEN.now(), 
            this._startTime += this._delayTime, TWEEN._recursiveObjetCopy(this._valuesEnd, this._valuesStart, this._valuesStartRepeat, this._object), 
            this;
        },
        stop: function() {
            return this._isPlaying && (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), 
            this.stopChainedTweens()), this;
        },
        end: function() {
            return this.update(1 / 0), this;
        },
        stopChainedTweens: function() {
            for (var t = 0, n = this._chainedTweens.length; t < n; t++) this._chainedTweens[t].stop();
        },
        group: function(t) {
            return this._group = t, this;
        },
        delay: function(t) {
            return this._delayTime = t, this;
        },
        repeat: function(t) {
            return this._repeat = t, this;
        },
        repeatDelay: function(t) {
            return this._repeatDelayTime = t, this;
        },
        yoyo: function(t) {
            return this._yoyo = t, this;
        },
        easing: function(t) {
            return this._easingFunction = t, this;
        },
        interpolation: function(t) {
            return this._interpolationFunction = t, this;
        },
        chain: function() {
            return this._chainedTweens = arguments, this;
        },
        onStart: function(t) {
            return this._onStartCallback = t, this;
        },
        onUpdate: function(t) {
            return this._onUpdateCallback = t, this;
        },
        onRepeat: function(t) {
            return this._onRepeatCallback = t, this;
        },
        onComplete: function(t) {
            return this._onCompleteCallback = t, this;
        },
        onStop: function(t) {
            return this._onStopCallback = t, this;
        },
        update: function(t) {
            var n, e, i;
            if (t < this._startTime) return !0;
            if (!1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), 
            this._onStartCallbackFired = !0), e = (t - this._startTime) / this._duration, e = 0 === this._duration || 1 < e ? 1 : e, 
            i = this._easingFunction(e), TWEEN._recursiveObjetUpdate(this._valuesEnd, this._valuesStart, i, this._object, this), 
            null !== this._onUpdateCallback && this._onUpdateCallback(this._object, e), 1 !== e) return !0;
            if (0 < this._repeat) {
                for (n in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                    if ("string" == typeof this._valuesEnd[n] && (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])), 
                    this._yoyo) {
                        var r = this._valuesStartRepeat[n];
                        this._valuesStartRepeat[n] = this._valuesEnd[n], this._valuesEnd[n] = r;
                    }
                    this._valuesStart[n] = this._valuesStartRepeat[n];
                }
                return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, 
                null !== this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
            }
            if (null !== this._onCompleteCallback && this._onCompleteCallback(this._object), 
            null !== this._onCompleteCallbackForCocos) this._onCompleteCallbackForCocos(this); else for (var o = 0, a = this._chainedTweens.length; o < a; o++) this._chainedTweens[o].start(this._startTime + this._duration);
            return !1;
        },
        cc_onCompleteCallback: function(t) {
            this._onCompleteCallbackForCocos = t;
        }
    }, TWEEN._recursiveObjetUpdate = function(t, n, e, i, r) {
        var o, a;
        for (var s in t) o = t[s], a = n[s], o instanceof Array ? i[s] = r._interpolationFunction(o, e) : ("string" == typeof o && (o = "+" === o.charAt(0) || "-" === o.charAt(0) ? a + parseFloat(o) : parseFloat(o)), 
        "number" == typeof o ? i[s] = a + (o - a) * e : "object" == typeof o && TWEEN._recursiveObjetUpdate(o, a, e, i[s], r));
    }, TWEEN._recursiveObjetCopy = function(t, n, e, i) {
        for (var r in t) {
            if (t[r] instanceof Array) {
                if (0 === t[r].length) continue;
                t[r] = [ i[r] ].concat(t[r]);
            }
            void 0 !== i[r] && ("object" == typeof i[r] ? (n[r] = {}, e[r] = {}, TWEEN._recursiveObjetCopy(t[r], n[r], e[r], i[r])) : (n[r] = i[r], 
            "string" == typeof n[r] && (n[r] *= 1), e[r] = n[r] || 0));
        }
    }, TWEEN.Easing = {
        Linear: {
            None: function(t) {
                return t;
            }
        },
        Quadratic: {
            In: function(t) {
                return t * t;
            },
            Out: function(t) {
                return t * (2 - t);
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
            }
        },
        Cubic: {
            In: function(t) {
                return t * t * t;
            },
            Out: function(t) {
                return --t * t * t + 1;
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
            }
        },
        Quartic: {
            In: function(t) {
                return t * t * t * t;
            },
            Out: function(t) {
                return 1 - --t * t * t * t;
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
            }
        },
        Quintic: {
            In: function(t) {
                return t * t * t * t * t;
            },
            Out: function(t) {
                return --t * t * t * t * t + 1;
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
            }
        },
        Sinusoidal: {
            In: function(t) {
                return 1 - Math.cos(t * Math.PI / 2);
            },
            Out: function(t) {
                return Math.sin(t * Math.PI / 2);
            },
            InOut: function(t) {
                return .5 * (1 - Math.cos(Math.PI * t));
            }
        },
        Exponential: {
            In: function(t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1);
            },
            Out: function(t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
            },
            InOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)));
            }
        },
        Circular: {
            In: function(t) {
                return 1 - Math.sqrt(1 - t * t);
            },
            Out: function(t) {
                return Math.sqrt(1 - --t * t);
            },
            InOut: function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
            }
        },
        Elastic: {
            In: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI);
            },
            Out: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1;
            },
            InOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1;
            }
        },
        Back: {
            In: function(t) {
                return t * t * (2.70158 * t - 1.70158);
            },
            Out: function(t) {
                return --t * t * (2.70158 * t + 1.70158) + 1;
            },
            InOut: function(t) {
                var n = 2.5949095;
                return (t *= 2) < 1 ? t * t * ((1 + n) * t - n) * .5 : .5 * ((t -= 2) * t * ((1 + n) * t + n) + 2);
            }
        },
        Bounce: {
            In: function(t) {
                return 1 - TWEEN.Easing.Bounce.Out(1 - t);
            },
            Out: function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
            },
            InOut: function(t) {
                return t < .5 ? .5 * TWEEN.Easing.Bounce.In(2 * t) : .5 * TWEEN.Easing.Bounce.Out(2 * t - 1) + .5;
            }
        }
    }, TWEEN.Interpolation = {
        Linear: function(t, n) {
            var e = t.length - 1, i = e * n, r = Math.floor(i), o = TWEEN.Interpolation.Utils.Linear;
            return n < 0 ? o(t[0], t[1], i) : 1 < n ? o(t[e], t[e - 1], e - i) : o(t[r], t[e < r + 1 ? e : r + 1], i - r);
        },
        Bezier: function(t, n) {
            for (var e = 0, i = t.length - 1, r = Math.pow, o = TWEEN.Interpolation.Utils.Bernstein, a = 0; a <= i; a++) e += r(1 - n, i - a) * r(n, a) * t[a] * o(i, a);
            return e;
        },
        CatmullRom: function(t, n) {
            var e = t.length - 1, i = e * n, r = Math.floor(i), o = TWEEN.Interpolation.Utils.CatmullRom;
            return t[0] === t[e] ? (n < 0 && (r = Math.floor(i = e * (1 + n))), o(t[(r - 1 + e) % e], t[r], t[(r + 1) % e], t[(r + 2) % e], i - r)) : n < 0 ? t[0] - (o(t[0], t[0], t[1], t[1], -i) - t[0]) : 1 < n ? t[e] - (o(t[e], t[e], t[e - 1], t[e - 1], i - e) - t[e]) : o(t[r ? r - 1 : 0], t[r], t[e < r + 1 ? e : r + 1], t[e < r + 2 ? e : r + 2], i - r);
        },
        Utils: {
            Linear: function(t, n, e) {
                return (n - t) * e + t;
            },
            Bernstein: function(t, n) {
                var e = TWEEN.Interpolation.Utils.Factorial;
                return e(t) / e(n) / e(t - n);
            },
            Factorial: function() {
                var i = [ 1 ];
                return function(t) {
                    var n = 1;
                    if (i[t]) return i[t];
                    for (var e = t; 1 < e; e--) n *= e;
                    return i[t] = n;
                };
            }(),
            CatmullRom: function(t, n, e, i, r) {
                var o = .5 * (e - t), a = .5 * (i - n), s = r * r;
                return (2 * n - 2 * e + o + a) * (r * s) + (-3 * n + 3 * e - 2 * o - a) * s + o * r + n;
            }
        }
    }, module.exports = TWEEN;
}), TweenAction = (Tween_min.TWEEN, function TweenAction(target, duration, props, opts) {
    if (_classCallCheck(this, TweenAction), this.id = void 0, this.tween = void 0, this._opts = void 0, 
    this._props = void 0, this.id = TweenAction._idCounter++, this.tween = new Tween_min.Tween(target), 
    this._props = props, this._opts = opts, this.tween.to(props, duration), null != opts) {
        if (null != opts.delay && this.tween.delay(opts.delay), null != opts.repeat && this.tween.repeat(opts.repeat), 
        null != opts.repeatDelay && this.tween.repeatDelay(opts.repeatDelay), null != opts.yoyo && this.tween.yoyo(opts.yoyo), 
        null != opts.easing) if ("string" == typeof opts.easing) {
            var e = opts.easing.split("-");
            if (e.length >= 2) {
                var e0 = e[0], e1 = e[1];
                "Linear" === e0 ? "None" === e1 && this.tween.easing(Tween_min.Easing[e0][e1]) : "In" !== e1 && "Out" !== e1 && "InOut" !== e1 || this.tween.easing(Tween_min.Easing[e0][e1]);
            }
        } else this.tween.easing(opts.easing);
        if (null != opts.interpolation) if ("string" == typeof opts.interpolation) {
            var i = opts.interpolation.split("-");
            if (i.length >= 1) {
                var i0 = i[0];
                this.tween.interpolation(Tween_min.Interpolation[i0]);
            }
        } else this.tween.interpolation(opts.interpolation);
        null != opts.onStart && this.tween.onStart(opts.onStart), null != opts.onStop && this.tween.onStop(opts.onStop), 
        null != opts.onUpdate && this.tween.onUpdate(opts.onUpdate), null != opts.onComplete && this.tween.onComplete(opts.onComplete);
    }
});

function setWrap$1(object, wrapper) {
    object.__cc_wrapper__ = wrapper;
}

TweenAction._idCounter = 0, cc.TweenAction = TweenAction, window.TWEEN = Tween_min;

var TweenCommand = function() {
    function TweenCommand() {
        _classCallCheck(this, TweenCommand), this.quene = [];
    }
    return _createClass(TweenCommand, [ {
        key: "updateChain",
        value: function updateChain() {
            for (var len = this.length, i0 = 0, i1 = 1; i0 < len; ) {
                var union = this.quene[i0];
                if (i1 < len) {
                    if (union.length > 0) {
                        var next = this.quene[i1];
                        if (0 === union.repeatTimes) {
                            if (next.length > 0) union.lastAction.tween.chain(next.lastAction.tween);
                        } else this.wrapAndEvent(union);
                    }
                } else if (union.length > 0 && 0 !== union.repeatTimes) {
                    var _lastAction = union.lastAction;
                    setWrap$1(_lastAction.tween, union), _lastAction.tween.cc_onCompleteCallback(this._onComplete.bind(this));
                }
                ++i0, ++i1;
            }
        }
    }, {
        key: "start",
        value: function start() {
            this.updateChain(), this.length > 0 && this.firstUnion.start();
        }
    }, {
        key: "stop",
        value: function stop() {
            for (var i = 0; i < this.length; i++) {
                if (this.quene[i].stop()) break;
            }
        }
    }, {
        key: "union",
        value: function union(_union) {
            this.quene.push(_union);
        }
    }, {
        key: "isExistUnion",
        value: function isExistUnion(union) {
            return -1 !== this.quene.indexOf(union);
        }
    }, {
        key: "wrapAndEvent",
        value: function wrapAndEvent(union) {
            var lastAction = union.lastAction;
            setWrap$1(lastAction.tween, union), lastAction.tween.cc_onCompleteCallback(this._onComplete.bind(this));
        }
    }, {
        key: "_onComplete",
        value: function _onComplete(tween) {
            var union = function getWrap$1(object) {
                return object.__cc_wrapper__;
            }(tween);
            if (union.repeatTimes > 0 && union.lastCount > 0) {
                union.runTimes++;
                var index = this.quene.indexOf(union);
                if (index >= 0) {
                    for (var i = 0; i < index; i++) this.quene[i].runTimes = 0;
                    this.firstUnion.start();
                }
            } else if (-1 === union.repeatTimes) {
                var _index = this.quene.indexOf(union);
                if (_index >= 0) {
                    for (var _i = 0; _i < _index; _i++) this.quene[_i].runTimes = 0;
                    this.firstUnion.start();
                }
            } else {
                union.onCompeleteCallback && union.onCompeleteCallback(tween._object);
                var _index2 = this.quene.indexOf(union);
                if (_index2 !== this.length - 1) this.quene[_index2 + 1].start();
            }
        }
    }, {
        key: "length",
        get: function get() {
            return this.quene.length;
        }
    }, {
        key: "firstUnion",
        get: function get() {
            return this.quene[0];
        }
    }, {
        key: "lastUnion",
        get: function get() {
            return this.quene[this.quene.length - 1];
        }
    } ]), TweenCommand;
}();

cc.TweenCommand = TweenCommand;

var TweenUnion = function() {
    function TweenUnion(target) {
        _classCallCheck(this, TweenUnion), this.id = void 0, this._actions = [], this._target = void 0, 
        this._runTimes = 0, this._repeatTimes = 0, this._onCompeleteCallback = void 0, this._delay = 0, 
        this.id = TweenUnion._idCounter++, this._target = target;
    }
    return _createClass(TweenUnion, [ {
        key: "actions",
        get: function get() {
            return this._actions;
        }
    }, {
        key: "length",
        get: function get() {
            return this._actions.length;
        }
    }, {
        key: "firstAction",
        get: function get() {
            return this._actions[0];
        }
    }, {
        key: "lastAction",
        get: function get() {
            return this._actions[this._actions.length - 1];
        }
    }, {
        key: "target",
        get: function get() {
            return this._target;
        }
    }, {
        key: "runTimes",
        get: function get() {
            return this._runTimes;
        },
        set: function set(times) {
            this._runTimes = times;
        }
    }, {
        key: "repeatTimes",
        get: function get() {
            return this._repeatTimes;
        },
        set: function set(times) {
            this._repeatTimes = times;
        }
    }, {
        key: "lastCount",
        get: function get() {
            return this._repeatTimes - this._runTimes;
        }
    }, {
        key: "onCompeleteCallback",
        set: function set(callback) {
            this._onCompeleteCallback = callback;
        },
        get: function get() {
            return this._onCompeleteCallback;
        }
    }, {
        key: "delay",
        get: function get() {
            return this._delay;
        },
        set: function set(v) {
            this._delay = v;
        }
    } ]), _createClass(TweenUnion, [ {
        key: "start",
        value: function start() {
            if (this.length > 0) if (this.delay > 0) {
                var tween = this.actions[0].tween;
                setTimeout(tween.start.bind(tween), this.delay);
            } else this.actions[0].tween.start();
        }
    }, {
        key: "stop",
        value: function stop() {
            for (var i = 0; i < this._actions.length; i++) {
                var tween = this._actions[i].tween;
                if (tween.isPlaying()) return tween.stop(), !0;
            }
            return !1;
        }
    } ]), TweenUnion;
}();

TweenUnion._idCounter = 0, cc.TweenUnion = TweenUnion;

var Tween = function() {
    function Tween(target) {
        _classCallCheck(this, Tween), this._command = new TweenCommand(), this._default = void 0, 
        this._uionDirty = !1, this._default = new TweenUnion(target);
    }
    return _createClass(Tween, null, [ {
        key: "_recursiveForBy",
        value: function _recursiveForBy(props) {
            var theProp;
            for (var property in props) if ("number" == typeof (theProp = props[property])) {
                var symbol = theProp > 0 ? "+" : "-";
                props[property] = symbol + theProp;
            } else "object" === _typeof(theProp) && Tween._recursiveForBy(theProp);
        }
    } ]), _createClass(Tween, [ {
        key: "to",
        value: function to(duration, props, opts) {
            this._uionDirty && (this._default = new TweenUnion(this._default.target), this._uionDirty = !1);
            var action = new TweenAction(this._default.target, 1e3 * duration, props, opts);
            return this._default.length > 0 && this._default.actions[this._default.length - 1].tween.chain(action.tween), 
            this._default.actions.push(action), this;
        }
    }, {
        key: "by",
        value: function by(duration, props, opts) {
            this._uionDirty && (this._default = new TweenUnion(this._default.target), this._uionDirty = !1), 
            Tween._recursiveForBy(props);
            var action = new TweenAction(this._default.target, 1e3 * duration, props, opts);
            return this._default.length > 0 && this._default.actions[this._default.length - 1].tween.chain(action.tween), 
            this._default.actions.push(action), this;
        }
    }, {
        key: "union",
        value: function union() {
            return this._command.isExistUnion(this._default) || (this._command.union(this._default), 
            this._uionDirty = !0), this;
        }
    }, {
        key: "start",
        value: function start() {
            return this._default.length > 0 && (this._command.isExistUnion(this._default) || this._command.union(this._default)), 
            this._command.start(), this;
        }
    }, {
        key: "stop",
        value: function stop() {
            return this._command.stop(), this;
        }
    }, {
        key: "repeat",
        value: function repeat(times) {
            return this._uionDirty ? this._default.repeatTimes = times : this._default.length > 0 && this._default.lastAction.tween.repeat(times), 
            this;
        }
    }, {
        key: "repeatForever",
        value: function repeatForever() {
            return this._uionDirty ? this._default.repeatTimes = -1 : this._default.length > 0 && this._default.lastAction.tween.repeat(1 / 0), 
            this;
        }
    }, {
        key: "delay",
        value: function delay(timeInSecond) {
            return this._uionDirty ? this._default.delay = 1e3 * timeInSecond : this._default.length > 0 && this._default.lastAction.tween.delay(1e3 * timeInSecond), 
            this;
        }
    }, {
        key: "call",
        value: function call(callback) {
            return this._uionDirty ? this._default.onCompeleteCallback = callback : this._default.length > 0 && this._default.lastAction.tween.onComplete(callback), 
            this;
        }
    } ]), Tween;
}();

function tweenUtil(target) {
    return new Tween(target);
}

cc.Tween = Tween, cc.tweenUtil = tweenUtil, replaceProperty(cc, "cc", [ {
    name: "tween",
    newName: "tweenUtil"
} ]);

export { AffineTransform, AnimCurve, AnimationClip, AnimationComponent, AnimationManager, AnimationState, Asset, AssetLibrary, AudioClip, AudioSourceComponent, AvatarModelComponent, AvatarUnit, BaseNode, BatchedSkinningModelComponent, BillboardComponent, BitmapFont, BlockInputEventsComponent, BoxColliderComponent, ButtonComponent, CCBoolean, CCClass, CCFloat, CCInteger, CCObject, CCString, CameraComponent, CanvasComponent, CanvasPool, CircularPool, ColliderComponent, Color, Component, ComponentModifier, CubicSplineNumberValue, CubicSplineQuatValue, CubicSplineVec2Value, CubicSplineVec3Value, CubicSplineVec4Value, CurveValueAdapter, Director, Downloader, EditBoxComponent, EffectAsset, Enum, Event, EventAcceleration, EventHandler, EventInfo, EventKeyboard, EventMouse, EventTarget, EventTouch, EventType$1 as EventType, FixedArray, Font, FrameIDValueAdapter, GFXAttributeName, GFXFormat, GFXPrimitiveMode, Game, GraphicsComponent, HierachyModifier, HorizontalTextAlignment, HtmlTextParser, ICurveInstance, ImageAsset, JavaScript, JsonAsset, LabelAtlas, LabelComponent, LabelOutlineComponent, Layers, LayoutComponent, LightComponent, LineComponent, LinkedArray, Loader, LoadingItems, MaskComponent, Mat3, Mat4, Material, Mesh, MeshBuffer, MissingScript, ModelComponent, Node$1 as Node, NodeActivator, NodePool, Overflow, PageViewComponent, PageViewIndicatorComponent, ParticleSystemComponent, PhysicsMaterial, PhysicsSystem, Pipeline, Pool$1 as Pool, Prefab, PrefabInfo, PrivateNode, Profiler, ProgressBarComponent, Quat, RatioSampler, RawAsset, Rect, RecyclePool, RenderTexture, RenderableComponent, RichTextComponent, RigidBodyComponent, Scene, SceneAsset, Script, ScrollBarComponent, ScrollViewComponent, Size, SkeletalAnimationClip, SkeletalAnimationComponent, SkeletalAnimationState, Skeleton, SkinningModelComponent, SkinningModelUnit, SliderComponent, Socket, SphereColliderComponent, SpriteAtlas, SpriteComponent, SpriteFrame, StencilManager, SystemEvent, SystemEventType, TTFFont, TextAsset, Texture2D, ToggleComponent, ToggleContainerComponent, SimpleTexture as TrivialTexture, Tween, TypeScript, typedArrayPool as TypedArrayPool, UIComponent, UIModelComponent, UIRenderComponent, UIReorderComponent, UITransformComponent, UIVertexFormat, UniformCurveValueAdapter, ValueType, Vec2, Vec3, Vec4, VerticalTextAlignment, ViewGroupComponent, WebviewComponent, WidgetComponent, _decorator, barFilled, bezier, bezierByTime, bmfont, builtinResMgr, cclegacy, computeRatioByType, deserialize, director, easing, effects$1 as effects, eventManager, find, fragmentText, game, geometry, getPathFromRoot, getWorldTransformUntilRoot, graphicsAssembler as graphics, graphicsAssemblerManager as graphicsAssembler, instantiate, isCustomTargetModifier, isElementModifier, isPropertyModifier, isUnicodeCJK, isUnicodeSpace, js$1 as js, labelAssembler, letter, loader, macro, markAsWarning, maskAssembler as mask, maskEndAssembler as maskEnd, math, misc, path, primitives, profiler, radialFilled, removeProperty, renderer, replaceProperty, safeMeasureText, sampleAnimationCurve, screen$1 as screen, setDefaultLogTimes, simple, sliced, spriteAssembler, systemEvent, textureUtil, ttf, tweenUtil, url, utils, vmath, widgetManager };

//# sourceMappingURL=cc.js.map